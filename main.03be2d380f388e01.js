(self.webpackChunksamson=self.webpackChunksamson||[]).push([[179],{6546:function(){(function(){"use strict";var Et;function le(B){var ve=0;return function(){return ve<B.length?{done:!1,value:B[ve++]}:{done:!0}}}var h="function"==typeof Object.defineProperties?Object.defineProperty:function(B,ve,Be){return B==Array.prototype||B==Object.prototype||(B[ve]=Be.value),B},Z=function U(B){B=["object"==typeof globalThis&&globalThis,B,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var ve=0;ve<B.length;++ve){var Be=B[ve];if(Be&&Be.Math==Math)return Be}throw Error("Cannot find global object")}(this);function y(B,ve){if(ve)e:{var Be=Z;B=B.split(".");for(var ot=0;ot<B.length-1;ot++){var st=B[ot];if(!(st in Be))break e;Be=Be[st]}(ve=ve(ot=Be[B=B[B.length-1]]))!=ot&&null!=ve&&h(Be,B,{configurable:!0,writable:!0,value:ve})}}function F(B){return(B={next:B})[Symbol.iterator]=function(){return this},B}function I(B){var ve=typeof Symbol<"u"&&Symbol.iterator&&B[Symbol.iterator];return ve?ve.call(B):{next:le(B)}}function N(B){if(!(B instanceof Array)){B=I(B);for(var ve,Be=[];!(ve=B.next()).done;)Be.push(ve.value);B=Be}return B}y("Symbol",function(B){function Be(Xt,jt){this.h=Xt,h(this,"description",{configurable:!0,writable:!0,value:jt})}if(B)return B;Be.prototype.toString=function(){return this.h};var ot="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",st=0;return function ve(Xt){if(this instanceof ve)throw new TypeError("Symbol is not a constructor");return new Be(ot+(Xt||"")+"_"+st++,Xt)}}),y("Symbol.iterator",function(B){if(B)return B;B=Symbol("Symbol.iterator");for(var ve="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),Be=0;Be<ve.length;Be++){var ot=Z[ve[Be]];"function"==typeof ot&&"function"!=typeof ot.prototype[B]&&h(ot.prototype,B,{configurable:!0,writable:!0,value:function(){return F(le(this))}})}return B});var W="function"==typeof Object.assign?Object.assign:function(B,ve){for(var Be=1;Be<arguments.length;Be++){var ot=arguments[Be];if(ot)for(var st in ot)Object.prototype.hasOwnProperty.call(ot,st)&&(B[st]=ot[st])}return B};y("Object.assign",function(B){return B||W});var w,l="function"==typeof Object.create?Object.create:function(B){function ve(){}return ve.prototype=B,new ve};if("function"==typeof Object.setPrototypeOf)w=Object.setPrototypeOf;else{var M;e:{var D={};try{D.__proto__={a:!0},M=D.a;break e}catch{}M=!1}w=M?function(B,ve){if(B.__proto__=ve,B.__proto__!==ve)throw new TypeError(B+" is not extensible");return B}:null}var G=w;function J(B,ve){if(B.prototype=l(ve.prototype),B.prototype.constructor=B,G)G(B,ve);else for(var Be in ve)if("prototype"!=Be)if(Object.defineProperties){var ot=Object.getOwnPropertyDescriptor(ve,Be);ot&&Object.defineProperty(B,Be,ot)}else B[Be]=ve[Be];B.za=ve.prototype}function K(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function _e(B){if(B.m)throw new TypeError("Generator is already running");B.m=!0}function Re(B,ve){B.l={ma:ve,na:!0},B.h=B.s||B.v}function we(B,ve,Be){return B.h=Be,{value:ve}}function We(B){this.h=new K,this.i=B}function ie(B,ve,Be,ot){try{var st=ve.call(B.h.j,Be);if(!(st instanceof Object))throw new TypeError("Iterator result "+st+" is not an object");if(!st.done)return B.h.m=!1,st;var Xt=st.value}catch(jt){return B.h.j=null,Re(B.h,jt),Le(B)}return B.h.j=null,ot.call(B.h,Xt),Le(B)}function Le(B){for(;B.h.h;)try{var ve=B.i(B.h);if(ve)return B.h.m=!1,{value:ve.value,done:!1}}catch(Be){B.h.i=void 0,Re(B.h,Be)}if(B.h.m=!1,B.h.l){if(ve=B.h.l,B.h.l=null,ve.na)throw ve.ma;return{value:ve.return,done:!0}}return{value:void 0,done:!0}}function De(B){this.next=function(ve){return _e(B.h),B.h.j?ve=ie(B,B.h.j.next,ve,B.h.u):(B.h.u(ve),ve=Le(B)),ve},this.throw=function(ve){return _e(B.h),B.h.j?ve=ie(B,B.h.j.throw,ve,B.h.u):(Re(B.h,ve),ve=Le(B)),ve},this.return=function(ve){return function Oe(B,ve){_e(B.h);var Be=B.h.j;return Be?ie(B,"return"in Be?Be.return:function(ot){return{value:ot,done:!0}},ve,B.h.return):(B.h.return(ve),Le(B))}(B,ve)},this[Symbol.iterator]=function(){return this}}function de(B){return function te(B){function ve(ot){return B.next(ot)}function Be(ot){return B.throw(ot)}return new Promise(function(ot,st){!function Xt(jt){jt.done?ot(jt.value):Promise.resolve(jt.value).then(ve,Be).then(Xt,st)}(B.next())})}(new De(new We(B)))}function oe(B){return B||Array.prototype.fill}K.prototype.u=function(B){this.i=B},K.prototype.return=function(B){this.l={return:B},this.h=this.v},y("Promise",function(B){function ve(jt){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Yt=this.l();try{jt(Yt.resolve,Yt.reject)}catch(xn){Yt.reject(xn)}}function Be(){this.h=null}function ot(jt){return jt instanceof ve?jt:new ve(function(Yt){Yt(jt)})}if(B)return B;Be.prototype.i=function(jt){if(null==this.h){this.h=[];var Yt=this;this.j(function(){Yt.m()})}this.h.push(jt)};var st=Z.setTimeout;Be.prototype.j=function(jt){st(jt,0)},Be.prototype.m=function(){for(;this.h&&this.h.length;){var jt=this.h;this.h=[];for(var Yt=0;Yt<jt.length;++Yt){var xn=jt[Yt];jt[Yt]=null;try{xn()}catch(ss){this.l(ss)}}}this.h=null},Be.prototype.l=function(jt){this.j(function(){throw jt})},ve.prototype.l=function(){function jt(ss){return function(Jn){xn||(xn=!0,ss.call(Yt,Jn))}}var Yt=this,xn=!1;return{resolve:jt(this.I),reject:jt(this.m)}},ve.prototype.I=function(jt){if(jt===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(jt instanceof ve)this.L(jt);else{e:switch(typeof jt){case"object":var Yt=null!=jt;break e;case"function":Yt=!0;break e;default:Yt=!1}Yt?this.F(jt):this.s(jt)}},ve.prototype.F=function(jt){var Yt=void 0;try{Yt=jt.then}catch(xn){return void this.m(xn)}"function"==typeof Yt?this.M(Yt,jt):this.s(jt)},ve.prototype.m=function(jt){this.v(2,jt)},ve.prototype.s=function(jt){this.v(1,jt)},ve.prototype.v=function(jt,Yt){if(0!=this.i)throw Error("Cannot settle("+jt+", "+Yt+"): Promise already settled in state"+this.i);this.i=jt,this.j=Yt,2===this.i&&this.K(),this.H()},ve.prototype.K=function(){var jt=this;st(function(){if(jt.D()){var Yt=Z.console;typeof Yt<"u"&&Yt.error(jt.j)}},1)},ve.prototype.D=function(){if(this.u)return!1;var jt=Z.CustomEvent,Yt=Z.Event,xn=Z.dispatchEvent;return typeof xn>"u"||("function"==typeof jt?jt=new jt("unhandledrejection",{cancelable:!0}):"function"==typeof Yt?jt=new Yt("unhandledrejection",{cancelable:!0}):(jt=Z.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,jt),jt.promise=this,jt.reason=this.j,xn(jt))},ve.prototype.H=function(){if(null!=this.h){for(var jt=0;jt<this.h.length;++jt)Xt.i(this.h[jt]);this.h=null}};var Xt=new Be;return ve.prototype.L=function(jt){var Yt=this.l();jt.T(Yt.resolve,Yt.reject)},ve.prototype.M=function(jt,Yt){var xn=this.l();try{jt.call(Yt,xn.resolve,xn.reject)}catch(ss){xn.reject(ss)}},ve.prototype.then=function(jt,Yt){function xn(Qs,As){return"function"==typeof Qs?function(cn){try{ss(Qs(cn))}catch(Zr){Jn(Zr)}}:As}var ss,Jn,_r=new ve(function(Qs,As){ss=Qs,Jn=As});return this.T(xn(jt,ss),xn(Yt,Jn)),_r},ve.prototype.catch=function(jt){return this.then(void 0,jt)},ve.prototype.T=function(jt,Yt){function xn(){switch(ss.i){case 1:jt(ss.j);break;case 2:Yt(ss.j);break;default:throw Error("Unexpected state: "+ss.i)}}var ss=this;null==this.h?Xt.i(xn):this.h.push(xn),this.u=!0},ve.resolve=ot,ve.reject=function(jt){return new ve(function(Yt,xn){xn(jt)})},ve.race=function(jt){return new ve(function(Yt,xn){for(var ss=I(jt),Jn=ss.next();!Jn.done;Jn=ss.next())ot(Jn.value).T(Yt,xn)})},ve.all=function(jt){var Yt=I(jt),xn=Yt.next();return xn.done?ot([]):new ve(function(ss,Jn){function _r(cn){return function(Zr){Qs[cn]=Zr,0==--As&&ss(Qs)}}var Qs=[],As=0;do{Qs.push(void 0),As++,ot(xn.value).T(_r(Qs.length-1),Jn),xn=Yt.next()}while(!xn.done)})},ve}),y("Array.prototype.keys",function(B){return B||function(){return function P(B,ve){B instanceof String&&(B+="");var Be=0,ot=!1,st={next:function(){if(!ot&&Be<B.length){var Xt=Be++;return{value:ve(Xt,B[Xt]),done:!1}}return ot=!0,{done:!0,value:void 0}}};return st[Symbol.iterator]=function(){return st},st}(this,function(ve){return ve})}}),y("Array.prototype.fill",function(B){return B||function(ve,Be,ot){var st=this.length||0;for(0>Be&&(Be=Math.max(0,st+Be)),(null==ot||ot>st)&&(ot=st),0>(ot=Number(ot))&&(ot=Math.max(0,st+ot)),Be=Number(Be||0);Be<ot;Be++)this[Be]=ve;return this}}),y("Int8Array.prototype.fill",oe),y("Uint8Array.prototype.fill",oe),y("Uint8ClampedArray.prototype.fill",oe),y("Int16Array.prototype.fill",oe),y("Uint16Array.prototype.fill",oe),y("Int32Array.prototype.fill",oe),y("Uint32Array.prototype.fill",oe),y("Float32Array.prototype.fill",oe),y("Float64Array.prototype.fill",oe),y("Object.is",function(B){return B||function(ve,Be){return ve===Be?0!==ve||1/ve==1/Be:ve!=ve&&Be!=Be}}),y("Array.prototype.includes",function(B){return B||function(ve,Be){var ot=this;ot instanceof String&&(ot=String(ot));var st=ot.length;for(0>(Be=Be||0)&&(Be=Math.max(Be+st,0));Be<st;Be++){var Xt=ot[Be];if(Xt===ve||Object.is(Xt,ve))return!0}return!1}}),y("String.prototype.includes",function(B){return B||function(ve,Be){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(ve instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(ve,Be||0)}});var ye=this||self;function Te(B,ve){B=B.split(".");var ot,Be=ye;B[0]in Be||typeof Be.execScript>"u"||Be.execScript("var "+B[0]);for(;B.length&&(ot=B.shift());)B.length||void 0===ve?Be=Be[ot]&&Be[ot]!==Object.prototype[ot]?Be[ot]:Be[ot]={}:Be[ot]=ve}function v(B){var ve;return(ve=ye.navigator)&&(ve=ve.userAgent)||(ve=""),-1!=ve.indexOf(B)}var at=Array.prototype.map?function(B,ve){return Array.prototype.map.call(B,ve,void 0)}:function(B,ve){for(var Be=B.length,ot=Array(Be),st="string"==typeof B?B.split(""):B,Xt=0;Xt<Be;Xt++)Xt in st&&(ot[Xt]=ve.call(void 0,st[Xt],Xt,B));return ot},Xe={},Ue=null;function It(){if(!Ue){Ue={};for(var B="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),ve=["+/=","+/","-_=","-_.","-_"],Be=0;5>Be;Be++){var ot=B.concat(ve[Be].split(""));Xe[Be]=ot;for(var st=0;st<ot.length;st++){var Xt=ot[st];void 0===Ue[Xt]&&(Ue[Xt]=st)}}}}var nn=typeof Uint8Array<"u",Bt=!(v("Trident")||v("MSIE"))&&"function"==typeof ye.btoa;function bn(B){if(!Bt){var ve;void 0===ve&&(ve=0),It(),ve=Xe[ve];for(var Be=Array(Math.floor(B.length/3)),ot=ve[64]||"",st=0,Xt=0;st<B.length-2;st+=3){var jt=B[st],Yt=B[st+1],xn=B[st+2],ss=ve[jt>>2];Be[Xt++]=ss+(jt=ve[(3&jt)<<4|Yt>>4])+(Yt=ve[(15&Yt)<<2|xn>>6])+(xn=ve[63&xn])}switch(ss=0,xn=ot,B.length-st){case 2:xn=ve[(15&(ss=B[st+1]))<<2]||ot;case 1:Be[Xt]=ve[(B=B[st])>>2]+ve[(3&B)<<4|ss>>4]+xn+ot}return Be.join("")}for(ve="";10240<B.length;)ve+=String.fromCharCode.apply(null,B.subarray(0,10240)),B=B.subarray(10240);return ve+=String.fromCharCode.apply(null,B),btoa(ve)}var Es,Qn=RegExp("[-_.]","g");function Dn(B){switch(B){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function ps(B){if(!Bt)return function pt(B){var ve=B.length,Be=3*ve/4;Be%3?Be=Math.floor(Be):-1!="=.".indexOf(B[ve-1])&&(Be=-1!="=.".indexOf(B[ve-2])?Be-2:Be-1);var ot=new Uint8Array(Be),st=0;return function Ct(B,ve){function Be(xn){for(;ot<B.length;){var ss=B.charAt(ot++),Jn=Ue[ss];if(null!=Jn)return Jn;if(!/^[\s\xa0]*$/.test(ss))throw Error("Unknown base64 encoding at char: "+ss)}return xn}It();for(var ot=0;;){var st=Be(-1),Xt=Be(0),jt=Be(64),Yt=Be(64);if(64===Yt&&-1===st)break;ve(st<<2|Xt>>4),64!=jt&&(ve(Xt<<4&240|jt>>2),64!=Yt&&ve(jt<<6&192|Yt))}}(B,function(Xt){ot[st++]=Xt}),st!==Be?ot.subarray(0,st):ot}(B);Qn.test(B)&&(B=B.replace(Qn,Dn)),B=atob(B);for(var ve=new Uint8Array(B.length),Be=0;Be<B.length;Be++)ve[Be]=B.charCodeAt(Be);return ve}function Xn(){return Es||(Es=new Uint8Array(0))}var Ts={},or="function"==typeof Uint8Array.prototype.slice,Ir=0,Ss=0;function Qe(B){var ve=0>B,Be=(B=Math.abs(B))>>>0;B=Math.floor((B-Be)/4294967296),ve&&(ve=(Be=I(Qt(Be,B))).next().value,B=Be.next().value,Be=ve),Ir=Be>>>0,Ss=B>>>0}var zs,Lt="function"==typeof BigInt;function Qt(B,ve){return ve=~ve,B?B=1+~B:ve+=1,[B,ve]}function Nn(B,ve){this.i=B>>>0,this.h=ve>>>0}function Os(B){if(!B)return zs||(zs=new Nn(0,0));if(!/^-?\d+$/.test(B))return null;if(16>B.length)Qe(Number(B));else if(Lt)B=BigInt(B),Ir=Number(B&BigInt(4294967295))>>>0,Ss=Number(B>>BigInt(32)&BigInt(4294967295));else{var ve=+("-"===B[0]);Ss=Ir=0;for(var Be=B.length,ot=ve,st=(Be-ve)%6+ve;st<=Be;ot=st,st+=6)ot=Number(B.slice(ot,st)),Ss*=1e6,4294967296<=(Ir=1e6*Ir+ot)&&(Ss+=Ir/4294967296|0,Ir%=4294967296);ve&&(B=(ve=I(Qt(Ir,Ss))).next().value,ve=ve.next().value,Ir=B,Ss=ve)}return new Nn(Ir,Ss)}function cr(B,ve){return Error("Invalid wire type: "+B+" (at position "+ve+")")}function xr(){return Error("Failed to read varint, encoding is invalid.")}function $r(B,ve){return Error("Tried to read past the end of the data "+ve+" > "+B)}function eo(){throw Error("Invalid UTF8")}function oa(B,ve){return ve=String.fromCharCode.apply(null,ve),null==B?ve:B+ve}var Po,za,lo,aa=void 0,xa=typeof TextDecoder<"u",To=typeof TextEncoder<"u";function Ao(B){if(B!==Ts)throw Error("illegal external caller")}function Ho(B,ve){if(Ao(ve),this.V=B,null!=B&&0===B.length)throw Error("ByteString should be constructed with non-empty values")}function sl(){return lo||(lo=new Ho(null,Ts))}function ka(B){Ao(Ts);var ve=B.V;return null==(ve=null==ve||nn&&null!=ve&&ve instanceof Uint8Array?ve:"string"==typeof ve?ps(ve):null)?ve:B.V=ve}function rl(B,ve){this.i=null,this.m=!1,this.h=this.j=this.l=0,Wa(this,B,ve)}function Wa(B,ve,Be){B.S=void 0!==(Be=void 0===Be?{}:Be).S&&Be.S,ve&&(ve=function to(B){if("string"==typeof B)return{buffer:ps(B),C:!1};if(Array.isArray(B))return{buffer:new Uint8Array(B),C:!1};if(B.constructor===Uint8Array)return{buffer:B,C:!1};if(B.constructor===ArrayBuffer)return{buffer:new Uint8Array(B),C:!1};if(B.constructor===Ho)return{buffer:ka(B)||Xn(),C:!0};if(B instanceof Uint8Array)return{buffer:new Uint8Array(B.buffer,B.byteOffset,B.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(ve),B.i=ve.buffer,B.m=ve.C,B.l=0,B.j=B.i.length,B.h=B.l)}function Fo(B,ve){if(B.h=ve,ve>B.j)throw $r(B.j,ve)}function Ha(B){var ve=B.i,Be=B.h,ot=ve[Be++],st=127&ot;if(128&ot&&(st|=(127&(ot=ve[Be++]))<<7,128&ot&&(st|=(127&(ot=ve[Be++]))<<14,128&ot&&(st|=(127&(ot=ve[Be++]))<<21,128&ot&&(st|=(ot=ve[Be++])<<28,128&ot&&128&ve[Be++]&&128&ve[Be++]&&128&ve[Be++]&&128&ve[Be++]&&128&ve[Be++])))))throw xr();return Fo(B,Be),st}function qe(B,ve){if(0>ve)throw Error("Tried to read a negative byte length: "+ve);var Be=B.h,ot=Be+ve;if(ot>B.j)throw $r(ve,B.j-Be);return B.h=ot,Be}rl.prototype.reset=function(){this.h=this.l};var jo=[];function la(){this.h=[]}function $s(B,ve,Be){for(;0<Be||127<ve;)B.h.push(127&ve|128),ve=(ve>>>7|Be<<25)>>>0,Be>>>=7;B.h.push(ve)}function co(B,ve){for(;127<ve;)B.h.push(127&ve|128),ve>>>=7;B.h.push(ve)}function ui(B,ve){if(jo.length){var Be=jo.pop();Wa(Be,B,ve),B=Be}else B=new rl(B,ve);this.h=B,this.j=this.h.h,this.i=this.l=-1,this.setOptions(ve)}function ja(B){var ve=B.h;if(ve.h==ve.j)return!1;B.j=B.h.h;var Be=Ha(B.h)>>>0;if(ve=Be>>>3,!(0<=(Be&=7)&&5>=Be))throw cr(Be,B.j);if(1>ve)throw Error("Invalid field number: "+ve+" (at position "+B.j+")");return B.l=ve,B.i=Be,!0}function Go(B){switch(B.i){case 0:if(0!=B.i)Go(B);else e:{for(var ve=(B=B.h).h,Be=ve+10,ot=B.i;ve<Be;)if(!(128&ot[ve++])){Fo(B,ve);break e}throw xr()}break;case 1:Fo(B=B.h,B.h+8);break;case 2:2!=B.i?Go(B):(ve=Ha(B.h)>>>0,Fo(B=B.h,B.h+ve));break;case 5:Fo(B=B.h,B.h+4);break;case 3:for(ve=B.l;;){if(!ja(B))throw Error("Unmatched start-group tag: stream EOF");if(4==B.i){if(B.l!=ve)throw Error("Unmatched end-group tag");break}Go(B)}break;default:throw cr(B.i,B.j)}}la.prototype.length=function(){return this.h.length},la.prototype.end=function(){var B=this.h;return this.h=[],B},ui.prototype.setOptions=function(B){this.ca=void 0!==(B=void 0===B?{}:B).ca&&B.ca},ui.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var Li=[];function wa(){this.j=[],this.i=0,this.h=new la}function Ki(B,ve){0!==ve.length&&(B.j.push(ve),B.i+=ve.length)}var $i="function"==typeof Symbol&&"symbol"==typeof Symbol()?Symbol():void 0;function Bi(B,ve){return $i?B[$i]|=ve:void 0!==B.A?B.A|=ve:(Object.defineProperties(B,{A:{value:ve,configurable:!0,writable:!0,enumerable:!1}}),ve)}function hl(B,ve){$i?B[$i]&&(B[$i]&=~ve):void 0!==B.A&&(B.A&=~ve)}function Jr(B){return($i?B[$i]:B.A)??0}function Lo(B,ve){$i?B[$i]=ve:void 0!==B.A?B.A=ve:Object.defineProperties(B,{A:{value:ve,configurable:!0,writable:!0,enumerable:!1}})}function dc(B){return Bi(B,1),B}function hc(B,ve){Lo(ve,-51&(0|B))}function Ga(B,ve){Lo(ve,-41&(18|B))}var Ko={};function pc(B){return null!==B&&"object"==typeof B&&!Array.isArray(B)&&B.constructor===Object}var pl,Oa,ko=[];function fl(B){if(2&Jr(B.o))throw Error("Cannot mutate an immutable Message")}function no(B){var ve=B.length;(ve=ve?B[ve-1]:void 0)&&pc(ve)?ve.g=1:B.push(((ve={}).g=1,ve))}function Ka(B){return B.B||(B.B=B.o[B.i+B.G]={})}function so(B,ve){return-1===ve?null:ve>=B.i?B.B?B.B[ve]:void 0:B.o[ve+B.G]}function il(B,ve,Be,ot){fl(B),Yi(B,ve,Be,ot)}function Yi(B,ve,Be,ot){B.j&&(B.j=void 0),ve>=B.i||ot?Ka(B)[ve]=Be:(B.o[ve+B.G]=Be,(B=B.B)&&ve in B&&delete B[ve])}function fc(B,ve,Be,ot){var st=so(B,ve);Array.isArray(st)||(st=pl);var Xt=Jr(st);if(1&Xt||dc(st),ot)2&Xt||Bi(st,2),1&Be||Object.freeze(st);else{ot=!(2&Be);var jt=2&Xt;1&Be||!jt?ot&&16&Xt&&!jt&&hl(st,16):Yi(B,ve,st=dc(Array.prototype.slice.call(st)))}return st}function zl(B,ve){var Be=so(B,ve),ot=null==Be?Be:"number"==typeof Be||"NaN"===Be||"Infinity"===Be||"-Infinity"===Be?Number(Be):void 0;return null!=ot&&ot!==Be&&Yi(B,ve,ot),ot}function ol(B,ve,Be,ot,st){B.h||(B.h={});var Xt=B.h[Be],jt=fc(B,Be,3,st);if(!Xt){var Yt=jt;Xt=[];var xn=!!(16&Jr(B.o));jt=!!(2&Jr(Yt));var ss=Yt;!st&&jt&&(Yt=Array.prototype.slice.call(Yt));for(var Jn=jt,_r=0;_r<Yt.length;_r++){var Qs=Yt[_r],As=ve,cn=!1;if(cn=void 0!==cn&&cn,void 0!==(Qs=Array.isArray(Qs)?new As(Qs):cn?new As:void 0)){var Zr=cn=Jr(As=Qs.o);jt&&(Zr|=2),xn&&(Zr|=16),Zr!=cn&&Lo(As,Zr),As=Zr,Jn=Jn||!!(2&As),Xt.push(Qs)}}return B.h[Be]=Xt,ve=33|(xn=Jr(Yt)),xn!=(ve=Jn?-9&ve:8|ve)&&(Jn=Yt,Object.isFrozen(Jn)&&(Jn=Array.prototype.slice.call(Jn)),Lo(Jn,ve),Yt=Jn),ss!==Yt&&Yi(B,Be,Yt),(st||ot&&jt)&&Bi(Xt,2),ot&&Object.freeze(Xt),Xt}return st||(st=Object.isFrozen(Xt),ot&&!st?Object.freeze(Xt):!ot&&st&&(Xt=Array.prototype.slice.call(Xt),B.h[Be]=Xt)),Xt}function Xa(B,ve,Be){var ot=!!(2&Jr(B.o));if(ve=ol(B,ve,Be,ot,ot),B=fc(B,Be,3,ot),!(ot||8&Jr(B))){for(ot=0;ot<ve.length;ot++){if(2&Jr((Be=ve[ot]).o)){var st=Xs(Be,!1);st.j=Be}else st=Be;Be!==st&&(ve[ot]=st,B[ot]=st.o)}Bi(B,8)}return ve}function Js(B,ve,Be){if(null!=Be&&"number"!=typeof Be)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof Be+": "+Be);il(B,ve,Be)}function vi(B,ve,Be,ot,st){fl(B);var Xt=ol(B,Be,ve,!1,!1);return Be=ot??new Be,B=fc(B,ve,2,!1),null!=st?(Xt.splice(st,0,Be),B.splice(st,0,Be.o)):(Xt.push(Be),B.push(Be.o)),Be.C()&&hl(B,8),Be}function $o(B,ve){return B??ve}function Pr(B,ve,Be){return Be=void 0===Be?0:Be,$o(zl(B,ve),Be)}function uo(B,ve,Be,ot){if(null!=B){if(Array.isArray(B))B=Ra(B,ve,Be,void 0!==ot);else if(pc(B)){var Xt,st={};for(Xt in B)st[Xt]=uo(B[Xt],ve,Be,ot);B=st}else B=ve(B,ot);return B}}function Ra(B,ve,Be,ot){var st=Jr(B);ot=ot?!!(16&st):void 0,B=Array.prototype.slice.call(B);for(var Xt=0;Xt<B.length;Xt++)B[Xt]=uo(B[Xt],ve,Be,ot);return Be(st,B),B}function Zi(B){return B.ja===Ko?B.toJSON():function Al(B){switch(typeof B){case"number":return isFinite(B)?B:String(B);case"object":if(B)if(Array.isArray(B)){if(128&Jr(B))return no(B=Array.prototype.slice.call(B)),B}else{if(nn&&null!=B&&B instanceof Uint8Array)return bn(B);if(B instanceof Ho){var ve=B.V;return null==ve?"":"string"==typeof ve?ve:B.V=bn(ve)}}}return B}(B)}function Oo(B,ve){128&B&&no(ve)}function Hi(B,ve,Be){if(Be=void 0===Be?Ga:Be,null!=B){if(nn&&B instanceof Uint8Array)return B.length?new Ho(new Uint8Array(B),Ts):sl();if(Array.isArray(B)){var ot=Jr(B);return 2&ot?B:!ve||32&ot||!(16&ot||0===ot)?(4&(ve=Jr(B=Ra(B,Hi,4&ot?Ga:Be,!0)))&&2&ve&&Object.freeze(B),B):(Lo(B,2|ot),B)}return B.ja===Ko?Di(B):B}}function ji(B,ve,Be,ot,st,Xt,jt){if(B=B.h&&B.h[Be]){if(2&(ot=Jr(B))?ot=B:(Ga(ot,Xt=at(B,Di)),Object.freeze(Xt),ot=Xt),fl(ve),jt=null==ot?pl:dc([]),null!=ot){for(Xt=!!ot.length,B=0;B<ot.length;B++){var Yt=ot[B];Xt=Xt&&!(2&Jr(Yt.o)),jt[B]=Yt.o}Xt=1|(Xt?8:0),((B=Jr(jt))&Xt)!==Xt&&(Object.isFrozen(jt)&&(jt=Array.prototype.slice.call(jt)),Lo(jt,B|Xt)),ve.h||(ve.h={}),ve.h[Be]=ot}else ve.h&&(ve.h[Be]=void 0);Yi(ve,Be,jt,st)}else il(ve,Be,Hi(ot,Xt,jt),st)}function Di(B){return 2&Jr(B.o)||Bi((B=Xs(B,!0)).o,2),B}function Xs(B,ve){var Be=B.o,ot=[];Bi(ot,16);var st=B.constructor.h;if(st&&ot.push(st),st=B.B){ot.length=Be.length,ot.fill(void 0,ot.length,Be.length);var Xt={};ot[ot.length-1]=Xt}128&Jr(Be)&&no(ot),ve=ve||B.C()?Ga:hc,Oa=ot,ot=new(Xt=B.constructor)(ot),Oa=void 0,B.R&&(ot.R=B.R.slice()),Xt=!!(16&Jr(Be));for(var jt=st?Be.length-1:Be.length,Yt=0;Yt<jt;Yt++)ji(B,ot,Yt-B.G,Be[Yt],!1,Xt,ve);if(st)for(var xn in st)ji(B,ot,+xn,st[xn],!0,Xt,ve);return ot}function ro(B,ve,Be){null==B&&(B=Oa),Oa=void 0;var As,ot=this.constructor.i||0,st=0<ot,Xt=this.constructor.h,jt=!1;if(null==B){var Yt=48,xn=!0;st&&(ot=0,Yt|=128),Lo(B=Xt?[Xt]:[],Yt)}else{if(!Array.isArray(B)||Xt&&Xt!==B[0])throw Error();var ss=Yt=Bi(B,0);if((xn=0!=(16&ss))&&((jt=0!=(32&ss))||(ss|=32)),st){if(128&ss)ot=0;else if(0<B.length){var Jn=B[B.length-1];if(pc(Jn)&&"g"in Jn){ot=0,ss|=128,delete Jn.g;var Qs,_r=!0;for(Qs in Jn){_r=!1;break}_r&&B.pop()}}}else if(128&ss)throw Error();Yt!==ss&&Lo(B,ss)}if(this.G=(Xt?0:-1)-ot,this.h=void 0,this.o=B,ot=(Xt=this.o.length)-1,Xt&&pc(Xt=this.o[ot])?(this.B=Xt,this.i=ot-this.G):void 0!==ve&&-1<ve?(this.i=Math.max(ve,ot+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!st&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(Be)for(ve=xn&&!jt&&!0,st=this.i,xn=0;xn<Be.length;xn++)(jt=Be[xn])<st?(ot=B[jt+=this.G])?pa(ot,ve):B[jt]=pl:(As||(As=Ka(this)),(ot=As[jt])?pa(ot,ve):As[jt]=pl)}function pa(B,ve){if(Array.isArray(B)){var Be=Jr(B),ot=1;!ve||2&Be||(ot|=16),(Be&ot)!==ot&&Lo(B,Be|ot)}}function Qi(B,ve,Be){if(Be){var st,ot={};for(st in Be){var Xt=Be[st],jt=Xt.ra;jt||(ot.J=Xt.xa||Xt.oa.W,Xt.ia?(ot.aa=dr(Xt.ia),jt=function(Yt){return function(xn,ss,Jn){return Yt.J(xn,ss,Jn,Yt.aa)}}(ot)):Xt.ka?(ot.Z=Xo(Xt.da.P,Xt.ka),jt=function(Yt){return function(xn,ss,Jn){return Yt.J(xn,ss,Jn,Yt.Z)}}(ot)):jt=ot.J,Xt.ra=jt),jt(ve,B,Xt.da),ot={J:ot.J,aa:ot.aa,Z:ot.Z}}}!function Xi(B,ve){if(ve=ve.R){Ki(B,B.h.end());for(var Be=0;Be<ve.length;Be++)Ki(B,ka(ve[Be])||Xn())}}(ve,B)}Lo(ko,23),pl=Object.freeze(ko),ro.prototype.toJSON=function(){return Ra(this.o,Zi,Oo)},ro.prototype.C=function(){return!!(2&Jr(this.o))},ro.prototype.ja=Ko,ro.prototype.toString=function(){return this.o.toString()};var al=Symbol();function fa(B,ve,Be){return B[al]||(B[al]=function(ot,st){return ve(ot,st,Be)})}function di(B){var ve=B[al];if(!ve){var Be=_o(B);B[al]=ve=function(ot,st){return mc(ot,st,Be)}}return ve}function mo(B){var ve=function ma(B){var ve=B.ia;return ve?di(ve):(ve=B.wa)?fa(B.da.P,ve,B.ka):void 0}(B),Be=B.da,ot=B.oa.U;return ve?function(st,Xt){return ot(st,Xt,Be,ve)}:function(st,Xt){return ot(st,Xt,Be)}}function mi(B,ve){var Be=B[ve];return"function"==typeof Be&&0===Be.length&&(Be=Be(),B[ve]=Be),Array.isArray(Be)&&(ar in Be||go in Be||0<Be.length&&"function"==typeof Be[0])?Be:void 0}function ic(B,ve,Be,ot,st,Xt){ve.P=B[0];var jt=1;if(B.length>jt&&"number"!=typeof B[jt]){var Yt=B[jt++];Be(ve,Yt)}for(;jt<B.length;){Be=B[jt++];for(var xn=jt+1;xn<B.length&&"number"!=typeof B[xn];)xn++;switch(Yt=B[jt++],xn-=jt){case 0:ot(ve,Be,Yt);break;case 1:(xn=mi(B,jt))?(jt++,st(ve,Be,Yt,xn)):ot(ve,Be,Yt,B[jt++]);break;case 2:st(ve,Be,Yt,xn=mi(B,xn=jt++),B[jt++]);break;case 3:Xt(ve,Be,Yt,B[jt++],B[jt++],B[jt++]);break;case 4:Xt(ve,Be,Yt,B[jt++],B[jt++],B[jt++],B[jt++]);break;default:throw Error("unexpected number of binary field arguments: "+xn)}}return ve}var Br=Symbol();function dr(B){var ve=B[Br];if(!ve){var Be=wr(B);B[Br]=ve=function(ot,st){return Ro(ot,st,Be)}}return ve}function Xo(B,ve){var Be=B[Br];return Be||(B[Br]=Be=function(ot,st){return Qi(ot,st,ve)}),Be}var go=Symbol();function ml(B,ve){B.push(ve)}function Na(B,ve,Be){B.push(ve,Be.W)}function En(B,ve,Be,ot){var st=dr(ot),Xt=wr(ot).P,jt=Be.W;B.push(ve,function(Yt,xn,ss){return jt(Yt,xn,ss,Xt,st)})}function ki(B,ve,Be,ot,st,Xt){var jt=Xo(ot,Xt),Yt=Be.W;B.push(ve,function(xn,ss,Jn){return Yt(xn,ss,Jn,ot,jt)})}function wr(B){var ve=B[go];return ve||(ve=ic(B,B[go]=[],ml,Na,En,ki),ar in B&&go in B&&(B.length=0),ve)}var ar=Symbol();function Ma(B,ve){B[0]=ve}function gn(B,ve,Be,ot){var st=Be.U;B[ve]=ot?function(Xt,jt,Yt){return st(Xt,jt,Yt,ot)}:st}function qr(B,ve,Be,ot,st){var Xt=Be.U,jt=di(ot),Yt=_o(ot).P;B[ve]=function(xn,ss,Jn){return Xt(xn,ss,Jn,Yt,jt,st)}}function Wl(B,ve,Be,ot,st,Xt,jt){var Yt=Be.U,xn=fa(ot,st,Xt);B[ve]=function(ss,Jn,_r){return Yt(ss,Jn,_r,ot,xn,jt)}}function _o(B){var ve=B[ar];return ve||(ve=ic(B,B[ar]={},Ma,gn,qr,Wl),ar in B&&go in B&&(B.length=0),ve)}function mc(B,ve,Be){for(;ja(ve)&&4!=ve.i;){var ot=ve.l,st=Be[ot];if(!st){var Xt=Be[0];Xt&&(Xt=Xt[ot])&&(st=Be[ot]=mo(Xt))}if(!st||!st(ve,B,ot)){ot=B,Xt=(st=ve).j,Go(st);var jt=st;if(!jt.ca){if(st=jt.h.h-Xt,jt.h.h=Xt,jt=jt.h,0==st)st=sl();else{if(Xt=qe(jt,st),jt.S&&jt.m)st=jt.i.subarray(Xt,Xt+st);else{jt=jt.i;var Yt=Xt;st=Yt===(st=Xt+st)?Xn():or?jt.slice(Yt,st):new Uint8Array(jt.subarray(Yt,st))}st=0==st.length?sl():new Ho(st,Ts)}(Xt=ot.R)?Xt.push(st):ot.R=[st]}}}return B}function Ro(B,ve,Be){for(var ot=Be.length,st=ot%2==1,Xt=st?1:0;Xt<ot;Xt+=2)(0,Be[Xt+1])(ve,B,Be[Xt]);Qi(B,ve,st?Be[0]:void 0)}function ll(B,ve){return{U:B,W:ve}}var Si=ll(function(B,ve,Be){if(5!==B.i)return!1;var ot=(B=B.h).i,st=B.h,Xt=ot[st],jt=ot[st+1],Yt=ot[st+2];return ot=ot[st+3],Fo(B,B.h+4),B=2*((jt=(Xt<<0|jt<<8|Yt<<16|ot<<24)>>>0)>>31)+1,Xt=jt>>>23&255,jt&=8388607,il(ve,Be,255==Xt?jt?NaN:1/0*B:0==Xt?B*Math.pow(2,-149)*jt:B*Math.pow(2,Xt-150)*(jt+Math.pow(2,23))),!0},function(B,ve,Be){if(null!=(ve=zl(ve,Be))){co(B.h,8*Be+5),B=B.h;var ot=+ve;0===ot?0<1/ot?Ir=Ss=0:(Ss=0,Ir=2147483648):isNaN(ot)?(Ss=0,Ir=2147483647):34028234663852886e22<(ot=(Be=0>ot?-2147483648:0)?-ot:ot)?(Ss=0,Ir=(2139095040|Be)>>>0):11754943508222875e-54>ot?(ot=Math.round(ot/Math.pow(2,-149)),Ss=0,Ir=(Be|ot)>>>0):(ve=Math.floor(Math.log(ot)/Math.LN2),ot*=Math.pow(2,-ve),16777216<=(ot=Math.round(8388608*ot))&&++ve,Ss=0,Ir=(Be|ve+127<<23|8388607&ot)>>>0),B.h.push((Be=Ir)>>>0&255),B.h.push(Be>>>8&255),B.h.push(Be>>>16&255),B.h.push(Be>>>24&255)}}),Ca=ll(function(B,ve,Be){if(0!==B.i)return!1;var ot=B.h,st=0,Xt=B=0,jt=ot.i,Yt=ot.h;do{var xn=jt[Yt++];st|=(127&xn)<<Xt,Xt+=7}while(32>Xt&&128&xn);for(32<Xt&&(B|=(127&xn)>>4),Xt=3;32>Xt&&128&xn;Xt+=7)B|=(127&(xn=jt[Yt++]))<<Xt;if(Fo(ot,Yt),!(128>xn))throw xr();return ot=st>>>0,(B=2147483648&(xn=B>>>0))&&(xn=~xn>>>0,0==(ot=1+~ot>>>0)&&(xn=xn+1>>>0)),ot=4294967296*xn+(ot>>>0),il(ve,Be,B?-ot:ot),!0},function(B,ve,Be){null!=(ve=so(ve,Be))&&("string"==typeof ve&&Os(ve),null!=ve&&(co(B.h,8*Be),"number"==typeof ve?(B=B.h,Qe(ve),$s(B,Ir,Ss)):(Be=Os(ve),$s(B.h,Be.i,Be.h))))}),Pa=ll(function(B,ve,Be){return 0===B.i&&(il(ve,Be,Ha(B.h)),!0)},function(B,ve,Be){if(null!=(ve=so(ve,Be))&&null!=ve)if(co(B.h,8*Be),B=B.h,0<=(Be=ve))co(B,Be);else{for(ve=0;9>ve;ve++)B.h.push(127&Be|128),Be>>=7;B.h.push(1)}}),Ea=ll(function(B,ve,Be){if(2!==B.i)return!1;var ot=Ha(B.h)>>>0,st=qe(B=B.h,ot);if(B=B.i,xa){var jt,Xt=B;(jt=Po)||(jt=Po=new TextDecoder("utf-8",{fatal:!0})),B=st+ot,Xt=0===st&&B===Xt.length?Xt:Xt.subarray(st,B);try{var Yt=jt.decode(Xt)}catch(_r){if(void 0===aa){try{jt.decode(new Uint8Array([128]))}catch{}try{jt.decode(new Uint8Array([97])),aa=!0}catch{aa=!1}}throw!aa&&(Po=void 0),_r}}else{ot=(Yt=st)+ot,st=[];for(var ss,Jn,xn=null;Yt<ot;)128>(ss=B[Yt++])?st.push(ss):224>ss?Yt>=ot?eo():(Jn=B[Yt++],194>ss||128!=(192&Jn)?(Yt--,eo()):st.push((31&ss)<<6|63&Jn)):240>ss?Yt>=ot-1?eo():128!=(192&(Jn=B[Yt++]))||224===ss&&160>Jn||237===ss&&160<=Jn||128!=(192&(Xt=B[Yt++]))?(Yt--,eo()):st.push((15&ss)<<12|(63&Jn)<<6|63&Xt):244>=ss?Yt>=ot-2?eo():128!=(192&(Jn=B[Yt++]))||Jn-144+(ss<<28)>>30||128!=(192&(Xt=B[Yt++]))||128!=(192&(jt=B[Yt++]))?(Yt--,eo()):(ss=(7&ss)<<18|(63&Jn)<<12|(63&Xt)<<6|63&jt,st.push(55296+((ss-=65536)>>10&1023),56320+(1023&ss))):eo(),8192<=st.length&&(xn=oa(xn,st),st.length=0);Yt=oa(xn,st)}return il(ve,Be,Yt),!0},function(B,ve,Be){if(null!=(ve=so(ve,Be))){var ot=!1;if(ot=void 0!==ot&&ot,To){if(ot&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(ve))throw Error("Found an unpaired surrogate");ve=(za||(za=new TextEncoder)).encode(ve)}else{for(var st=0,Xt=new Uint8Array(3*ve.length),jt=0;jt<ve.length;jt++){var Yt=ve.charCodeAt(jt);if(128>Yt)Xt[st++]=Yt;else{if(2048>Yt)Xt[st++]=Yt>>6|192;else{if(55296<=Yt&&57343>=Yt){if(56319>=Yt&&jt<ve.length){var xn=ve.charCodeAt(++jt);if(56320<=xn&&57343>=xn){Xt[st++]=(Yt=1024*(Yt-55296)+xn-56320+65536)>>18|240,Xt[st++]=Yt>>12&63|128,Xt[st++]=Yt>>6&63|128,Xt[st++]=63&Yt|128;continue}jt--}if(ot)throw Error("Found an unpaired surrogate");Yt=65533}Xt[st++]=Yt>>12|224,Xt[st++]=Yt>>6&63|128}Xt[st++]=63&Yt|128}}ve=st===Xt.length?Xt:Xt.subarray(0,st)}co(B.h,8*Be+2),co(B.h,ve.length),Ki(B,B.h.end()),Ki(B,ve)}}),gl=ll(function(B,ve,Be,ot,st){if(2!==B.i)return!1;ve=vi(ve,Be,ot),Be=B.h.j,ot=Ha(B.h)>>>0;var Xt=B.h.h+ot,jt=Xt-Be;if(0>=jt&&(B.h.j=Xt,st(ve,B,void 0,void 0,void 0),jt=Xt-B.h.h),jt)throw Error("Message parsing ended unexpectedly. Expected to read "+ot+" bytes, instead read "+(ot-jt)+" bytes, either the data ended unexpectedly or the message misreported its own length");return B.h.h=Xt,B.h.j=Be,!0},function(B,ve,Be,ot,st){if(null!=(ve=Xa(ve,ot,Be)))for(ot=0;ot<ve.length;ot++){var Xt=B;co(Xt.h,8*Be+2);var jt=Xt.h.end();Ki(Xt,jt),jt.push(Xt.i),Xt=jt,st(ve[ot],B),jt=B;var Yt=Xt.pop();for(Yt=jt.i+jt.h.length()-Yt;127<Yt;)Xt.push(127&Yt|128),Yt>>>=7,jt.i++;Xt.push(Yt),jt.i++}});function _l(B){return function(ve,Be){e:{if(Li.length){var ot=Li.pop();ot.setOptions(Be),Wa(ot.h,ve,Be),ve=ot}else ve=new ui(ve,Be);try{var st=_o(B),Xt=mc(new st.P,ve,st);break e}finally{(st=ve.h).i=null,st.m=!1,st.l=0,st.j=0,st.h=0,st.S=!1,ve.l=-1,ve.i=-1,100>Li.length&&Li.push(ve)}Xt=void 0}return Xt}}function q(B){return function(){var ve=new wa;Ro(this,ve,wr(B)),Ki(ve,ve.h.end());for(var Be=new Uint8Array(ve.i),ot=ve.j,st=ot.length,Xt=0,jt=0;jt<st;jt++){var Yt=ot[jt];Be.set(Yt,Xt),Xt+=Yt.length}return ve.j=[Be],Be}}function L(B){ro.call(this,B)}J(L,ro);var X=[L,1,Pa,2,Si,3,Ea,4,Ea];function Ae(B){ro.call(this,B,-1,He)}L.prototype.l=q(X),J(Ae,ro),Ae.prototype.addClassification=function(B,ve){return vi(this,1,L,B,ve),this};var He=[1],Ye=_l([Ae,1,gl,X]);function it(B){ro.call(this,B)}J(it,ro);var _t=[it,1,Si,2,Si,3,Si,4,Si,5,Si];function wt(B){ro.call(this,B,-1,kn)}it.prototype.l=q(_t),J(wt,ro);var kn=[1],pn=_l([wt,1,gl,_t]);function qn(B){ro.call(this,B)}J(qn,ro);var os=[qn,1,Si,2,Si,3,Si,4,Si,5,Si,6,Ca],Ms=_l(os);function Tr(B,ve,Be){if(Be=B.createShader(0===Be?B.VERTEX_SHADER:B.FRAGMENT_SHADER),B.shaderSource(Be,ve),B.compileShader(Be),!B.getShaderParameter(Be,B.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+B.getShaderInfoLog(Be));return Be}function Cr(B){return Xa(B,L,1).map(function(ve){return{index:so(ve,1)??0,qa:Pr(ve,2),label:null!=so(ve,3)?$o(so(ve,3),""):void 0,displayName:null!=so(ve,4)?$o(so(ve,4),""):void 0}})}function Is(B){return{x:Pr(B,1),y:Pr(B,2),z:Pr(B,3),visibility:null!=zl(B,4)?Pr(B,4):void 0}}function lr(B){return Xa(pn(B),it,1).map(Is)}function yo(B,ve){this.i=B,this.h=ve,this.m=0}function Da(B,ve,Be){return function Jt(B,ve){var Be=B.h;if(void 0===B.s){var ot=Tr(Be,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),st=Tr(Be,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),Xt=Be.createProgram();if(Be.attachShader(Xt,ot),Be.attachShader(Xt,st),Be.linkProgram(Xt),!Be.getProgramParameter(Xt,Be.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+Be.getProgramInfoLog(Xt));ot=B.s=Xt,Be.useProgram(ot),st=Be.getUniformLocation(ot,"sampler0"),B.l={O:Be.getAttribLocation(ot,"aVertex"),N:Be.getAttribLocation(ot,"aTex"),ya:st},B.v=Be.createBuffer(),Be.bindBuffer(Be.ARRAY_BUFFER,B.v),Be.enableVertexAttribArray(B.l.O),Be.vertexAttribPointer(B.l.O,2,Be.FLOAT,!1,0,0),Be.bufferData(Be.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),Be.STATIC_DRAW),Be.bindBuffer(Be.ARRAY_BUFFER,null),B.u=Be.createBuffer(),Be.bindBuffer(Be.ARRAY_BUFFER,B.u),Be.enableVertexAttribArray(B.l.N),Be.vertexAttribPointer(B.l.N,2,Be.FLOAT,!1,0,0),Be.bufferData(Be.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),Be.STATIC_DRAW),Be.bindBuffer(Be.ARRAY_BUFFER,null),Be.uniform1i(st,0)}ot=B.l,Be.useProgram(B.s),Be.canvas.width=ve.width,Be.canvas.height=ve.height,Be.viewport(0,0,ve.width,ve.height),Be.activeTexture(Be.TEXTURE0),B.i.bindTexture2d(ve.glName),Be.enableVertexAttribArray(ot.O),Be.bindBuffer(Be.ARRAY_BUFFER,B.v),Be.vertexAttribPointer(ot.O,2,Be.FLOAT,!1,0,0),Be.enableVertexAttribArray(ot.N),Be.bindBuffer(Be.ARRAY_BUFFER,B.u),Be.vertexAttribPointer(ot.N,2,Be.FLOAT,!1,0,0),Be.bindFramebuffer(Be.DRAW_FRAMEBUFFER?Be.DRAW_FRAMEBUFFER:Be.FRAMEBUFFER,null),Be.clearColor(0,0,0,0),Be.clear(Be.COLOR_BUFFER_BIT),Be.colorMask(!0,!0,!0,!0),Be.drawArrays(Be.TRIANGLE_FAN,0,4),Be.disableVertexAttribArray(ot.O),Be.disableVertexAttribArray(ot.N),Be.bindBuffer(Be.ARRAY_BUFFER,null),B.i.bindTexture2d(0)}(B,ve),"function"==typeof B.h.canvas.transferToImageBitmap?Promise.resolve(B.h.canvas.transferToImageBitmap()):Be?Promise.resolve(B.h.canvas):"function"==typeof createImageBitmap?createImageBitmap(B.h.canvas):(void 0===B.j&&(B.j=document.createElement("canvas")),new Promise(function(ot){B.j.height=B.h.canvas.height,B.j.width=B.h.canvas.width,B.j.getContext("2d",{}).drawImage(B.h.canvas,0,0,B.h.canvas.width,B.h.canvas.height),ot(B.j)}))}function ai(B){this.h=B}qn.prototype.l=q(os);var oc=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function wo(B,ve){return ve+B}function Fa(B,ve){window[B]=ve}function Yc(B){if(this.h=B,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=B&&B.locateFile||wo,"object"==typeof window)var ve=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if(!(typeof location<"u"))throw Error("solutions can only be loaded on a web page or in a web worker");ve=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=ve,B.options)for(var Be=(ve=I(Object.keys(B.options))).next();!Be.done;Be=ve.next()){var ot=B.options[Be=Be.value].default;void 0!==ot&&(this.l[Be]="function"==typeof ot?ot():ot)}}function Zc(B,ve){var Be,ot;return de(function(st){return ve in B.L?st.return(B.L[ve]):(Be=B.locateFile(ve,""),ot=fetch(Be).then(function(Xt){return Xt.arrayBuffer()}),B.L[ve]=ot,st.return(ot))})}function Qc(B,ve){for(var Be=ve.name||"$",ot=[].concat(N(ve.wants)),st=new B.i.StringList,Xt=I(ve.wants),jt=Xt.next();!jt.done;jt=Xt.next())st.push_back(jt.value);Xt=B.i.PacketListener.implement({onResults:function(Yt){for(var xn={},ss=0;ss<ve.wants.length;++ss)xn[ot[ss]]=Yt.get(ss);var Jn=B.listeners[Be];Jn&&(B.I=function Oc(B,ve,Be){var ot,st,Xt,jt,xn,ss,Jn,_r,Qs,As,Zr,jn;return de(function(Oi){switch(Oi.h){case 1:if(!Be)return Oi.return(ve);for(ot={},st=0,Xt=I(Object.keys(Be)),jt=Xt.next();!jt.done;jt=Xt.next())"string"!=typeof(xn=Be[jt.value])&&"texture"===xn.type&&void 0!==ve[xn.stream]&&++st;1<st&&(B.M=!1),ss=I(Object.keys(Be)),jt=ss.next();case 2:if(jt.done){Oi.h=4;break}if("string"==typeof(_r=Be[Jn=jt.value]))return Zr=ot,jn=Jn,we(Oi,function Fc(B,ve,Be){var ot;return de(function(st){return"number"==typeof Be||Be instanceof Uint8Array||Be instanceof B.i.Uint8BlobList?st.return(Be):Be instanceof B.i.Texture2dDataOut?((ot=B.v[ve])||(ot=new yo(B.i,B.K),B.v[ve]=ot),st.return(Da(ot,Be,B.M))):st.return(void 0)})}(B,Jn,ve[_r]),14);if(Qs=ve[_r.stream],"detection_list"===_r.type){if(Qs){for(var ca=Qs.getRectList(),Yo=Qs.getLandmarksList(),La=Qs.getClassificationsList(),hi=[],ci=0;ci<ca.size();++ci){var qt=Ms(ca.get(ci)),Gi=void 0;Gi=void 0===Gi?0:Gi,qt={la:{sa:Pr(qt,1),ta:Pr(qt,2),height:Pr(qt,3),width:Pr(qt,4),rotation:Pr(qt,5,0),pa:$o(so(qt,6),Gi)},ea:lr(Yo.get(ci)),ba:Cr(Ye(La.get(ci)))},hi.push(qt)}ca=hi}else ca=[];ot[Jn]=ca,Oi.h=7;break}if("proto_list"===_r.type){if(Qs){for(ca=Array(Qs.size()),Yo=0;Yo<Qs.size();Yo++)ca[Yo]=Qs.get(Yo);Qs.delete()}else ca=[];ot[Jn]=ca,Oi.h=7;break}if(void 0===Qs){Oi.h=3;break}if("float_list"===_r.type){ot[Jn]=Qs,Oi.h=7;break}if("proto"===_r.type){ot[Jn]=Qs,Oi.h=7;break}if("texture"!==_r.type)throw Error("Unknown output config type: '"+_r.type+"'");return(As=B.v[Jn])||(As=new yo(B.i,B.K),B.v[Jn]=As),we(Oi,Da(As,Qs,B.M),13);case 13:ot[Jn]=Oi.i;case 7:_r.transform&&ot[Jn]&&(ot[Jn]=_r.transform(ot[Jn])),Oi.h=3;break;case 14:Zr[jn]=Oi.i;case 3:jt=ss.next(),Oi.h=2;break;case 4:return Oi.return(ot)}})}(B,xn,ve.outs).then(function(_r){_r=Jn(_r);for(var Qs=0;Qs<ve.wants.length;++Qs){var As=xn[ot[Qs]];"object"==typeof As&&As.hasOwnProperty&&As.hasOwnProperty("delete")&&As.delete()}_r&&(B.I=_r)}))}}),B.j.attachMultiListener(st,Xt),st.delete()}function Ai(B){switch(void 0===B&&(B=0),B){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Iu(B){var ve=this;this.h=new Yc({locateFile:(B=B||{}).locateFile,files:function(Be){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Ai(Be.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:lr},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:lr},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"==typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(Be){var ot,st;return de(function(jt){return 1==jt.h?(ot=Ai(Be),st="third_party/mediapipe/modules/pose_landmark/"+ot,we(jt,Zc(ve.h,ot),2)):(ve.h.overrideFile(st,jt.i),jt.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(Et=Yc.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},Et.reset=function(){var B=this;return de(function(ve){B.j&&(B.j.reset(),B.s={},B.v={}),ve.h=0})},Et.setOptions=function(B,ve){var Be=this;if(ve=ve||this.h.options){for(var ot=[],st=[],Xt={},jt=I(Object.keys(B)),Yt=jt.next();!Yt.done;Xt={X:Xt.X,Y:Xt.Y},Yt=jt.next())if(!((Yt=Yt.value)in this.l)||this.l[Yt]!==B[Yt]){this.l[Yt]=B[Yt];var xn=ve[Yt];void 0!==xn&&(xn.onChange&&(Xt.X=xn.onChange,Xt.Y=B[Yt],ot.push(function(ss){return function(){return de(function(_r){if(1==_r.h)return we(_r,ss.X(ss.Y),2);!0===_r.i&&(Be.u=!0),_r.h=0})}}(Xt))),xn.graphOptionXref&&(Yt=Object.assign({},{calculatorName:"",calculatorIndex:0},xn.graphOptionXref,{valueNumber:1===xn.type?B[Yt]:0,valueBoolean:0===xn.type&&B[Yt],valueString:2===xn.type?B[Yt]:""}),st.push(Yt)))}(0!==ot.length||0!==st.length)&&(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(st),this.F=(void 0===this.F?[]:this.F).concat(ot))}},Et.initialize=function(){var B=this;return de(function(ve){return 1==ve.h?we(ve,function Wu(B){var ve,Be,ot,st,Xt,jt,Yt,xn,ss,Jn,_r;return de(function(Qs){switch(Qs.h){case 1:return B.ga?(ve=void 0===B.h.files?[]:"function"==typeof B.h.files?B.h.files(B.l):B.h.files,we(Qs,function Fi(){return de(function(B){switch(B.h){case 1:return B.s=2,we(B,WebAssembly.instantiate(oc),4);case 4:B.h=3,B.s=0;break;case 2:return B.s=0,B.l=null,B.return(!1);case 3:return B.return(!0)}})}(),2)):Qs.return();case 2:if(Be=Qs.i,"object"==typeof window)return Fa("createMediapipeSolutionsWasm",{locateFile:B.locateFile}),Fa("createMediapipeSolutionsPackedAssets",{locateFile:B.locateFile}),jt=ve.filter(function(As){return void 0!==As.data}),Yt=ve.filter(function(As){return void 0===As.data}),xn=Promise.all(jt.map(function(As){var cn=Zc(B,As.url);if(void 0!==As.path){var Zr=As.path;cn=cn.then(function(jn){return B.overrideFile(Zr,jn),Promise.resolve(jn)})}return cn})),ss=Promise.all(Yt.map(function(As){return void 0===As.simd||As.simd&&Be||!As.simd&&!Be?function yl(B){var ve=document.createElement("script");return ve.setAttribute("src",B),ve.setAttribute("crossorigin","anonymous"),new Promise(function(Be){ve.addEventListener("load",function(){Be()},!1),ve.addEventListener("error",function(){Be()},!1),document.body.appendChild(ve)})}(B.locateFile(As.url,B.ha)):Promise.resolve()})).then(function(){var As,cn,Zr;return de(function(jn){if(1==jn.h)return As=window.createMediapipeSolutionsWasm,cn=window.createMediapipeSolutionsPackedAssets,Zr=B,we(jn,As(cn),2);Zr.i=jn.i,jn.h=0})}),Jn=de(function(As){return B.h.graph&&B.h.graph.url?As=we(As,Zc(B,B.h.graph.url),0):(As.h=0,As=void 0),As}),we(Qs,Promise.all([ss,xn,Jn]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return ot=ve.filter(function(As){return void 0===As.simd||As.simd&&Be||!As.simd&&!Be}).map(function(As){return B.locateFile(As.url,B.ha)}),importScripts.apply(null,N(ot)),st=B,we(Qs,createMediapipeSolutionsWasm(Module),6);case 6:st.i=Qs.i,B.m=new OffscreenCanvas(1,1),B.i.canvas=B.m,Xt=B.i.GL.createContext(B.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),B.i.GL.makeContextCurrent(Xt),Qs.h=4;break;case 7:if(B.m=document.createElement("canvas"),!(_r=B.m.getContext("webgl2",{}))&&!(_r=B.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),Qs.return();B.K=_r,B.i.canvas=B.m,B.i.createContext(B.m,!0,!0,{});case 4:B.j=new B.i.SolutionWasm,B.ga=!1,Qs.h=0}})}(B),2):3!=ve.h?we(ve,function vl(B){var Be,ot,st,Xt,jt,xn;return de(function(ss){if(1==ss.h)return B.h.graph&&B.h.graph.url&&B.fa===B.h.graph.url?ss.return():(B.u=!0,B.h.graph&&B.h.graph.url?(B.fa=B.h.graph.url,we(ss,Zc(B,B.h.graph.url),3)):void(ss.h=2));for(2!=ss.h&&B.j.loadGraph(ss.i),Be=I(Object.keys(B.D)),ot=Be.next();!ot.done;ot=Be.next())B.j.overrideFile(st=ot.value,B.D[st]);if(B.D={},B.h.listeners)for(Xt=I(B.h.listeners),jt=Xt.next();!jt.done;jt=Xt.next())Qc(B,jt.value);xn=B.l,B.l={},B.setOptions(xn),ss.h=0})}(B),3):we(ve,function Hl(B){var ve,Be,st,Xt,jt;return de(function(xn){switch(xn.h){case 1:if(!B.u)return xn.return();if(!B.F){xn.h=2;break}ve=I(B.F),Be=ve.next();case 3:if(Be.done){xn.h=5;break}return we(xn,(0,Be.value)(),4);case 4:Be=ve.next(),xn.h=3;break;case 5:B.F=void 0;case 2:if(B.H){for(st=new B.i.GraphOptionChangeRequestList,Xt=I(B.H),jt=Xt.next();!jt.done;jt=Xt.next())st.push_back(jt.value);B.j.changeOptions(st),st.delete(),B.H=void 0}B.u=!1,xn.h=0}})}(B),0)})},Et.overrideFile=function(B,ve){this.j?this.j.overrideFile(B,ve):this.D[B]=ve},Et.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},Et.send=function(B,ve){var ot,st,Xt,jt,Yt,xn,ss,Jn,_r,Be=this;return de(function(Qs){switch(Qs.h){case 1:return Be.h.inputs?(ot=1e3*(ve??performance.now()),we(Qs,Be.I,2)):Qs.return();case 2:return we(Qs,Be.initialize(),3);case 3:for(st=new Be.i.PacketDataList,Xt=I(Object.keys(B)),jt=Xt.next();!jt.done;jt=Xt.next())if(xn=Be.h.inputs[Yt=jt.value]){e:{var As=B[Yt];switch(xn.type){case"video":var cn=Be.s[xn.stream];if(cn||(cn=new yo(Be.i,Be.K),Be.s[xn.stream]=cn),0===cn.m&&(cn.m=cn.i.createTexture()),typeof HTMLVideoElement<"u"&&As instanceof HTMLVideoElement)var Zr=As.videoWidth,jn=As.videoHeight;else typeof HTMLImageElement<"u"&&As instanceof HTMLImageElement?(Zr=As.naturalWidth,jn=As.naturalHeight):(Zr=As.width,jn=As.height);jn={glName:cn.m,width:Zr,height:jn},(Zr=cn.h).canvas.width=jn.width,Zr.canvas.height=jn.height,Zr.activeTexture(Zr.TEXTURE0),cn.i.bindTexture2d(cn.m),Zr.texImage2D(Zr.TEXTURE_2D,0,Zr.RGBA,Zr.RGBA,Zr.UNSIGNED_BYTE,As),cn.i.bindTexture2d(0),cn=jn;break e;case"detections":for((cn=Be.s[xn.stream])||(cn=new ai(Be.i),Be.s[xn.stream]=cn),cn.data||(cn.data=new cn.h.DetectionListData),cn.data.reset(As.length),jn=0;jn<As.length;++jn){var Oi=cn.data,ca=Oi.setBoundingBox,Yo=jn,La=(Zr=As[jn]).la,hi=new qn;if(Js(hi,1,La.sa),Js(hi,2,La.ta),Js(hi,3,La.height),Js(hi,4,La.width),Js(hi,5,La.rotation),il(hi,6,La.pa),La=hi.l(),ca.call(Oi,Yo,La),Zr.ea)for(Oi=0;Oi<Zr.ea.length;++Oi){hi=Zr.ea[Oi],Yo=(ca=cn.data).addNormalizedLandmark,La=jn,hi=Object.assign({},hi,{visibility:hi.visibility?hi.visibility:0});var ci=new it;Js(ci,1,hi.x),Js(ci,2,hi.y),Js(ci,3,hi.z),hi.visibility&&Js(ci,4,hi.visibility),hi=ci.l(),Yo.call(ca,La,hi)}if(Zr.ba)for(Oi=0;Oi<Zr.ba.length;++Oi)Yo=(ca=cn.data).addClassification,La=jn,hi=Zr.ba[Oi],Js(ci=new L,2,hi.qa),hi.index&&il(ci,1,hi.index),hi.label&&il(ci,3,hi.label),hi.displayName&&il(ci,4,hi.displayName),hi=ci.l(),Yo.call(ca,La,hi)}cn=cn.data;break e;default:cn={}}}switch(ss=cn,Jn=xn.stream,xn.type){case"video":st.pushTexture2d(Object.assign({},ss,{stream:Jn,timestamp:ot}));break;case"detections":(_r=ss).stream=Jn,_r.timestamp=ot,st.pushDetectionList(_r);break;default:throw Error("Unknown input config type: '"+xn.type+"'")}}return Be.j.send(st),we(Qs,Be.I,4);case 4:st.delete(),Qs.h=0}})},Et.onResults=function(B,ve){this.listeners[ve||"$"]=B},Te("Solution",Yc),Te("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(Et=Iu.prototype).reset=function(){this.h.reset()},Et.close=function(){return this.h.close(),Promise.resolve()},Et.onResults=function(B){this.h.onResults(B)},Et.initialize=function(){var B=this;return de(function(ve){return we(ve,B.h.initialize(),0)})},Et.send=function(B,ve){var Be=this;return de(function(ot){return we(ot,Be.h.send(B,ve),0)})},Et.setOptions=function(B){this.h.setOptions(B)},Te("Pose",Iu),Te("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),Te("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),Te("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),Te("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),Te("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),Te("VERSION","0.5.1675469404")}).call(this)},5388:(Et,le,h)=>{"use strict";function U(t){return"function"==typeof t}function Z(t){const s=t(n=>{Error.call(n),n.stack=(new Error).stack});return s.prototype=Object.create(Error.prototype),s.prototype.constructor=s,s}const y=Z(t=>function(s){t(this),this.message=s?`${s.length} errors occurred during unsubscription:\n${s.map((n,r)=>`${r+1}) ${n.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=s});function F(t,e){if(t){const s=t.indexOf(e);0<=s&&t.splice(s,1)}}class I{constructor(e){this.initialTeardown=e,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let e;if(!this.closed){this.closed=!0;const{_parentage:s}=this;if(s)if(this._parentage=null,Array.isArray(s))for(const i of s)i.remove(this);else s.remove(this);const{initialTeardown:n}=this;if(U(n))try{n()}catch(i){e=i instanceof y?i.errors:[i]}const{_finalizers:r}=this;if(r){this._finalizers=null;for(const i of r)try{l(i)}catch(a){e=e??[],a instanceof y?e=[...e,...a.errors]:e.push(a)}}if(e)throw new y(e)}}add(e){var s;if(e&&e!==this)if(this.closed)l(e);else{if(e instanceof I){if(e.closed||e._hasParent(this))return;e._addParent(this)}(this._finalizers=null!==(s=this._finalizers)&&void 0!==s?s:[]).push(e)}}_hasParent(e){const{_parentage:s}=this;return s===e||Array.isArray(s)&&s.includes(e)}_addParent(e){const{_parentage:s}=this;this._parentage=Array.isArray(s)?(s.push(e),s):s?[s,e]:e}_removeParent(e){const{_parentage:s}=this;s===e?this._parentage=null:Array.isArray(s)&&F(s,e)}remove(e){const{_finalizers:s}=this;s&&F(s,e),e instanceof I&&e._removeParent(this)}}I.EMPTY=(()=>{const t=new I;return t.closed=!0,t})();const N=I.EMPTY;function W(t){return t instanceof I||t&&"closed"in t&&U(t.remove)&&U(t.add)&&U(t.unsubscribe)}function l(t){U(t)?t():t.unsubscribe()}const w={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},M={setTimeout(t,e,...s){const{delegate:n}=M;return n?.setTimeout?n.setTimeout(t,e,...s):setTimeout(t,e,...s)},clearTimeout(t){const{delegate:e}=M;return(e?.clearTimeout||clearTimeout)(t)},delegate:void 0};function T(t){M.setTimeout(()=>{const{onUnhandledError:e}=w;if(!e)throw t;e(t)})}function D(){}const G=_e("C",void 0,void 0);function _e(t,e,s){return{kind:t,value:e,error:s}}let Re=null;function we(t){if(w.useDeprecatedSynchronousErrorHandling){const e=!Re;if(e&&(Re={errorThrown:!1,error:null}),t(),e){const{errorThrown:s,error:n}=Re;if(Re=null,s)throw n}}else t()}class Oe extends I{constructor(e){super(),this.isStopped=!1,e?(this.destination=e,W(e)&&e.add(this)):this.destination=ye}static create(e,s,n){return new te(e,s,n)}next(e){this.isStopped?oe(function K(t){return _e("N",t,void 0)}(e),this):this._next(e)}error(e){this.isStopped?oe(function J(t){return _e("E",void 0,t)}(e),this):(this.isStopped=!0,this._error(e))}complete(){this.isStopped?oe(G,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(e){this.destination.next(e)}_error(e){try{this.destination.error(e)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const ie=Function.prototype.bind;function Le(t,e){return ie.call(t,e)}class De{constructor(e){this.partialObserver=e}next(e){const{partialObserver:s}=this;if(s.next)try{s.next(e)}catch(n){de(n)}}error(e){const{partialObserver:s}=this;if(s.error)try{s.error(e)}catch(n){de(n)}else de(e)}complete(){const{partialObserver:e}=this;if(e.complete)try{e.complete()}catch(s){de(s)}}}class te extends Oe{constructor(e,s,n){let r;if(super(),U(e)||!e)r={next:e??void 0,error:s??void 0,complete:n??void 0};else{let i;this&&w.useDeprecatedNextContext?(i=Object.create(e),i.unsubscribe=()=>this.unsubscribe(),r={next:e.next&&Le(e.next,i),error:e.error&&Le(e.error,i),complete:e.complete&&Le(e.complete,i)}):r=e}this.destination=new De(r)}}function de(t){w.useDeprecatedSynchronousErrorHandling?function We(t){w.useDeprecatedSynchronousErrorHandling&&Re&&(Re.errorThrown=!0,Re.error=t)}(t):T(t)}function oe(t,e){const{onStoppedNotification:s}=w;s&&M.setTimeout(()=>s(t,e))}const ye={closed:!0,next:D,error:function P(t){throw t},complete:D},Te="function"==typeof Symbol&&Symbol.observable||"@@observable";function v(t){return t}function Xe(t){return 0===t.length?v:1===t.length?t[0]:function(s){return t.reduce((n,r)=>r(n),s)}}let Ue=(()=>{class t{constructor(s){s&&(this._subscribe=s)}lift(s){const n=new t;return n.source=this,n.operator=s,n}subscribe(s,n,r){const i=function It(t){return t&&t instanceof Oe||function Ct(t){return t&&U(t.next)&&U(t.error)&&U(t.complete)}(t)&&W(t)}(s)?s:new te(s,n,r);return we(()=>{const{operator:a,source:c}=this;i.add(a?a.call(i,c):c?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(s){try{return this._subscribe(s)}catch(n){s.error(n)}}forEach(s,n){return new(n=pt(n))((r,i)=>{const a=new te({next:c=>{try{s(c)}catch(f){i(f),a.unsubscribe()}},error:i,complete:r});this.subscribe(a)})}_subscribe(s){var n;return null===(n=this.source)||void 0===n?void 0:n.subscribe(s)}[Te](){return this}pipe(...s){return Xe(s)(this)}toPromise(s){return new(s=pt(s))((n,r)=>{let i;this.subscribe(a=>i=a,a=>r(a),()=>n(i))})}}return t.create=e=>new t(e),t})();function pt(t){var e;return null!==(e=t??w.Promise)&&void 0!==e?e:Promise}const nn=Z(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Bt=(()=>{class t extends Ue{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(s){const n=new bn(this,this);return n.operator=s,n}_throwIfClosed(){if(this.closed)throw new nn}next(s){we(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const n of this.currentObservers)n.next(s)}})}error(s){we(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=s;const{observers:n}=this;for(;n.length;)n.shift().error(s)}})}complete(){we(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:s}=this;for(;s.length;)s.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var s;return(null===(s=this.observers)||void 0===s?void 0:s.length)>0}_trySubscribe(s){return this._throwIfClosed(),super._trySubscribe(s)}_subscribe(s){return this._throwIfClosed(),this._checkFinalizedStatuses(s),this._innerSubscribe(s)}_innerSubscribe(s){const{hasError:n,isStopped:r,observers:i}=this;return n||r?N:(this.currentObservers=null,i.push(s),new I(()=>{this.currentObservers=null,F(i,s)}))}_checkFinalizedStatuses(s){const{hasError:n,thrownError:r,isStopped:i}=this;n?s.error(r):i&&s.complete()}asObservable(){const s=new Ue;return s.source=this,s}}return t.create=(e,s)=>new bn(e,s),t})();class bn extends Bt{constructor(e,s){super(),this.destination=e,this.source=s}next(e){var s,n;null===(n=null===(s=this.destination)||void 0===s?void 0:s.next)||void 0===n||n.call(s,e)}error(e){var s,n;null===(n=null===(s=this.destination)||void 0===s?void 0:s.error)||void 0===n||n.call(s,e)}complete(){var e,s;null===(s=null===(e=this.destination)||void 0===e?void 0:e.complete)||void 0===s||s.call(e)}_subscribe(e){var s,n;return null!==(n=null===(s=this.source)||void 0===s?void 0:s.subscribe(e))&&void 0!==n?n:N}}function Qn(t){return U(t?.lift)}function Dn(t){return e=>{if(Qn(e))return e.lift(function(s){try{return t(s,this)}catch(n){this.error(n)}});throw new TypeError("Unable to lift unknown Observable type")}}function ps(t,e,s,n,r){return new Es(t,e,s,n,r)}class Es extends Oe{constructor(e,s,n,r,i,a){super(e),this.onFinalize=i,this.shouldUnsubscribe=a,this._next=s?function(c){try{s(c)}catch(f){e.error(f)}}:super._next,this._error=r?function(c){try{r(c)}catch(f){e.error(f)}finally{this.unsubscribe()}}:super._error,this._complete=n?function(){try{n()}catch(c){e.error(c)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var e;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:s}=this;super.unsubscribe(),!s&&(null===(e=this.onFinalize)||void 0===e||e.call(this))}}}function Xn(t,e){return Dn((s,n)=>{let r=0;s.subscribe(ps(n,i=>{n.next(t.call(e,i,r++))}))})}function lo(t){return this instanceof lo?(this.v=t,this):new lo(t)}function sl(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,e=t[Symbol.asyncIterator];return e?e.call(t):(t=function aa(t){var e="function"==typeof Symbol&&Symbol.iterator,s=e&&t[e],n=0;if(s)return s.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&n>=t.length&&(t=void 0),{value:t&&t[n++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),s={},n("next"),n("throw"),n("return"),s[Symbol.asyncIterator]=function(){return this},s);function n(i){s[i]=t[i]&&function(a){return new Promise(function(c,f){!function r(i,a,c,f){Promise.resolve(f).then(function(g){i({value:g,done:c})},a)}(c,f,(a=t[i](a)).done,a.value)})}}}"function"==typeof SuppressedError&&SuppressedError;const ui=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function ja(t){return U(t?.then)}function Go(t){return U(t[Te])}function Li(t){return Symbol.asyncIterator&&U(t?.[Symbol.asyncIterator])}function wa(t){return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const Xi=function Ki(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function $i(t){return U(t?.[Xi])}function Bi(t){return function Ao(t,e,s){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,n=s.apply(t,e||[]),i=[];return r={},a("next"),a("throw"),a("return"),r[Symbol.asyncIterator]=function(){return this},r;function a(Y){n[Y]&&(r[Y]=function(ne){return new Promise(function(Ee,Ge){i.push([Y,ne,Ee,Ge])>1||c(Y,ne)})})}function c(Y,ne){try{!function f(Y){Y.value instanceof lo?Promise.resolve(Y.value.v).then(g,E):A(i[0][2],Y)}(n[Y](ne))}catch(Ee){A(i[0][3],Ee)}}function g(Y){c("next",Y)}function E(Y){c("throw",Y)}function A(Y,ne){Y(ne),i.shift(),i.length&&c(i[0][0],i[0][1])}}(this,arguments,function*(){const s=t.getReader();try{for(;;){const{value:n,done:r}=yield lo(s.read());if(r)return yield lo(void 0);yield yield lo(n)}}finally{s.releaseLock()}})}function hl(t){return U(t?.getReader)}function Jr(t){if(t instanceof Ue)return t;if(null!=t){if(Go(t))return function Lo(t){return new Ue(e=>{const s=t[Te]();if(U(s.subscribe))return s.subscribe(e);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(t);if(ui(t))return function dc(t){return new Ue(e=>{for(let s=0;s<t.length&&!e.closed;s++)e.next(t[s]);e.complete()})}(t);if(ja(t))return function hc(t){return new Ue(e=>{t.then(s=>{e.closed||(e.next(s),e.complete())},s=>e.error(s)).then(null,T)})}(t);if(Li(t))return Ko(t);if($i(t))return function Ga(t){return new Ue(e=>{for(const s of t)if(e.next(s),e.closed)return;e.complete()})}(t);if(hl(t))return function pc(t){return Ko(Bi(t))}(t)}throw wa(t)}function Ko(t){return new Ue(e=>{(function pl(t,e){var s,n,r,i;return function xr(t,e,s,n){return new(s||(s=Promise))(function(i,a){function c(E){try{g(n.next(E))}catch(A){a(A)}}function f(E){try{g(n.throw(E))}catch(A){a(A)}}function g(E){E.done?i(E.value):function r(i){return i instanceof s?i:new s(function(a){a(i)})}(E.value).then(c,f)}g((n=n.apply(t,e||[])).next())})}(this,void 0,void 0,function*(){try{for(s=sl(t);!(n=yield s.next()).done;)if(e.next(n.value),e.closed)return}catch(a){r={error:a}}finally{try{n&&!n.done&&(i=s.return)&&(yield i.call(s))}finally{if(r)throw r.error}}e.complete()})})(t,e).catch(s=>e.error(s))})}function ko(t,e,s,n=0,r=!1){const i=e.schedule(function(){s(),r?t.add(this.schedule(null,n)):this.unsubscribe()},n);if(t.add(i),!r)return i}function no(t,e,s=1/0){return U(e)?no((n,r)=>Xn((i,a)=>e(n,i,r,a))(Jr(t(n,r))),s):("number"==typeof e&&(s=e),Dn((n,r)=>function fl(t,e,s,n,r,i,a,c){const f=[];let g=0,E=0,A=!1;const Y=()=>{A&&!f.length&&!g&&e.complete()},ne=Ge=>g<n?Ee(Ge):f.push(Ge),Ee=Ge=>{i&&e.next(Ge),g++;let tt=!1;Jr(s(Ge,E++)).subscribe(ps(e,Nt=>{r?.(Nt),i?ne(Nt):e.next(Nt)},()=>{tt=!0},void 0,()=>{if(tt)try{for(g--;f.length&&g<n;){const Nt=f.shift();a?ko(e,a,()=>Ee(Nt)):Ee(Nt)}Y()}catch(Nt){e.error(Nt)}}))};return t.subscribe(ps(e,ne,()=>{A=!0,Y()})),()=>{c?.()}}(n,r,t,s)))}function Ka(t=1/0){return no(v,t)}const so=new Ue(t=>t.complete());function fc(t){return t&&U(t.schedule)}function zl(t){return t[t.length-1]}function ol(t){return U(zl(t))?t.pop():void 0}function Xa(t){return fc(zl(t))?t.pop():void 0}function vi(t,e=0){return Dn((s,n)=>{s.subscribe(ps(n,r=>ko(n,t,()=>n.next(r),e),()=>ko(n,t,()=>n.complete(),e),r=>ko(n,t,()=>n.error(r),e)))})}function $o(t,e=0){return Dn((s,n)=>{n.add(t.schedule(()=>s.subscribe(n),e))})}function Ra(t,e){if(!t)throw new Error("Iterable cannot be null");return new Ue(s=>{ko(s,e,()=>{const n=t[Symbol.asyncIterator]();ko(s,e,()=>{n.next().then(r=>{r.done?s.complete():s.next(r.value)})},0,!0)})})}function Hi(t,e){return e?function Oo(t,e){if(null!=t){if(Go(t))return function Pr(t,e){return Jr(t).pipe($o(e),vi(e))}(t,e);if(ui(t))return function Al(t,e){return new Ue(s=>{let n=0;return e.schedule(function(){n===t.length?s.complete():(s.next(t[n++]),s.closed||this.schedule())})})}(t,e);if(ja(t))return function Oa(t,e){return Jr(t).pipe($o(e),vi(e))}(t,e);if(Li(t))return Ra(t,e);if($i(t))return function uo(t,e){return new Ue(s=>{let n;return ko(s,e,()=>{n=t[Xi](),ko(s,e,()=>{let r,i;try{({value:r,done:i}=n.next())}catch(a){return void s.error(a)}i?s.complete():s.next(r)},0,!0)}),()=>U(n?.return)&&n.return()})}(t,e);if(hl(t))return function Zi(t,e){return Ra(Bi(t),e)}(t,e)}throw wa(t)}(t,e):Jr(t)}function ji(...t){const e=Xa(t),s=function Js(t,e){return"number"==typeof zl(t)?t.pop():e}(t,1/0),n=t;return n.length?1===n.length?Jr(n[0]):Ka(s)(Hi(n,e)):so}class Di extends Bt{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const s=super._subscribe(e);return!s.closed&&e.next(this._value),s}getValue(){const{hasError:e,thrownError:s,_value:n}=this;if(e)throw s;return this._throwIfClosed(),n}next(e){super.next(this._value=e)}}function Xs(...t){return Hi(t,Xa(t))}function ro(t={}){const{connector:e=(()=>new Bt),resetOnError:s=!0,resetOnComplete:n=!0,resetOnRefCountZero:r=!0}=t;return i=>{let a,c,f,g=0,E=!1,A=!1;const Y=()=>{c?.unsubscribe(),c=void 0},ne=()=>{Y(),a=f=void 0,E=A=!1},Ee=()=>{const Ge=a;ne(),Ge?.unsubscribe()};return Dn((Ge,tt)=>{g++,!A&&!E&&Y();const Nt=f=f??e();tt.add(()=>{g--,0===g&&!A&&!E&&(c=pa(Ee,r))}),Nt.subscribe(tt),!a&&g>0&&(a=new te({next:kt=>Nt.next(kt),error:kt=>{A=!0,Y(),c=pa(ne,s,kt),Nt.error(kt)},complete:()=>{E=!0,Y(),c=pa(ne,n),Nt.complete()}}),Jr(Ge).subscribe(a))})(i)}}function pa(t,e,...s){if(!0===e)return void t();if(!1===e)return;const n=new te({next:()=>{n.unsubscribe(),t()}});return Jr(e(...s)).subscribe(n)}function Qi(t,e){return Dn((s,n)=>{let r=null,i=0,a=!1;const c=()=>a&&!r&&n.complete();s.subscribe(ps(n,f=>{r?.unsubscribe();let g=0;const E=i++;Jr(t(f,E)).subscribe(r=ps(n,A=>n.next(e?e(f,A,E,g++):A),()=>{r=null,c()}))},()=>{a=!0,c()}))})}function al(t,e=v){return t=t??fa,Dn((s,n)=>{let r,i=!0;s.subscribe(ps(n,a=>{const c=e(a);(i||!t(r,c))&&(i=!1,r=c,n.next(a))}))})}function fa(t,e){return t===e}function di(t){for(let e in t)if(t[e]===di)return e;throw Error("Could not find renamed property on target object.")}function ma(t,e){for(const s in e)e.hasOwnProperty(s)&&!t.hasOwnProperty(s)&&(t[s]=e[s])}function mo(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(mo).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const e=t.toString();if(null==e)return""+e;const s=e.indexOf("\n");return-1===s?e:e.substring(0,s)}function mi(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const ic=di({__forward_ref__:di});function Br(t){return t.__forward_ref__=Br,t.toString=function(){return mo(this())},t}function dr(t){return Xo(t)?t():t}function Xo(t){return"function"==typeof t&&t.hasOwnProperty(ic)&&t.__forward_ref__===Br}function go(t){return t&&!!t.\u0275providers}const Na="https://g.co/ng/security#xss";class En extends Error{constructor(e,s){super(function ki(t,e){return`NG0${Math.abs(t)}${e?": "+e:""}`}(e,s)),this.code=e}}function wr(t){return"string"==typeof t?t:null==t?"":String(t)}function Wl(t,e){throw new En(-201,!1)}function Ae(t,e){null==t&&function He(t,e,s,n){throw new Error(`ASSERTION ERROR: ${t}`+(null==n?"":` [Expected=> ${s} ${n} ${e} <=Actual]`))}(e,t,null,"!=")}function wt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function pn(t){return{providers:t.providers||[],imports:t.imports||[]}}function qn(t){return Ms(t,Is)||Ms(t,yo)}function Ms(t,e){return t.hasOwnProperty(e)?t[e]:null}function Cr(t){return t&&(t.hasOwnProperty(lr)||t.hasOwnProperty(Da))?t[lr]:null}const Is=di({\u0275prov:di}),lr=di({\u0275inj:di}),yo=di({ngInjectableDef:di}),Da=di({ngInjectorDef:di});var Jt=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}(Jt||{});let ai;function wo(t){const e=ai;return ai=t,e}function Fa(t,e,s){const n=qn(t);return n&&"root"==n.providedIn?void 0===n.value?n.value=n.factory():n.value:s&Jt.Optional?null:void 0!==e?e:void Wl(mo(t))}const Fi=globalThis,ot={},st="__NG_DI_FLAG__",Xt="ngTempTokenPath",Yt=/\n/gm,ss="__source";let Jn;function Qs(t){const e=Jn;return Jn=t,e}function As(t,e=Jt.Default){if(void 0===Jn)throw new En(-203,!1);return null===Jn?Fa(t,void 0,e):Jn.get(t,e&Jt.Optional?null:void 0,e)}function cn(t,e=Jt.Default){return(function oc(){return ai}()||As)(dr(t),e)}function jn(t,e=Jt.Default){return cn(t,Oi(e))}function Oi(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function ca(t){const e=[];for(let s=0;s<t.length;s++){const n=dr(t[s]);if(Array.isArray(n)){if(0===n.length)throw new En(900,!1);let r,i=Jt.Default;for(let a=0;a<n.length;a++){const c=n[a],f=La(c);"number"==typeof f?-1===f?r=c.token:i|=f:r=c}e.push(cn(r,i))}else e.push(cn(n))}return e}function Yo(t,e){return t[st]=e,t.prototype[st]=e,t}function La(t){return t[st]}function qt(t){return{toString:t}.toString()}var jl=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}(jl||{}),oo=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}(oo||{});const Bo={},wi=[],$a=di({\u0275cmp:di}),Gi=di({\u0275dir:di}),uu=di({\u0275pipe:di}),an=di({\u0275mod:di}),kl=di({\u0275fac:di}),Gl=di({__NG_ELEMENT_ID__:di}),Tu=di({__NG_ENV_ID__:di});function sd(t,e,s){let n=t.length;for(;;){const r=t.indexOf(e,s);if(-1===r)return r;if(0===r||t.charCodeAt(r-1)<=32){const i=e.length;if(r+i===n||t.charCodeAt(r+i)<=32)return r}s=r+1}}function gc(t,e,s){let n=0;for(;n<s.length;){const r=s[n];if("number"==typeof r){if(0!==r)break;n++;const i=s[n++],a=s[n++],c=s[n++];t.setAttribute(e,a,c,i)}else{const i=r,a=s[++n];Au(i)?t.setProperty(e,i,a):t.setAttribute(e,i,a),n++}}return n}function rd(t){return 3===t||4===t||6===t}function Au(t){return 64===t.charCodeAt(0)}function V(t,e){if(null!==e&&0!==e.length)if(null===t||0===t.length)t=e.slice();else{let s=-1;for(let n=0;n<e.length;n++){const r=e[n];"number"==typeof r?s=r:0===s||O(t,s,r,null,-1===s||2===s?e[++n]:null)}}return t}function O(t,e,s,n,r){let i=0,a=t.length;if(-1===e)a=-1;else for(;i<t.length;){const c=t[i++];if("number"==typeof c){if(c===e){a=-1;break}if(c>e){a=i-1;break}}}for(;i<t.length;){const c=t[i];if("number"==typeof c)break;if(c===s){if(null===n)return void(null!==r&&(t[i+1]=r));if(n===t[i+1])return void(t[i+2]=r)}i++,null!==n&&i++,null!==r&&i++}-1!==a&&(t.splice(a,0,e),i=a+1),t.splice(i++,0,s),null!==n&&t.splice(i++,0,n),null!==r&&t.splice(i++,0,r)}const z="ng-template";function pe(t,e,s){let n=0,r=!0;for(;n<t.length;){let i=t[n++];if("string"==typeof i&&r){const a=t[n++];if(s&&"class"===i&&-1!==sd(a.toLowerCase(),e,0))return!0}else{if(1===i){for(;n<t.length&&"string"==typeof(i=t[n++]);)if(i.toLowerCase()===e)return!0;return!1}"number"==typeof i&&(r=!1)}}return!1}function Pe(t){return 4===t.type&&t.value!==z}function Ve(t,e,s){return e===(4!==t.type||s?t.value:z)}function et(t,e,s){let n=4;const r=t.attrs||[],i=function $n(t){for(let e=0;e<t.length;e++)if(rd(t[e]))return e;return t.length}(r);let a=!1;for(let c=0;c<e.length;c++){const f=e[c];if("number"!=typeof f){if(!a)if(4&n){if(n=2|1&n,""!==f&&!Ve(t,f,s)||""===f&&1===e.length){if(mt(n))return!1;a=!0}}else{const g=8&n?f:e[++c];if(8&n&&null!==t.attrs){if(!pe(t.attrs,g,s)){if(mt(n))return!1;a=!0}continue}const A=Wt(8&n?"class":f,r,Pe(t),s);if(-1===A){if(mt(n))return!1;a=!0;continue}if(""!==g){let Y;Y=A>i?"":r[A+1].toLowerCase();const ne=8&n?Y:null;if(ne&&-1!==sd(ne,g,0)||2&n&&g!==Y){if(mt(n))return!1;a=!0}}}}else{if(!a&&!mt(n)&&!mt(f))return!1;if(a&&mt(f))continue;a=!1,n=f|1&n}}return mt(n)||a}function mt(t){return 0==(1&t)}function Wt(t,e,s,n){if(null===e)return-1;let r=0;if(n||!s){let i=!1;for(;r<e.length;){const a=e[r];if(a===t)return r;if(3===a||6===a)i=!0;else{if(1===a||2===a){let c=e[++r];for(;"string"==typeof c;)c=e[++r];continue}if(4===a)break;if(0===a){r+=4;continue}}r+=i?1:2}return-1}return function zn(t,e){let s=t.indexOf(4);if(s>-1)for(s++;s<t.length;){const n=t[s];if("number"==typeof n)return-1;if(n===e)return s;s++}return-1}(e,t)}function mn(t,e,s=!1){for(let n=0;n<e.length;n++)if(et(t,e[n],s))return!0;return!1}function Bs(t,e){e:for(let s=0;s<e.length;s++){const n=e[s];if(t.length===n.length){for(let r=0;r<t.length;r++)if(t[r]!==n[r])continue e;return!0}}return!1}function ur(t,e){return t?":not("+e.trim()+")":e}function Rs(t){let e=t[0],s=1,n=2,r="",i=!1;for(;s<t.length;){let a=t[s];if("string"==typeof a)if(2&n){const c=t[++s];r+="["+a+(c.length>0?'="'+c+'"':"")+"]"}else 8&n?r+="."+a:4&n&&(r+=" "+a);else""!==r&&!mt(a)&&(e+=ur(i,r),r=""),n=a,i=i||!mt(n);s++}return""!==r&&(e+=ur(i,r)),e}function sr(t){return qt(()=>{const e=Ou(t),s={...e,decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===jl.OnPush,directiveDefs:null,pipeDefs:null,dependencies:e.standalone&&t.dependencies||null,getStandaloneInjector:null,signals:t.signals??!1,data:t.data||{},encapsulation:t.encapsulation||oo.Emulated,styles:t.styles||wi,_:null,schemas:t.schemas||null,tView:null,id:""};xd(s);const n=t.dependencies;return s.directiveDefs=yc(n,!1),s.pipeDefs=yc(n,!0),s.id=function Ru(t){let e=0;const s=[t.selectors,t.ngContentSelectors,t.hostVars,t.hostAttrs,t.consts,t.vars,t.decls,t.encapsulation,t.standalone,t.signals,t.exportAs,JSON.stringify(t.inputs),JSON.stringify(t.outputs),Object.getOwnPropertyNames(t.type.prototype),!!t.contentQueries,!!t.viewQuery].join("|");for(const r of s)e=Math.imul(31,e)+r.charCodeAt(0)<<0;return e+=2147483648,"c"+e}(s),s})}function ho(t){return Vi(t)||xl(t)}function Rc(t){return null!==t}function Vr(t){return qt(()=>({type:t.type,bootstrap:t.bootstrap||wi,declarations:t.declarations||wi,imports:t.imports||wi,exports:t.exports||wi,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function ku(t,e){if(null==t)return Bo;const s={};for(const n in t)if(t.hasOwnProperty(n)){let r=t[n],i=r;Array.isArray(r)&&(i=r[1],r=r[0]),s[r]=n,e&&(e[r]=i)}return s}function Gn(t){return qt(()=>{const e=Ou(t);return xd(e),e})}function bl(t){return{type:t.type,name:t.name,factory:null,pure:!1!==t.pure,standalone:!0===t.standalone,onDestroy:t.type.prototype.ngOnDestroy||null}}function Vi(t){return t[$a]||null}function xl(t){return t[Gi]||null}function Kl(t){return t[uu]||null}function _c(t,e){const s=t[an]||null;if(!s&&!0===e)throw new Error(`Type ${mo(t)} does not have '\u0275mod' property.`);return s}function Ou(t){const e={};return{type:t.type,providersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputTransforms:null,inputConfig:t.inputs||Bo,exportAs:t.exportAs||null,standalone:!0===t.standalone,signals:!0===t.signals,selectors:t.selectors||wi,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:ku(t.inputs,e),outputs:ku(t.outputs)}}function xd(t){t.features?.forEach(e=>e(t))}function yc(t,e){if(!t)return null;const s=e?Kl:ho;return()=>("function"==typeof t?t():t).map(n=>s(n)).filter(Rc)}const Sa=0,Ws=1,Wr=2,Mo=3,Eo=4,Ol=5,ln=6,ei=7,ua=8,Nc=9,Mc=10,Ur=11,wl=12,wd=13,Do=14,ks=15,Zo=16,Me=17,ge=18,ke=19,Ke=20,dt=21,$t=22,dn=23,Sn=24,en=25,xe=1,ee=2,me=7,gt=9,zt=11;function On(t){return Array.isArray(t)&&"object"==typeof t[xe]}function Kn(t){return Array.isArray(t)&&!0===t[xe]}function Ln(t){return 0!=(4&t.flags)}function An(t){return t.componentOffset>-1}function vs(t){return 1==(1&t.flags)}function ir(t){return!!t.template}function Er(t){return 0!=(512&t[Wr])}function Hu(t,e){return t.hasOwnProperty(kl)?t[kl]:null}let Ya=null,Ba=!1;function du(t){const e=Ya;return Ya=t,e}const Bc={version:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{}};function zf(t){if(!xu(t)||t.dirty){if(!t.producerMustRecompute(t)&&!qp(t))return void(t.dirty=!1);t.producerRecomputeValue(t),t.dirty=!1}}function Wf(t){t.dirty=!0,function zd(t){if(void 0===t.liveConsumerNode)return;const e=Ba;Ba=!0;try{for(const s of t.liveConsumerNode)s.dirty||Wf(s)}finally{Ba=e}}(t),t.consumerMarkedDirty?.(t)}function qc(t){return t&&(t.nextProducerIndex=0),du(t)}function od(t,e){if(du(e),t&&void 0!==t.producerNode&&void 0!==t.producerIndexOfThis&&void 0!==t.producerLastReadVersion){if(xu(t))for(let s=t.nextProducerIndex;s<t.producerNode.length;s++)Nl(t.producerNode[s],t.producerIndexOfThis[s]);for(let s=t.nextProducerIndex;s<t.producerNode.length;s++)t.producerNode.pop(),t.producerLastReadVersion.pop(),t.producerIndexOfThis.pop()}}function qp(t){ju(t);for(let e=0;e<t.producerNode.length;e++){const s=t.producerNode[e],n=t.producerLastReadVersion[e];if(n!==s.version||(zf(s),n!==s.version))return!0}return!1}function Lh(t){if(ju(t),xu(t))for(let e=0;e<t.producerNode.length;e++)Nl(t.producerNode[e],t.producerIndexOfThis[e]);t.producerNode.length=t.producerLastReadVersion.length=t.producerIndexOfThis.length=0,t.liveConsumerNode&&(t.liveConsumerNode.length=t.liveConsumerIndexOfThis.length=0)}function Nl(t,e){if(function $h(t){t.liveConsumerNode??=[],t.liveConsumerIndexOfThis??=[]}(t),ju(t),1===t.liveConsumerNode.length)for(let n=0;n<t.producerNode.length;n++)Nl(t.producerNode[n],t.producerIndexOfThis[n]);const s=t.liveConsumerNode.length-1;if(t.liveConsumerNode[e]=t.liveConsumerNode[s],t.liveConsumerIndexOfThis[e]=t.liveConsumerIndexOfThis[s],t.liveConsumerNode.length--,t.liveConsumerIndexOfThis.length--,e<t.liveConsumerNode.length){const n=t.liveConsumerIndexOfThis[e],r=t.liveConsumerNode[e];ju(r),r.producerIndexOfThis[n]=e}}function xu(t){return t.consumerIsAlwaysLive||(t?.liveConsumerNode?.length??0)>0}function ju(t){t.producerNode??=[],t.producerIndexOfThis??=[],t.producerLastReadVersion??=[]}let Pc=null;const rf=()=>{},Vc={...Bc,consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!1,consumerMarkedDirty:t=>{t.schedule(t.ref)},hasRun:!1,cleanupFn:rf};class bp{constructor(e,s,n){this.previousValue=e,this.currentValue=s,this.firstChange=n}isFirstChange(){return this.firstChange}}function Ia(){return xp}function xp(t){return t.type.prototype.ngOnChanges&&(t.setInput=af),Dd}function Dd(){const t=lf(this),e=t?.current;if(e){const s=t.previous;if(s===Bo)t.previous=e;else for(let n in e)s[n]=e[n];t.current=null,this.ngOnChanges(e)}}function af(t,e,s,n){const r=this.declaredInputs[s],i=lf(t)||function Uc(t,e){return t[wp]=e}(t,{previous:Bo,current:null}),a=i.current||(i.current={}),c=i.previous,f=c[r];a[r]=new bp(f&&f.currentValue,e,c===Bo),t[n]=e}Ia.ngInherit=!0;const wp="__ngSimpleChanges__";function lf(t){return t[wp]||null}const hu=function(t,e,s){},Bh="svg";function Vo(t){for(;Array.isArray(t);)t=t[Sa];return t}function Vh(t,e){return Vo(e[t])}function Ic(t,e){return Vo(e[t.index])}function Uo(t,e){return t.data[e]}function Xl(t,e){return t[e]}function Tc(t,e){const s=e[t];return On(s)?s:s[Sa]}function Pu(t,e){return null==e?null:t[e]}function pu(t){t[Me]=0}function Xf(t){1024&t[Wr]||(t[Wr]|=1024,yt(t,1))}function Tt(t){1024&t[Wr]&&(t[Wr]&=-1025,yt(t,-1))}function yt(t,e){let s=t[Mo];if(null===s)return;s[Ol]+=e;let n=s;for(s=s[Mo];null!==s&&(1===e&&1===n[Ol]||-1===e&&0===n[Ol]);)s[Ol]+=e,n=s,s=s[Mo]}const ut={lFrame:Jf(null),bindingsEnabled:!0,skipHydrationRootTNode:null};function as(){return ut.bindingsEnabled}function is(){return null!==ut.skipHydrationRootTNode}function Fn(){return ut.lFrame.lView}function Fr(){return ut.lFrame.tView}function hr(t){return ut.lFrame.contextLView=t,t[ua]}function gs(t){return ut.lFrame.contextLView=null,t}function Ui(){let t=Ni();for(;null!==t&&64===t.type;)t=t.parent;return t}function Ni(){return ut.lFrame.currentTNode}function Io(t,e){const s=ut.lFrame;s.currentTNode=t,s.isParent=e}function da(){return ut.lFrame.isParent}function zo(){ut.lFrame.isParent=!1}function Jo(){const t=ut.lFrame;let e=t.bindingRootIndex;return-1===e&&(e=t.bindingRootIndex=t.tView.bindingStartIndex),e}function Yl(){return ut.lFrame.bindingIndex++}function zc(t){const e=ut.lFrame,s=e.bindingIndex;return e.bindingIndex=e.bindingIndex+t,s}function x_(t,e){const s=ut.lFrame;s.bindingIndex=s.bindingRootIndex=t,Dp(e)}function Dp(t){ut.lFrame.currentDirectiveIndex=t}function Yf(){return ut.lFrame.currentQueryIndex}function cf(t){ut.lFrame.currentQueryIndex=t}function Xm(t){const e=t[Ws];return 2===e.type?e.declTNode:1===e.type?t[ln]:null}function Zf(t,e,s){if(s&Jt.SkipSelf){let r=e,i=t;for(;!(r=r.parent,null!==r||s&Jt.Host||(r=Xm(i),null===r||(i=i[Do],10&r.type))););if(null===r)return!1;e=r,t=i}const n=ut.lFrame=Zl();return n.currentTNode=e,n.lView=t,!0}function Qf(t){const e=Zl(),s=t[Ws];ut.lFrame=e,e.currentTNode=s.firstChild,e.lView=t,e.tView=s,e.contextLView=t,e.bindingIndex=s.bindingStartIndex,e.inI18n=!1}function Zl(){const t=ut.lFrame,e=null===t?null:t.child;return null===e?Jf(t):e}function Jf(t){const e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=e),e}function Ql(){const t=ut.lFrame;return ut.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const Ym=Ql;function qf(){const t=Ql();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function ga(){return ut.lFrame.selectedIndex}function Kd(t){ut.lFrame.selectedIndex=t}function Wo(){const t=ut.lFrame;return Uo(t.tView,t.selectedIndex)}function Gu(){ut.lFrame.currentNamespace=Bh}function Ip(){!function C_(){ut.lFrame.currentNamespace=null}()}let Jm=!0;function uf(){return Jm}function Xd(t){Jm=t}function Tp(t,e){for(let s=e.directiveStart,n=e.directiveEnd;s<n;s++){const i=t.data[s].type.prototype,{ngAfterContentInit:a,ngAfterContentChecked:c,ngAfterViewInit:f,ngAfterViewChecked:g,ngOnDestroy:E}=i;a&&(t.contentHooks??=[]).push(-s,a),c&&((t.contentHooks??=[]).push(s,c),(t.contentCheckHooks??=[]).push(s,c)),f&&(t.viewHooks??=[]).push(-s,f),g&&((t.viewHooks??=[]).push(s,g),(t.viewCheckHooks??=[]).push(s,g)),null!=E&&(t.destroyHooks??=[]).push(s,E)}}function Ap(t,e,s){em(t,e,3,s)}function df(t,e,s,n){(3&t[Wr])===s&&em(t,e,s,n)}function ns(t,e){let s=t[Wr];(3&s)===e&&(s&=8191,s+=1,t[Wr]=s)}function em(t,e,s,n){const i=n??-1,a=e.length-1;let c=0;for(let f=void 0!==n?65535&t[Me]:0;f<a;f++)if("number"==typeof e[f+1]){if(c=e[f],null!=n&&c>=n)break}else e[f]<0&&(t[Me]+=65536),(c<i||-1==i)&&(qm(t,s,e,f),t[Me]=(4294901760&t[Me])+f+2),f++}function Id(t,e){hu(4,t,e);const s=du(null);try{e.call(t)}finally{du(s),hu(5,t,e)}}function qm(t,e,s,n){const r=s[n]<0,i=s[n+1],c=t[r?-s[n]:s[n]];r?t[Wr]>>13<t[Me]>>16&&(3&t[Wr])===e&&(t[Wr]+=8192,Id(c,i)):Id(c,i)}const zh=-1;class kp{constructor(e,s,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=s,this.injectImpl=n}}function wu(t){return t!==zh}function vh(t){return 32767&t}function Yd(t,e){let s=function Hh(t){return t>>16}(t),n=e;for(;s>0;)n=n[Do],s--;return n}let Zd=!0;function hf(t){const e=Zd;return Zd=t,e}const ng=255,sg=5;let S0=0;const Cu={};function ff(t,e){const s=he(t,e);if(-1!==s)return s;const n=e[Ws];n.firstCreatePass&&(t.injectorIndex=e.length,be(n.data,t),be(e,null),be(n.blueprint,null));const r=se(t,e),i=t.injectorIndex;if(wu(r)){const a=vh(r),c=Yd(r,e),f=c[Ws].data;for(let g=0;g<8;g++)e[i+g]=c[a+g]|f[a+g]}return e[i+8]=r,i}function be(t,e){t.push(0,0,0,0,0,0,0,0,e)}function he(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===e[t.injectorIndex+8]?-1:t.injectorIndex}function se(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let s=0,n=null,r=e;for(;null!==r;){if(n=Ji(r),null===n)return zh;if(s++,r=r[Do],-1!==n.injectorIndex)return n.injectorIndex|s<<16}return zh}function Ie(t,e,s){!function pf(t,e,s){let n;"string"==typeof s?n=s.charCodeAt(0)||0:s.hasOwnProperty(Gl)&&(n=s[Gl]),null==n&&(n=s[Gl]=S0++);const r=n&ng;e.data[t+(r>>sg)]|=1<<r}(t,e,s)}function Ze(t,e,s){if(s&Jt.Optional||void 0!==t)return t;Wl()}function ct(t,e,s,n){if(s&Jt.Optional&&void 0===n&&(n=null),!(s&(Jt.Self|Jt.Host))){const r=t[Nc],i=wo(void 0);try{return r?r.get(e,n,s&Jt.Optional):Fa(e,n,s&Jt.Optional)}finally{wo(i)}}return Ze(n,0,s)}function Dt(t,e,s,n=Jt.Default,r){if(null!==t){if(2048&e[Wr]&&!(n&Jt.Self)){const a=function Jl(t,e,s,n,r){let i=t,a=e;for(;null!==i&&null!==a&&2048&a[Wr]&&!(512&a[Wr]);){const c=Ht(i,a,s,n|Jt.Self,Cu);if(c!==Cu)return c;let f=i.parent;if(!f){const g=a[Ke];if(g){const E=g.get(s,Cu,n);if(E!==Cu)return E}f=Ji(a),a=a[Do]}i=f}return r}(t,e,s,n,Cu);if(a!==Cu)return a}const i=Ht(t,e,s,n,Cu);if(i!==Cu)return i}return ct(e,s,n,r)}function Ht(t,e,s,n,r){const i=function cs(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(Gl)?t[Gl]:void 0;return"number"==typeof e?e>=0?e&ng:_a:e}(s);if("function"==typeof i){if(!Zf(e,t,n))return n&Jt.Host?Ze(r,0,n):ct(e,s,n,r);try{let a;if(a=i(n),null!=a||n&Jt.Optional)return a;Wl()}finally{Ym()}}else if("number"==typeof i){let a=null,c=he(t,e),f=zh,g=n&Jt.Host?e[ks][ln]:null;for((-1===c||n&Jt.SkipSelf)&&(f=-1===c?se(t,e):e[c+8],f!==zh&&fr(n,!1)?(a=e[Ws],c=vh(f),e=Yd(f,e)):c=-1);-1!==c;){const E=e[Ws];if(Hs(i,c,E.data)){const A=Gt(c,e,s,a,n,g);if(A!==Cu)return A}f=e[c+8],f!==zh&&fr(n,e[Ws].data[c+8]===g)&&Hs(i,c,e)?(a=E,c=vh(f),e=Yd(f,e)):c=-1}}return r}function Gt(t,e,s,n,r,i){const a=e[Ws],c=a.data[t+8],E=vn(c,a,s,null==n?An(c)&&Zd:n!=a&&0!=(3&c.type),r&Jt.Host&&i===c);return null!==E?wn(e,a,E,c):Cu}function vn(t,e,s,n,r){const i=t.providerIndexes,a=e.data,c=1048575&i,f=t.directiveStart,E=i>>20,Y=r?c+E:t.directiveEnd;for(let ne=n?c:c+E;ne<Y;ne++){const Ee=a[ne];if(ne<f&&s===Ee||ne>=f&&Ee.type===s)return ne}if(r){const ne=a[f];if(ne&&ir(ne)&&ne.type===s)return f}return null}function wn(t,e,s,n){let r=t[s];const i=e.data;if(function Wh(t){return t instanceof kp}(r)){const a=r;a.resolving&&function Ma(t,e){const s=e?`. Dependency path: ${e.join(" > ")} > ${t}`:"";throw new En(-200,`Circular dependency in DI detected for ${t}${s}`)}(function ar(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():wr(t)}(i[s]));const c=hf(a.canSeeViewProviders);a.resolving=!0;const g=a.injectImpl?wo(a.injectImpl):null;Zf(t,n,Jt.Default);try{r=t[s]=a.factory(void 0,i,t,n),e.firstCreatePass&&s>=n.directiveStart&&function E_(t,e,s){const{ngOnChanges:n,ngOnInit:r,ngDoCheck:i}=e.type.prototype;if(n){const a=xp(e);(s.preOrderHooks??=[]).push(t,a),(s.preOrderCheckHooks??=[]).push(t,a)}r&&(s.preOrderHooks??=[]).push(0-t,r),i&&((s.preOrderHooks??=[]).push(t,i),(s.preOrderCheckHooks??=[]).push(t,i))}(s,i[s],e)}finally{null!==g&&wo(g),hf(c),a.resolving=!1,Ym()}}return r}function Hs(t,e,s){return!!(s[e+(t>>sg)]&1<<t)}function fr(t,e){return!(t&Jt.Self||t&Jt.Host&&e)}class mr{constructor(e,s){this._tNode=e,this._lView=s}get(e,s,n){return Dt(this._tNode,this._lView,e,Oi(n),s)}}function _a(){return new mr(Ui(),Fn())}function Gr(t){return qt(()=>{const e=t.prototype.constructor,s=e[kl]||ul(e),n=Object.prototype;let r=Object.getPrototypeOf(t.prototype).constructor;for(;r&&r!==n;){const i=r[kl]||ul(r);if(i&&i!==s)return i;r=Object.getPrototypeOf(r)}return i=>new i})}function ul(t){return Xo(t)?()=>{const e=ul(dr(t));return e&&e()}:Hu(t)}function Ji(t){const e=t[Ws],s=e.type;return 2===s?e.declTNode:1===s?t[ln]:null}function na(t){return function $e(t,e){if("class"===e)return t.classes;if("style"===e)return t.styles;const s=t.attrs;if(s){const n=s.length;let r=0;for(;r<n;){const i=s[r];if(rd(i))break;if(0===i)r+=2;else if("number"==typeof i)for(r++;r<n&&"string"==typeof s[r];)r++;else{if(i===e)return s[r+1];r+=2}}}return null}(Ui(),t)}const sa="__parameters__";function Ac(t,e,s){return qt(()=>{const n=function mu(t){return function(...s){if(t){const n=t(...s);for(const r in n)this[r]=n[r]}}}(e);function r(...i){if(this instanceof r)return n.apply(this,i),this;const a=new r(...i);return c.annotation=a,c;function c(f,g,E){const A=f.hasOwnProperty(sa)?f[sa]:Object.defineProperty(f,sa,{value:[]})[sa];for(;A.length<=E;)A.push(null);return(A[E]=A[E]||[]).push(a),f}}return s&&(r.prototype=Object.create(s.prototype)),r.prototype.ngMetadataName=t,r.annotationCls=r,r})}function nm(t,e){t.forEach(s=>Array.isArray(s)?nm(s,e):e(s))}function sm(t,e,s){e>=t.length?t.push(s):t.splice(e,0,s)}function ig(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function og(t,e){const s=[];for(let n=0;n<t;n++)s.push(e);return s}function Xu(t,e,s){let n=Rp(t,e);return n>=0?t[1|n]=s:(n=~n,function O_(t,e,s,n){let r=t.length;if(r==e)t.push(s,n);else if(1===r)t.push(n,t[0]),t[0]=s;else{for(r--,t.push(t[r-1],t[r]);r>e;)t[r]=t[r-2],r--;t[e]=s,t[e+1]=n}}(t,n,e,s)),n}function ld(t,e){const s=Rp(t,e);if(s>=0)return t[1|s]}function Rp(t,e){return function T0(t,e,s){let n=0,r=t.length>>s;for(;r!==n;){const i=n+(r-n>>1),a=t[i<<s];if(e===a)return i<<s;a>e?r=i:n=i+1}return~(r<<s)}(t,e,1)}const R0=Yo(Ac("Inject",t=>({token:t})),-1),wh=Yo(Ac("Optional"),8),Gh=Yo(Ac("SkipSelf"),4);function ug(t){return 128==(128&t.flags)}var Eu=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}(Eu||{});const B_=/^>|^->|<!--|-->|--!>|<!-$/g,Xh=/(<|>)/g,V_="\u200b$1\u200b";const _f=new Map;let rx=0;const pg="__ngContext__";function tu(t,e){On(e)?(t[pg]=e[ke],function z0(t){_f.set(t[ke],t)}(e)):t[pg]=e}let gg;function bf(t,e){return gg(t,e)}function Np(t){const e=t[Mo];return Kn(e)?e[Mo]:e}function G_(t){return K_(t[wl])}function G0(t){return K_(t[Eo])}function K_(t){for(;null!==t&&!Kn(t);)t=t[Eo];return t}function Mp(t,e,s,n,r){if(null!=n){let i,a=!1;Kn(n)?i=n:On(n)&&(a=!0,n=n[Sa]);const c=Vo(n);0===t&&null!==s?null==r?vg(e,s,c):Pp(e,s,c,r||null,!0):1===t&&null!==s?Pp(e,s,c,r||null,!0):2===t?function Fp(t,e,s){const n=hm(t,e);n&&function ty(t,e,s,n){t.removeChild(e,s,n)}(t,n,e,s)}(e,c,a):3===t&&e.destroyNode(c),null!=i&&function Eg(t,e,s,n,r){const i=s[me];i!==Vo(s)&&Mp(e,t,n,i,r);for(let c=zt;c<s.length;c++){const f=s[c];wg(f[Ws],f,t,e,n,i)}}(e,t,i,s,r)}}function Y_(t,e){return t.createComment(function U_(t){return t.replace(B_,e=>e.replace(Xh,V_))}(e))}function um(t,e,s){return t.createElement(e,s)}function _g(t,e){const s=t[gt],n=s.indexOf(e);Tt(e),s.splice(n,1)}function dm(t,e){if(t.length<=zt)return;const s=zt+e,n=t[s];if(n){const r=n[Zo];null!==r&&r!==t&&_g(r,n),e>0&&(t[s-1][Eo]=n[Eo]);const i=ig(t,zt+e);!function K0(t,e){wg(t,e,e[Ur],2,null,null),e[Sa]=null,e[ln]=null}(n[Ws],n);const a=i[ge];null!==a&&a.detachView(i[Ws]),n[Mo]=null,n[Eo]=null,n[Wr]&=-129}return n}function wf(t,e){if(!(256&e[Wr])){const s=e[Ur];e[dn]&&Lh(e[dn]),e[Sn]&&Lh(e[Sn]),s.destroyNode&&wg(t,e,s,3,null,null),function Zh(t){let e=t[wl];if(!e)return yg(t[Ws],t);for(;e;){let s=null;if(On(e))s=e[wl];else{const n=e[zt];n&&(s=n)}if(!s){for(;e&&!e[Eo]&&e!==t;)On(e)&&yg(e[Ws],e),e=e[Mo];null===e&&(e=t),On(e)&&yg(e[Ws],e),s=e&&e[Eo]}e=s}}(e)}}function yg(t,e){if(!(256&e[Wr])){e[Wr]&=-129,e[Wr]|=256,function Ch(t,e){let s;if(null!=t&&null!=(s=t.destroyHooks))for(let n=0;n<s.length;n+=2){const r=e[s[n]];if(!(r instanceof kp)){const i=s[n+1];if(Array.isArray(i))for(let a=0;a<i.length;a+=2){const c=r[i[a]],f=i[a+1];hu(4,c,f);try{f.call(c)}finally{hu(5,c,f)}}else{hu(4,r,i);try{i.call(r)}finally{hu(5,r,i)}}}}}(t,e),function J_(t,e){const s=t.cleanup,n=e[ei];if(null!==s)for(let i=0;i<s.length-1;i+=2)if("string"==typeof s[i]){const a=s[i+3];a>=0?n[a]():n[-a].unsubscribe(),i+=2}else s[i].call(n[s[i+1]]);null!==n&&(e[ei]=null);const r=e[dt];if(null!==r){e[dt]=null;for(let i=0;i<r.length;i++)(0,r[i])()}}(t,e),1===e[Ws].type&&e[Ur].destroy();const s=e[Zo];if(null!==s&&Kn(e[Mo])){s!==e[Mo]&&_g(s,e);const n=e[ge];null!==n&&n.detachView(t)}!function W0(t){_f.delete(t[ke])}(e)}}function q_(t,e,s){return function ox(t,e,s){let n=e;for(;null!==n&&40&n.type;)n=(e=n).parent;if(null===n)return s[Sa];{const{componentOffset:r}=n;if(r>-1){const{encapsulation:i}=t.data[n.directiveStart+r];if(i===oo.None||i===oo.Emulated)return null}return Ic(n,s)}}(t,e.parent,s)}function Pp(t,e,s,n,r){t.insertBefore(e,s,n,r)}function vg(t,e,s){t.appendChild(e,s)}function ey(t,e,s,n,r){null!==n?Pp(t,e,s,n,r):vg(t,e,s)}function hm(t,e){return t.parentNode(e)}function ny(t,e,s){return ry(t,e,s)}let bg,Sg,iy,mm,ry=function sy(t,e,s){return 40&t.type?Ic(t,s):null};function pm(t,e,s,n){const r=q_(t,n,e),i=e[Ur],c=ny(n.parent||e[ln],n,e);if(null!=r)if(Array.isArray(s))for(let f=0;f<s.length;f++)ey(i,r,s[f],c,!1);else ey(i,r,s,c,!1);void 0!==bg&&bg(i,n,e,s,r)}function qd(t,e){if(null!==e){const s=e.type;if(3&s)return Ic(e,t);if(4&s)return Z0(-1,t[e.index]);if(8&s){const n=e.child;if(null!==n)return qd(t,n);{const r=t[e.index];return Kn(r)?Z0(-1,r):Vo(r)}}if(32&s)return bf(e,t)()||Vo(t[e.index]);{const n=fm(t,e);return null!==n?Array.isArray(n)?n[0]:qd(Np(t[ks]),n):qd(t,e.next)}}return null}function fm(t,e){return null!==e?t[ks][ln].projection[e.projection]:null}function Z0(t,e){const s=zt+t+1;if(s<e.length){const n=e[s],r=n[Ws].firstChild;if(null!==r)return qd(n,r)}return e[me]}function Cf(t,e,s,n,r,i,a){for(;null!=s;){const c=n[s.index],f=s.type;if(a&&0===e&&(c&&tu(Vo(c),n),s.flags|=2),32!=(32&s.flags))if(8&f)Cf(t,e,s.child,n,r,i,!1),Mp(e,t,r,c,i);else if(32&f){const g=bf(s,n);let E;for(;E=g();)Mp(e,t,r,E,i);Mp(e,t,r,c,i)}else 16&f?o1(t,e,n,s,r,i):Mp(e,t,r,c,i);s=a?s.projectionNext:s.next}}function wg(t,e,s,n,r,i){Cf(s,n,t.firstChild,e,r,i,!1)}function o1(t,e,s,n,r,i){const a=s[ks],f=a[ln].projection[n.projection];if(Array.isArray(f))for(let g=0;g<f.length;g++)Mp(e,t,r,f[g],i);else{let g=f;const E=a[Mo];ug(n)&&(g.flags|=128),Cf(t,e,g,E,r,i,!0)}}function lx(t,e,s){""===s?t.removeAttribute(e,"class"):t.setAttribute(e,"class",s)}function Ef(t,e,s){const{mergedAttrs:n,classes:r,styles:i}=s;null!==n&&gc(t,e,n),null!==r&&lx(t,e,r),null!==i&&function Dg(t,e,s){t.setAttribute(e,"style",s)}(t,e,i)}function Lp(t){return function Ig(){if(void 0===Sg&&(Sg=null,Fi.trustedTypes))try{Sg=Fi.trustedTypes.createPolicy("angular",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch{}return Sg}()?.createHTML(t)||t}function gm(t){return function q0(){if(void 0===mm&&(mm=null,Fi.trustedTypes))try{mm=Fi.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch{}return mm}()?.createScriptURL(t)||t}class Qh{constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Na})`}}class tv extends Qh{getTypeName(){return"HTML"}}class dx extends Qh{getTypeName(){return"Style"}}class nv extends Qh{getTypeName(){return"Script"}}class sv extends Qh{getTypeName(){return"URL"}}class hx extends Qh{getTypeName(){return"ResourceURL"}}function Lu(t){return t instanceof Qh?t.changingThisBreaksApplicationSecurity:t}function Od(t,e){const s=function Ag(t){return t instanceof Qh&&t.getTypeName()||null}(t);if(null!=s&&s!==e){if("ResourceURL"===s&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${s} (see ${Na})`)}return s===e}class cv{constructor(e){this.inertDocumentHelper=e}getInertBodyElement(e){e="<body><remove></remove>"+e;try{const s=(new window.DOMParser).parseFromString(Lp(e),"text/html").body;return null===s?this.inertDocumentHelper.getInertBodyElement(e):(s.removeChild(s.firstChild),s)}catch{return null}}}class uv{constructor(e){this.defaultDoc=e,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert")}getInertBodyElement(e){const s=this.inertDocument.createElement("template");return s.innerHTML=Lp(e),s}}const px=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function kg(t){return(t=String(t)).match(px)?t:"unsafe:"+t}function eh(t){const e={};for(const s of t.split(","))e[s]=!0;return e}function Df(...t){const e={};for(const s of t)for(const n in s)s.hasOwnProperty(n)&&(e[n]=!0);return e}const fx=eh("area,br,col,hr,img,wbr"),hv=eh("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),ly=eh("rp,rt"),Og=Df(fx,Df(hv,eh("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),Df(ly,eh("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Df(ly,hv)),Rg=eh("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),gx=Df(Rg,eh("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),eh("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),pv=eh("script,style,template");class fv{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(e){let s=e.firstChild,n=!0;for(;s;)if(s.nodeType===Node.ELEMENT_NODE?n=this.startElement(s):s.nodeType===Node.TEXT_NODE?this.chars(s.nodeValue):this.sanitizedSomething=!0,n&&s.firstChild)s=s.firstChild;else for(;s;){s.nodeType===Node.ELEMENT_NODE&&this.endElement(s);let r=this.checkClobberedElement(s,s.nextSibling);if(r){s=r;break}s=this.checkClobberedElement(s,s.parentNode)}return this.buf.join("")}startElement(e){const s=e.nodeName.toLowerCase();if(!Og.hasOwnProperty(s))return this.sanitizedSomething=!0,!pv.hasOwnProperty(s);this.buf.push("<"),this.buf.push(s);const n=e.attributes;for(let r=0;r<n.length;r++){const i=n.item(r),a=i.name,c=a.toLowerCase();if(!gx.hasOwnProperty(c)){this.sanitizedSomething=!0;continue}let f=i.value;Rg[c]&&(f=kg(f)),this.buf.push(" ",a,'="',mv(f),'"')}return this.buf.push(">"),!0}endElement(e){const s=e.nodeName.toLowerCase();Og.hasOwnProperty(s)&&!fx.hasOwnProperty(s)&&(this.buf.push("</"),this.buf.push(s),this.buf.push(">"))}chars(e){this.buf.push(mv(e))}checkClobberedElement(e,s){if(s&&(e.compareDocumentPosition(s)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${e.outerHTML}`);return s}}const d1=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,_x=/([^\#-~ |!])/g;function mv(t){return t.replace(/&/g,"&amp;").replace(d1,function(e){return"&#"+(1024*(e.charCodeAt(0)-55296)+(e.charCodeAt(1)-56320)+65536)+";"}).replace(_x,function(e){return"&#"+e.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let Ng;function gv(t,e){let s=null;try{Ng=Ng||function ay(t){const e=new uv(t);return function dv(){try{return!!(new window.DOMParser).parseFromString(Lp(""),"text/html")}catch{return!1}}()?new cv(e):e}(t);let n=e?String(e):"";s=Ng.getInertBodyElement(n);let r=5,i=n;do{if(0===r)throw new Error("Failed to sanitize html because the input is unstable");r--,n=i,i=s.innerHTML,s=Ng.getInertBodyElement(n)}while(n!==i);return Lp((new fv).sanitizeChildren(cy(s)||s))}finally{if(s){const n=cy(s)||s;for(;n.firstChild;)n.removeChild(n.firstChild)}}}function cy(t){return"content"in t&&function yx(t){return t.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===t.nodeName}(t)?t.content:null}var nu=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}(nu||{});function uy(t){const e=_m();return e?e.sanitize(nu.URL,t)||"":Od(t,"URL")?Lu(t):kg(wr(t))}function _v(t){const e=_m();if(e)return gm(e.sanitize(nu.RESOURCE_URL,t)||"");if(Od(t,"ResourceURL"))return gm(Lu(t));throw new En(904,!1)}function _m(){const t=Fn();return t&&t[Mc].sanitizer}class Zn{constructor(e,s){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof s?this.__NG_ELEMENT_ID__=s:void 0!==s&&(this.\u0275prov=wt({token:this,providedIn:s.providedIn||"root",factory:s.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const ym=new Zn("ENVIRONMENT_INITIALIZER"),vv=new Zn("INJECTOR",-1),dy=new Zn("INJECTOR_DEF_TYPES");class hy{get(e,s=ot){if(s===ot){const n=new Error(`NullInjectorError: No provider for ${mo(e)}!`);throw n.name="NullInjectorError",n}return s}}function Sx(...t){return{\u0275providers:bv(0,t),\u0275fromNgModule:!0}}function bv(t,...e){const s=[],n=new Set;let r;const i=a=>{s.push(a)};return nm(e,a=>{const c=a;Mg(c,i,[],n)&&(r||=[],r.push(c))}),void 0!==r&&xv(r,i),s}function xv(t,e){for(let s=0;s<t.length;s++){const{ngModule:n,providers:r}=t[s];fy(r,i=>{e(i,n)})}}function Mg(t,e,s,n){if(!(t=dr(t)))return!1;let r=null,i=Cr(t);const a=!i&&Vi(t);if(i||a){if(a&&!a.standalone)return!1;r=t}else{const f=t.ngModule;if(i=Cr(f),!i)return!1;r=f}const c=n.has(r);if(a){if(c)return!1;if(n.add(r),a.dependencies){const f="function"==typeof a.dependencies?a.dependencies():a.dependencies;for(const g of f)Mg(g,e,s,n)}}else{if(!i)return!1;{if(null!=i.imports&&!c){let g;n.add(r);try{nm(i.imports,E=>{Mg(E,e,s,n)&&(g||=[],g.push(E))})}finally{}void 0!==g&&xv(g,e)}if(!c){const g=Hu(r)||(()=>new r);e({provide:r,useFactory:g,deps:wi},r),e({provide:dy,useValue:r,multi:!0},r),e({provide:ym,useValue:()=>cn(r),multi:!0},r)}const f=i.providers;if(null!=f&&!c){const g=t;fy(f,E=>{e(E,g)})}}}return r!==t&&void 0!==t.providers}function fy(t,e){for(let s of t)go(s)&&(s=s.\u0275providers),Array.isArray(s)?fy(s,e):e(s)}const Ix=di({provide:String,useValue:di});function my(t){return null!==t&&"object"==typeof t&&Ix in t}function Bp(t){return"function"==typeof t}const vm=new Zn("Set Injector scope."),gy={},Ax={};let bm;function _y(){return void 0===bm&&(bm=new hy),bm}class Yu{}class Fg extends Yu{get destroyed(){return this._destroyed}constructor(e,s,n,r){super(),this.parent=s,this.source=n,this.scopes=r,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Eh(e,a=>this.processProvider(a)),this.records.set(vv,Jh(void 0,this)),r.has("environment")&&this.records.set(Yu,Jh(void 0,this));const i=this.records.get(vm);null!=i&&"string"==typeof i.value&&this.scopes.add(i.value),this.injectorDefTypes=new Set(this.get(dy.multi,wi,Jt.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const s of this._ngOnDestroyHooks)s.ngOnDestroy();const e=this._onDestroyHooks;this._onDestroyHooks=[];for(const s of e)s()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear()}}onDestroy(e){return this.assertNotDestroyed(),this._onDestroyHooks.push(e),()=>this.removeOnDestroy(e)}runInContext(e){this.assertNotDestroyed();const s=Qs(this),n=wo(void 0);try{return e()}finally{Qs(s),wo(n)}}get(e,s=ot,n=Jt.Default){if(this.assertNotDestroyed(),e.hasOwnProperty(Tu))return e[Tu](this);n=Oi(n);const i=Qs(this),a=wo(void 0);try{if(!(n&Jt.SkipSelf)){let f=this.records.get(e);if(void 0===f){const g=function Rx(t){return"function"==typeof t||"object"==typeof t&&t instanceof Zn}(e)&&qn(e);f=g&&this.injectableDefInScope(g)?Jh(yy(e),gy):null,this.records.set(e,f)}if(null!=f)return this.hydrate(e,f)}return(n&Jt.Self?_y():this.parent).get(e,s=n&Jt.Optional&&s===ot?null:s)}catch(c){if("NullInjectorError"===c.name){if((c[Xt]=c[Xt]||[]).unshift(mo(e)),i)throw c;return function hi(t,e,s,n){const r=t[Xt];throw e[ss]&&r.unshift(e[ss]),t.message=function ci(t,e,s,n=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.slice(2):t;let r=mo(e);if(Array.isArray(e))r=e.map(mo).join(" -> ");else if("object"==typeof e){let i=[];for(let a in e)if(e.hasOwnProperty(a)){let c=e[a];i.push(a+":"+("string"==typeof c?JSON.stringify(c):mo(c)))}r=`{${i.join(", ")}}`}return`${s}${n?"("+n+")":""}[${r}]: ${t.replace(Yt,"\n  ")}`}("\n"+t.message,r,s,n),t.ngTokenPath=r,t[Xt]=null,t}(c,e,"R3InjectorError",this.source)}throw c}finally{wo(a),Qs(i)}}resolveInjectorInitializers(){const e=Qs(this),s=wo(void 0);try{const r=this.get(ym.multi,wi,Jt.Self);for(const i of r)i()}finally{Qs(e),wo(s)}}toString(){const e=[],s=this.records;for(const n of s.keys())e.push(mo(n));return`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new En(205,!1)}processProvider(e){let s=Bp(e=dr(e))?e:dr(e&&e.provide);const n=function Ev(t){return my(t)?Jh(void 0,t.useValue):Jh(vy(t),gy)}(e);if(Bp(e)||!0!==e.multi)this.records.get(s);else{let r=this.records.get(s);r||(r=Jh(void 0,gy,!0),r.factory=()=>ca(r.multi),this.records.set(s,r)),s=e,r.multi.push(e)}this.records.set(s,n)}hydrate(e,s){return s.value===gy&&(s.value=Ax,s.value=s.factory()),"object"==typeof s.value&&s.value&&function Ox(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(s.value)&&this._ngOnDestroyHooks.add(s.value),s.value}injectableDefInScope(e){if(!e.providedIn)return!1;const s=dr(e.providedIn);return"string"==typeof s?"any"===s||this.scopes.has(s):this.injectorDefTypes.has(s)}removeOnDestroy(e){const s=this._onDestroyHooks.indexOf(e);-1!==s&&this._onDestroyHooks.splice(s,1)}}function yy(t){const e=qn(t),s=null!==e?e.factory:Hu(t);if(null!==s)return s;if(t instanceof Zn)throw new En(204,!1);if(t instanceof Function)return function Cv(t){const e=t.length;if(e>0)throw og(e,"?"),new En(204,!1);const s=function Tr(t){return t&&(t[Is]||t[yo])||null}(t);return null!==s?()=>s.factory(t):()=>new t}(t);throw new En(204,!1)}function vy(t,e,s){let n;if(Bp(t)){const r=dr(t);return Hu(r)||yy(r)}if(my(t))n=()=>dr(t.useValue);else if(function Pg(t){return!(!t||!t.useFactory)}(t))n=()=>t.useFactory(...ca(t.deps||[]));else if(function wv(t){return!(!t||!t.useExisting)}(t))n=()=>cn(dr(t.useExisting));else{const r=dr(t&&(t.useClass||t.provide));if(!function kx(t){return!!t.deps}(t))return Hu(r)||yy(r);n=()=>new r(...ca(t.deps))}return n}function Jh(t,e,s=!1){return{factory:t,value:e,multi:s?[]:void 0}}function Eh(t,e){for(const s of t)Array.isArray(s)?Eh(s,e):s&&go(s)?Eh(s.\u0275providers,e):e(s)}const Sf=new Zn("AppId",{providedIn:"root",factory:()=>Nx}),Nx="ng",Dv=new Zn("Platform Initializer"),qh=new Zn("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),ac=new Zn("AnimationModuleType"),by=new Zn("CSP nonce",{providedIn:"root",factory:()=>function $p(){if(void 0!==iy)return iy;if(typeof document<"u")return document;throw new En(210,!1)}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let ft=(t,e,s)=>null;function tn(t,e,s=!1){return ft(t,e,s)}class ql{}class cd{}class Zu{resolveComponentFactory(e){throw function $u(t){const e=Error(`No component factory found for ${mo(t)}.`);return e.ngComponent=t,e}(e)}}let lc=(()=>{class e{}return e.NULL=new Zu,e})();function ep(){return Vu(Ui(),Fn())}function Vu(t,e){return new yr(Ic(t,e))}let yr=(()=>{class e{constructor(n){this.nativeElement=n}}return e.__NG_ELEMENT_ID__=ep,e})();function xm(t){return t instanceof yr?t.nativeElement:t}class tp{}let th=(()=>{class e{constructor(){this.destroyNode=null}}return e.__NG_ELEMENT_ID__=()=>function np(){const t=Fn(),s=Tc(Ui().index,t);return(On(s)?s:t)[Ur]}(),e})(),Sv=(()=>{var t;class e{}return(t=e).\u0275prov=wt({token:t,providedIn:"root",factory:()=>null}),e})();class wm{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const rT=new wm("16.2.5"),Fx={};function y1(t,e=null,s=null,n){const r=v1(t,e,s,n);return r.resolveInjectorInitializers(),r}function v1(t,e=null,s=null,n,r=new Set){const i=[s||wi,Sx(t)];return n=n||("object"==typeof t?void 0:mo(t)),new Fg(i,e||_y(),n||null,r)}let Wc=(()=>{var t;class e{static create(n,r){if(Array.isArray(n))return y1({name:""},r,n,"");{const i=n.name??"";return y1({name:i},n.parent,n.providers,i)}}}return(t=e).THROW_IF_NOT_FOUND=ot,t.NULL=new hy,t.\u0275prov=wt({token:t,providedIn:"any",factory:()=>cn(vv)}),t.__NG_ELEMENT_ID__=-1,e})();function Vx(t){return t.ngOriginalError}class nh{constructor(){this._console=console}handleError(e){const s=this._findOriginalError(e);this._console.error("ERROR",e),s&&this._console.error("ORIGINAL ERROR",s)}_findOriginalError(e){let s=e&&Vx(e);for(;s&&Vx(s);)s=Vx(s);return s||null}}function Vp(t){return e=>{setTimeout(t,void 0,e)}}const Rr=class x1 extends Bt{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,s,n){let r=e,i=s||(()=>null),a=n;if(e&&"object"==typeof e){const f=e;r=f.next?.bind(f),i=f.error?.bind(f),a=f.complete?.bind(f)}this.__isAsync&&(i=Vp(i),r&&(r=Vp(r)),a&&(a=Vp(a)));const c=super.subscribe({next:r,error:i,complete:a});return e instanceof I&&e.add(c),c}};function zx(...t){}class Gs{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:s=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Rr(!1),this.onMicrotaskEmpty=new Rr(!1),this.onStable=new Rr(!1),this.onError=new Rr(!1),typeof Zone>"u")throw new En(908,!1);Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!n&&s,r.shouldCoalesceRunChangeDetection=n,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function aT(){const t="function"==typeof Fi.requestAnimationFrame;let e=Fi[t?"requestAnimationFrame":"setTimeout"],s=Fi[t?"cancelAnimationFrame":"clearTimeout"];if(typeof Zone<"u"&&e&&s){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const r=s[Zone.__symbol__("OriginalDelegate")];r&&(s=r)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:s}}().nativeRequestAnimationFrame,function uT(t){const e=()=>{!function cT(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(Fi,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Av(t),t.isCheckStableRunning=!0,Wx(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Av(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(s,n,r,i,a,c)=>{if(function C1(t){return!(!Array.isArray(t)||1!==t.length)&&!0===t[0].data?.__ignore_ng_zone__}(c))return s.invokeTask(r,i,a,c);try{return Ey(t),s.invokeTask(r,i,a,c)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||t.shouldCoalesceRunChangeDetection)&&e(),$g(t)}},onInvoke:(s,n,r,i,a,c,f)=>{try{return Ey(t),s.invoke(r,i,a,c,f)}finally{t.shouldCoalesceRunChangeDetection&&e(),$g(t)}},onHasTask:(s,n,r,i)=>{s.hasTask(r,i),n===r&&("microTask"==i.change?(t._hasPendingMicrotasks=i.microTask,Av(t),Wx(t)):"macroTask"==i.change&&(t.hasPendingMacrotasks=i.macroTask))},onHandleError:(s,n,r,i)=>(s.handleError(r,i),t.runOutsideAngular(()=>t.onError.emit(i)),!1)})}(r)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Gs.isInAngularZone())throw new En(909,!1)}static assertNotInAngularZone(){if(Gs.isInAngularZone())throw new En(909,!1)}run(e,s,n){return this._inner.run(e,s,n)}runTask(e,s,n,r){const i=this._inner,a=i.scheduleEventTask("NgZoneEvent: "+r,e,lT,zx,zx);try{return i.runTask(a,s,n)}finally{i.cancelTask(a)}}runGuarded(e,s,n){return this._inner.runGuarded(e,s,n)}runOutsideAngular(e){return this._outer.run(e)}}const lT={};function Wx(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Av(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function Ey(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function $g(t){t._nesting--,Wx(t)}class w1{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Rr,this.onMicrotaskEmpty=new Rr,this.onStable=new Rr,this.onError=new Rr}run(e,s,n){return e.apply(s,n)}runGuarded(e,s,n){return e.apply(s,n)}runOutsideAngular(e){return e()}runTask(e,s,n,r){return e.apply(s,n)}}const Dy=new Zn("",{providedIn:"root",factory:kv});function kv(){const t=jn(Gs);let e=!0;return ji(new Ue(r=>{e=t.isStable&&!t.hasPendingMacrotasks&&!t.hasPendingMicrotasks,t.runOutsideAngular(()=>{r.next(e),r.complete()})}),new Ue(r=>{let i;t.runOutsideAngular(()=>{i=t.onStable.subscribe(()=>{Gs.assertNotInAngularZone(),queueMicrotask(()=>{!e&&!t.hasPendingMacrotasks&&!t.hasPendingMicrotasks&&(e=!0,r.next(!0))})})});const a=t.onUnstable.subscribe(()=>{Gs.assertInAngularZone(),e&&(e=!1,t.runOutsideAngular(()=>{r.next(!1)}))});return()=>{i.unsubscribe(),a.unsubscribe()}}).pipe(ro()))}function sp(t){return t instanceof Function?t():t}let Rv=(()=>{var t;class e{constructor(){this.renderDepth=0,this.handler=null}begin(){this.handler?.validateBegin(),this.renderDepth++}end(){this.renderDepth--,0===this.renderDepth&&this.handler?.execute()}ngOnDestroy(){this.handler?.destroy(),this.handler=null}}return(t=e).\u0275prov=wt({token:t,providedIn:"root",factory:()=>new t}),e})();function Vg(t){for(;t;){t[Wr]|=64;const e=Np(t);if(Er(t)&&!e)return t;t=e}return null}const jx=new Zn("",{providedIn:"root",factory:()=>!1});let Sy=null;function Kx(t,e){return t[e]??Up()}function Qa(t,e){const s=Up();s.producerNode?.length&&(t[e]=Sy,s.lView=t,Sy=M1())}const N1={...Bc,consumerIsAlwaysLive:!0,consumerMarkedDirty:t=>{Vg(t.lView)},lView:null};function M1(){return Object.create(N1)}function Up(){return Sy??=M1(),Sy}const zi={};function Un(t){If(Fr(),Fn(),ga()+t,!1)}function If(t,e,s,n){if(!n)if(3==(3&e[Wr])){const i=t.preOrderCheckHooks;null!==i&&Ap(e,i,s)}else{const i=t.preOrderHooks;null!==i&&df(e,i,0,s)}Kd(s)}function lt(t,e=Jt.Default){const s=Fn();return null===s?cn(t,e):Dt(Ui(),s,dr(t),e)}function Tf(){throw new Error("invalid")}function Iy(t,e,s,n,r,i,a,c,f,g,E){const A=e.blueprint.slice();return A[Sa]=r,A[Wr]=140|n,(null!==g||t&&2048&t[Wr])&&(A[Wr]|=2048),pu(A),A[Mo]=A[Do]=t,A[ua]=s,A[Mc]=a||t&&t[Mc],A[Ur]=c||t&&t[Ur],A[Nc]=f||t&&t[Nc]||null,A[ln]=i,A[ke]=function ix(){return rx++}(),A[$t]=E,A[Ke]=g,A[ks]=2==e.type?t[ks]:A,A}function Ug(t,e,s,n,r){let i=t.data[e];if(null===i)i=function Mv(t,e,s,n,r){const i=Ni(),a=da(),f=t.data[e]=function xT(t,e,s,n,r,i){let a=e?e.injectorIndex:-1,c=0;return is()&&(c|=128),{type:s,index:n,insertBeforeIndex:null,injectorIndex:a,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:c,providerIndexes:0,value:r,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,a?i:i&&i.parent,s,e,n,r);return null===t.firstChild&&(t.firstChild=f),null!==i&&(a?null==i.child&&null!==f.parent&&(i.child=f):null===i.next&&(i.next=f,f.prev=i)),f}(t,e,s,n,r),function Gd(){return ut.lFrame.inI18n}()&&(i.flags|=32);else if(64&i.type){i.type=s,i.value=n,i.attrs=r;const a=function ta(){const t=ut.lFrame,e=t.currentTNode;return t.isParent?e:e.parent}();i.injectorIndex=null===a?-1:a.injectorIndex}return Io(i,!0),i}function Ty(t,e,s,n){if(0===s)return-1;const r=e.length;for(let i=0;i<s;i++)e.push(n),t.blueprint.push(n),t.data.push(null);return r}function Xx(t,e,s,n,r){const i=Kx(e,dn),a=ga(),c=2&n;try{Kd(-1),c&&e.length>en&&If(t,e,en,!1),hu(c?2:0,r);const g=c?i:null,E=qc(g);try{null!==g&&(g.dirty=!1),s(n,r)}finally{od(g,E)}}finally{c&&null===e[dn]&&Qa(e,dn),Kd(a),hu(c?3:1,r)}}function zg(t,e,s){if(Ln(e)){const n=du(null);try{const i=e.directiveEnd;for(let a=e.directiveStart;a<i;a++){const c=t.data[a];c.contentQueries&&c.contentQueries(1,s[a],a)}}finally{du(n)}}}function Af(t,e,s){as()&&(function IT(t,e,s,n){const r=s.directiveStart,i=s.directiveEnd;An(s)&&function NT(t,e,s){const n=Ic(e,t),r=P1(s);let a=16;s.signals?a=4096:s.onPush&&(a=64);const c=Fv(t,Iy(t,r,null,a,n,e,null,t[Mc].rendererFactory.createRenderer(n,s),null,null,null));t[e.index]=c}(e,s,t.data[r+s.componentOffset]),t.firstCreatePass||ff(s,e),tu(n,e);const a=s.initialInputs;for(let c=r;c<i;c++){const f=t.data[c],g=wn(e,t,c,s);tu(g,e),null!==a&&U1(0,c-r,g,f,0,a),ir(f)&&(Tc(s.index,e)[ua]=wn(e,t,c,s))}}(t,e,s,Ic(s,e)),64==(64&s.flags)&&V1(t,e,s))}function Ja(t,e,s=Ic){const n=e.localNames;if(null!==n){let r=e.index+1;for(let i=0;i<n.length;i+=2){const a=n[i+1],c=-1===a?s(e,t):t[a];t[r++]=c}}}function P1(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=Pv(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts,t.id):e}function Pv(t,e,s,n,r,i,a,c,f,g,E){const A=en+n,Y=A+r,ne=function mT(t,e){const s=[];for(let n=0;n<e;n++)s.push(n<t?null:zi);return s}(A,Y),Ee="function"==typeof g?g():g;return ne[Ws]={type:t,blueprint:ne,template:s,queries:null,viewQuery:c,declTNode:e,data:ne.slice().fill(null,A),bindingStartIndex:A,expandoStartIndex:Y,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof a?a():a,firstChild:null,schemas:f,consts:Ee,incompleteFirstPass:!1,ssrId:E}}let F1=t=>null;function L1(t,e,s,n){for(let r in t)if(t.hasOwnProperty(r)){s=null===s?{}:s;const i=t[r];null===n?$1(s,e,r,i):n.hasOwnProperty(r)&&$1(s,e,n[r],i)}return s}function $1(t,e,s,n){t.hasOwnProperty(s)?t[s].push(e,n):t[s]=[e,n]}function Rd(t,e,s,n,r,i,a,c){const f=Ic(e,s);let E,g=e.inputs;!c&&null!=g&&(E=g[n])?(qx(t,s,E,n,r),An(e)&&function CT(t,e){const s=Tc(e,t);16&s[Wr]||(s[Wr]|=64)}(s,e.index)):3&e.type&&(n=function wT(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(n),r=null!=a?a(r,e.value||"",n):r,i.setProperty(f,n,r))}function Yx(t,e,s,n){if(as()){const r=null===n?null:{"":-1},i=function AT(t,e){const s=t.directiveRegistry;let n=null,r=null;if(s)for(let i=0;i<s.length;i++){const a=s[i];if(mn(e,a.selectors,!1))if(n||(n=[]),ir(a))if(null!==a.findHostDirectiveDefs){const c=[];r=r||new Map,a.findHostDirectiveDefs(a,c,r),n.unshift(...c,a),Zx(t,e,c.length)}else n.unshift(a),Zx(t,e,0);else r=r||new Map,a.findHostDirectiveDefs?.(a,n,r),n.push(a)}return null===n?null:[n,r]}(t,s);let a,c;null===i?a=c=null:[a,c]=i,null!==a&&B1(t,e,s,a,r,c),r&&function Wg(t,e,s){if(e){const n=t.localNames=[];for(let r=0;r<e.length;r+=2){const i=s[e[r+1]];if(null==i)throw new En(-301,!1);n.push(e[r],i)}}}(s,n,r)}s.mergedAttrs=V(s.mergedAttrs,s.attrs)}function B1(t,e,s,n,r,i){for(let g=0;g<n.length;g++)Ie(ff(s,e),t,n[g].type);!function OT(t,e,s){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+s,t.providerIndexes=e}(s,t.data.length,n.length);for(let g=0;g<n.length;g++){const E=n[g];E.providersResolver&&E.providersResolver(E)}let a=!1,c=!1,f=Ty(t,e,n.length,null);for(let g=0;g<n.length;g++){const E=n[g];s.mergedAttrs=V(s.mergedAttrs,E.hostAttrs),RT(t,s,e,f,E),kT(f,E,r),null!==E.contentQueries&&(s.flags|=4),(null!==E.hostBindings||null!==E.hostAttrs||0!==E.hostVars)&&(s.flags|=64);const A=E.type.prototype;!a&&(A.ngOnChanges||A.ngOnInit||A.ngDoCheck)&&((t.preOrderHooks??=[]).push(s.index),a=!0),!c&&(A.ngOnChanges||A.ngDoCheck)&&((t.preOrderCheckHooks??=[]).push(s.index),c=!0),f++}!function ud(t,e,s){const r=e.directiveEnd,i=t.data,a=e.attrs,c=[];let f=null,g=null;for(let E=e.directiveStart;E<r;E++){const A=i[E],Y=s?s.get(A):null,Ee=Y?Y.outputs:null;f=L1(A.inputs,E,f,Y?Y.inputs:null),g=L1(A.outputs,E,g,Ee);const Ge=null===f||null===a||Pe(e)?null:MT(f,E,a);c.push(Ge)}null!==f&&(f.hasOwnProperty("class")&&(e.flags|=8),f.hasOwnProperty("style")&&(e.flags|=16)),e.initialInputs=c,e.inputs=f,e.outputs=g}(t,s,i)}function V1(t,e,s){const n=s.directiveStart,r=s.directiveEnd,i=s.index,a=function E0(){return ut.lFrame.currentDirectiveIndex}();try{Kd(i);for(let c=n;c<r;c++){const f=t.data[c],g=e[c];Dp(c),(null!==f.hostBindings||0!==f.hostVars||null!==f.hostAttrs)&&TT(f,g)}}finally{Kd(-1),Dp(a)}}function TT(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function Zx(t,e,s){e.componentOffset=s,(t.components??=[]).push(e.index)}function kT(t,e,s){if(s){if(e.exportAs)for(let n=0;n<e.exportAs.length;n++)s[e.exportAs[n]]=t;ir(e)&&(s[""]=t)}}function RT(t,e,s,n,r){t.data[n]=r;const i=r.factory||(r.factory=Hu(r.type)),a=new kp(i,ir(r),lt);t.blueprint[n]=a,s[n]=a,function DT(t,e,s,n,r){const i=r.hostBindings;if(i){let a=t.hostBindingOpCodes;null===a&&(a=t.hostBindingOpCodes=[]);const c=~e.index;(function ST(t){let e=t.length;for(;e>0;){const s=t[--e];if("number"==typeof s&&s<0)return s}return 0})(a)!=c&&a.push(c),a.push(s,n,i)}}(t,e,n,Ty(t,s,r.hostVars,zi),r)}function rp(t,e,s,n,r,i){const a=Ic(t,e);!function Ay(t,e,s,n,r,i,a){if(null==i)t.removeAttribute(e,r,s);else{const c=null==a?wr(i):a(i,n||"",r);t.setAttribute(e,r,c,s)}}(e[Ur],a,i,t.value,s,n,r)}function U1(t,e,s,n,r,i){const a=i[e];if(null!==a)for(let c=0;c<a.length;)Qx(n,s,a[c++],a[c++],a[c++])}function Qx(t,e,s,n,r){const i=du(null);try{const a=t.inputTransforms;null!==a&&a.hasOwnProperty(n)&&(r=a[n].call(e,r)),null!==t.setInput?t.setInput(e,r,s,n):e[n]=r}finally{du(i)}}function MT(t,e,s){let n=null,r=0;for(;r<s.length;){const i=s[r];if(0!==i)if(5!==i){if("number"==typeof i)break;if(t.hasOwnProperty(i)){null===n&&(n=[]);const a=t[i];for(let c=0;c<a.length;c+=2)if(a[c]===e){n.push(i,a[c+1],s[r+1]);break}}r+=2}else r+=2;else r+=4}return n}function z1(t,e,s,n){return[t,!0,!1,e,null,0,n,s,null,null,null]}function W1(t,e){const s=t.contentQueries;if(null!==s)for(let n=0;n<s.length;n+=2){const i=s[n+1];if(-1!==i){const a=t.data[i];cf(s[n]),a.contentQueries(2,e[i],i)}}}function Fv(t,e){return t[wl]?t[wd][Eo]=e:t[wl]=e,t[wd]=e,e}function Jx(t,e,s){cf(0);const n=du(null);try{e(t,s)}finally{du(n)}}function H1(t){return t[ei]||(t[ei]=[])}function j1(t){return t.cleanup||(t.cleanup=[])}function K1(t,e){const s=t[Nc],n=s?s.get(nh,null):null;n&&n.handleError(e)}function qx(t,e,s,n,r){for(let i=0;i<s.length;){const a=s[i++],c=s[i++];Qx(t.data[a],e[a],n,c,r)}}function Qu(t,e,s){const n=Vh(e,t);!function X_(t,e,s){t.setValue(e,s)}(t[Ur],n,s)}function PT(t,e){const s=Tc(e,t),n=s[Ws];!function FT(t,e){for(let s=e.length;s<t.blueprint.length;s++)e.push(t.blueprint[s])}(n,s);const r=s[Sa];null!==r&&null===s[$t]&&(s[$t]=tn(r,s[Nc])),ky(n,s,s[ua])}function ky(t,e,s){Qf(e);try{const n=t.viewQuery;null!==n&&Jx(1,n,s);const r=t.template;null!==r&&Xx(t,e,r,1,s),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&W1(t,e),t.staticViewQueries&&Jx(2,t.viewQuery,s);const i=t.components;null!==i&&function LT(t,e){for(let s=0;s<e.length;s++)PT(t,e[s])}(e,i)}catch(n){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),n}finally{e[Wr]&=-5,qf()}}let X1=(()=>{var t;class e{constructor(){this.all=new Set,this.queue=new Map}create(n,r,i){const a=typeof Zone>"u"?null:Zone.current,c=function Kf(t,e,s){const n=Object.create(Vc);s&&(n.consumerAllowSignalWrites=!0),n.fn=t,n.schedule=e;const r=a=>{n.cleanupFn=a};return n.ref={notify:()=>Wf(n),run:()=>{if(n.dirty=!1,n.hasRun&&!qp(n))return;n.hasRun=!0;const a=qc(n);try{n.cleanupFn(),n.cleanupFn=rf,n.fn(r)}finally{od(n,a)}},cleanup:()=>n.cleanupFn()},n.ref}(n,E=>{this.all.has(E)&&this.queue.set(E,a)},i);let f;this.all.add(c),c.notify();const g=()=>{c.cleanup(),f?.(),this.all.delete(c),this.queue.delete(c)};return f=r?.onDestroy(g),{destroy:g}}flush(){if(0!==this.queue.size)for(const[n,r]of this.queue)this.queue.delete(n),r?r.run(()=>n.run()):n.run()}get isQueueEmpty(){return 0===this.queue.size}}return(t=e).\u0275prov=wt({token:t,providedIn:"root",factory:()=>new t}),e})();function Lv(t,e,s){let n=s?t.styles:null,r=s?t.classes:null,i=0;if(null!==e)for(let a=0;a<e.length;a++){const c=e[a];"number"==typeof c?i=c:1==i?r=mi(r,c):2==i&&(n=mi(n,c+": "+e[++a]+";"))}s?t.styles=n:t.stylesWithoutHost=n,s?t.classes=r:t.classesWithoutHost=r}function Oy(t,e,s,n,r=!1){for(;null!==s;){const i=e[s.index];null!==i&&n.push(Vo(i)),Kn(i)&&Ry(i,n);const a=s.type;if(8&a)Oy(t,e,s.child,n);else if(32&a){const c=bf(s,e);let f;for(;f=c();)n.push(f)}else if(16&a){const c=fm(e,s);if(Array.isArray(c))n.push(...c);else{const f=Np(e[ks]);Oy(f[Ws],f,c,n,!0)}}s=r?s.projectionNext:s.next}return n}function Ry(t,e){for(let s=zt;s<t.length;s++){const n=t[s],r=n[Ws].firstChild;null!==r&&Oy(n[Ws],n,r,e)}t[me]!==t[Sa]&&e.push(t[me])}function $v(t,e,s,n=!0){const r=e[Mc],i=r.rendererFactory,a=r.afterRenderEventManager;i.begin?.(),a?.begin();try{sh(t,e,t.template,s)}catch(f){throw n&&K1(e,f),f}finally{i.end?.(),r.effectManager?.flush(),a?.end()}}function sh(t,e,s,n){const r=e[Wr];if(256!=(256&r)){e[Mc].effectManager?.flush(),Qf(e);try{pu(e),function Sd(t){return ut.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==s&&Xx(t,e,s,2,n);const a=3==(3&r);if(a){const g=t.preOrderCheckHooks;null!==g&&Ap(e,g,null)}else{const g=t.preOrderHooks;null!==g&&df(e,g,0,null),ns(e,0)}if(function VT(t){for(let e=G_(t);null!==e;e=G0(e)){if(!e[ee])continue;const s=e[gt];for(let n=0;n<s.length;n++){Xf(s[n])}}}(e),Y1(e,2),null!==t.contentQueries&&W1(t,e),a){const g=t.contentCheckHooks;null!==g&&Ap(e,g)}else{const g=t.contentHooks;null!==g&&df(e,g,1),ns(e,1)}!function fT(t,e){const s=t.hostBindingOpCodes;if(null===s)return;const n=Kx(e,Sn);try{for(let r=0;r<s.length;r++){const i=s[r];if(i<0)Kd(~i);else{const a=i,c=s[++r],f=s[++r];x_(c,a),n.dirty=!1;const g=qc(n);try{f(2,e[a])}finally{od(n,g)}}}}finally{null===e[Sn]&&Qa(e,Sn),Kd(-1)}}(t,e);const c=t.components;null!==c&&Z1(e,c,0);const f=t.viewQuery;if(null!==f&&Jx(2,f,n),a){const g=t.viewCheckHooks;null!==g&&Ap(e,g)}else{const g=t.viewHooks;null!==g&&df(e,g,2),ns(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),e[Wr]&=-73,Tt(e)}finally{qf()}}}function Y1(t,e){for(let s=G_(t);null!==s;s=G0(s))for(let n=zt;n<s.length;n++)Em(s[n],e)}function UT(t,e,s){Em(Tc(e,t),s)}function Em(t,e){if(!function ao(t){return 128==(128&t[Wr])}(t))return;const s=t[Ws],n=t[Wr];if(80&n&&0===e||1024&n||2===e)sh(s,t,s.template,t[ua]);else if(t[Ol]>0){Y1(t,1);const r=s.components;null!==r&&Z1(t,r,1)}}function Z1(t,e,s){for(let n=0;n<e.length;n++)UT(t,e[n],s)}class ip{get rootNodes(){const e=this._lView,s=e[Ws];return Oy(s,e,s.firstChild,[])}constructor(e,s){this._lView=e,this._cdRefInjectingView=s,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[ua]}set context(e){this._lView[ua]=e}get destroyed(){return 256==(256&this._lView[Wr])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const e=this._lView[Mo];if(Kn(e)){const s=e[8],n=s?s.indexOf(this):-1;n>-1&&(dm(e,n),ig(s,n))}this._attachedToViewContainer=!1}wf(this._lView[Ws],this._lView)}onDestroy(e){!function ht(t,e){if(256==(256&t[Wr]))throw new En(911,!1);null===t[dt]&&(t[dt]=[]),t[dt].push(e)}(this._lView,e)}markForCheck(){Vg(this._cdRefInjectingView||this._lView)}detach(){this._lView[Wr]&=-129}reattach(){this._lView[Wr]|=128}detectChanges(){$v(this._lView[Ws],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new En(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Yh(t,e){wg(t,e,e[Ur],2,null,null)}(this._lView[Ws],this._lView)}attachToAppRef(e){if(this._attachedToViewContainer)throw new En(902,!1);this._appRef=e}}class Hg extends ip{constructor(e){super(e),this._view=e}detectChanges(){const e=this._view;$v(e[Ws],e,e[ua],!1)}checkNoChanges(){}get context(){return null}}class Q1 extends lc{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const s=Vi(e);return new Ny(s,this.ngModule)}}function ew(t){const e=[];for(let s in t)t.hasOwnProperty(s)&&e.push({propName:t[s],templateName:s});return e}class WT{constructor(e,s){this.injector=e,this.parentInjector=s}get(e,s,n){n=Oi(n);const r=this.injector.get(e,Fx,n);return r!==Fx||s===Fx?r:this.parentInjector.get(e,s,n)}}class Ny extends cd{get inputs(){const e=this.componentDef,s=e.inputTransforms,n=ew(e.inputs);if(null!==s)for(const r of n)s.hasOwnProperty(r.propName)&&(r.transform=s[r.propName]);return n}get outputs(){return ew(this.componentDef.outputs)}constructor(e,s){super(),this.componentDef=e,this.ngModule=s,this.componentType=e.type,this.selector=function Or(t){return t.map(Rs).join(",")}(e.selectors),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!s}create(e,s,n,r){let i=(r=r||this.ngModule)instanceof Yu?r:r?.injector;i&&null!==this.componentDef.getStandaloneInjector&&(i=this.componentDef.getStandaloneInjector(i)||i);const a=i?new WT(e,i):e,c=a.get(tp,null);if(null===c)throw new En(407,!1);const A={rendererFactory:c,sanitizer:a.get(Sv,null),effectManager:a.get(X1,null),afterRenderEventManager:a.get(Rv,null)},Y=c.createRenderer(null,this.componentDef),ne=this.componentDef.selectors[0][0]||"div",Ee=n?function gT(t,e,s,n){const i=n.get(jx,!1)||s===oo.ShadowDom,a=t.selectRootElement(e,i);return function _T(t){F1(t)}(a),a}(Y,n,this.componentDef.encapsulation,a):um(Y,ne,function zT(t){const e=t.toLowerCase();return"svg"===e?Bh:"math"===e?"math":null}(ne)),Nt=this.componentDef.signals?4608:this.componentDef.onPush?576:528;let kt=null;null!==Ee&&(kt=tn(Ee,a,!0));const on=Pv(0,null,null,1,0,null,null,null,null,null,null),fn=Iy(null,on,null,Nt,null,null,A,Y,a,null,kt);let Tn,Hn;Qf(fn);try{const Wn=this.componentDef;let xs,fs=null;Wn.findHostDirectiveDefs?(xs=[],fs=new Map,Wn.findHostDirectiveDefs(Wn,xs,fs),xs.push(Wn)):xs=[Wn];const Ks=function jT(t,e){const s=t[Ws],n=en;return t[n]=e,Ug(s,n,2,"#host",null)}(fn,Ee),Hr=function GT(t,e,s,n,r,i,a){const c=r[Ws];!function KT(t,e,s,n){for(const r of t)e.mergedAttrs=V(e.mergedAttrs,r.hostAttrs);null!==e.mergedAttrs&&(Lv(e,e.mergedAttrs,!0),null!==s&&Ef(n,s,e))}(n,t,e,a);let f=null;null!==e&&(f=tn(e,r[Nc]));const g=i.rendererFactory.createRenderer(e,s);let E=16;s.signals?E=4096:s.onPush&&(E=64);const A=Iy(r,P1(s),null,E,r[t.index],t,i,g,null,null,f);return c.firstCreatePass&&Zx(c,t,n.length-1),Fv(r,A),r[t.index]=A}(Ks,Ee,Wn,xs,fn,A,Y);Hn=Uo(on,en),Ee&&function YT(t,e,s,n){if(n)gc(t,s,["ng-version",rT.full]);else{const{attrs:r,classes:i}=function zr(t){const e=[],s=[];let n=1,r=2;for(;n<t.length;){let i=t[n];if("string"==typeof i)2===r?""!==i&&e.push(i,t[++n]):8===r&&s.push(i);else{if(!mt(r))break;r=i}n++}return{attrs:e,classes:s}}(e.selectors[0]);r&&gc(t,s,r),i&&i.length>0&&lx(t,s,i.join(" "))}}(Y,Wn,Ee,n),void 0!==s&&function ZT(t,e,s){const n=t.projection=[];for(let r=0;r<e.length;r++){const i=s[r];n.push(null!=i?Array.from(i):null)}}(Hn,this.ngContentSelectors,s),Tn=function XT(t,e,s,n,r,i){const a=Ui(),c=r[Ws],f=Ic(a,r);B1(c,r,a,s,null,n);for(let E=0;E<s.length;E++)tu(wn(r,c,a.directiveStart+E,a),r);V1(c,r,a),f&&tu(f,r);const g=wn(r,c,a.directiveStart+a.componentOffset,a);if(t[ua]=r[ua]=g,null!==i)for(const E of i)E(g,e);return zg(c,a,t),g}(Hr,Wn,xs,fs,fn,[QT]),ky(on,fn,null)}finally{qf()}return new HT(this.componentType,Tn,Vu(Hn,fn),fn,Hn)}}class HT extends ql{constructor(e,s,n,r,i){super(),this.location=n,this._rootLView=r,this._tNode=i,this.previousInputValues=null,this.instance=s,this.hostView=this.changeDetectorRef=new Hg(r),this.componentType=e}setInput(e,s){const n=this._tNode.inputs;let r;if(null!==n&&(r=n[e])){if(this.previousInputValues??=new Map,this.previousInputValues.has(e)&&Object.is(this.previousInputValues.get(e),s))return;const i=this._rootLView;qx(i[Ws],i,r,e,s),this.previousInputValues.set(e,s),Vg(Tc(this._tNode.index,i))}}get injector(){return new mr(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}}function QT(){const t=Ui();Tp(Fn()[Ws],t)}function Ps(t){let e=function J1(t){return Object.getPrototypeOf(t.prototype).constructor}(t.type),s=!0;const n=[t];for(;e;){let r;if(ir(t))r=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new En(903,!1);r=e.\u0275dir}if(r){if(s){n.push(r);const a=t;a.inputs=Bv(t.inputs),a.inputTransforms=Bv(t.inputTransforms),a.declaredInputs=Bv(t.declaredInputs),a.outputs=Bv(t.outputs);const c=r.hostBindings;c&&tA(t,c);const f=r.viewQuery,g=r.contentQueries;if(f&&qT(t,f),g&&eA(t,g),ma(t.inputs,r.inputs),ma(t.declaredInputs,r.declaredInputs),ma(t.outputs,r.outputs),null!==r.inputTransforms&&(null===a.inputTransforms&&(a.inputTransforms={}),ma(a.inputTransforms,r.inputTransforms)),ir(r)&&r.data.animation){const E=t.data;E.animation=(E.animation||[]).concat(r.data.animation)}}const i=r.features;if(i)for(let a=0;a<i.length;a++){const c=i[a];c&&c.ngInherit&&c(t),c===Ps&&(s=!1)}}e=Object.getPrototypeOf(e)}!function JT(t){let e=0,s=null;for(let n=t.length-1;n>=0;n--){const r=t[n];r.hostVars=e+=r.hostVars,r.hostAttrs=V(r.hostAttrs,s=V(s,r.hostAttrs))}}(n)}function Bv(t){return t===Bo?{}:t===wi?[]:t}function qT(t,e){const s=t.viewQuery;t.viewQuery=s?(n,r)=>{e(n,r),s(n,r)}:e}function eA(t,e){const s=t.contentQueries;t.contentQueries=s?(n,r,i)=>{e(n,r,i),s(n,r,i)}:e}function tA(t,e){const s=t.hostBindings;t.hostBindings=s?(n,r)=>{e(n,r),s(n,r)}:e}function nE(t){const e=t.inputConfig,s={};for(const n in e)if(e.hasOwnProperty(n)){const r=e[n];Array.isArray(r)&&r[2]&&(s[n]=r[2])}t.inputTransforms=s}function Vv(t){return!!tw(t)&&(Array.isArray(t)||!(t instanceof Map)&&Symbol.iterator in t)}function tw(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function op(t,e,s){return t[e]=s}function Uu(t,e,s){return!Object.is(t[e],s)&&(t[e]=s,!0)}function si(t,e,s,n){const r=Fn();return Uu(r,Yl(),e)&&(Fr(),rp(Wo(),r,t,e,s,n)),si}function Gg(t,e,s,n){return Uu(t,Yl(),s)?e+wr(s)+n:zi}function Kg(t,e,s,n,r,i){const c=function Dm(t,e,s,n){const r=Uu(t,e,s);return Uu(t,e+1,n)||r}(t,function El(){return ut.lFrame.bindingIndex}(),s,r);return zc(2),c?e+wr(s)+n+wr(r)+i:zi}function Fs(t,e,s,n,r,i,a,c){const f=Fn(),g=Fr(),E=t+en,A=g.firstCreatePass?function CA(t,e,s,n,r,i,a,c,f){const g=e.consts,E=Ug(e,t,4,a||null,Pu(g,c));Yx(e,s,E,Pu(g,f)),Tp(e,E);const A=E.tView=Pv(2,E,n,r,i,e.directiveRegistry,e.pipeRegistry,null,e.schemas,g,null);return null!==e.queries&&(e.queries.template(e,E),A.queries=e.queries.embeddedTView(E)),E}(E,g,f,e,s,n,r,i,a):g.data[E];Io(A,!1);const Y=gE(g,f,A,t);uf()&&pm(g,f,Y,A),tu(Y,f),Fv(f,f[E]=z1(Y,f,Y,A)),vs(A)&&Af(g,f,A),null!=a&&Ja(f,A,c)}let gE=function _E(t,e,s,n){return Xd(!0),e[Ur].createComment("")};function zp(t){return Xl(function Za(){return ut.lFrame.contextLView}(),en+t)}function Yn(t,e,s){const n=Fn();return Uu(n,Yl(),e)&&Rd(Fr(),Wo(),n,t,e,n[Ur],s,!1),Yn}function dw(t,e,s,n,r){const a=r?"class":"style";qx(t,s,e.inputs[a],a,n)}function yn(t,e,s,n){const r=Fn(),i=Fr(),a=en+t,c=r[Ur],f=i.firstCreatePass?function IA(t,e,s,n,r,i){const a=e.consts,f=Ug(e,t,2,n,Pu(a,r));return Yx(e,s,f,Pu(a,i)),null!==f.attrs&&Lv(f,f.attrs,!1),null!==f.mergedAttrs&&Lv(f,f.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,f),f}(a,i,r,e,s,n):i.data[a],g=yE(i,r,f,c,e,t);r[a]=g;const E=vs(f);return Io(f,!0),Ef(c,g,f),32!=(32&f.flags)&&uf()&&pm(i,r,g,f),0===function un(){return ut.lFrame.elementDepthCount}()&&tu(g,r),function Rn(){ut.lFrame.elementDepthCount++}(),E&&(Af(i,r,f),zg(i,f,r)),null!==n&&Ja(r,f),yn}function In(){let t=Ui();da()?zo():(t=t.parent,Io(t,!1));const e=t;(function js(t){return ut.skipHydrationRootTNode===t})(e)&&function Xr(){ut.skipHydrationRootTNode=null}(),function Mn(){ut.lFrame.elementDepthCount--}();const s=Fr();return s.firstCreatePass&&(Tp(s,t),Ln(t)&&s.queries.elementEnd(t)),null!=e.classesWithoutHost&&function eg(t){return 0!=(8&t.flags)}(e)&&dw(s,e,Fn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function tg(t){return 0!=(16&t.flags)}(e)&&dw(s,e,Fn(),e.stylesWithoutHost,!1),In}function ti(t,e,s,n){return yn(t,e,s,n),In(),ti}let yE=(t,e,s,n,r,i)=>(Xd(!0),um(n,r,function Qm(){return ut.lFrame.currentNamespace}()));function dd(t,e,s){const n=Fn(),r=Fr(),i=t+en,a=r.firstCreatePass?function kA(t,e,s,n,r){const i=e.consts,a=Pu(i,n),c=Ug(e,t,8,"ng-container",a);return null!==a&&Lv(c,a,!0),Yx(e,s,c,Pu(i,r)),null!==e.queries&&e.queries.elementStart(e,c),c}(i,r,n,e,s):r.data[i];Io(a,!0);const c=vE(r,n,a,t);return n[i]=c,uf()&&pm(r,n,c,a),tu(c,n),vs(a)&&(Af(r,n,a),zg(r,a,n)),null!=s&&Ja(n,a),dd}function hd(){let t=Ui();const e=Fr();return da()?zo():(t=t.parent,Io(t,!1)),e.firstCreatePass&&(Tp(e,t),Ln(t)&&e.queries.elementEnd(t)),hd}function Nd(t,e,s){return dd(t,e,s),hd(),Nd}let vE=(t,e,s,n)=>(Xd(!0),Y_(e[Ur],""));function iu(){return Fn()}function By(t){return!!t&&"function"==typeof t.then}function bE(t){return!!t&&"function"==typeof t.subscribe}function qs(t,e,s,n){const r=Fn(),i=Fr(),a=Ui();return function wE(t,e,s,n,r,i,a){const c=vs(n),g=t.firstCreatePass&&j1(t),E=e[ua],A=H1(e);let Y=!0;if(3&n.type||a){const Ge=Ic(n,e),tt=a?a(Ge):Ge,Nt=A.length,kt=a?fn=>a(Vo(fn[n.index])):n.index;let on=null;if(!a&&c&&(on=function NA(t,e,s,n){const r=t.cleanup;if(null!=r)for(let i=0;i<r.length-1;i+=2){const a=r[i];if(a===s&&r[i+1]===n){const c=e[ei],f=r[i+2];return c.length>f?c[f]:null}"string"==typeof a&&(i+=2)}return null}(t,e,r,n.index)),null!==on)(on.__ngLastListenerFn__||on).__ngNextListenerFn__=i,on.__ngLastListenerFn__=i,Y=!1;else{i=EE(n,e,E,i,!1);const fn=s.listen(tt,r,i);A.push(i,fn),g&&g.push(r,kt,Nt,Nt+1)}}else i=EE(n,e,E,i,!1);const ne=n.outputs;let Ee;if(Y&&null!==ne&&(Ee=ne[r])){const Ge=Ee.length;if(Ge)for(let tt=0;tt<Ge;tt+=2){const Tn=e[Ee[tt]][Ee[tt+1]].subscribe(i),Hn=A.length;A.push(i,Tn),g&&g.push(r,n.index,Hn,-(Hn+1))}}}(i,r,r[Ur],a,t,e,n),qs}function CE(t,e,s,n){try{return hu(6,e,s),!1!==s(n)}catch(r){return K1(t,r),!1}finally{hu(7,e,s)}}function EE(t,e,s,n,r){return function i(a){if(a===Function)return n;Vg(t.componentOffset>-1?Tc(t.index,e):e);let f=CE(e,s,n,a),g=i.__ngNextListenerFn__;for(;g;)f=CE(e,s,g,a)&&f,g=g.__ngNextListenerFn__;return r&&!1===f&&a.preventDefault(),f}}function bs(t=1){return function Sp(t){return(ut.lFrame.contextLView=function Zm(t,e){for(;t>0;)e=e[Do],t--;return e}(t,ut.lFrame.contextLView))[ua]}(t)}function MA(t,e){let s=null;const n=function rn(t){const e=t.attrs;if(null!=e){const s=e.indexOf(5);if(!(1&s))return e[s+1]}return null}(t);for(let r=0;r<e.length;r++){const i=e[r];if("*"!==i){if(null===n?mn(t,i,!0):Bs(n,i))return r}else s=r}return s}function Pl(t){const e=Fn()[ks][ln];if(!e.projection){const n=e.projection=og(t?t.length:1,null),r=n.slice();let i=e.child;for(;null!==i;){const a=t?MA(i,t):0;null!==a&&(r[a]?r[a].projectionNext=i:n[a]=i,r[a]=i),i=i.next}}}function ri(t,e=0,s){const n=Fn(),r=Fr(),i=Ug(r,en+t,16,null,s||null);null===i.projection&&(i.projection=e),zo(),(!n[$t]||is())&&32!=(32&i.flags)&&function Cg(t,e,s){o1(e[Ur],0,e,s,q_(t,s,e),ny(s.parent||e[ln],s,e))}(r,n,i)}function Hv(t,e,s){return hw(t,"",e,"",s),Hv}function hw(t,e,s,n,r){const i=Fn(),a=Gg(i,e,s,n);return a!==zi&&Rd(Fr(),Wo(),i,t,a,i[Ur],r,!1),hw}function Vy(t,e){return t<<17|e<<2}function kf(t){return t>>17&32767}function pw(t){return 2|t}function Tm(t){return(131068&t)>>2}function fw(t,e){return-131069&t|e<<2}function mw(t){return 1|t}function NE(t,e,s,n,r){const i=t[s+1],a=null===e;let c=n?kf(i):Tm(i),f=!1;for(;0!==c&&(!1===f||a);){const E=t[c+1];VA(t[c],e)&&(f=!0,t[c+1]=n?mw(E):pw(E)),c=n?kf(E):Tm(E)}f&&(t[s+1]=n?pw(i):mw(i))}function VA(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&Rp(t,e)>=0}const ou={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function ME(t){return t.substring(ou.key,ou.keyEnd)}function gw(t,e){const s=ou.textEnd;return s===e?-1:(e=ou.keyEnd=function FE(t,e,s){for(;e<s&&t.charCodeAt(e)>32;)e++;return e}(t,ou.key=e,s),qg(t,e,s))}function qg(t,e,s){for(;e<s&&t.charCodeAt(e)<=32;)e++;return e}function Ju(t,e,s){return Dh(t,e,s,!1),Ju}function Ei(t,e){return Dh(t,e,null,!0),Ei}function lp(t,e){for(let s=function UA(t){return function PE(t){ou.key=0,ou.keyEnd=0,ou.value=0,ou.valueEnd=0,ou.textEnd=t.length}(t),gw(t,qg(t,0,ou.textEnd))}(e);s>=0;s=gw(e,s))Xu(t,ME(e),!0)}function Dh(t,e,s,n){const r=Fn(),i=Fr(),a=zc(2);i.firstUpdatePass&&UE(i,t,a,n),e!==zi&&Uu(r,a,e)&&WE(i,i.data[ga()],r,r[Ur],t,r[a+1]=function qA(t,e){return null==t||""===t||("string"==typeof e?t+=e:"object"==typeof t&&(t=mo(Lu(t)))),t}(e,s),n,a)}function Sh(t,e,s,n){const r=Fr(),i=zc(2);r.firstUpdatePass&&UE(r,null,i,n);const a=Fn();if(s!==zi&&Uu(a,i,s)){const c=r.data[ga()];if(jE(c,n)&&!VE(r,i)){let f=n?c.classesWithoutHost:c.stylesWithoutHost;null!==f&&(s=mi(f,s||"")),dw(r,c,a,s,n)}else!function JA(t,e,s,n,r,i,a,c){r===zi&&(r=wi);let f=0,g=0,E=0<r.length?r[0]:null,A=0<i.length?i[0]:null;for(;null!==E||null!==A;){const Y=f<r.length?r[f+1]:void 0,ne=g<i.length?i[g+1]:void 0;let Ge,Ee=null;E===A?(f+=2,g+=2,Y!==ne&&(Ee=A,Ge=ne)):null===A||null!==E&&E<A?(f+=2,Ee=E):(g+=2,Ee=A,Ge=ne),null!==Ee&&WE(t,e,s,n,Ee,Ge,a,c),E=f<r.length?r[f]:null,A=g<i.length?i[g]:null}}(r,c,a,a[Ur],a[i+1],a[i+1]=function ZA(t,e,s){if(null==s||""===s)return wi;const n=[],r=Lu(s);if(Array.isArray(r))for(let i=0;i<r.length;i++)t(n,r[i],!0);else if("object"==typeof r)for(const i in r)r.hasOwnProperty(i)&&t(n,i,r[i]);else"string"==typeof r&&e(n,r);return n}(t,e,s),n,i)}}function VE(t,e){return e>=t.expandoStartIndex}function UE(t,e,s,n){const r=t.data;if(null===r[s+1]){const i=r[ga()],a=VE(t,s);jE(i,n)&&null===e&&!a&&(e=!1),e=function GA(t,e,s,n){const r=function yh(t){const e=ut.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}(t);let i=n?e.residualClasses:e.residualStyles;if(null===r)0===(n?e.classBindings:e.styleBindings)&&(s=Uy(s=yw(null,t,e,s,n),e.attrs,n),i=null);else{const a=e.directiveStylingLast;if(-1===a||t[a]!==r)if(s=yw(r,t,e,s,n),null===i){let f=function KA(t,e,s){const n=s?e.classBindings:e.styleBindings;if(0!==Tm(n))return t[kf(n)]}(t,e,n);void 0!==f&&Array.isArray(f)&&(f=yw(null,t,e,f[1],n),f=Uy(f,e.attrs,n),function XA(t,e,s,n){t[kf(s?e.classBindings:e.styleBindings)]=n}(t,e,n,f))}else i=function YA(t,e,s){let n;const r=e.directiveEnd;for(let i=1+e.directiveStylingLast;i<r;i++)n=Uy(n,t[i].hostAttrs,s);return Uy(n,e.attrs,s)}(t,e,n)}return void 0!==i&&(n?e.residualClasses=i:e.residualStyles=i),s}(r,i,e,n),function $A(t,e,s,n,r,i){let a=i?e.classBindings:e.styleBindings,c=kf(a),f=Tm(a);t[n]=s;let E,g=!1;if(Array.isArray(s)?(E=s[1],(null===E||Rp(s,E)>0)&&(g=!0)):E=s,r)if(0!==f){const Y=kf(t[c+1]);t[n+1]=Vy(Y,c),0!==Y&&(t[Y+1]=fw(t[Y+1],n)),t[c+1]=function FA(t,e){return 131071&t|e<<17}(t[c+1],n)}else t[n+1]=Vy(c,0),0!==c&&(t[c+1]=fw(t[c+1],n)),c=n;else t[n+1]=Vy(f,0),0===c?c=n:t[f+1]=fw(t[f+1],n),f=n;g&&(t[n+1]=pw(t[n+1])),NE(t,E,n,!0),NE(t,E,n,!1),function BA(t,e,s,n,r){const i=r?t.residualClasses:t.residualStyles;null!=i&&"string"==typeof e&&Rp(i,e)>=0&&(s[n+1]=mw(s[n+1]))}(e,E,t,n,i),a=Vy(c,f),i?e.classBindings=a:e.styleBindings=a}(r,i,e,s,a,n)}}function yw(t,e,s,n,r){let i=null;const a=s.directiveEnd;let c=s.directiveStylingLast;for(-1===c?c=s.directiveStart:c++;c<a&&(i=e[c],n=Uy(n,i.hostAttrs,r),i!==t);)c++;return null!==t&&(s.directiveStylingLast=c),n}function Uy(t,e,s){const n=s?1:2;let r=-1;if(null!==e)for(let i=0;i<e.length;i++){const a=e[i];"number"==typeof a?r=a:r===n&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),Xu(t,a,!!s||e[++i]))}return void 0===t?null:t}function QA(t,e,s){const n=String(e);""!==n&&!n.includes(" ")&&Xu(t,n,s)}function WE(t,e,s,n,r,i,a,c){if(!(3&e.type))return;const f=t.data,g=f[c+1],E=function LA(t){return 1==(1&t)}(g)?HE(f,e,s,r,Tm(g),a):void 0;Gv(E)||(Gv(i)||function PA(t){return 2==(2&t)}(g)&&(i=HE(f,null,s,r,c,a)),function a1(t,e,s,n,r){if(e)r?t.addClass(s,n):t.removeClass(s,n);else{let i=-1===n.indexOf("-")?void 0:Eu.DashCase;null==r?t.removeStyle(s,n,i):("string"==typeof r&&r.endsWith("!important")&&(r=r.slice(0,-10),i|=Eu.Important),t.setStyle(s,n,r,i))}}(n,a,Vh(ga(),s),r,i))}function HE(t,e,s,n,r,i){const a=null===e;let c;for(;r>0;){const f=t[r],g=Array.isArray(f),E=g?f[1]:f,A=null===E;let Y=s[r+1];Y===zi&&(Y=A?wi:void 0);let ne=A?ld(Y,n):E===n?Y:void 0;if(g&&!Gv(ne)&&(ne=ld(f,n)),Gv(ne)&&(c=ne,a))return c;const Ee=t[r+1];r=a?kf(Ee):Tm(Ee)}if(null!==e){let f=i?e.residualClasses:e.residualStyles;null!=f&&(c=ld(f,n))}return c}function Gv(t){return void 0!==t}function jE(t,e){return 0!=(t.flags&(e?8:16))}function Ys(t,e=""){const s=Fn(),n=Fr(),r=t+en,i=n.firstCreatePass?Ug(n,r,1,e,null):n.data[r],a=GE(n,s,i,e,t);s[r]=a,uf()&&pm(n,s,a,i),Io(i,!1)}let GE=(t,e,s,n,r)=>(Xd(!0),function cm(t,e){return t.createText(e)}(e[Ur],n));function zu(t){return pd("",t,""),zu}function pd(t,e,s){const n=Fn(),r=Gg(n,t,e,s);return r!==zi&&Qu(n,ga(),r),pd}function Kv(t,e,s,n,r){const i=Fn(),a=Kg(i,t,e,s,n,r);return a!==zi&&Qu(i,ga(),a),Kv}function ih(t,e,s){const n=Fn();return Uu(n,Yl(),e)&&Rd(Fr(),Wo(),n,t,e,n[Ur],s,!0),ih}const n_="en-US";let pD=n_;function Il(t,e,s,n,r){if(t=dr(t),Array.isArray(t))for(let i=0;i<t.length;i++)Il(t[i],e,s,n,r);else{const i=Fr(),a=Fn(),c=Ui();let f=Bp(t)?t:dr(t.provide);const g=vy(t),E=1048575&c.providerIndexes,A=c.directiveStart,Y=c.providerIndexes>>20;if(Bp(t)||!t.multi){const ne=new kp(g,r,lt),Ee=up(f,e,r?E:E+Y,A);-1===Ee?(Ie(ff(c,a),i,f),Ih(i,t,e.length),e.push(f),c.directiveStart++,c.directiveEnd++,r&&(c.providerIndexes+=1048576),s.push(ne),a.push(ne)):(s[Ee]=ne,a[Ee]=ne)}else{const ne=up(f,e,E+Y,A),Ee=up(f,e,E,E+Y),tt=Ee>=0&&s[Ee];if(r&&!tt||!r&&!(ne>=0&&s[ne])){Ie(ff(c,a),i,f);const Nt=function Wp(t,e,s,n,r){const i=new kp(t,s,lt);return i.multi=[],i.index=e,i.componentProviders=0,au(i,r,n&&!s),i}(r?km:Md,s.length,r,n,g);!r&&tt&&(s[Ee].providerFactory=Nt),Ih(i,t,e.length,0),e.push(f),c.directiveStart++,c.directiveEnd++,r&&(c.providerIndexes+=1048576),s.push(Nt),a.push(Nt)}else Ih(i,t,ne>-1?ne:Ee,au(s[r?Ee:ne],g,!r&&n));!r&&n&&tt&&s[Ee].componentProviders++}}}function Ih(t,e,s,n){const r=Bp(e),i=function Tx(t){return!!t.useClass}(e);if(r||i){const f=(i?dr(e.useClass):e).prototype.ngOnDestroy;if(f){const g=t.destroyHooks||(t.destroyHooks=[]);if(!r&&e.multi){const E=g.indexOf(s);-1===E?g.push(s,[n,f]):g[E+1].push(n,f)}else g.push(s,f)}}}function au(t,e,s){return s&&t.componentProviders++,t.multi.push(e)-1}function up(t,e,s,n){for(let r=s;r<n;r++)if(e[r]===t)return r;return-1}function Md(t,e,s,n){return Pd(this.multi,[])}function km(t,e,s,n){const r=this.multi;let i;if(this.providerFactory){const a=this.providerFactory.componentProviders,c=wn(s,s[Ws],this.providerFactory.index,n);i=c.slice(0,a),Pd(r,i);for(let f=a;f<c.length;f++)i.push(c[f])}else i=[],Pd(r,i);return i}function Pd(t,e){for(let s=0;s<t.length;s++)e.push((0,t[s])());return e}function vr(t,e=[]){return s=>{s.providersResolver=(n,r)=>function cc(t,e,s){const n=Fr();if(n.firstCreatePass){const r=ir(t);Il(s,n.data,n.blueprint,r,!0),Il(e,n.data,n.blueprint,r,!1)}}(n,r?r(t):t,e)}}class md{}class Hp{}class Gy extends md{constructor(e,s,n){super(),this._parent=s,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new Q1(this);const r=_c(e);this._bootstrapComponents=sp(r.bootstrap),this._r3Injector=v1(e,s,[{provide:md,useValue:this},{provide:lc,useValue:this.componentFactoryResolver},...n],mo(e),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(e)}get injector(){return this._r3Injector}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(s=>s()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class bw extends Hp{constructor(e){super(),this.moduleType=e}create(e){return new Gy(this.moduleType,e,[])}}class SD extends md{constructor(e){super(),this.componentFactoryResolver=new Q1(this),this.instance=null;const s=new Fg([...e.providers,{provide:md,useValue:this},{provide:lc,useValue:this.componentFactoryResolver}],e.parent||_y(),e.debugName,new Set(["environment"]));this.injector=s,e.runEnvironmentInitializers&&s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(e){this.injector.onDestroy(e)}}function xw(t,e,s=null){return new SD({providers:t,parent:e,debugName:s,runEnvironmentInitializers:!0}).injector}let O4=(()=>{var t;class e{constructor(n){this._injector=n,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(n){if(!n.standalone)return null;if(!this.cachedInjectors.has(n)){const r=bv(0,n.type),i=r.length>0?xw([r],this._injector,`Standalone[${n.type.name}]`):null;this.cachedInjectors.set(n,i)}return this.cachedInjectors.get(n)}ngOnDestroy(){try{for(const n of this.cachedInjectors.values())null!==n&&n.destroy()}finally{this.cachedInjectors.clear()}}}return(t=e).\u0275prov=wt({token:t,providedIn:"environment",factory:()=>new t(cn(Yu))}),e})();function Pk(t){t.getStandaloneInjector=e=>e.get(O4).getOrCreateStandaloneInjector(t)}function Lk(t,e,s){const n=Jo()+t,r=Fn();return r[n]===zi?op(r,n,s?e.call(s):e()):function My(t,e){return t[e]}(r,n)}function IM(t,e,s,n,r,i){const a=e+s;return Uu(t,a,r)?op(t,a+1,i?n.call(i,r):n(r)):function ww(t,e){const s=t[e];return s===zi?void 0:s}(t,a+1)}function Cw(t,e){const s=Fr();let n;const r=t+en;s.firstCreatePass?(n=function Y4(t,e){if(e)for(let s=e.length-1;s>=0;s--){const n=e[s];if(t===n.name)return n}}(e,s.pipeRegistry),s.data[r]=n,n.onDestroy&&(s.destroyHooks??=[]).push(r,n.onDestroy)):n=s.data[r];const i=n.factory||(n.factory=Hu(n.type)),c=wo(lt);try{const f=hf(!1),g=i();return hf(f),function SA(t,e,s,n){s>=t.data.length&&(t.data[s]=null,t.blueprint[s]=null),e[s]=n}(s,Fn(),r,g),g}finally{wo(c)}}function Ew(t,e,s){const n=t+en,r=Fn(),i=Xl(r,n);return function Dw(t,e){return t[Ws].data[e].pure}(r,n)?IM(r,Jo(),e,i.transform,s,i):i.transform(s)}function eW(){return this._results[Symbol.iterator]()}class Ky{get changes(){return this._changes||(this._changes=new Rr)}constructor(e=!1){this._emitDistinctChangesOnly=e,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const s=Ky.prototype;s[Symbol.iterator]||(s[Symbol.iterator]=eW)}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,s){return this._results.reduce(e,s)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,s){const n=this;n.dirty=!1;const r=function Td(t){return t.flat(Number.POSITIVE_INFINITY)}(e);(this._changesDetected=!function jb(t,e,s){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++){let r=t[n],i=e[n];if(s&&(r=s(r),i=s(i)),i!==r)return!1}return!0}(n._results,r,s))&&(n._results=r,n.length=r.length,n.last=r[this.length-1],n.first=r[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}function nW(t,e,s,n=!0){const r=e[Ws];if(function Z_(t,e,s,n){const r=zt+n,i=s.length;n>0&&(s[r-1][Eo]=e),n<i-zt?(e[Eo]=s[r],sm(s,zt+n,e)):(s.push(e),e[Eo]=null),e[Mo]=s;const a=e[Zo];null!==a&&s!==a&&function Q_(t,e){const s=t[gt];e[ks]!==e[Mo][Mo][ks]&&(t[ee]=!0),null===s?t[gt]=[e]:s.push(e)}(a,e);const c=e[ge];null!==c&&c.insertView(t),e[Wr]|=128}(r,e,t,s),n){const i=Z0(s,t),a=e[Ur],c=hm(a,t[me]);null!==c&&function X0(t,e,s,n,r,i){n[Sa]=r,n[ln]=e,wg(t,n,s,1,r,i)}(r,t[ln],a,e,c,i)}}let Hc=(()=>{class e{}return e.__NG_ELEMENT_ID__=iW,e})();const sW=Hc,rW=class extends sW{constructor(e,s,n){super(),this._declarationLView=e,this._declarationTContainer=s,this.elementRef=n}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(e,s){return this.createEmbeddedViewImpl(e,s)}createEmbeddedViewImpl(e,s,n){const r=function tW(t,e,s,n){const r=e.tView,c=Iy(t,r,s,4096&t[Wr]?4096:16,null,e,null,null,null,n?.injector??null,n?.hydrationInfo??null);c[Zo]=t[e.index];const g=t[ge];return null!==g&&(c[ge]=g.createEmbeddedView(r)),ky(r,c,s),c}(this._declarationLView,this._declarationTContainer,e,{injector:s,hydrationInfo:n});return new ip(r)}};function iW(){return ID(Ui(),Fn())}function ID(t,e){return 4&t.type?new rW(e,t,Vu(t,e)):null}let jc=(()=>{class e{}return e.__NG_ELEMENT_ID__=dW,e})();function dW(){return $M(Ui(),Fn())}const hW=jc,FM=class extends hW{constructor(e,s,n){super(),this._lContainer=e,this._hostTNode=s,this._hostLView=n}get element(){return Vu(this._hostTNode,this._hostLView)}get injector(){return new mr(this._hostTNode,this._hostLView)}get parentInjector(){const e=se(this._hostTNode,this._hostLView);if(wu(e)){const s=Yd(e,this._hostLView),n=vh(e);return new mr(s[Ws].data[n+8],s)}return new mr(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){const s=LM(this._lContainer);return null!==s&&s[e]||null}get length(){return this._lContainer.length-zt}createEmbeddedView(e,s,n){let r,i;"number"==typeof n?r=n:null!=n&&(r=n.index,i=n.injector);const c=e.createEmbeddedViewImpl(s||{},i,null);return this.insertImpl(c,r,false),c}createComponent(e,s,n,r,i){const a=e&&!function jh(t){return"function"==typeof t}(e);let c;if(a)c=s;else{const Ge=s||{};c=Ge.index,n=Ge.injector,r=Ge.projectableNodes,i=Ge.environmentInjector||Ge.ngModuleRef}const f=a?e:new Ny(Vi(e)),g=n||this.parentInjector;if(!i&&null==f.ngModule){const tt=(a?g:this.parentInjector).get(Yu,null);tt&&(i=tt)}Vi(f.componentType??{});const ne=f.create(g,r,null,i);return this.insertImpl(ne.hostView,c,false),ne}insert(e,s){return this.insertImpl(e,s,!1)}insertImpl(e,s,n){const r=e._lView;if(function Uh(t){return Kn(t[Mo])}(r)){const f=this.indexOf(e);if(-1!==f)this.detach(f);else{const g=r[Mo],E=new FM(g,g[ln],g[Mo]);E.detach(E.indexOf(e))}}const a=this._adjustIndex(s),c=this._lContainer;return nW(c,r,a,!n),e.attachToViewContainerRef(),sm($k(c),a,e),e}move(e,s){return this.insert(e,s)}indexOf(e){const s=LM(this._lContainer);return null!==s?s.indexOf(e):-1}remove(e){const s=this._adjustIndex(e,-1),n=dm(this._lContainer,s);n&&(ig($k(this._lContainer),s),wf(n[Ws],n))}detach(e){const s=this._adjustIndex(e,-1),n=dm(this._lContainer,s);return n&&null!=ig($k(this._lContainer),s)?new ip(n):null}_adjustIndex(e,s=0){return e??this.length+s}};function LM(t){return t[8]}function $k(t){return t[8]||(t[8]=[])}function $M(t,e){let s;const n=e[t.index];return Kn(n)?s=n:(s=z1(n,e,null,t),e[t.index]=s,Fv(e,s)),BM(s,e,t,n),new FM(s,t,e)}let BM=function VM(t,e,s,n){if(t[me])return;let r;r=8&s.type?Vo(n):function pW(t,e){const s=t[Ur],n=s.createComment(""),r=Ic(e,t);return Pp(s,hm(s,r),n,function Y0(t,e){return t.nextSibling(e)}(s,r),!1),n}(e,s),t[me]=r};class Bk{constructor(e){this.queryList=e,this.matches=null}clone(){return new Bk(this.queryList)}setDirty(){this.queryList.setDirty()}}class Vk{constructor(e=[]){this.queries=e}createEmbeddedView(e){const s=e.queries;if(null!==s){const n=null!==e.contentQueries?e.contentQueries[0]:s.length,r=[];for(let i=0;i<n;i++){const a=s.getByIndex(i);r.push(this.queries[a.indexInDeclarationView].clone())}return new Vk(r)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let s=0;s<this.queries.length;s++)null!==jM(e,s).matches&&this.queries[s].setDirty()}}class UM{constructor(e,s,n=null){this.predicate=e,this.flags=s,this.read=n}}class Uk{constructor(e=[]){this.queries=e}elementStart(e,s){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,s)}elementEnd(e){for(let s=0;s<this.queries.length;s++)this.queries[s].elementEnd(e)}embeddedTView(e){let s=null;for(let n=0;n<this.length;n++){const r=null!==s?s.length:0,i=this.getByIndex(n).embeddedTView(e,r);i&&(i.indexInDeclarationView=n,null!==s?s.push(i):s=[i])}return null!==s?new Uk(s):null}template(e,s){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,s)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class zk{constructor(e,s=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=s}elementStart(e,s){this.isApplyingToNode(s)&&this.matchTNode(e,s)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,s){this.elementStart(e,s)}embeddedTView(e,s){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,s),new zk(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const s=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&8&n.type&&n.index!==s;)n=n.parent;return s===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,s){const n=this.metadata.predicate;if(Array.isArray(n))for(let r=0;r<n.length;r++){const i=n[r];this.matchTNodeWithReadOption(e,s,gW(s,i)),this.matchTNodeWithReadOption(e,s,vn(s,e,i,!1,!1))}else n===Hc?4&s.type&&this.matchTNodeWithReadOption(e,s,-1):this.matchTNodeWithReadOption(e,s,vn(s,e,n,!1,!1))}matchTNodeWithReadOption(e,s,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===yr||r===jc||r===Hc&&4&s.type)this.addMatch(s.index,-2);else{const i=vn(s,e,r,!1,!1);null!==i&&this.addMatch(s.index,i)}else this.addMatch(s.index,n)}}addMatch(e,s){null===this.matches?this.matches=[e,s]:this.matches.push(e,s)}}function gW(t,e){const s=t.localNames;if(null!==s)for(let n=0;n<s.length;n+=2)if(s[n]===e)return s[n+1];return null}function yW(t,e,s,n){return-1===s?function _W(t,e){return 11&t.type?Vu(t,e):4&t.type?ID(t,e):null}(e,t):-2===s?function vW(t,e,s){return s===yr?Vu(e,t):s===Hc?ID(e,t):s===jc?$M(e,t):void 0}(t,e,n):wn(t,t[Ws],s,e)}function zM(t,e,s,n){const r=e[ge].queries[n];if(null===r.matches){const i=t.data,a=s.matches,c=[];for(let f=0;f<a.length;f+=2){const g=a[f];c.push(g<0?null:yW(e,i[g],a[f+1],s.metadata.read))}r.matches=c}return r.matches}function Wk(t,e,s,n){const r=t.queries.getByIndex(s),i=r.matches;if(null!==i){const a=zM(t,e,r,s);for(let c=0;c<i.length;c+=2){const f=i[c];if(f>0)n.push(a[c/2]);else{const g=i[c+1],E=e[-f];for(let A=zt;A<E.length;A++){const Y=E[A];Y[Zo]===Y[Mo]&&Wk(Y[Ws],Y,g,n)}if(null!==E[gt]){const A=E[gt];for(let Y=0;Y<A.length;Y++){const ne=A[Y];Wk(ne[Ws],ne,g,n)}}}}}return n}function Ar(t){const e=Fn(),s=Fr(),n=Yf();cf(n+1);const r=jM(s,n);if(t.dirty&&function li(t){return 4==(4&t[Wr])}(e)===(2==(2&r.metadata.flags))){if(null===r.matches)t.reset([]);else{const i=r.crossesNgTemplate?Wk(s,e,n,[]):zM(s,e,r,n);t.reset(i,xm),t.notifyOnChanges()}return!0}return!1}function qo(t,e,s){const n=Fr();n.firstCreatePass&&(HM(n,new UM(t,e,s),-1),2==(2&e)&&(n.staticViewQueries=!0)),WM(n,Fn(),e)}function ea(t,e,s,n){const r=Fr();if(r.firstCreatePass){const i=Ui();HM(r,new UM(e,s,n),i.index),function xW(t,e){const s=t.contentQueries||(t.contentQueries=[]);e!==(s.length?s[s.length-1]:-1)&&s.push(t.queries.length-1,e)}(r,t),2==(2&s)&&(r.staticContentQueries=!0)}WM(r,Fn(),s)}function kr(){return function bW(t,e){return t[ge].queries[e].queryList}(Fn(),Yf())}function WM(t,e,s){const n=new Ky(4==(4&s));(function bT(t,e,s,n){const r=H1(e);r.push(s),t.firstCreatePass&&j1(t).push(n,r.length-1)})(t,e,n,n.destroy),null===e[ge]&&(e[ge]=new Vk),e[ge].queries.push(new Bk(n))}function HM(t,e,s){null===t.queries&&(t.queries=new Uk),t.queries.track(new zk(e,s))}function jM(t,e){return t.queries.getByIndex(e)}function Jv(t,e){return ID(t,e)}const Yk=new Zn("Application Initializer");let Zk=(()=>{var t;class e{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((n,r)=>{this.resolve=n,this.reject=r}),this.appInits=jn(Yk,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const n=[];for(const i of this.appInits){const a=i();if(By(a))n.push(a);else if(bE(a)){const c=new Promise((f,g)=>{a.subscribe({complete:f,error:g})});n.push(c)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(n).then(()=>{r()}).catch(i=>{this.reject(i)}),0===n.length&&r(),this.initialized=!0}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),lP=(()=>{var t;class e{log(n){console.log(n)}warn(n){console.warn(n)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"platform"}),e})();const Of=new Zn("LocaleId",{providedIn:"root",factory:()=>jn(Of,Jt.Optional|Jt.SkipSelf)||function zW(){return typeof $localize<"u"&&$localize.locale||n_}()});let kD=(()=>{var t;class e{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new Di(!1)}add(){this.hasPendingTasks.next(!0);const n=this.taskId++;return this.pendingTasks.add(n),n}remove(n){this.pendingTasks.delete(n),0===this.pendingTasks.size&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks.next(!1)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();class jW{constructor(e,s){this.ngModuleFactory=e,this.componentFactories=s}}let cP=(()=>{var t;class e{compileModuleSync(n){return new bw(n)}compileModuleAsync(n){return Promise.resolve(this.compileModuleSync(n))}compileModuleAndAllComponentsSync(n){const r=this.compileModuleSync(n),a=sp(_c(n).declarations).reduce((c,f)=>{const g=Vi(f);return g&&c.push(new Ny(g)),c},[]);return new jW(r,a)}compileModuleAndAllComponentsAsync(n){return Promise.resolve(this.compileModuleAndAllComponentsSync(n))}clearCache(){}clearCacheFor(n){}getModuleId(n){}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const pP=new Zn(""),RD=new Zn("");let t2,qk=(()=>{var t;class e{constructor(n,r,i){this._ngZone=n,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,t2||(function d5(t){t2=t}(i),i.addToWindow(r)),this._watchAngularEvents(),n.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Gs.assertNotInAngularZone(),queueMicrotask(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())queueMicrotask(()=>{for(;0!==this._callbacks.length;){let n=this._callbacks.pop();clearTimeout(n.timeoutId),n.doneCb(this._didWork)}this._didWork=!1});else{let n=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(n)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(n=>({source:n.source,creationLocation:n.creationLocation,data:n.data})):[]}addCallback(n,r,i){let a=-1;r&&r>0&&(a=setTimeout(()=>{this._callbacks=this._callbacks.filter(c=>c.timeoutId!==a),n(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:n,timeoutId:a,updateCb:i})}whenStable(n,r,i){if(i&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(n,r,i),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(n){this.registry.registerApplication(n,this)}unregisterApplication(n){this.registry.unregisterApplication(n)}findProviders(n,r,i){return[]}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Gs),cn(e2),cn(RD))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})(),e2=(()=>{var t;class e{constructor(){this._applications=new Map}registerApplication(n,r){this._applications.set(n,r)}unregisterApplication(n){this._applications.delete(n)}unregisterAllApplications(){this._applications.clear()}getTestability(n){return this._applications.get(n)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(n,r=!0){return t2?.findTestabilityInTree(this,n,r)??null}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"platform"}),e})(),r_=null;const fP=new Zn("AllowMultipleToken"),n2=new Zn("PlatformDestroyListeners"),s2=new Zn("appBootstrapListener");class gP{constructor(e,s){this.name=e,this.token=s}}function yP(t,e,s=[]){const n=`Platform: ${e}`,r=new Zn(n);return(i=[])=>{let a=r2();if(!a||a.injector.get(fP,!1)){const c=[...s,...i,{provide:r,useValue:!0}];t?t(c):function f5(t){if(r_&&!r_.get(fP,!1))throw new En(400,!1);(function mP(){!function ad(t){Pc=t}(()=>{throw new En(600,!1)})})(),r_=t;const e=t.get(bP);(function _P(t){t.get(Dv,null)?.forEach(s=>s())})(t)}(function vP(t=[],e){return Wc.create({name:e,providers:[{provide:vm,useValue:"platform"},{provide:n2,useValue:new Set([()=>r_=null])},...t]})}(c,n))}return function g5(t){const e=r2();if(!e)throw new En(401,!1);return e}()}}function r2(){return r_?.get(bP)??null}let bP=(()=>{var t;class e{constructor(n){this._injector=n,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(n,r){const i=function _5(t="zone.js",e){return"noop"===t?new w1:"zone.js"===t?new Gs(e):t}(r?.ngZone,function xP(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:t?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:t?.runCoalescing??!1}}({eventCoalescing:r?.ngZoneEventCoalescing,runCoalescing:r?.ngZoneRunCoalescing}));return i.run(()=>{const a=function Qv(t,e,s){return new Gy(t,e,s)}(n.moduleType,this.injector,function SP(t){return[{provide:Gs,useFactory:t},{provide:ym,multi:!0,useFactory:()=>{const e=jn(v5,{optional:!0});return()=>e.initialize()}},{provide:DP,useFactory:y5},{provide:Dy,useFactory:kv}]}(()=>i)),c=a.injector.get(nh,null);return i.runOutsideAngular(()=>{const f=i.onError.subscribe({next:g=>{c.handleError(g)}});a.onDestroy(()=>{ND(this._modules,a),f.unsubscribe()})}),function wP(t,e,s){try{const n=s();return By(n)?n.catch(r=>{throw e.runOutsideAngular(()=>t.handleError(r)),r}):n}catch(n){throw e.runOutsideAngular(()=>t.handleError(n)),n}}(c,i,()=>{const f=a.injector.get(Zk);return f.runInitializers(),f.donePromise.then(()=>(function fD(t){Ae(t,"Expected localeId to be defined"),"string"==typeof t&&(pD=t.toLowerCase().replace(/_/g,"-"))}(a.injector.get(Of,n_)||n_),this._moduleDoBootstrap(a),a))})})}bootstrapModule(n,r=[]){const i=CP({},r);return function h5(t,e,s){const n=new bw(s);return Promise.resolve(n)}(0,0,n).then(a=>this.bootstrapModuleFactory(a,i))}_moduleDoBootstrap(n){const r=n.injector.get(i_);if(n._bootstrapComponents.length>0)n._bootstrapComponents.forEach(i=>r.bootstrap(i));else{if(!n.instance.ngDoBootstrap)throw new En(-403,!1);n.instance.ngDoBootstrap(r)}this._modules.push(n)}onDestroy(n){this._destroyListeners.push(n)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new En(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const n=this._injector.get(n2,null);n&&(n.forEach(r=>r()),n.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Wc))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"platform"}),e})();function CP(t,e){return Array.isArray(e)?e.reduce(CP,t):{...t,...e}}let i_=(()=>{var t;class e{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=jn(DP),this.zoneIsStable=jn(Dy),this.componentTypes=[],this.components=[],this.isStable=jn(kD).hasPendingTasks.pipe(Qi(n=>n?Xs(!1):this.zoneIsStable),al(),ro()),this._injector=jn(Yu)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(n,r){const i=n instanceof cd;if(!this._injector.get(Zk).done)throw!i&&function bu(t){const e=Vi(t)||xl(t)||Kl(t);return null!==e&&e.standalone}(n),new En(405,!1);let c;c=i?n:this._injector.get(lc).resolveComponentFactory(n),this.componentTypes.push(c.componentType);const f=function p5(t){return t.isBoundToModule}(c)?void 0:this._injector.get(md),E=c.create(Wc.NULL,[],r||c.selector,f),A=E.location.nativeElement,Y=E.injector.get(pP,null);return Y?.registerApplication(A),E.onDestroy(()=>{this.detachView(E.hostView),ND(this.components,E),Y?.unregisterApplication(A)}),this._loadComponent(E),E}tick(){if(this._runningTick)throw new En(101,!1);try{this._runningTick=!0;for(let n of this._views)n.detectChanges()}catch(n){this.internalErrorHandler(n)}finally{this._runningTick=!1}}attachView(n){const r=n;this._views.push(r),r.attachToAppRef(this)}detachView(n){const r=n;ND(this._views,r),r.detachFromAppRef()}_loadComponent(n){this.attachView(n.hostView),this.tick(),this.components.push(n);const r=this._injector.get(s2,[]);r.push(...this._bootstrapListeners),r.forEach(i=>i(n))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(n=>n()),this._views.slice().forEach(n=>n.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(n){return this._destroyListeners.push(n),()=>ND(this._destroyListeners,n)}destroy(){if(this._destroyed)throw new En(406,!1);const n=this._injector;n.destroy&&!n.destroyed&&n.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function ND(t,e){const s=t.indexOf(e);s>-1&&t.splice(s,1)}const DP=new Zn("",{providedIn:"root",factory:()=>jn(nh).handleError.bind(void 0)});function y5(){const t=jn(Gs),e=jn(nh);return s=>t.runOutsideAngular(()=>e.handleError(s))}let v5=(()=>{var t;class e{constructor(){this.zone=jn(Gs),this.applicationRef=jn(i_)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();let Ll=(()=>{class e{}return e.__NG_ELEMENT_ID__=x5,e})();function x5(t){return function w5(t,e,s){if(An(t)&&!s){const n=Tc(t.index,e);return new ip(n,n)}return 47&t.type?new ip(e[ks],e):null}(Ui(),Fn(),16==(16&t))}class kP{constructor(){}supports(e){return Vv(e)}create(e){return new T5(e)}}const I5=(t,e)=>e;class T5{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||I5}forEachItem(e){let s;for(s=this._itHead;null!==s;s=s._next)e(s)}forEachOperation(e){let s=this._itHead,n=this._removalsHead,r=0,i=null;for(;s||n;){const a=!n||s&&s.currentIndex<RP(n,r,i)?s:n,c=RP(a,r,i),f=a.currentIndex;if(a===n)r--,n=n._nextRemoved;else if(s=s._next,null==a.previousIndex)r++;else{i||(i=[]);const g=c-r,E=f-r;if(g!=E){for(let Y=0;Y<g;Y++){const ne=Y<i.length?i[Y]:i[Y]=0,Ee=ne+Y;E<=Ee&&Ee<g&&(i[Y]=ne+1)}i[a.previousIndex]=E-g}}c!==f&&e(a,c,f)}}forEachPreviousItem(e){let s;for(s=this._previousItHead;null!==s;s=s._nextPrevious)e(s)}forEachAddedItem(e){let s;for(s=this._additionsHead;null!==s;s=s._nextAdded)e(s)}forEachMovedItem(e){let s;for(s=this._movesHead;null!==s;s=s._nextMoved)e(s)}forEachRemovedItem(e){let s;for(s=this._removalsHead;null!==s;s=s._nextRemoved)e(s)}forEachIdentityChange(e){let s;for(s=this._identityChangesHead;null!==s;s=s._nextIdentityChange)e(s)}diff(e){if(null==e&&(e=[]),!Vv(e))throw new En(900,!1);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let r,i,a,s=this._itHead,n=!1;if(Array.isArray(e)){this.length=e.length;for(let c=0;c<this.length;c++)i=e[c],a=this._trackByFn(c,i),null!==s&&Object.is(s.trackById,a)?(n&&(s=this._verifyReinsertion(s,i,a,c)),Object.is(s.item,i)||this._addIdentityChange(s,i)):(s=this._mismatch(s,i,a,c),n=!0),s=s._next}else r=0,function cA(t,e){if(Array.isArray(t))for(let s=0;s<t.length;s++)e(t[s]);else{const s=t[Symbol.iterator]();let n;for(;!(n=s.next()).done;)e(n.value)}}(e,c=>{a=this._trackByFn(r,c),null!==s&&Object.is(s.trackById,a)?(n&&(s=this._verifyReinsertion(s,c,a,r)),Object.is(s.item,c)||this._addIdentityChange(s,c)):(s=this._mismatch(s,c,a,r),n=!0),s=s._next,r++}),this.length=r;return this._truncate(s),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,s,n,r){let i;return null===e?i=this._itTail:(i=e._prev,this._remove(e)),null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(e.item,s)||this._addIdentityChange(e,s),this._reinsertAfter(e,i,r)):null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(e.item,s)||this._addIdentityChange(e,s),this._moveAfter(e,i,r)):e=this._addAfter(new A5(s,n),i,r),e}_verifyReinsertion(e,s,n,r){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==i?e=this._reinsertAfter(i,e._prev,r):e.currentIndex!=r&&(e.currentIndex=r,this._addToMoves(e,r)),e}_truncate(e){for(;null!==e;){const s=e._next;this._addToRemovals(this._unlink(e)),e=s}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,s,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const r=e._prevRemoved,i=e._nextRemoved;return null===r?this._removalsHead=i:r._nextRemoved=i,null===i?this._removalsTail=r:i._prevRemoved=r,this._insertAfter(e,s,n),this._addToMoves(e,n),e}_moveAfter(e,s,n){return this._unlink(e),this._insertAfter(e,s,n),this._addToMoves(e,n),e}_addAfter(e,s,n){return this._insertAfter(e,s,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,s,n){const r=null===s?this._itHead:s._next;return e._next=r,e._prev=s,null===r?this._itTail=e:r._prev=e,null===s?this._itHead=e:s._next=e,null===this._linkedRecords&&(this._linkedRecords=new OP),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const s=e._prev,n=e._next;return null===s?this._itHead=n:s._next=n,null===n?this._itTail=s:n._prev=s,e}_addToMoves(e,s){return e.previousIndex===s||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new OP),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,s){return e.item=s,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class A5{constructor(e,s){this.item=e,this.trackById=s,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class k5{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,s){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===s||s<=n.currentIndex)&&Object.is(n.trackById,e))return n;return null}remove(e){const s=e._prevDup,n=e._nextDup;return null===s?this._head=n:s._nextDup=n,null===n?this._tail=s:n._prevDup=s,null===this._head}}class OP{constructor(){this.map=new Map}put(e){const s=e.trackById;let n=this.map.get(s);n||(n=new k5,this.map.set(s,n)),n.add(e)}get(e,s){const r=this.map.get(e);return r?r.get(e,s):null}remove(e){const s=e.trackById;return this.map.get(s).remove(e)&&this.map.delete(s),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function RP(t,e,s){const n=t.previousIndex;if(null===n)return n;let r=0;return s&&n<s.length&&(r=s[n]),n+e+r}class NP{constructor(){}supports(e){return e instanceof Map||tw(e)}create(){return new O5}}class O5{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let s;for(s=this._mapHead;null!==s;s=s._next)e(s)}forEachPreviousItem(e){let s;for(s=this._previousMapHead;null!==s;s=s._nextPrevious)e(s)}forEachChangedItem(e){let s;for(s=this._changesHead;null!==s;s=s._nextChanged)e(s)}forEachAddedItem(e){let s;for(s=this._additionsHead;null!==s;s=s._nextAdded)e(s)}forEachRemovedItem(e){let s;for(s=this._removalsHead;null!==s;s=s._nextRemoved)e(s)}diff(e){if(e){if(!(e instanceof Map||tw(e)))throw new En(900,!1)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let s=this._mapHead;if(this._appendAfter=null,this._forEach(e,(n,r)=>{if(s&&s.key===r)this._maybeAddToChanges(s,n),this._appendAfter=s,s=s._next;else{const i=this._getOrCreateRecordForKey(r,n);s=this._insertBeforeOrAppend(s,i)}}),s){s._prev&&(s._prev._next=null),this._removalsHead=s;for(let n=s;null!==n;n=n._nextRemoved)n===this._mapHead&&(this._mapHead=null),this._records.delete(n.key),n._nextRemoved=n._next,n.previousValue=n.currentValue,n.currentValue=null,n._prev=null,n._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,s){if(e){const n=e._prev;return s._next=e,s._prev=n,e._prev=s,n&&(n._next=s),e===this._mapHead&&(this._mapHead=s),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=s,s._prev=this._appendAfter):this._mapHead=s,this._appendAfter=s,null}_getOrCreateRecordForKey(e,s){if(this._records.has(e)){const r=this._records.get(e);this._maybeAddToChanges(r,s);const i=r._prev,a=r._next;return i&&(i._next=a),a&&(a._prev=i),r._next=null,r._prev=null,r}const n=new R5(e);return this._records.set(e,n),n.currentValue=s,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,s){Object.is(s,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=s,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,s){e instanceof Map?e.forEach(s):Object.keys(e).forEach(n=>s(e[n],n))}}class R5{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function MP(){return new Om([new kP])}let Om=(()=>{var t;class e{constructor(n){this.factories=n}static create(n,r){if(null!=r){const i=r.factories.slice();n=n.concat(i)}return new e(n)}static extend(n){return{provide:e,useFactory:r=>e.create(n,r||MP()),deps:[[e,new Gh,new wh]]}}find(n){const r=this.factories.find(i=>i.supports(n));if(null!=r)return r;throw new En(901,!1)}}return(t=e).\u0275prov=wt({token:t,providedIn:"root",factory:MP}),e})();function PP(){return new Tw([new NP])}let Tw=(()=>{var t;class e{constructor(n){this.factories=n}static create(n,r){if(r){const i=r.factories.slice();n=n.concat(i)}return new e(n)}static extend(n){return{provide:e,useFactory:r=>e.create(n,r||PP()),deps:[[e,new Gh,new wh]]}}find(n){const r=this.factories.find(i=>i.supports(n));if(r)return r;throw new En(901,!1)}}return(t=e).\u0275prov=wt({token:t,providedIn:"root",factory:PP}),e})();const P5=yP(null,"core",[]);let F5=(()=>{var t;class e{constructor(n){}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(i_))},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();function tb(t){return"boolean"==typeof t?t:null!=t&&"false"!==t}let d2=null;function o_(){return d2}class Z5{}const yi=new Zn("DocumentToken");let h2=(()=>{var t;class e{historyGo(n){throw new Error("Not implemented")}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(){return jn(J5)},providedIn:"platform"}),e})();const Q5=new Zn("Location Initialized");let J5=(()=>{var t;class e extends h2{constructor(){super(),this._doc=jn(yi),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return o_().getBaseHref(this._doc)}onPopState(n){const r=o_().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",n,!1),()=>r.removeEventListener("popstate",n)}onHashChange(n){const r=o_().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",n,!1),()=>r.removeEventListener("hashchange",n)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(n){this._location.pathname=n}pushState(n,r,i){this._history.pushState(n,r,i)}replaceState(n,r,i){this._history.replaceState(n,r,i)}forward(){this._history.forward()}back(){this._history.back()}historyGo(n=0){this._history.go(n)}getState(){return this._history.state}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(){return new t},providedIn:"platform"}),e})();function p2(t,e){if(0==t.length)return e;if(0==e.length)return t;let s=0;return t.endsWith("/")&&s++,e.startsWith("/")&&s++,2==s?t+e.substring(1):1==s?t+e:t+"/"+e}function HP(t){const e=t.match(/#|\?|$/),s=e&&e.index||t.length;return t.slice(0,s-("/"===t[s-1]?1:0))+t.slice(s)}function Rm(t){return t&&"?"!==t[0]?"?"+t:t}let Yy=(()=>{var t;class e{historyGo(n){throw new Error("Not implemented")}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(){return jn(GP)},providedIn:"root"}),e})();const jP=new Zn("appBaseHref");let GP=(()=>{var t;class e extends Yy{constructor(n,r){super(),this._platformLocation=n,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??jn(yi).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(n){this._removeListenerFns.push(this._platformLocation.onPopState(n),this._platformLocation.onHashChange(n))}getBaseHref(){return this._baseHref}prepareExternalUrl(n){return p2(this._baseHref,n)}path(n=!1){const r=this._platformLocation.pathname+Rm(this._platformLocation.search),i=this._platformLocation.hash;return i&&n?`${r}${i}`:r}pushState(n,r,i,a){const c=this.prepareExternalUrl(i+Rm(a));this._platformLocation.pushState(n,r,c)}replaceState(n,r,i,a){const c=this.prepareExternalUrl(i+Rm(a));this._platformLocation.replaceState(n,r,c)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(n=0){this._platformLocation.historyGo?.(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(h2),cn(jP,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),q5=(()=>{var t;class e extends Yy{constructor(n,r){super(),this._platformLocation=n,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(n){this._removeListenerFns.push(this._platformLocation.onPopState(n),this._platformLocation.onHashChange(n))}getBaseHref(){return this._baseHref}path(n=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(n){const r=p2(this._baseHref,n);return r.length>0?"#"+r:r}pushState(n,r,i,a){let c=this.prepareExternalUrl(i+Rm(a));0==c.length&&(c=this._platformLocation.pathname),this._platformLocation.pushState(n,r,c)}replaceState(n,r,i,a){let c=this.prepareExternalUrl(i+Rm(a));0==c.length&&(c=this._platformLocation.pathname),this._platformLocation.replaceState(n,r,c)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(n=0){this._platformLocation.historyGo?.(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(h2),cn(jP,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})(),Aw=(()=>{var t;class e{constructor(n){this._subject=new Rr,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=n;const r=this._locationStrategy.getBaseHref();this._basePath=function nH(t){if(new RegExp("^(https?:)?//").test(t)){const[,s]=t.split(/\/\/[^\/]+/);return s}return t}(HP(KP(r))),this._locationStrategy.onPopState(i=>{this._subject.emit({url:this.path(!0),pop:!0,state:i.state,type:i.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(n=!1){return this.normalize(this._locationStrategy.path(n))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(n,r=""){return this.path()==this.normalize(n+Rm(r))}normalize(n){return e.stripTrailingSlash(function tH(t,e){if(!t||!e.startsWith(t))return e;const s=e.substring(t.length);return""===s||["/",";","?","#"].includes(s[0])?s:e}(this._basePath,KP(n)))}prepareExternalUrl(n){return n&&"/"!==n[0]&&(n="/"+n),this._locationStrategy.prepareExternalUrl(n)}go(n,r="",i=null){this._locationStrategy.pushState(i,"",n,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(n+Rm(r)),i)}replaceState(n,r="",i=null){this._locationStrategy.replaceState(i,"",n,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(n+Rm(r)),i)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(n=0){this._locationStrategy.historyGo?.(n)}onUrlChange(n){return this._urlChangeListeners.push(n),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(n);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(n="",r){this._urlChangeListeners.forEach(i=>i(n,r))}subscribe(n,r,i){return this._subject.subscribe({next:n,error:r,complete:i})}}return(t=e).normalizeQueryParams=Rm,t.joinWithSlash=p2,t.stripTrailingSlash=HP,t.\u0275fac=function(n){return new(n||t)(cn(Yy))},t.\u0275prov=wt({token:t,factory:function(){return function eH(){return new Aw(cn(Yy))}()},providedIn:"root"}),e})();function KP(t){return t.replace(/\/index.html$/,"")}function nF(t,e){e=encodeURIComponent(e);for(const s of t.split(";")){const n=s.indexOf("="),[r,i]=-1==n?[s,""]:[s.slice(0,n),s.slice(n+1)];if(r.trim()===e)return decodeURIComponent(i)}return null}const C2=/\s+/,sF=[];let E2=(()=>{var t;class e{constructor(n,r,i,a){this._iterableDiffers=n,this._keyValueDiffers=r,this._ngEl=i,this._renderer=a,this.initialClasses=sF,this.stateMap=new Map}set klass(n){this.initialClasses=null!=n?n.trim().split(C2):sF}set ngClass(n){this.rawClass="string"==typeof n?n.trim().split(C2):n}ngDoCheck(){for(const r of this.initialClasses)this._updateState(r,!0);const n=this.rawClass;if(Array.isArray(n)||n instanceof Set)for(const r of n)this._updateState(r,!0);else if(null!=n)for(const r of Object.keys(n))this._updateState(r,!!n[r]);this._applyStateDiff()}_updateState(n,r){const i=this.stateMap.get(n);void 0!==i?(i.enabled!==r&&(i.changed=!0,i.enabled=r),i.touched=!0):this.stateMap.set(n,{enabled:r,changed:!0,touched:!0})}_applyStateDiff(){for(const n of this.stateMap){const r=n[0],i=n[1];i.changed?(this._toggleClass(r,i.enabled),i.changed=!1):i.touched||(i.enabled&&this._toggleClass(r,!1),this.stateMap.delete(r)),i.touched=!1}}_toggleClass(n,r){(n=n.trim()).length>0&&n.split(C2).forEach(i=>{r?this._renderer.addClass(this._ngEl.nativeElement,i):this._renderer.removeClass(this._ngEl.nativeElement,i)})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Om),lt(Tw),lt(yr),lt(th))},t.\u0275dir=Gn({type:t,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),e})();class UH{constructor(e,s,n,r){this.$implicit=e,this.ngForOf=s,this.index=n,this.count=r}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Rw=(()=>{var t;class e{set ngForOf(n){this._ngForOf=n,this._ngForOfDirty=!0}set ngForTrackBy(n){this._trackByFn=n}get ngForTrackBy(){return this._trackByFn}constructor(n,r,i){this._viewContainer=n,this._template=r,this._differs=i,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(n){n&&(this._template=n)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;!this._differ&&n&&(this._differ=this._differs.find(n).create(this.ngForTrackBy))}if(this._differ){const n=this._differ.diff(this._ngForOf);n&&this._applyChanges(n)}}_applyChanges(n){const r=this._viewContainer;n.forEachOperation((i,a,c)=>{if(null==i.previousIndex)r.createEmbeddedView(this._template,new UH(i.item,this._ngForOf,-1,-1),null===c?void 0:c);else if(null==c)r.remove(null===a?void 0:a);else if(null!==a){const f=r.get(a);r.move(f,c),iF(f,i)}});for(let i=0,a=r.length;i<a;i++){const f=r.get(i).context;f.index=i,f.count=a,f.ngForOf=this._ngForOf}n.forEachIdentityChange(i=>{iF(r.get(i.currentIndex),i)})}static ngTemplateContextGuard(n,r){return!0}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(Hc),lt(Om))},t.\u0275dir=Gn({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),e})();function iF(t,e){t.context.$implicit=e.item}let $d=(()=>{var t;class e{constructor(n,r){this._viewContainer=n,this._context=new zH,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(n){this._context.$implicit=this._context.ngIf=n,this._updateView()}set ngIfThen(n){oF("ngIfThen",n),this._thenTemplateRef=n,this._thenViewRef=null,this._updateView()}set ngIfElse(n){oF("ngIfElse",n),this._elseTemplateRef=n,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(n,r){return!0}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(Hc))},t.\u0275dir=Gn({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),e})();class zH{constructor(){this.$implicit=null,this.ngIf=null}}function oF(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${mo(e)}'.`)}class D2{constructor(e,s){this._viewContainerRef=e,this._templateRef=s,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(e){e&&!this._created?this.create():!e&&this._created&&this.destroy()}}let sb=(()=>{var t;class e{constructor(){this._defaultViews=[],this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(n){this._ngSwitch=n,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(n){this._defaultViews.push(n)}_matchCase(n){const r=n==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||r,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),r}_updateDefaultCases(n){if(this._defaultViews.length>0&&n!==this._defaultUsed){this._defaultUsed=n;for(const r of this._defaultViews)r.enforceState(n)}}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"},standalone:!0}),e})(),KD=(()=>{var t;class e{constructor(n,r,i){this.ngSwitch=i,i._addCase(),this._view=new D2(n,r)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(Hc),lt(sb,9))},t.\u0275dir=Gn({type:t,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"},standalone:!0}),e})(),aF=(()=>{var t;class e{constructor(n,r,i){i._addDefault(new D2(n,r))}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(Hc),lt(sb,9))},t.\u0275dir=Gn({type:t,selectors:[["","ngSwitchDefault",""]],standalone:!0}),e})(),S2=(()=>{var t;class e{constructor(n){this._viewContainerRef=n,this._viewRef=null,this.ngTemplateOutletContext=null,this.ngTemplateOutlet=null,this.ngTemplateOutletInjector=null}ngOnChanges(n){if(n.ngTemplateOutlet||n.ngTemplateOutletInjector){const r=this._viewContainerRef;if(this._viewRef&&r.remove(r.indexOf(this._viewRef)),this.ngTemplateOutlet){const{ngTemplateOutlet:i,ngTemplateOutletContext:a,ngTemplateOutletInjector:c}=this;this._viewRef=r.createEmbeddedView(i,a,c?{injector:c}:void 0)}else this._viewRef=null}else this._viewRef&&n.ngTemplateOutletContext&&this.ngTemplateOutletContext&&(this._viewRef.context=this.ngTemplateOutletContext)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc))},t.\u0275dir=Gn({type:t,selectors:[["","ngTemplateOutlet",""]],inputs:{ngTemplateOutletContext:"ngTemplateOutletContext",ngTemplateOutlet:"ngTemplateOutlet",ngTemplateOutletInjector:"ngTemplateOutletInjector"},standalone:!0,features:[Ia]}),e})(),Ah=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();const uF="browser";function dF(t){return"server"===t}let _j=(()=>{var t;class e{}return(t=e).\u0275prov=wt({token:t,providedIn:"root",factory:()=>new yj(cn(yi),window)}),e})();class yj{constructor(e,s){this.document=e,this.window=s,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(!this.supportsScrolling())return;const s=function vj(t,e){const s=t.getElementById(e)||t.getElementsByName(e)[0];if(s)return s;if("function"==typeof t.createTreeWalker&&t.body&&"function"==typeof t.body.attachShadow){const n=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let r=n.currentNode;for(;r;){const i=r.shadowRoot;if(i){const a=i.getElementById(e)||i.querySelector(`[name="${e}"]`);if(a)return a}r=n.nextNode()}}return null}(this.document,e);s&&(this.scrollToElement(s),s.focus())}setHistoryScrollRestoration(e){this.supportsScrolling()&&(this.window.history.scrollRestoration=e)}scrollToElement(e){const s=e.getBoundingClientRect(),n=s.left+this.window.pageXOffset,r=s.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(n-i[0],r-i[1])}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}class hF{}class zj extends Z5{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class O2 extends zj{static makeCurrent(){!function Y5(t){d2||(d2=t)}(new O2)}onAndCancel(e,s,n){return e.addEventListener(s,n),()=>{e.removeEventListener(s,n)}}dispatchEvent(e,s){e.dispatchEvent(s)}remove(e){e.parentNode&&e.parentNode.removeChild(e)}createElement(e,s){return(s=s||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,s){return"window"===s?window:"document"===s?e:"body"===s?e.body:null}getBaseHref(e){const s=function Wj(){return Mw=Mw||document.querySelector("base"),Mw?Mw.getAttribute("href"):null}();return null==s?null:function Hj(t){ZD=ZD||document.createElement("a"),ZD.setAttribute("href",t);const e=ZD.pathname;return"/"===e.charAt(0)?e:`/${e}`}(s)}resetBaseElement(){Mw=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return nF(document.cookie,e)}}let ZD,Mw=null,Gj=(()=>{var t;class e{build(){return new XMLHttpRequest}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();const R2=new Zn("EventManagerPlugins");let _F=(()=>{var t;class e{constructor(n,r){this._zone=r,this._eventNameToPlugin=new Map,n.forEach(i=>{i.manager=this}),this._plugins=n.slice().reverse()}addEventListener(n,r,i){return this._findPluginFor(r).addEventListener(n,r,i)}getZone(){return this._zone}_findPluginFor(n){let r=this._eventNameToPlugin.get(n);if(r)return r;if(r=this._plugins.find(a=>a.supports(n)),!r)throw new En(5101,!1);return this._eventNameToPlugin.set(n,r),r}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(R2),cn(Gs))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();class yF{constructor(e){this._doc=e}}const N2="ng-app-id";let vF=(()=>{var t;class e{constructor(n,r,i,a={}){this.doc=n,this.appId=r,this.nonce=i,this.platformId=a,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=dF(a),this.resetHostNodes()}addStyles(n){for(const r of n)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(n){for(const r of n)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){const n=this.styleNodesInDOM;n&&(n.forEach(r=>r.remove()),n.clear());for(const r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(n){this.hostNodes.add(n);for(const r of this.getAllStyles())this.addStyleToHost(n,r)}removeHost(n){this.hostNodes.delete(n)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(n){for(const r of this.hostNodes)this.addStyleToHost(r,n)}onStyleRemoved(n){const r=this.styleRef;r.get(n)?.elements?.forEach(i=>i.remove()),r.delete(n)}collectServerRenderedStyles(){const n=this.doc.head?.querySelectorAll(`style[${N2}="${this.appId}"]`);if(n?.length){const r=new Map;return n.forEach(i=>{null!=i.textContent&&r.set(i.textContent,i)}),r}return null}changeUsageCount(n,r){const i=this.styleRef;if(i.has(n)){const a=i.get(n);return a.usage+=r,a.usage}return i.set(n,{usage:r,elements:[]}),r}getStyleElement(n,r){const i=this.styleNodesInDOM,a=i?.get(r);if(a?.parentNode===n)return i.delete(r),a.removeAttribute(N2),a;{const c=this.doc.createElement("style");return this.nonce&&c.setAttribute("nonce",this.nonce),c.textContent=r,this.platformIsServer&&c.setAttribute(N2,this.appId),c}}addStyleToHost(n,r){const i=this.getStyleElement(n,r);n.appendChild(i);const a=this.styleRef,c=a.get(r)?.elements;c?c.push(i):a.set(r,{elements:[i],usage:1})}resetHostNodes(){const n=this.hostNodes;n.clear(),n.add(this.doc.head)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(Sf),cn(by,8),cn(qh))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();const M2={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},P2=/%COMP%/g,Zj=new Zn("RemoveStylesOnCompDestroy",{providedIn:"root",factory:()=>!1});function xF(t,e){return e.map(s=>s.replace(P2,t))}let F2=(()=>{var t;class e{constructor(n,r,i,a,c,f,g,E=null){this.eventManager=n,this.sharedStylesHost=r,this.appId=i,this.removeStylesOnCompDestroy=a,this.doc=c,this.platformId=f,this.ngZone=g,this.nonce=E,this.rendererByCompId=new Map,this.platformIsServer=dF(f),this.defaultRenderer=new L2(n,c,g,this.platformIsServer)}createRenderer(n,r){if(!n||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===oo.ShadowDom&&(r={...r,encapsulation:oo.Emulated});const i=this.getOrCreateRenderer(n,r);return i instanceof CF?i.applyToHost(n):i instanceof $2&&i.applyStyles(),i}getOrCreateRenderer(n,r){const i=this.rendererByCompId;let a=i.get(r.id);if(!a){const c=this.doc,f=this.ngZone,g=this.eventManager,E=this.sharedStylesHost,A=this.removeStylesOnCompDestroy,Y=this.platformIsServer;switch(r.encapsulation){case oo.Emulated:a=new CF(g,E,r,this.appId,A,c,f,Y);break;case oo.ShadowDom:return new eG(g,E,n,r,c,f,this.nonce,Y);default:a=new $2(g,E,r,A,c,f,Y)}i.set(r.id,a)}return a}ngOnDestroy(){this.rendererByCompId.clear()}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(_F),cn(vF),cn(Sf),cn(Zj),cn(yi),cn(qh),cn(Gs),cn(by))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();class L2{constructor(e,s,n,r){this.eventManager=e,this.doc=s,this.ngZone=n,this.platformIsServer=r,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(e,s){return s?this.doc.createElementNS(M2[s]||s,e):this.doc.createElement(e)}createComment(e){return this.doc.createComment(e)}createText(e){return this.doc.createTextNode(e)}appendChild(e,s){(wF(e)?e.content:e).appendChild(s)}insertBefore(e,s,n){e&&(wF(e)?e.content:e).insertBefore(s,n)}removeChild(e,s){e&&e.removeChild(s)}selectRootElement(e,s){let n="string"==typeof e?this.doc.querySelector(e):e;if(!n)throw new En(-5104,!1);return s||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,s,n,r){if(r){s=r+":"+s;const i=M2[r];i?e.setAttributeNS(i,s,n):e.setAttribute(s,n)}else e.setAttribute(s,n)}removeAttribute(e,s,n){if(n){const r=M2[n];r?e.removeAttributeNS(r,s):e.removeAttribute(`${n}:${s}`)}else e.removeAttribute(s)}addClass(e,s){e.classList.add(s)}removeClass(e,s){e.classList.remove(s)}setStyle(e,s,n,r){r&(Eu.DashCase|Eu.Important)?e.style.setProperty(s,n,r&Eu.Important?"important":""):e.style[s]=n}removeStyle(e,s,n){n&Eu.DashCase?e.style.removeProperty(s):e.style[s]=""}setProperty(e,s,n){e[s]=n}setValue(e,s){e.nodeValue=s}listen(e,s,n){if("string"==typeof e&&!(e=o_().getGlobalEventTarget(this.doc,e)))throw new Error(`Unsupported event target ${e} for event ${s}`);return this.eventManager.addEventListener(e,s,this.decoratePreventDefault(n))}decoratePreventDefault(e){return s=>{if("__ngUnwrap__"===s)return e;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>e(s)):e(s))&&s.preventDefault()}}}function wF(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class eG extends L2{constructor(e,s,n,r,i,a,c,f){super(e,i,a,f),this.sharedStylesHost=s,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const g=xF(r.id,r.styles);for(const E of g){const A=document.createElement("style");c&&A.setAttribute("nonce",c),A.textContent=E,this.shadowRoot.appendChild(A)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}appendChild(e,s){return super.appendChild(this.nodeOrShadowRoot(e),s)}insertBefore(e,s,n){return super.insertBefore(this.nodeOrShadowRoot(e),s,n)}removeChild(e,s){return super.removeChild(this.nodeOrShadowRoot(e),s)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class $2 extends L2{constructor(e,s,n,r,i,a,c,f){super(e,i,a,c),this.sharedStylesHost=s,this.removeStylesOnCompDestroy=r,this.styles=f?xF(f,n.styles):n.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles)}}class CF extends $2{constructor(e,s,n,r,i,a,c,f){const g=r+"-"+n.id;super(e,s,n,i,a,c,f,g),this.contentAttr=function Qj(t){return"_ngcontent-%COMP%".replace(P2,t)}(g),this.hostAttr=function Jj(t){return"_nghost-%COMP%".replace(P2,t)}(g)}applyToHost(e){this.applyStyles(),this.setAttribute(e,this.hostAttr,"")}createElement(e,s){const n=super.createElement(e,s);return super.setAttribute(n,this.contentAttr,""),n}}let tG=(()=>{var t;class e extends yF{constructor(n){super(n)}supports(n){return!0}addEventListener(n,r,i){return n.addEventListener(r,i,!1),()=>this.removeEventListener(n,r,i)}removeEventListener(n,r,i){return n.removeEventListener(r,i)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();const EF=["alt","control","meta","shift"],nG={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},sG={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let rG=(()=>{var t;class e extends yF{constructor(n){super(n)}supports(n){return null!=e.parseEventName(n)}addEventListener(n,r,i){const a=e.parseEventName(r),c=e.eventCallback(a.fullKey,i,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>o_().onAndCancel(n,a.domEventName,c))}static parseEventName(n){const r=n.toLowerCase().split("."),i=r.shift();if(0===r.length||"keydown"!==i&&"keyup"!==i)return null;const a=e._normalizeKey(r.pop());let c="",f=r.indexOf("code");if(f>-1&&(r.splice(f,1),c="code."),EF.forEach(E=>{const A=r.indexOf(E);A>-1&&(r.splice(A,1),c+=E+".")}),c+=a,0!=r.length||0===a.length)return null;const g={};return g.domEventName=i,g.fullKey=c,g}static matchEventFullKeyCode(n,r){let i=nG[n.key]||n.key,a="";return r.indexOf("code.")>-1&&(i=n.code,a="code."),!(null==i||!i)&&(i=i.toLowerCase()," "===i?i="space":"."===i&&(i="dot"),EF.forEach(c=>{c!==i&&(0,sG[c])(n)&&(a+=c+".")}),a+=i,a===r)}static eventCallback(n,r,i){return a=>{e.matchEventFullKeyCode(a,n)&&i.runGuarded(()=>r(a))}}static _normalizeKey(n){return"esc"===n?"escape":n}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();const SF=[{provide:qh,useValue:uF},{provide:Dv,useValue:function iG(){O2.makeCurrent()},multi:!0},{provide:yi,useFactory:function aG(){return function ux(t){iy=t}(document),document},deps:[]}],lG=yP(P5,"browser",SF),cG=new Zn(""),IF=[{provide:RD,useClass:class jj{addToWindow(e){Fi.getAngularTestability=(n,r=!0)=>{const i=e.findTestabilityInTree(n,r);if(null==i)throw new En(5103,!1);return i},Fi.getAllAngularTestabilities=()=>e.getAllTestabilities(),Fi.getAllAngularRootElements=()=>e.getAllRootElements(),Fi.frameworkStabilizers||(Fi.frameworkStabilizers=[]),Fi.frameworkStabilizers.push(n=>{const r=Fi.getAllAngularTestabilities();let i=r.length,a=!1;const c=function(f){a=a||f,i--,0==i&&n(a)};r.forEach(f=>{f.whenStable(c)})})}findTestabilityInTree(e,s,n){return null==s?null:e.getTestability(s)??(n?o_().isShadowRoot(s)?this.findTestabilityInTree(e,s.host,!0):this.findTestabilityInTree(e,s.parentElement,!0):null)}},deps:[]},{provide:pP,useClass:qk,deps:[Gs,e2,RD]},{provide:qk,useClass:qk,deps:[Gs,e2,RD]}],TF=[{provide:vm,useValue:"root"},{provide:nh,useFactory:function oG(){return new nh},deps:[]},{provide:R2,useClass:tG,multi:!0,deps:[yi,Gs,qh]},{provide:R2,useClass:rG,multi:!0,deps:[yi]},F2,vF,_F,{provide:tp,useExisting:F2},{provide:hF,useClass:Gj,deps:[]},[]];let AF=(()=>{var t;class e{constructor(n){}static withServerTransition(n){return{ngModule:e,providers:[{provide:Sf,useValue:n.appId}]}}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(cG,12))},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[...TF,...IF],imports:[Ah,F5]}),e})(),kF=(()=>{var t;class e{constructor(n){this._doc=n}getTitle(){return this._doc.title}setTitle(n){this._doc.title=n||""}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi))},t.\u0275prov=wt({token:t,factory:function(n){let r=null;return r=n?new n:function dG(){return new kF(cn(yi))}(),r},providedIn:"root"}),e})();typeof window<"u"&&window;let V2=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(n){let r=null;return r=n?new(n||t):cn(NF),r},providedIn:"root"}),e})(),NF=(()=>{var t;class e extends V2{constructor(n){super(),this._doc=n}sanitize(n,r){if(null==r)return null;switch(n){case nu.NONE:return r;case nu.HTML:return Od(r,"HTML")?Lu(r):gv(this._doc,String(r)).toString();case nu.STYLE:return Od(r,"Style")?Lu(r):r;case nu.SCRIPT:if(Od(r,"Script"))return Lu(r);throw new En(5200,!1);case nu.URL:return Od(r,"URL")?Lu(r):kg(String(r));case nu.RESOURCE_URL:if(Od(r,"ResourceURL"))return Lu(r);throw new En(5201,!1);default:throw new En(5202,!1)}}bypassSecurityTrustHtml(n){return function rv(t){return new tv(t)}(n)}bypassSecurityTrustStyle(n){return function iv(t){return new dx(t)}(n)}bypassSecurityTrustScript(n){return function ov(t){return new nv(t)}(n)}bypassSecurityTrustUrl(n){return function av(t){return new sv(t)}(n)}bypassSecurityTrustResourceUrl(n){return function lv(t){return new hx(t)}(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi))},t.\u0275prov=wt({token:t,factory:function(n){let r=null;return r=n?new n:function mG(t){return new NF(t.get(yi))}(cn(Wc)),r},providedIn:"root"}),e})();const{isArray:gG}=Array,{getPrototypeOf:_G,prototype:yG,keys:vG}=Object;function PF(t){if(1===t.length){const e=t[0];if(gG(e))return{args:e,keys:null};if(function bG(t){return t&&"object"==typeof t&&_G(t)===yG}(e)){const s=vG(e);return{args:s.map(n=>e[n]),keys:s}}}return{args:t,keys:null}}const{isArray:xG}=Array;function U2(t){return Xn(e=>function wG(t,e){return xG(e)?t(...e):t(e)}(t,e))}function FF(t,e){return t.reduce((s,n,r)=>(s[n]=e[r],s),{})}function LF(...t){const e=ol(t),{args:s,keys:n}=PF(t),r=new Ue(i=>{const{length:a}=s;if(!a)return void i.complete();const c=new Array(a);let f=a,g=a;for(let E=0;E<a;E++){let A=!1;Jr(s[E]).subscribe(ps(i,Y=>{A||(A=!0,g--),c[E]=Y},()=>f--,void 0,()=>{(!f||!A)&&(g||i.next(n?FF(n,c):c),i.complete())}))}});return e?r.pipe(U2(e)):r}let $F=(()=>{var t;class e{constructor(n,r){this._renderer=n,this._elementRef=r,this.onChange=i=>{},this.onTouched=()=>{}}setProperty(n,r){this._renderer.setProperty(this._elementRef.nativeElement,n,r)}registerOnTouched(n){this.onTouched=n}registerOnChange(n){this.onChange=n}setDisabledState(n){this.setProperty("disabled",n)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(th),lt(yr))},t.\u0275dir=Gn({type:t}),e})(),Zy=(()=>{var t;class e extends $F{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,features:[Ps]}),e})();const ah=new Zn("NgValueAccessor"),EG={provide:ah,useExisting:Br(()=>QD),multi:!0},SG=new Zn("CompositionEventMode");let QD=(()=>{var t;class e extends $F{constructor(n,r,i){super(n,r),this._compositionMode=i,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function DG(){const t=o_()?o_().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(n){this.setProperty("value",n??"")}_handleInput(n){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(n)}_compositionStart(){this._composing=!0}_compositionEnd(n){this._composing=!1,this._compositionMode&&this.onChange(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(th),lt(yr),lt(SG,8))},t.\u0275dir=Gn({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(n,r){1&n&&qs("input",function(a){return r._handleInput(a.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(a){return r._compositionEnd(a.target.value)})},features:[vr([EG]),Ps]}),e})();function l_(t){return null==t||("string"==typeof t||Array.isArray(t))&&0===t.length}function VF(t){return null!=t&&"number"==typeof t.length}const gd=new Zn("NgValidators"),c_=new Zn("NgAsyncValidators"),IG=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class z2{static min(e){return function UF(t){return e=>{if(l_(e.value)||l_(t))return null;const s=parseFloat(e.value);return!isNaN(s)&&s<t?{min:{min:t,actual:e.value}}:null}}(e)}static max(e){return function zF(t){return e=>{if(l_(e.value)||l_(t))return null;const s=parseFloat(e.value);return!isNaN(s)&&s>t?{max:{max:t,actual:e.value}}:null}}(e)}static required(e){return function WF(t){return l_(t.value)?{required:!0}:null}(e)}static requiredTrue(e){return function HF(t){return!0===t.value?null:{required:!0}}(e)}static email(e){return function jF(t){return l_(t.value)||IG.test(t.value)?null:{email:!0}}(e)}static minLength(e){return function GF(t){return e=>l_(e.value)||!VF(e.value)?null:e.value.length<t?{minlength:{requiredLength:t,actualLength:e.value.length}}:null}(e)}static maxLength(e){return function KF(t){return e=>VF(e.value)&&e.value.length>t?{maxlength:{requiredLength:t,actualLength:e.value.length}}:null}(e)}static pattern(e){return function XF(t){if(!t)return JD;let e,s;return"string"==typeof t?(s="","^"!==t.charAt(0)&&(s+="^"),s+=t,"$"!==t.charAt(t.length-1)&&(s+="$"),e=new RegExp(s)):(s=t.toString(),e=t),n=>{if(l_(n.value))return null;const r=n.value;return e.test(r)?null:{pattern:{requiredPattern:s,actualValue:r}}}}(e)}static nullValidator(e){return null}static compose(e){return eL(e)}static composeAsync(e){return tL(e)}}function JD(t){return null}function YF(t){return null!=t}function ZF(t){return By(t)?Hi(t):t}function QF(t){let e={};return t.forEach(s=>{e=null!=s?{...e,...s}:e}),0===Object.keys(e).length?null:e}function JF(t,e){return e.map(s=>s(t))}function qF(t){return t.map(e=>function TG(t){return!t.validate}(e)?e:s=>e.validate(s))}function eL(t){if(!t)return null;const e=t.filter(YF);return 0==e.length?null:function(s){return QF(JF(s,e))}}function W2(t){return null!=t?eL(qF(t)):null}function tL(t){if(!t)return null;const e=t.filter(YF);return 0==e.length?null:function(s){return LF(JF(s,e).map(ZF)).pipe(Xn(QF))}}function H2(t){return null!=t?tL(qF(t)):null}function nL(t,e){return null===t?[e]:Array.isArray(t)?[...t,e]:[t,e]}function sL(t){return t._rawValidators}function rL(t){return t._rawAsyncValidators}function j2(t){return t?Array.isArray(t)?t:[t]:[]}function qD(t,e){return Array.isArray(t)?t.includes(e):t===e}function iL(t,e){const s=j2(e);return j2(t).forEach(r=>{qD(s,r)||s.push(r)}),s}function oL(t,e){return j2(e).filter(s=>!qD(t,s))}class aL{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(e){this._rawValidators=e||[],this._composedValidatorFn=W2(this._rawValidators)}_setAsyncValidators(e){this._rawAsyncValidators=e||[],this._composedAsyncValidatorFn=H2(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(e){this._onDestroyCallbacks.push(e)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(e=>e()),this._onDestroyCallbacks=[]}reset(e=void 0){this.control&&this.control.reset(e)}hasError(e,s){return!!this.control&&this.control.hasError(e,s)}getError(e,s){return this.control?this.control.getError(e,s):null}}class Bd extends aL{get formDirective(){return null}get path(){return null}}class Kp extends aL{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class lL{constructor(e){this._cd=e}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let cL=(()=>{var t;class e extends lL{constructor(n){super(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Kp,2))},t.\u0275dir=Gn({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(n,r){2&n&&Ei("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[Ps]}),e})();const Pw="VALID",tS="INVALID",rb="PENDING",Fw="DISABLED";function X2(t){return(nS(t)?t.validators:t)||null}function Y2(t,e){return(nS(e)?e.asyncValidators:t)||null}function nS(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class pL{constructor(e,s){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(e),this._assignAsyncValidators(s)}get validator(){return this._composedValidatorFn}set validator(e){this._rawValidators=this._composedValidatorFn=e}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(e){this._rawAsyncValidators=this._composedAsyncValidatorFn=e}get parent(){return this._parent}get valid(){return this.status===Pw}get invalid(){return this.status===tS}get pending(){return this.status==rb}get disabled(){return this.status===Fw}get enabled(){return this.status!==Fw}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(e){this._assignValidators(e)}setAsyncValidators(e){this._assignAsyncValidators(e)}addValidators(e){this.setValidators(iL(e,this._rawValidators))}addAsyncValidators(e){this.setAsyncValidators(iL(e,this._rawAsyncValidators))}removeValidators(e){this.setValidators(oL(e,this._rawValidators))}removeAsyncValidators(e){this.setAsyncValidators(oL(e,this._rawAsyncValidators))}hasValidator(e){return qD(this._rawValidators,e)}hasAsyncValidator(e){return qD(this._rawAsyncValidators,e)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(e={}){this.touched=!0,this._parent&&!e.onlySelf&&this._parent.markAsTouched(e)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(e=>e.markAllAsTouched())}markAsUntouched(e={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(s=>{s.markAsUntouched({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}markAsDirty(e={}){this.pristine=!1,this._parent&&!e.onlySelf&&this._parent.markAsDirty(e)}markAsPristine(e={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(s=>{s.markAsPristine({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}markAsPending(e={}){this.status=rb,!1!==e.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!e.onlySelf&&this._parent.markAsPending(e)}disable(e={}){const s=this._parentMarkedDirty(e.onlySelf);this.status=Fw,this.errors=null,this._forEachChild(n=>{n.disable({...e,onlySelf:!0})}),this._updateValue(),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...e,skipPristineCheck:s}),this._onDisabledChange.forEach(n=>n(!0))}enable(e={}){const s=this._parentMarkedDirty(e.onlySelf);this.status=Pw,this._forEachChild(n=>{n.enable({...e,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent}),this._updateAncestors({...e,skipPristineCheck:s}),this._onDisabledChange.forEach(n=>n(!1))}_updateAncestors(e){this._parent&&!e.onlySelf&&(this._parent.updateValueAndValidity(e),e.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(e){this._parent=e}getRawValue(){return this.value}updateValueAndValidity(e={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===Pw||this.status===rb)&&this._runAsyncValidator(e.emitEvent)),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!e.onlySelf&&this._parent.updateValueAndValidity(e)}_updateTreeValidity(e={emitEvent:!0}){this._forEachChild(s=>s._updateTreeValidity(e)),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Fw:Pw}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(e){if(this.asyncValidator){this.status=rb,this._hasOwnPendingAsyncValidator=!0;const s=ZF(this.asyncValidator(this));this._asyncValidationSubscription=s.subscribe(n=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(n,{emitEvent:e})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(e,s={}){this.errors=e,this._updateControlsErrors(!1!==s.emitEvent)}get(e){let s=e;return null==s||(Array.isArray(s)||(s=s.split(".")),0===s.length)?null:s.reduce((n,r)=>n&&n._find(r),this)}getError(e,s){const n=s?this.get(s):this;return n&&n.errors?n.errors[e]:null}hasError(e,s){return!!this.getError(e,s)}get root(){let e=this;for(;e._parent;)e=e._parent;return e}_updateControlsErrors(e){this.status=this._calculateStatus(),e&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(e)}_initObservables(){this.valueChanges=new Rr,this.statusChanges=new Rr}_calculateStatus(){return this._allControlsDisabled()?Fw:this.errors?tS:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(rb)?rb:this._anyControlsHaveStatus(tS)?tS:Pw}_anyControlsHaveStatus(e){return this._anyControls(s=>s.status===e)}_anyControlsDirty(){return this._anyControls(e=>e.dirty)}_anyControlsTouched(){return this._anyControls(e=>e.touched)}_updatePristine(e={}){this.pristine=!this._anyControlsDirty(),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}_updateTouched(e={}){this.touched=this._anyControlsTouched(),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}_registerOnCollectionChange(e){this._onCollectionChange=e}_setUpdateStrategy(e){nS(e)&&null!=e.updateOn&&(this._updateOn=e.updateOn)}_parentMarkedDirty(e){return!e&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(e){return null}_assignValidators(e){this._rawValidators=Array.isArray(e)?e.slice():e,this._composedValidatorFn=function NG(t){return Array.isArray(t)?W2(t):t||null}(this._rawValidators)}_assignAsyncValidators(e){this._rawAsyncValidators=Array.isArray(e)?e.slice():e,this._composedAsyncValidatorFn=function MG(t){return Array.isArray(t)?H2(t):t||null}(this._rawAsyncValidators)}}class Z2 extends pL{constructor(e,s,n){super(X2(s),Y2(n,s)),this.controls=e,this._initObservables(),this._setUpdateStrategy(s),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(e,s){return this.controls[e]?this.controls[e]:(this.controls[e]=s,s.setParent(this),s._registerOnCollectionChange(this._onCollectionChange),s)}addControl(e,s,n={}){this.registerControl(e,s),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}removeControl(e,s={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],this.updateValueAndValidity({emitEvent:s.emitEvent}),this._onCollectionChange()}setControl(e,s,n={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],s&&this.registerControl(e,s),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}contains(e){return this.controls.hasOwnProperty(e)&&this.controls[e].enabled}setValue(e,s={}){(function hL(t,e,s){t._forEachChild((n,r)=>{if(void 0===s[r])throw new En(1002,"")})})(this,0,e),Object.keys(e).forEach(n=>{(function dL(t,e,s){const n=t.controls;if(!(e?Object.keys(n):n).length)throw new En(1e3,"");if(!n[s])throw new En(1001,"")})(this,!0,n),this.controls[n].setValue(e[n],{onlySelf:!0,emitEvent:s.emitEvent})}),this.updateValueAndValidity(s)}patchValue(e,s={}){null!=e&&(Object.keys(e).forEach(n=>{const r=this.controls[n];r&&r.patchValue(e[n],{onlySelf:!0,emitEvent:s.emitEvent})}),this.updateValueAndValidity(s))}reset(e={},s={}){this._forEachChild((n,r)=>{n.reset(e[r],{onlySelf:!0,emitEvent:s.emitEvent})}),this._updatePristine(s),this._updateTouched(s),this.updateValueAndValidity(s)}getRawValue(){return this._reduceChildren({},(e,s,n)=>(e[n]=s.getRawValue(),e))}_syncPendingControls(){let e=this._reduceChildren(!1,(s,n)=>!!n._syncPendingControls()||s);return e&&this.updateValueAndValidity({onlySelf:!0}),e}_forEachChild(e){Object.keys(this.controls).forEach(s=>{const n=this.controls[s];n&&e(n,s)})}_setUpControls(){this._forEachChild(e=>{e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(e){for(const[s,n]of Object.entries(this.controls))if(this.contains(s)&&e(n))return!0;return!1}_reduceValue(){return this._reduceChildren({},(s,n,r)=>((n.enabled||this.disabled)&&(s[r]=n.value),s))}_reduceChildren(e,s){let n=e;return this._forEachChild((r,i)=>{n=s(n,r,i)}),n}_allControlsDisabled(){for(const e of Object.keys(this.controls))if(this.controls[e].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(e){return this.controls.hasOwnProperty(e)?this.controls[e]:null}}const ib=new Zn("CallSetDisabledState",{providedIn:"root",factory:()=>sS}),sS="always";function Lw(t,e,s=sS){Q2(t,e),e.valueAccessor.writeValue(t.value),(t.disabled||"always"===s)&&e.valueAccessor.setDisabledState?.(t.disabled),function LG(t,e){e.valueAccessor.registerOnChange(s=>{t._pendingValue=s,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&fL(t,e)})}(t,e),function BG(t,e){const s=(n,r)=>{e.valueAccessor.writeValue(n),r&&e.viewToModelUpdate(n)};t.registerOnChange(s),e._registerOnDestroy(()=>{t._unregisterOnChange(s)})}(t,e),function $G(t,e){e.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&fL(t,e),"submit"!==t.updateOn&&t.markAsTouched()})}(t,e),function FG(t,e){if(e.valueAccessor.setDisabledState){const s=n=>{e.valueAccessor.setDisabledState(n)};t.registerOnDisabledChange(s),e._registerOnDestroy(()=>{t._unregisterOnDisabledChange(s)})}}(t,e)}function iS(t,e,s=!0){const n=()=>{};e.valueAccessor&&(e.valueAccessor.registerOnChange(n),e.valueAccessor.registerOnTouched(n)),aS(t,e),t&&(e._invokeOnDestroyCallbacks(),t._registerOnCollectionChange(()=>{}))}function oS(t,e){t.forEach(s=>{s.registerOnValidatorChange&&s.registerOnValidatorChange(e)})}function Q2(t,e){const s=sL(t);null!==e.validator?t.setValidators(nL(s,e.validator)):"function"==typeof s&&t.setValidators([s]);const n=rL(t);null!==e.asyncValidator?t.setAsyncValidators(nL(n,e.asyncValidator)):"function"==typeof n&&t.setAsyncValidators([n]);const r=()=>t.updateValueAndValidity();oS(e._rawValidators,r),oS(e._rawAsyncValidators,r)}function aS(t,e){let s=!1;if(null!==t){if(null!==e.validator){const r=sL(t);if(Array.isArray(r)&&r.length>0){const i=r.filter(a=>a!==e.validator);i.length!==r.length&&(s=!0,t.setValidators(i))}}if(null!==e.asyncValidator){const r=rL(t);if(Array.isArray(r)&&r.length>0){const i=r.filter(a=>a!==e.asyncValidator);i.length!==r.length&&(s=!0,t.setAsyncValidators(i))}}}const n=()=>{};return oS(e._rawValidators,n),oS(e._rawAsyncValidators,n),s}function fL(t,e){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function mL(t,e){Q2(t,e)}function gL(t,e){t._syncPendingControls(),e.forEach(s=>{const n=s.control;"submit"===n.updateOn&&n._pendingChange&&(s.viewToModelUpdate(n._pendingValue),n._pendingChange=!1)})}const HG={provide:Bd,useExisting:Br(()=>ob)},$w=(()=>Promise.resolve())();let ob=(()=>{var t;class e extends Bd{constructor(n,r,i){super(),this.callSetDisabledState=i,this.submitted=!1,this._directives=new Set,this.ngSubmit=new Rr,this.form=new Z2({},W2(n),H2(r))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(n){$w.then(()=>{const r=this._findContainer(n.path);n.control=r.registerControl(n.name,n.control),Lw(n.control,n,this.callSetDisabledState),n.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(n)})}getControl(n){return this.form.get(n.path)}removeControl(n){$w.then(()=>{const r=this._findContainer(n.path);r&&r.removeControl(n.name),this._directives.delete(n)})}addFormGroup(n){$w.then(()=>{const r=this._findContainer(n.path),i=new Z2({});mL(i,n),r.registerControl(n.name,i),i.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(n){$w.then(()=>{const r=this._findContainer(n.path);r&&r.removeControl(n.name)})}getFormGroup(n){return this.form.get(n.path)}updateModel(n,r){$w.then(()=>{this.form.get(n.path).setValue(r)})}setValue(n){this.control.setValue(n)}onSubmit(n){return this.submitted=!0,gL(this.form,this._directives),this.ngSubmit.emit(n),"dialog"===n?.target?.method}onReset(){this.resetForm()}resetForm(n=void 0){this.form.reset(n),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(n){return n.pop(),n.length?this.form.get(n):this.form}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(gd,10),lt(c_,10),lt(ib,8))},t.\u0275dir=Gn({type:t,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(n,r){1&n&&qs("submit",function(a){return r.onSubmit(a)})("reset",function(){return r.onReset()})},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[vr([HG]),Ps]}),e})();function _L(t,e){const s=t.indexOf(e);s>-1&&t.splice(s,1)}function yL(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}const vL=class extends pL{constructor(e=null,s,n){super(X2(s),Y2(n,s)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(e),this._setUpdateStrategy(s),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),nS(s)&&(s.nonNullable||s.initialValueIsDefault)&&(this.defaultValue=yL(e)?e.value:e)}setValue(e,s={}){this.value=this._pendingValue=e,this._onChange.length&&!1!==s.emitModelToViewChange&&this._onChange.forEach(n=>n(this.value,!1!==s.emitViewToModelChange)),this.updateValueAndValidity(s)}patchValue(e,s={}){this.setValue(e,s)}reset(e=this.defaultValue,s={}){this._applyFormState(e),this.markAsPristine(s),this.markAsUntouched(s),this.setValue(this.value,s),this._pendingChange=!1}_updateValue(){}_anyControls(e){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(e){this._onChange.push(e)}_unregisterOnChange(e){_L(this._onChange,e)}registerOnDisabledChange(e){this._onDisabledChange.push(e)}_unregisterOnDisabledChange(e){_L(this._onDisabledChange,e)}_forEachChild(e){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(e){yL(e)?(this.value=this._pendingValue=e.value,e.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=e}},KG={provide:Kp,useExisting:Br(()=>tO)},wL=(()=>Promise.resolve())();let tO=(()=>{var t;class e extends Kp{constructor(n,r,i,a,c,f){super(),this._changeDetectorRef=c,this.callSetDisabledState=f,this.control=new vL,this._registered=!1,this.name="",this.update=new Rr,this._parent=n,this._setValidators(r),this._setAsyncValidators(i),this.valueAccessor=function eO(t,e){if(!e)return null;let s,n,r;return Array.isArray(e),e.forEach(i=>{i.constructor===QD?s=i:function zG(t){return Object.getPrototypeOf(t.constructor)===Zy}(i)?n=i:r=i}),r||n||s||null}(0,a)}ngOnChanges(n){if(this._checkForErrors(),!this._registered||"name"in n){if(this._registered&&(this._checkName(),this.formDirective)){const r=n.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in n&&this._updateDisabled(n),function q2(t,e){if(!t.hasOwnProperty("model"))return!1;const s=t.model;return!!s.isFirstChange()||!Object.is(e,s.currentValue)}(n,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(n){this.viewModel=n,this.update.emit(n)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Lw(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(n){wL.then(()=>{this.control.setValue(n,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(n){const r=n.isDisabled.currentValue,i=0!==r&&tb(r);wL.then(()=>{i&&!this.control.disabled?this.control.disable():!i&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(n){return this._parent?function rS(t,e){return[...e.path,t]}(n,this._parent):[n]}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Bd,9),lt(gd,10),lt(c_,10),lt(ah,10),lt(Ll,8),lt(ib,8))},t.\u0275dir=Gn({type:t,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[vr([KG]),Ps,Ia]}),e})(),EL=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();const e6={provide:Bd,useExisting:Br(()=>ab)};let ab=(()=>{var t;class e extends Bd{constructor(n,r,i){super(),this.callSetDisabledState=i,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new Rr,this._setValidators(n),this._setAsyncValidators(r)}ngOnChanges(n){this._checkFormPresent(),n.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(aS(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(n){const r=this.form.get(n.path);return Lw(r,n,this.callSetDisabledState),r.updateValueAndValidity({emitEvent:!1}),this.directives.push(n),r}getControl(n){return this.form.get(n.path)}removeControl(n){iS(n.control||null,n,!1),function WG(t,e){const s=t.indexOf(e);s>-1&&t.splice(s,1)}(this.directives,n)}addFormGroup(n){this._setUpFormContainer(n)}removeFormGroup(n){this._cleanUpFormContainer(n)}getFormGroup(n){return this.form.get(n.path)}addFormArray(n){this._setUpFormContainer(n)}removeFormArray(n){this._cleanUpFormContainer(n)}getFormArray(n){return this.form.get(n.path)}updateModel(n,r){this.form.get(n.path).setValue(r)}onSubmit(n){return this.submitted=!0,gL(this.form,this.directives),this.ngSubmit.emit(n),"dialog"===n?.target?.method}onReset(){this.resetForm()}resetForm(n=void 0){this.form.reset(n),this.submitted=!1}_updateDomValue(){this.directives.forEach(n=>{const r=n.control,i=this.form.get(n.path);r!==i&&(iS(r||null,n),(t=>t instanceof vL)(i)&&(Lw(i,n,this.callSetDisabledState),n.control=i))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(n){const r=this.form.get(n.path);mL(r,n),r.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(n){if(this.form){const r=this.form.get(n.path);r&&function VG(t,e){return aS(t,e)}(r,n)&&r.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){Q2(this.form,this),this._oldForm&&aS(this._oldForm,this)}_checkFormPresent(){}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(gd,10),lt(c_,10),lt(ib,8))},t.\u0275dir=Gn({type:t,selectors:[["","formGroup",""]],hostBindings:function(n,r){1&n&&qs("submit",function(a){return r.onSubmit(a)})("reset",function(){return r.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[vr([e6]),Ps,Ia]}),e})(),y6=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[EL]}),e})(),b6=(()=>{var t;class e{static withConfig(n){return{ngModule:e,providers:[{provide:ib,useValue:n.callSetDisabledState??sS}]}}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[y6]}),e})();function lb(t,e){return U(e)?no(t,e,1):no(t,1)}function tc(t,e){return Dn((s,n)=>{let r=0;s.subscribe(ps(n,i=>t.call(e,i,r++)&&n.next(i)))})}function cb(t){return Dn((e,s)=>{try{e.subscribe(s)}finally{s.add(t)}})}class lS{}class cS{}class Rf{constructor(e){this.normalizedNames=new Map,this.lazyUpdate=null,e?"string"==typeof e?this.lazyInit=()=>{this.headers=new Map,e.split("\n").forEach(s=>{const n=s.indexOf(":");if(n>0){const r=s.slice(0,n),i=r.toLowerCase(),a=s.slice(n+1).trim();this.maybeSetNormalizedName(r,i),this.headers.has(i)?this.headers.get(i).push(a):this.headers.set(i,[a])}})}:typeof Headers<"u"&&e instanceof Headers?(this.headers=new Map,e.forEach((s,n)=>{this.setHeaderEntries(n,s)})):this.lazyInit=()=>{this.headers=new Map,Object.entries(e).forEach(([s,n])=>{this.setHeaderEntries(s,n)})}:this.headers=new Map}has(e){return this.init(),this.headers.has(e.toLowerCase())}get(e){this.init();const s=this.headers.get(e.toLowerCase());return s&&s.length>0?s[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(e){return this.init(),this.headers.get(e.toLowerCase())||null}append(e,s){return this.clone({name:e,value:s,op:"a"})}set(e,s){return this.clone({name:e,value:s,op:"s"})}delete(e,s){return this.clone({name:e,value:s,op:"d"})}maybeSetNormalizedName(e,s){this.normalizedNames.has(s)||this.normalizedNames.set(s,e)}init(){this.lazyInit&&(this.lazyInit instanceof Rf?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(e=>this.applyUpdate(e)),this.lazyUpdate=null))}copyFrom(e){e.init(),Array.from(e.headers.keys()).forEach(s=>{this.headers.set(s,e.headers.get(s)),this.normalizedNames.set(s,e.normalizedNames.get(s))})}clone(e){const s=new Rf;return s.lazyInit=this.lazyInit&&this.lazyInit instanceof Rf?this.lazyInit:this,s.lazyUpdate=(this.lazyUpdate||[]).concat([e]),s}applyUpdate(e){const s=e.name.toLowerCase();switch(e.op){case"a":case"s":let n=e.value;if("string"==typeof n&&(n=[n]),0===n.length)return;this.maybeSetNormalizedName(e.name,s);const r=("a"===e.op?this.headers.get(s):void 0)||[];r.push(...n),this.headers.set(s,r);break;case"d":const i=e.value;if(i){let a=this.headers.get(s);if(!a)return;a=a.filter(c=>-1===i.indexOf(c)),0===a.length?(this.headers.delete(s),this.normalizedNames.delete(s)):this.headers.set(s,a)}else this.headers.delete(s),this.normalizedNames.delete(s)}}setHeaderEntries(e,s){const n=(Array.isArray(s)?s:[s]).map(i=>i.toString()),r=e.toLowerCase();this.headers.set(r,n),this.maybeSetNormalizedName(e,r)}forEach(e){this.init(),Array.from(this.normalizedNames.keys()).forEach(s=>e(this.normalizedNames.get(s),this.headers.get(s)))}}class x6{encodeKey(e){return zL(e)}encodeValue(e){return zL(e)}decodeKey(e){return decodeURIComponent(e)}decodeValue(e){return decodeURIComponent(e)}}const C6=/%(\d[a-f0-9])/gi,E6={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function zL(t){return encodeURIComponent(t).replace(C6,(e,s)=>E6[s]??e)}function uS(t){return`${t}`}class u_{constructor(e={}){if(this.updates=null,this.cloneFrom=null,this.encoder=e.encoder||new x6,e.fromString){if(e.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function w6(t,e){const s=new Map;return t.length>0&&t.replace(/^\?/,"").split("&").forEach(r=>{const i=r.indexOf("="),[a,c]=-1==i?[e.decodeKey(r),""]:[e.decodeKey(r.slice(0,i)),e.decodeValue(r.slice(i+1))],f=s.get(a)||[];f.push(c),s.set(a,f)}),s}(e.fromString,this.encoder)}else e.fromObject?(this.map=new Map,Object.keys(e.fromObject).forEach(s=>{const n=e.fromObject[s],r=Array.isArray(n)?n.map(uS):[uS(n)];this.map.set(s,r)})):this.map=null}has(e){return this.init(),this.map.has(e)}get(e){this.init();const s=this.map.get(e);return s?s[0]:null}getAll(e){return this.init(),this.map.get(e)||null}keys(){return this.init(),Array.from(this.map.keys())}append(e,s){return this.clone({param:e,value:s,op:"a"})}appendAll(e){const s=[];return Object.keys(e).forEach(n=>{const r=e[n];Array.isArray(r)?r.forEach(i=>{s.push({param:n,value:i,op:"a"})}):s.push({param:n,value:r,op:"a"})}),this.clone(s)}set(e,s){return this.clone({param:e,value:s,op:"s"})}delete(e,s){return this.clone({param:e,value:s,op:"d"})}toString(){return this.init(),this.keys().map(e=>{const s=this.encoder.encodeKey(e);return this.map.get(e).map(n=>s+"="+this.encoder.encodeValue(n)).join("&")}).filter(e=>""!==e).join("&")}clone(e){const s=new u_({encoder:this.encoder});return s.cloneFrom=this.cloneFrom||this,s.updates=(this.updates||[]).concat(e),s}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(e=>this.map.set(e,this.cloneFrom.map.get(e))),this.updates.forEach(e=>{switch(e.op){case"a":case"s":const s=("a"===e.op?this.map.get(e.param):void 0)||[];s.push(uS(e.value)),this.map.set(e.param,s);break;case"d":if(void 0===e.value){this.map.delete(e.param);break}{let n=this.map.get(e.param)||[];const r=n.indexOf(uS(e.value));-1!==r&&n.splice(r,1),n.length>0?this.map.set(e.param,n):this.map.delete(e.param)}}}),this.cloneFrom=this.updates=null)}}class D6{constructor(){this.map=new Map}set(e,s){return this.map.set(e,s),this}get(e){return this.map.has(e)||this.map.set(e,e.defaultValue()),this.map.get(e)}delete(e){return this.map.delete(e),this}has(e){return this.map.has(e)}keys(){return this.map.keys()}}function WL(t){return typeof ArrayBuffer<"u"&&t instanceof ArrayBuffer}function HL(t){return typeof Blob<"u"&&t instanceof Blob}function jL(t){return typeof FormData<"u"&&t instanceof FormData}class Bw{constructor(e,s,n,r){let i;if(this.url=s,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=e.toUpperCase(),function S6(t){switch(t){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||r?(this.body=void 0!==n?n:null,i=r):i=n,i&&(this.reportProgress=!!i.reportProgress,this.withCredentials=!!i.withCredentials,i.responseType&&(this.responseType=i.responseType),i.headers&&(this.headers=i.headers),i.context&&(this.context=i.context),i.params&&(this.params=i.params)),this.headers||(this.headers=new Rf),this.context||(this.context=new D6),this.params){const a=this.params.toString();if(0===a.length)this.urlWithParams=s;else{const c=s.indexOf("?");this.urlWithParams=s+(-1===c?"?":c<s.length-1?"&":"")+a}}else this.params=new u_,this.urlWithParams=s}serializeBody(){return null===this.body?null:WL(this.body)||HL(this.body)||jL(this.body)||function I6(t){return typeof URLSearchParams<"u"&&t instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof u_?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||jL(this.body)?null:HL(this.body)?this.body.type||null:WL(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof u_?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(e={}){const s=e.method||this.method,n=e.url||this.url,r=e.responseType||this.responseType,i=void 0!==e.body?e.body:this.body,a=void 0!==e.withCredentials?e.withCredentials:this.withCredentials,c=void 0!==e.reportProgress?e.reportProgress:this.reportProgress;let f=e.headers||this.headers,g=e.params||this.params;const E=e.context??this.context;return void 0!==e.setHeaders&&(f=Object.keys(e.setHeaders).reduce((A,Y)=>A.set(Y,e.setHeaders[Y]),f)),e.setParams&&(g=Object.keys(e.setParams).reduce((A,Y)=>A.set(Y,e.setParams[Y]),g)),new Bw(s,n,i,{params:g,headers:f,context:E,reportProgress:c,responseType:r,withCredentials:a})}}var ub=function(t){return t[t.Sent=0]="Sent",t[t.UploadProgress=1]="UploadProgress",t[t.ResponseHeader=2]="ResponseHeader",t[t.DownloadProgress=3]="DownloadProgress",t[t.Response=4]="Response",t[t.User=5]="User",t}(ub||{});class aO{constructor(e,s=200,n="OK"){this.headers=e.headers||new Rf,this.status=void 0!==e.status?e.status:s,this.statusText=e.statusText||n,this.url=e.url||null,this.ok=this.status>=200&&this.status<300}}class lO extends aO{constructor(e={}){super(e),this.type=ub.ResponseHeader}clone(e={}){return new lO({headers:e.headers||this.headers,status:void 0!==e.status?e.status:this.status,statusText:e.statusText||this.statusText,url:e.url||this.url||void 0})}}class db extends aO{constructor(e={}){super(e),this.type=ub.Response,this.body=void 0!==e.body?e.body:null}clone(e={}){return new db({body:void 0!==e.body?e.body:this.body,headers:e.headers||this.headers,status:void 0!==e.status?e.status:this.status,statusText:e.statusText||this.statusText,url:e.url||this.url||void 0})}}class GL extends aO{constructor(e){super(e,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${e.url||"(unknown url)"}`:`Http failure response for ${e.url||"(unknown url)"}: ${e.status} ${e.statusText}`,this.error=e.error||null}}function cO(t,e){return{body:e,headers:t.headers,context:t.context,observe:t.observe,params:t.params,reportProgress:t.reportProgress,responseType:t.responseType,withCredentials:t.withCredentials}}let Vw=(()=>{var t;class e{constructor(n){this.handler=n}request(n,r,i={}){let a;if(n instanceof Bw)a=n;else{let g,E;g=i.headers instanceof Rf?i.headers:new Rf(i.headers),i.params&&(E=i.params instanceof u_?i.params:new u_({fromObject:i.params})),a=new Bw(n,r,void 0!==i.body?i.body:null,{headers:g,context:i.context,params:E,reportProgress:i.reportProgress,responseType:i.responseType||"json",withCredentials:i.withCredentials})}const c=Xs(a).pipe(lb(g=>this.handler.handle(g)));if(n instanceof Bw||"events"===i.observe)return c;const f=c.pipe(tc(g=>g instanceof db));switch(i.observe||"body"){case"body":switch(a.responseType){case"arraybuffer":return f.pipe(Xn(g=>{if(null!==g.body&&!(g.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return g.body}));case"blob":return f.pipe(Xn(g=>{if(null!==g.body&&!(g.body instanceof Blob))throw new Error("Response is not a Blob.");return g.body}));case"text":return f.pipe(Xn(g=>{if(null!==g.body&&"string"!=typeof g.body)throw new Error("Response is not a string.");return g.body}));default:return f.pipe(Xn(g=>g.body))}case"response":return f;default:throw new Error(`Unreachable: unhandled observe type ${i.observe}}`)}}delete(n,r={}){return this.request("DELETE",n,r)}get(n,r={}){return this.request("GET",n,r)}head(n,r={}){return this.request("HEAD",n,r)}jsonp(n,r){return this.request("JSONP",n,{params:(new u_).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(n,r={}){return this.request("OPTIONS",n,r)}patch(n,r,i={}){return this.request("PATCH",n,cO(i,r))}post(n,r,i={}){return this.request("POST",n,cO(i,r))}put(n,r,i={}){return this.request("PUT",n,cO(i,r))}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(lS))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();function YL(t,e){return e(t)}function A6(t,e){return(s,n)=>e.intercept(s,{handle:r=>t(r,n)})}const O6=new Zn(""),Uw=new Zn(""),ZL=new Zn("");function R6(){let t=null;return(e,s)=>{null===t&&(t=(jn(O6,{optional:!0})??[]).reduceRight(A6,YL));const n=jn(kD),r=n.add();return t(e,s).pipe(cb(()=>n.remove(r)))}}let QL=(()=>{var t;class e extends lS{constructor(n,r){super(),this.backend=n,this.injector=r,this.chain=null,this.pendingTasks=jn(kD)}handle(n){if(null===this.chain){const i=Array.from(new Set([...this.injector.get(Uw),...this.injector.get(ZL,[])]));this.chain=i.reduceRight((a,c)=>function k6(t,e,s){return(n,r)=>s.runInContext(()=>e(n,i=>t(i,r)))}(a,c,this.injector),YL)}const r=this.pendingTasks.add();return this.chain(n,i=>this.backend.handle(i)).pipe(cb(()=>this.pendingTasks.remove(r)))}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(cS),cn(Yu))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();const F6=/^\)\]\}',?\n/;let qL=(()=>{var t;class e{constructor(n){this.xhrFactory=n}handle(n){if("JSONP"===n.method)throw new En(-2800,!1);const r=this.xhrFactory;return(r.\u0275loadImpl?Hi(r.\u0275loadImpl()):Xs(null)).pipe(Qi(()=>new Ue(a=>{const c=r.build();if(c.open(n.method,n.urlWithParams),n.withCredentials&&(c.withCredentials=!0),n.headers.forEach((tt,Nt)=>c.setRequestHeader(tt,Nt.join(","))),n.headers.has("Accept")||c.setRequestHeader("Accept","application/json, text/plain, */*"),!n.headers.has("Content-Type")){const tt=n.detectContentTypeHeader();null!==tt&&c.setRequestHeader("Content-Type",tt)}if(n.responseType){const tt=n.responseType.toLowerCase();c.responseType="json"!==tt?tt:"text"}const f=n.serializeBody();let g=null;const E=()=>{if(null!==g)return g;const tt=c.statusText||"OK",Nt=new Rf(c.getAllResponseHeaders()),kt=function L6(t){return"responseURL"in t&&t.responseURL?t.responseURL:/^X-Request-URL:/m.test(t.getAllResponseHeaders())?t.getResponseHeader("X-Request-URL"):null}(c)||n.url;return g=new lO({headers:Nt,status:c.status,statusText:tt,url:kt}),g},A=()=>{let{headers:tt,status:Nt,statusText:kt,url:on}=E(),fn=null;204!==Nt&&(fn=typeof c.response>"u"?c.responseText:c.response),0===Nt&&(Nt=fn?200:0);let Tn=Nt>=200&&Nt<300;if("json"===n.responseType&&"string"==typeof fn){const Hn=fn;fn=fn.replace(F6,"");try{fn=""!==fn?JSON.parse(fn):null}catch(Wn){fn=Hn,Tn&&(Tn=!1,fn={error:Wn,text:fn})}}Tn?(a.next(new db({body:fn,headers:tt,status:Nt,statusText:kt,url:on||void 0})),a.complete()):a.error(new GL({error:fn,headers:tt,status:Nt,statusText:kt,url:on||void 0}))},Y=tt=>{const{url:Nt}=E(),kt=new GL({error:tt,status:c.status||0,statusText:c.statusText||"Unknown Error",url:Nt||void 0});a.error(kt)};let ne=!1;const Ee=tt=>{ne||(a.next(E()),ne=!0);let Nt={type:ub.DownloadProgress,loaded:tt.loaded};tt.lengthComputable&&(Nt.total=tt.total),"text"===n.responseType&&c.responseText&&(Nt.partialText=c.responseText),a.next(Nt)},Ge=tt=>{let Nt={type:ub.UploadProgress,loaded:tt.loaded};tt.lengthComputable&&(Nt.total=tt.total),a.next(Nt)};return c.addEventListener("load",A),c.addEventListener("error",Y),c.addEventListener("timeout",Y),c.addEventListener("abort",Y),n.reportProgress&&(c.addEventListener("progress",Ee),null!==f&&c.upload&&c.upload.addEventListener("progress",Ge)),c.send(f),a.next({type:ub.Sent}),()=>{c.removeEventListener("error",Y),c.removeEventListener("abort",Y),c.removeEventListener("load",A),c.removeEventListener("timeout",Y),n.reportProgress&&(c.removeEventListener("progress",Ee),null!==f&&c.upload&&c.upload.removeEventListener("progress",Ge)),c.readyState!==c.DONE&&c.abort()}})))}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(hF))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();const uO=new Zn("XSRF_ENABLED"),e$=new Zn("XSRF_COOKIE_NAME",{providedIn:"root",factory:()=>"XSRF-TOKEN"}),t$=new Zn("XSRF_HEADER_NAME",{providedIn:"root",factory:()=>"X-XSRF-TOKEN"});class n${}let V6=(()=>{var t;class e{constructor(n,r,i){this.doc=n,this.platform=r,this.cookieName=i,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const n=this.doc.cookie||"";return n!==this.lastCookieString&&(this.parseCount++,this.lastToken=nF(n,this.cookieName),this.lastCookieString=n),this.lastToken}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(qh),cn(e$))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();function U6(t,e){const s=t.url.toLowerCase();if(!jn(uO)||"GET"===t.method||"HEAD"===t.method||s.startsWith("http://")||s.startsWith("https://"))return e(t);const n=jn(n$).getToken(),r=jn(t$);return null!=n&&!t.headers.has(r)&&(t=t.clone({headers:t.headers.set(r,n)})),e(t)}var d_=function(t){return t[t.Interceptors=0]="Interceptors",t[t.LegacyInterceptors=1]="LegacyInterceptors",t[t.CustomXsrfConfiguration=2]="CustomXsrfConfiguration",t[t.NoXsrfProtection=3]="NoXsrfProtection",t[t.JsonpSupport=4]="JsonpSupport",t[t.RequestsMadeViaParent=5]="RequestsMadeViaParent",t[t.Fetch=6]="Fetch",t}(d_||{});function Jy(t,e){return{\u0275kind:t,\u0275providers:e}}function z6(...t){const e=[Vw,qL,QL,{provide:lS,useExisting:QL},{provide:cS,useExisting:qL},{provide:Uw,useValue:U6,multi:!0},{provide:uO,useValue:!0},{provide:n$,useClass:V6}];for(const s of t)e.push(...s.\u0275providers);return function py(t){return{\u0275providers:t}}(e)}const s$=new Zn("LEGACY_INTERCEPTOR_FN");let H6=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[z6(Jy(d_.LegacyInterceptors,[{provide:s$,useFactory:R6},{provide:Uw,useExisting:s$,multi:!0}]))]}),e})();function r$(t){return!!t&&(t instanceof Ue||U(t.lift)&&U(t.subscribe))}function qy(...t){const e=Xa(t),s=ol(t),{args:n,keys:r}=PF(t);if(0===n.length)return Hi([],e);const i=new Ue(function Z6(t,e,s=v){return n=>{i$(e,()=>{const{length:r}=t,i=new Array(r);let a=r,c=r;for(let f=0;f<r;f++)i$(e,()=>{const g=Hi(t[f],e);let E=!1;g.subscribe(ps(n,A=>{i[f]=A,E||(E=!0,c--),c||n.next(s(i.slice()))},()=>{--a||n.complete()}))},n)},n)}}(n,e,r?a=>FF(r,a):v));return s?i.pipe(U2(s)):i}function i$(t,e,s){t?ko(s,t,e):e()}const hS=Z(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"});function zw(...t){return function Q6(){return Ka(1)}()(Hi(t,Xa(t)))}function hb(t){return new Ue(e=>{Jr(t()).subscribe(e)})}function pb(t,e){const s=U(t)?t:()=>t,n=r=>r.error(s());return new Ue(e?r=>e.schedule(n,0,r):n)}function dO(){return Dn((t,e)=>{let s=null;t._refCount++;const n=ps(e,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount)return void(s=null);const r=t._connection,i=s;s=null,r&&(!i||r===i)&&r.unsubscribe(),e.unsubscribe()});t.subscribe(n),n.closed||(s=t.connect())})}class hO extends Ue{constructor(e,s){super(),this.source=e,this.subjectFactory=s,this._subject=null,this._refCount=0,this._connection=null,Qn(e)&&(this.lift=e.lift)}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return(!e||e.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:e}=this;this._subject=this._connection=null,e?.unsubscribe()}connect(){let e=this._connection;if(!e){e=this._connection=new I;const s=this.getSubject();e.add(this.source.subscribe(ps(s,void 0,()=>{this._teardown(),s.complete()},n=>{this._teardown(),s.error(n)},()=>this._teardown()))),e.closed&&(this._connection=null,e=I.EMPTY)}return e}refCount(){return dO()(this)}}function $l(t){return t<=0?()=>so:Dn((e,s)=>{let n=0;e.subscribe(ps(s,r=>{++n<=t&&(s.next(r),t<=n&&s.complete())}))})}function ed(...t){const e=Xa(t);return Dn((s,n)=>{(e?zw(t,s,e):zw(t,s)).subscribe(n)})}function pS(t){return Dn((e,s)=>{let n=!1;e.subscribe(ps(s,r=>{n=!0,s.next(r)},()=>{n||s.next(t),s.complete()}))})}function o$(t=J6){return Dn((e,s)=>{let n=!1;e.subscribe(ps(s,r=>{n=!0,s.next(r)},()=>n?s.complete():s.error(t())))})}function J6(){return new hS}function e0(t,e){const s=arguments.length>=2;return n=>n.pipe(t?tc((r,i)=>t(r,i,n)):v,$l(1),s?pS(e):o$(()=>new hS))}function Kc(t,e,s){const n=U(t)||e||s?{next:t,error:e,complete:s}:t;return n?Dn((r,i)=>{var a;null===(a=n.subscribe)||void 0===a||a.call(n);let c=!0;r.subscribe(ps(i,f=>{var g;null===(g=n.next)||void 0===g||g.call(n,f),i.next(f)},()=>{var f;c=!1,null===(f=n.complete)||void 0===f||f.call(n),i.complete()},f=>{var g;c=!1,null===(g=n.error)||void 0===g||g.call(n,f),i.error(f)},()=>{var f,g;c&&(null===(f=n.unsubscribe)||void 0===f||f.call(n)),null===(g=n.finalize)||void 0===g||g.call(n)}))}):v}function h_(t){return Dn((e,s)=>{let i,n=null,r=!1;n=e.subscribe(ps(s,void 0,void 0,a=>{i=Jr(t(a,h_(t)(e))),n?(n.unsubscribe(),n=null,i.subscribe(s)):r=!0})),r&&(n.unsubscribe(),n=null,i.subscribe(s))})}function pO(t){return t<=0?()=>so:Dn((e,s)=>{let n=[];e.subscribe(ps(s,r=>{n.push(r),t<n.length&&n.shift()},()=>{for(const r of n)s.next(r);s.complete()},void 0,()=>{n=null}))})}function fo(t){return Dn((e,s)=>{Jr(t).subscribe(ps(s,()=>s.complete(),D)),!s.closed&&e.subscribe(s)})}const bo="primary",Ww=Symbol("RouteTitle");class nK{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const s=this.params[e];return Array.isArray(s)?s[0]:s}return null}getAll(e){if(this.has(e)){const s=this.params[e];return Array.isArray(s)?s:[s]}return[]}get keys(){return Object.keys(this.params)}}function fb(t){return new nK(t)}function sK(t,e,s){const n=s.path.split("/");if(n.length>t.length||"full"===s.pathMatch&&(e.hasChildren()||n.length<t.length))return null;const r={};for(let i=0;i<n.length;i++){const a=n[i],c=t[i];if(a.startsWith(":"))r[a.substring(1)]=c;else if(a!==c.path)return null}return{consumed:t.slice(0,n.length),posParams:r}}function Nf(t,e){const s=t?Object.keys(t):void 0,n=e?Object.keys(e):void 0;if(!s||!n||s.length!=n.length)return!1;let r;for(let i=0;i<s.length;i++)if(r=s[i],!l$(t[r],e[r]))return!1;return!0}function l$(t,e){if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;const s=[...t].sort(),n=[...e].sort();return s.every((r,i)=>n[i]===r)}return t===e}function c$(t){return t.length>0?t[t.length-1]:null}function p_(t){return r$(t)?t:By(t)?Hi(Promise.resolve(t)):Xs(t)}const iK={exact:function h$(t,e,s){if(!t0(t.segments,e.segments)||!fS(t.segments,e.segments,s)||t.numberOfChildren!==e.numberOfChildren)return!1;for(const n in e.children)if(!t.children[n]||!h$(t.children[n],e.children[n],s))return!1;return!0},subset:p$},u$={exact:function oK(t,e){return Nf(t,e)},subset:function aK(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(s=>l$(t[s],e[s]))},ignored:()=>!0};function d$(t,e,s){return iK[s.paths](t.root,e.root,s.matrixParams)&&u$[s.queryParams](t.queryParams,e.queryParams)&&!("exact"===s.fragment&&t.fragment!==e.fragment)}function p$(t,e,s){return f$(t,e,e.segments,s)}function f$(t,e,s,n){if(t.segments.length>s.length){const r=t.segments.slice(0,s.length);return!(!t0(r,s)||e.hasChildren()||!fS(r,s,n))}if(t.segments.length===s.length){if(!t0(t.segments,s)||!fS(t.segments,s,n))return!1;for(const r in e.children)if(!t.children[r]||!p$(t.children[r],e.children[r],n))return!1;return!0}{const r=s.slice(0,t.segments.length),i=s.slice(t.segments.length);return!!(t0(t.segments,r)&&fS(t.segments,r,n)&&t.children[bo])&&f$(t.children[bo],e,i,n)}}function fS(t,e,s){return e.every((n,r)=>u$[s](t[r].parameters,n.parameters))}class mb{constructor(e=new Tl([],{}),s={},n=null){this.root=e,this.queryParams=s,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=fb(this.queryParams)),this._queryParamMap}toString(){return uK.serialize(this)}}class Tl{constructor(e,s){this.segments=e,this.children=s,this.parent=null,Object.values(s).forEach(n=>n.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return mS(this)}}class Hw{constructor(e,s){this.path=e,this.parameters=s}get parameterMap(){return this._parameterMap||(this._parameterMap=fb(this.parameters)),this._parameterMap}toString(){return _$(this)}}function t0(t,e){return t.length===e.length&&t.every((s,n)=>s.path===e[n].path)}let jw=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(){return new fO},providedIn:"root"}),e})();class fO{parse(e){const s=new xK(e);return new mb(s.parseRootSegment(),s.parseQueryParams(),s.parseFragment())}serialize(e){const s=`/${Gw(e.root,!0)}`,n=function pK(t){const e=Object.keys(t).map(s=>{const n=t[s];return Array.isArray(n)?n.map(r=>`${gS(s)}=${gS(r)}`).join("&"):`${gS(s)}=${gS(n)}`}).filter(s=>!!s);return e.length?`?${e.join("&")}`:""}(e.queryParams);return`${s}${n}${"string"==typeof e.fragment?`#${function dK(t){return encodeURI(t)}(e.fragment)}`:""}`}}const uK=new fO;function mS(t){return t.segments.map(e=>_$(e)).join("/")}function Gw(t,e){if(!t.hasChildren())return mS(t);if(e){const s=t.children[bo]?Gw(t.children[bo],!1):"",n=[];return Object.entries(t.children).forEach(([r,i])=>{r!==bo&&n.push(`${r}:${Gw(i,!1)}`)}),n.length>0?`${s}(${n.join("//")})`:s}{const s=function cK(t,e){let s=[];return Object.entries(t.children).forEach(([n,r])=>{n===bo&&(s=s.concat(e(r,n)))}),Object.entries(t.children).forEach(([n,r])=>{n!==bo&&(s=s.concat(e(r,n)))}),s}(t,(n,r)=>r===bo?[Gw(t.children[bo],!1)]:[`${r}:${Gw(n,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[bo]?`${mS(t)}/${s[0]}`:`${mS(t)}/(${s.join("//")})`}}function m$(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function gS(t){return m$(t).replace(/%3B/gi,";")}function mO(t){return m$(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function _S(t){return decodeURIComponent(t)}function g$(t){return _S(t.replace(/\+/g,"%20"))}function _$(t){return`${mO(t.path)}${function hK(t){return Object.keys(t).map(e=>`;${mO(e)}=${mO(t[e])}`).join("")}(t.parameters)}`}const fK=/^[^\/()?;#]+/;function gO(t){const e=t.match(fK);return e?e[0]:""}const mK=/^[^\/()?;=#]+/,_K=/^[^=?&#]+/,vK=/^[^&#]+/;class xK{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Tl([],{}):new Tl([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let s={};this.peekStartsWith("/(")&&(this.capture("/"),s=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(s).length>0)&&(n[bo]=new Tl(e,s)),n}parseSegment(){const e=gO(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new En(4009,!1);return this.capture(e),new Hw(_S(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const s=function gK(t){const e=t.match(mK);return e?e[0]:""}(this.remaining);if(!s)return;this.capture(s);let n="";if(this.consumeOptional("=")){const r=gO(this.remaining);r&&(n=r,this.capture(n))}e[_S(s)]=_S(n)}parseQueryParam(e){const s=function yK(t){const e=t.match(_K);return e?e[0]:""}(this.remaining);if(!s)return;this.capture(s);let n="";if(this.consumeOptional("=")){const a=function bK(t){const e=t.match(vK);return e?e[0]:""}(this.remaining);a&&(n=a,this.capture(n))}const r=g$(s),i=g$(n);if(e.hasOwnProperty(r)){let a=e[r];Array.isArray(a)||(a=[a],e[r]=a),a.push(i)}else e[r]=i}parseParens(e){const s={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=gO(this.remaining),r=this.remaining[n.length];if("/"!==r&&")"!==r&&";"!==r)throw new En(4010,!1);let i;n.indexOf(":")>-1?(i=n.slice(0,n.indexOf(":")),this.capture(i),this.capture(":")):e&&(i=bo);const a=this.parseChildren();s[i]=1===Object.keys(a).length?a[bo]:new Tl([],a),this.consumeOptional("//")}return s}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new En(4011,!1)}}function y$(t){return t.segments.length>0?new Tl([],{[bo]:t}):t}function v$(t){const e={};for(const n of Object.keys(t.children)){const i=v$(t.children[n]);if(n===bo&&0===i.segments.length&&i.hasChildren())for(const[a,c]of Object.entries(i.children))e[a]=c;else(i.segments.length>0||i.hasChildren())&&(e[n]=i)}return function wK(t){if(1===t.numberOfChildren&&t.children[bo]){const e=t.children[bo];return new Tl(t.segments.concat(e.segments),e.children)}return t}(new Tl(t.segments,e))}function n0(t){return t instanceof mb}function b$(t){let e;const r=y$(function s(i){const a={};for(const f of i.children){const g=s(f);a[f.outlet]=g}const c=new Tl(i.url,a);return i===t&&(e=c),c}(t.root));return e??r}function x$(t,e,s,n){let r=t;for(;r.parent;)r=r.parent;if(0===e.length)return _O(r,r,r,s,n);const i=function EK(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new C$(!0,0,t);let e=0,s=!1;const n=t.reduce((r,i,a)=>{if("object"==typeof i&&null!=i){if(i.outlets){const c={};return Object.entries(i.outlets).forEach(([f,g])=>{c[f]="string"==typeof g?g.split("/"):g}),[...r,{outlets:c}]}if(i.segmentPath)return[...r,i.segmentPath]}return"string"!=typeof i?[...r,i]:0===a?(i.split("/").forEach((c,f)=>{0==f&&"."===c||(0==f&&""===c?s=!0:".."===c?e++:""!=c&&r.push(c))}),r):[...r,i]},[]);return new C$(s,e,n)}(e);if(i.toRoot())return _O(r,r,new Tl([],{}),s,n);const a=function DK(t,e,s){if(t.isAbsolute)return new vS(e,!0,0);if(!s)return new vS(e,!1,NaN);if(null===s.parent)return new vS(s,!0,0);const n=yS(t.commands[0])?0:1;return function SK(t,e,s){let n=t,r=e,i=s;for(;i>r;){if(i-=r,n=n.parent,!n)throw new En(4005,!1);r=n.segments.length}return new vS(n,!1,r-i)}(s,s.segments.length-1+n,t.numberOfDoubleDots)}(i,r,t),c=a.processChildren?Xw(a.segmentGroup,a.index,i.commands):E$(a.segmentGroup,a.index,i.commands);return _O(r,a.segmentGroup,c,s,n)}function yS(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function Kw(t){return"object"==typeof t&&null!=t&&t.outlets}function _O(t,e,s,n,r){let a,i={};n&&Object.entries(n).forEach(([f,g])=>{i[f]=Array.isArray(g)?g.map(E=>`${E}`):`${g}`}),a=t===e?s:w$(t,e,s);const c=y$(v$(a));return new mb(c,i,r)}function w$(t,e,s){const n={};return Object.entries(t.children).forEach(([r,i])=>{n[r]=i===e?s:w$(i,e,s)}),new Tl(t.segments,n)}class C${constructor(e,s,n){if(this.isAbsolute=e,this.numberOfDoubleDots=s,this.commands=n,e&&n.length>0&&yS(n[0]))throw new En(4003,!1);const r=n.find(Kw);if(r&&r!==c$(n))throw new En(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class vS{constructor(e,s,n){this.segmentGroup=e,this.processChildren=s,this.index=n}}function E$(t,e,s){if(t||(t=new Tl([],{})),0===t.segments.length&&t.hasChildren())return Xw(t,e,s);const n=function TK(t,e,s){let n=0,r=e;const i={match:!1,pathIndex:0,commandIndex:0};for(;r<t.segments.length;){if(n>=s.length)return i;const a=t.segments[r],c=s[n];if(Kw(c))break;const f=`${c}`,g=n<s.length-1?s[n+1]:null;if(r>0&&void 0===f)break;if(f&&g&&"object"==typeof g&&void 0===g.outlets){if(!S$(f,g,a))return i;n+=2}else{if(!S$(f,{},a))return i;n++}r++}return{match:!0,pathIndex:r,commandIndex:n}}(t,e,s),r=s.slice(n.commandIndex);if(n.match&&n.pathIndex<t.segments.length){const i=new Tl(t.segments.slice(0,n.pathIndex),{});return i.children[bo]=new Tl(t.segments.slice(n.pathIndex),t.children),Xw(i,0,r)}return n.match&&0===r.length?new Tl(t.segments,{}):n.match&&!t.hasChildren()?yO(t,e,s):n.match?Xw(t,0,r):yO(t,e,s)}function Xw(t,e,s){if(0===s.length)return new Tl(t.segments,{});{const n=function IK(t){return Kw(t[0])?t[0].outlets:{[bo]:t}}(s),r={};if(Object.keys(n).some(i=>i!==bo)&&t.children[bo]&&1===t.numberOfChildren&&0===t.children[bo].segments.length){const i=Xw(t.children[bo],e,s);return new Tl(t.segments,i.children)}return Object.entries(n).forEach(([i,a])=>{"string"==typeof a&&(a=[a]),null!==a&&(r[i]=E$(t.children[i],e,a))}),Object.entries(t.children).forEach(([i,a])=>{void 0===n[i]&&(r[i]=a)}),new Tl(t.segments,r)}}function yO(t,e,s){const n=t.segments.slice(0,e);let r=0;for(;r<s.length;){const i=s[r];if(Kw(i)){const f=AK(i.outlets);return new Tl(n,f)}if(0===r&&yS(s[0])){n.push(new Hw(t.segments[e].path,D$(s[0]))),r++;continue}const a=Kw(i)?i.outlets[bo]:`${i}`,c=r<s.length-1?s[r+1]:null;a&&c&&yS(c)?(n.push(new Hw(a,D$(c))),r+=2):(n.push(new Hw(a,{})),r++)}return new Tl(n,{})}function AK(t){const e={};return Object.entries(t).forEach(([s,n])=>{"string"==typeof n&&(n=[n]),null!==n&&(e[s]=yO(new Tl([],{}),0,n))}),e}function D$(t){const e={};return Object.entries(t).forEach(([s,n])=>e[s]=`${n}`),e}function S$(t,e,s){return t==s.path&&Nf(e,s.parameters)}const Yw="imperative";class Mf{constructor(e,s){this.id=e,this.url=s}}class bS extends Mf{constructor(e,s,n="imperative",r=null){super(e,s),this.type=0,this.navigationTrigger=n,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class f_ extends Mf{constructor(e,s,n){super(e,s),this.urlAfterRedirects=n,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Zw extends Mf{constructor(e,s,n,r){super(e,s),this.reason=n,this.code=r,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class gb extends Mf{constructor(e,s,n,r){super(e,s),this.reason=n,this.code=r,this.type=16}}class xS extends Mf{constructor(e,s,n,r){super(e,s),this.error=n,this.target=r,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class I$ extends Mf{constructor(e,s,n,r){super(e,s),this.urlAfterRedirects=n,this.state=r,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class kK extends Mf{constructor(e,s,n,r){super(e,s),this.urlAfterRedirects=n,this.state=r,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class OK extends Mf{constructor(e,s,n,r,i){super(e,s),this.urlAfterRedirects=n,this.state=r,this.shouldActivate=i,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class RK extends Mf{constructor(e,s,n,r){super(e,s),this.urlAfterRedirects=n,this.state=r,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class NK extends Mf{constructor(e,s,n,r){super(e,s),this.urlAfterRedirects=n,this.state=r,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class MK{constructor(e){this.route=e,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class PK{constructor(e){this.route=e,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class FK{constructor(e){this.snapshot=e,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class LK{constructor(e){this.snapshot=e,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class $K{constructor(e){this.snapshot=e,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class BK{constructor(e){this.snapshot=e,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class T${constructor(e,s,n){this.routerEvent=e,this.position=s,this.anchor=n,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class vO{}class bO{constructor(e){this.url=e}}class VK{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new Qw,this.attachRef=null}}let Qw=(()=>{var t;class e{constructor(){this.contexts=new Map}onChildOutletCreated(n,r){const i=this.getOrCreateContext(n);i.outlet=r,this.contexts.set(n,i)}onChildOutletDestroyed(n){const r=this.getContext(n);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const n=this.contexts;return this.contexts=new Map,n}onOutletReAttached(n){this.contexts=n}getOrCreateContext(n){let r=this.getContext(n);return r||(r=new VK,this.contexts.set(n,r)),r}getContext(n){return this.contexts.get(n)||null}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();class A${constructor(e){this._root=e}get root(){return this._root.value}parent(e){const s=this.pathFromRoot(e);return s.length>1?s[s.length-2]:null}children(e){const s=xO(e,this._root);return s?s.children.map(n=>n.value):[]}firstChild(e){const s=xO(e,this._root);return s&&s.children.length>0?s.children[0].value:null}siblings(e){const s=wO(e,this._root);return s.length<2?[]:s[s.length-2].children.map(r=>r.value).filter(r=>r!==e)}pathFromRoot(e){return wO(e,this._root).map(s=>s.value)}}function xO(t,e){if(t===e.value)return e;for(const s of e.children){const n=xO(t,s);if(n)return n}return null}function wO(t,e){if(t===e.value)return[e];for(const s of e.children){const n=wO(t,s);if(n.length)return n.unshift(e),n}return[]}class Pm{constructor(e,s){this.value=e,this.children=s}toString(){return`TreeNode(${this.value})`}}function _b(t){const e={};return t&&t.children.forEach(s=>e[s.value.outlet]=s),e}class k$ extends A${constructor(e,s){super(e),this.snapshot=s,CO(this,e)}toString(){return this.snapshot.toString()}}function O$(t,e){const s=function UK(t,e){const a=new wS([],{},{},"",{},bo,e,null,{});return new N$("",new Pm(a,[]))}(0,e),n=new Di([new Hw("",{})]),r=new Di({}),i=new Di({}),a=new Di({}),c=new Di(""),f=new yb(n,r,a,c,i,bo,e,s.root);return f.snapshot=s.root,new k$(new Pm(f,[]),s)}class yb{constructor(e,s,n,r,i,a,c,f){this.urlSubject=e,this.paramsSubject=s,this.queryParamsSubject=n,this.fragmentSubject=r,this.dataSubject=i,this.outlet=a,this.component=c,this._futureSnapshot=f,this.title=this.dataSubject?.pipe(Xn(g=>g[Ww]))??Xs(void 0),this.url=e,this.params=s,this.queryParams=n,this.fragment=r,this.data=i}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Xn(e=>fb(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Xn(e=>fb(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function R$(t,e="emptyOnly"){const s=t.pathFromRoot;let n=0;if("always"!==e)for(n=s.length-1;n>=1;){const r=s[n],i=s[n-1];if(r.routeConfig&&""===r.routeConfig.path)n--;else{if(i.component)break;n--}}return function zK(t){return t.reduce((e,s)=>({params:{...e.params,...s.params},data:{...e.data,...s.data},resolve:{...s.data,...e.resolve,...s.routeConfig?.data,...s._resolvedData}}),{params:{},data:{},resolve:{}})}(s.slice(n))}class wS{get title(){return this.data?.[Ww]}constructor(e,s,n,r,i,a,c,f,g){this.url=e,this.params=s,this.queryParams=n,this.fragment=r,this.data=i,this.outlet=a,this.component=c,this.routeConfig=f,this._resolve=g}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=fb(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=fb(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(n=>n.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class N$ extends A${constructor(e,s){super(s),this.url=e,CO(this,s)}toString(){return M$(this._root)}}function CO(t,e){e.value._routerState=t,e.children.forEach(s=>CO(t,s))}function M$(t){const e=t.children.length>0?` { ${t.children.map(M$).join(", ")} } `:"";return`${t.value}${e}`}function EO(t){if(t.snapshot){const e=t.snapshot,s=t._futureSnapshot;t.snapshot=s,Nf(e.queryParams,s.queryParams)||t.queryParamsSubject.next(s.queryParams),e.fragment!==s.fragment&&t.fragmentSubject.next(s.fragment),Nf(e.params,s.params)||t.paramsSubject.next(s.params),function rK(t,e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;++s)if(!Nf(t[s],e[s]))return!1;return!0}(e.url,s.url)||t.urlSubject.next(s.url),Nf(e.data,s.data)||t.dataSubject.next(s.data)}else t.snapshot=t._futureSnapshot,t.dataSubject.next(t._futureSnapshot.data)}function DO(t,e){const s=Nf(t.params,e.params)&&function lK(t,e){return t0(t,e)&&t.every((s,n)=>Nf(s.parameters,e[n].parameters))}(t.url,e.url);return s&&!(!t.parent!=!e.parent)&&(!t.parent||DO(t.parent,e.parent))}let SO=(()=>{var t;class e{constructor(){this.activated=null,this._activatedRoute=null,this.name=bo,this.activateEvents=new Rr,this.deactivateEvents=new Rr,this.attachEvents=new Rr,this.detachEvents=new Rr,this.parentContexts=jn(Qw),this.location=jn(jc),this.changeDetector=jn(Ll),this.environmentInjector=jn(Yu),this.inputBinder=jn(CS,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(n){if(n.name){const{firstChange:r,previousValue:i}=n.name;if(r)return;this.isTrackedInParentContexts(i)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(i)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(n){return this.parentContexts.getContext(n)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const n=this.parentContexts.getContext(this.name);n?.route&&(n.attachRef?this.attach(n.attachRef,n.route):this.activateWith(n.route,n.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new En(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new En(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new En(4012,!1);this.location.detach();const n=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(n.instance),n}attach(n,r){this.activated=n,this._activatedRoute=r,this.location.insert(n.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(n.instance)}deactivate(){if(this.activated){const n=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(n)}}activateWith(n,r){if(this.isActivated)throw new En(4013,!1);this._activatedRoute=n;const i=this.location,c=n.snapshot.component,f=this.parentContexts.getOrCreateContext(this.name).children,g=new WK(n,f,i.injector);this.activated=i.createComponent(c,{index:i.length,injector:g,environmentInjector:r??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[Ia]}),e})();class WK{constructor(e,s,n){this.route=e,this.childContexts=s,this.parent=n}get(e,s){return e===yb?this.route:e===Qw?this.childContexts:this.parent.get(e,s)}}const CS=new Zn("");let P$=(()=>{var t;class e{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(n){this.unsubscribeFromRouteData(n),this.subscribeToRouteData(n)}unsubscribeFromRouteData(n){this.outletDataSubscriptions.get(n)?.unsubscribe(),this.outletDataSubscriptions.delete(n)}subscribeToRouteData(n){const{activatedRoute:r}=n,i=qy([r.queryParams,r.params,r.data]).pipe(Qi(([a,c,f],g)=>(f={...a,...c,...f},0===g?Xs(f):Promise.resolve(f)))).subscribe(a=>{if(!n.isActivated||!n.activatedComponentRef||n.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(n);const c=function X5(t){const e=Vi(t);if(!e)return null;const s=new Ny(e);return{get selector(){return s.selector},get type(){return s.componentType},get inputs(){return s.inputs},get outputs(){return s.outputs},get ngContentSelectors(){return s.ngContentSelectors},get isStandalone(){return e.standalone},get isSignal(){return e.signals}}}(r.component);if(c)for(const{templateName:f}of c.inputs)n.activatedComponentRef.setInput(f,a[f]);else this.unsubscribeFromRouteData(n)});this.outletDataSubscriptions.set(n,i)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();function Jw(t,e,s){if(s&&t.shouldReuseRoute(e.value,s.value.snapshot)){const n=s.value;n._futureSnapshot=e.value;const r=function jK(t,e,s){return e.children.map(n=>{for(const r of s.children)if(t.shouldReuseRoute(n.value,r.value.snapshot))return Jw(t,n,r);return Jw(t,n)})}(t,e,s);return new Pm(n,r)}{if(t.shouldAttach(e.value)){const i=t.retrieve(e.value);if(null!==i){const a=i.route;return a.value._futureSnapshot=e.value,a.children=e.children.map(c=>Jw(t,c)),a}}const n=function GK(t){return new yb(new Di(t.url),new Di(t.params),new Di(t.queryParams),new Di(t.fragment),new Di(t.data),t.outlet,t.component,t)}(e.value),r=e.children.map(i=>Jw(t,i));return new Pm(n,r)}}const IO="ngNavigationCancelingError";function F$(t,e){const{redirectTo:s,navigationBehaviorOptions:n}=n0(e)?{redirectTo:e,navigationBehaviorOptions:void 0}:e,r=L$(!1,0,e);return r.url=s,r.navigationBehaviorOptions=n,r}function L$(t,e,s){const n=new Error("NavigationCancelingError: "+(t||""));return n[IO]=!0,n.cancellationCode=e,s&&(n.url=s),n}function $$(t){return t&&t[IO]}let B$=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275cmp=sr({type:t,selectors:[["ng-component"]],standalone:!0,features:[Pk],decls:1,vars:0,template:function(n,r){1&n&&ti(0,"router-outlet")},dependencies:[SO],encapsulation:2}),e})();function TO(t){const e=t.children&&t.children.map(TO),s=e?{...t,children:e}:{...t};return!s.component&&!s.loadComponent&&(e||s.loadChildren)&&s.outlet&&s.outlet!==bo&&(s.component=B$),s}function Xp(t){return t.outlet||bo}function qw(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let e=t.parent;e;e=e.parent){const s=e.routeConfig;if(s?._loadedInjector)return s._loadedInjector;if(s?._injector)return s._injector}return null}class e8{constructor(e,s,n,r,i){this.routeReuseStrategy=e,this.futureState=s,this.currState=n,this.forwardEvent=r,this.inputBindingEnabled=i}activate(e){const s=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(s,n,e),EO(this.futureState.root),this.activateChildRoutes(s,n,e)}deactivateChildRoutes(e,s,n){const r=_b(s);e.children.forEach(i=>{const a=i.value.outlet;this.deactivateRoutes(i,r[a],n),delete r[a]}),Object.values(r).forEach(i=>{this.deactivateRouteAndItsChildren(i,n)})}deactivateRoutes(e,s,n){const r=e.value,i=s?s.value:null;if(r===i)if(r.component){const a=n.getContext(r.outlet);a&&this.deactivateChildRoutes(e,s,a.children)}else this.deactivateChildRoutes(e,s,n);else i&&this.deactivateRouteAndItsChildren(s,n)}deactivateRouteAndItsChildren(e,s){e.value.component&&this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,s):this.deactivateRouteAndOutlet(e,s)}detachAndStoreRouteSubtree(e,s){const n=s.getContext(e.value.outlet),r=n&&e.value.component?n.children:s,i=_b(e);for(const a of Object.keys(i))this.deactivateRouteAndItsChildren(i[a],r);if(n&&n.outlet){const a=n.outlet.detach(),c=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:a,route:e,contexts:c})}}deactivateRouteAndOutlet(e,s){const n=s.getContext(e.value.outlet),r=n&&e.value.component?n.children:s,i=_b(e);for(const a of Object.keys(i))this.deactivateRouteAndItsChildren(i[a],r);n&&(n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated()),n.attachRef=null,n.route=null)}activateChildRoutes(e,s,n){const r=_b(s);e.children.forEach(i=>{this.activateRoutes(i,r[i.value.outlet],n),this.forwardEvent(new BK(i.value.snapshot))}),e.children.length&&this.forwardEvent(new LK(e.value.snapshot))}activateRoutes(e,s,n){const r=e.value,i=s?s.value:null;if(EO(r),r===i)if(r.component){const a=n.getOrCreateContext(r.outlet);this.activateChildRoutes(e,s,a.children)}else this.activateChildRoutes(e,s,n);else if(r.component){const a=n.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const c=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),a.children.onOutletReAttached(c.contexts),a.attachRef=c.componentRef,a.route=c.route.value,a.outlet&&a.outlet.attach(c.componentRef,c.route.value),EO(c.route.value),this.activateChildRoutes(e,null,a.children)}else{const c=qw(r.snapshot);a.attachRef=null,a.route=r,a.injector=c,a.outlet&&a.outlet.activateWith(r,a.injector),this.activateChildRoutes(e,null,a.children)}}else this.activateChildRoutes(e,null,n)}}class V${constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class ES{constructor(e,s){this.component=e,this.route=s}}function t8(t,e,s){const n=t._root;return eC(n,e?e._root:null,s,[n.value])}function vb(t,e){const s=Symbol(),n=e.get(t,s);return n===s?"function"!=typeof t||function os(t){return null!==qn(t)}(t)?e.get(t):t:n}function eC(t,e,s,n,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=_b(e);return t.children.forEach(a=>{(function s8(t,e,s,n,r={canDeactivateChecks:[],canActivateChecks:[]}){const i=t.value,a=e?e.value:null,c=s?s.getContext(t.value.outlet):null;if(a&&i.routeConfig===a.routeConfig){const f=function r8(t,e,s){if("function"==typeof s)return s(t,e);switch(s){case"pathParamsChange":return!t0(t.url,e.url);case"pathParamsOrQueryParamsChange":return!t0(t.url,e.url)||!Nf(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!DO(t,e)||!Nf(t.queryParams,e.queryParams);default:return!DO(t,e)}}(a,i,i.routeConfig.runGuardsAndResolvers);f?r.canActivateChecks.push(new V$(n)):(i.data=a.data,i._resolvedData=a._resolvedData),eC(t,e,i.component?c?c.children:null:s,n,r),f&&c&&c.outlet&&c.outlet.isActivated&&r.canDeactivateChecks.push(new ES(c.outlet.component,a))}else a&&tC(e,c,r),r.canActivateChecks.push(new V$(n)),eC(t,null,i.component?c?c.children:null:s,n,r)})(a,i[a.value.outlet],s,n.concat([a.value]),r),delete i[a.value.outlet]}),Object.entries(i).forEach(([a,c])=>tC(c,s.getContext(a),r)),r}function tC(t,e,s){const n=_b(t),r=t.value;Object.entries(n).forEach(([i,a])=>{tC(a,r.component?e?e.children.getContext(i):null:e,s)}),s.canDeactivateChecks.push(new ES(r.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,r))}function nC(t){return"function"==typeof t}function U$(t){return t instanceof hS||"EmptyError"===t?.name}const DS=Symbol("INITIAL_VALUE");function bb(){return Qi(t=>qy(t.map(e=>e.pipe($l(1),ed(DS)))).pipe(Xn(e=>{for(const s of e)if(!0!==s){if(s===DS)return DS;if(!1===s||s instanceof mb)return s}return!0}),tc(e=>e!==DS),$l(1)))}function z$(t){return function at(...t){return Xe(t)}(Kc(e=>{if(n0(e))throw F$(0,e)}),Xn(e=>!0===e))}class SS{constructor(e){this.segmentGroup=e||null}}class W${constructor(e){this.urlTree=e}}function xb(t){return pb(new SS(t))}function H$(t){return pb(new W$(t))}class E8{constructor(e,s){this.urlSerializer=e,this.urlTree=s}noMatchError(e){return new En(4002,!1)}lineralizeSegments(e,s){let n=[],r=s.root;for(;;){if(n=n.concat(r.segments),0===r.numberOfChildren)return Xs(n);if(r.numberOfChildren>1||!r.children[bo])return pb(new En(4e3,!1));r=r.children[bo]}}applyRedirectCommands(e,s,n){return this.applyRedirectCreateUrlTree(s,this.urlSerializer.parse(s),e,n)}applyRedirectCreateUrlTree(e,s,n,r){const i=this.createSegmentGroup(e,s.root,n,r);return new mb(i,this.createQueryParams(s.queryParams,this.urlTree.queryParams),s.fragment)}createQueryParams(e,s){const n={};return Object.entries(e).forEach(([r,i])=>{if("string"==typeof i&&i.startsWith(":")){const c=i.substring(1);n[r]=s[c]}else n[r]=i}),n}createSegmentGroup(e,s,n,r){const i=this.createSegments(e,s.segments,n,r);let a={};return Object.entries(s.children).forEach(([c,f])=>{a[c]=this.createSegmentGroup(e,f,n,r)}),new Tl(i,a)}createSegments(e,s,n,r){return s.map(i=>i.path.startsWith(":")?this.findPosParam(e,i,r):this.findOrReturn(i,n))}findPosParam(e,s,n){const r=n[s.path.substring(1)];if(!r)throw new En(4001,!1);return r}findOrReturn(e,s){let n=0;for(const r of s){if(r.path===e.path)return s.splice(n),r;n++}return e}}const AO={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function D8(t,e,s,n,r){const i=kO(t,e,s);return i.matched?(n=function XK(t,e){return t.providers&&!t._injector&&(t._injector=xw(t.providers,e,`Route: ${t.path}`)),t._injector??e}(e,n),function x8(t,e,s,n){const r=e.canMatch;return r&&0!==r.length?Xs(r.map(a=>{const c=vb(a,t);return p_(function u8(t){return t&&nC(t.canMatch)}(c)?c.canMatch(e,s):t.runInContext(()=>c(e,s)))})).pipe(bb(),z$()):Xs(!0)}(n,e,s).pipe(Xn(a=>!0===a?i:{...AO}))):Xs(i)}function kO(t,e,s){if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||s.length>0)?{...AO}:{matched:!0,consumedSegments:[],remainingSegments:s,parameters:{},positionalParamSegments:{}};const r=(e.matcher||sK)(s,t,e);if(!r)return{...AO};const i={};Object.entries(r.posParams??{}).forEach(([c,f])=>{i[c]=f.path});const a=r.consumed.length>0?{...i,...r.consumed[r.consumed.length-1].parameters}:i;return{matched:!0,consumedSegments:r.consumed,remainingSegments:s.slice(r.consumed.length),parameters:a,positionalParamSegments:r.posParams??{}}}function j$(t,e,s,n){return s.length>0&&function T8(t,e,s){return s.some(n=>IS(t,e,n)&&Xp(n)!==bo)}(t,s,n)?{segmentGroup:new Tl(e,I8(n,new Tl(s,t.children))),slicedSegments:[]}:0===s.length&&function A8(t,e,s){return s.some(n=>IS(t,e,n))}(t,s,n)?{segmentGroup:new Tl(t.segments,S8(t,0,s,n,t.children)),slicedSegments:s}:{segmentGroup:new Tl(t.segments,t.children),slicedSegments:s}}function S8(t,e,s,n,r){const i={};for(const a of n)if(IS(t,s,a)&&!r[Xp(a)]){const c=new Tl([],{});i[Xp(a)]=c}return{...r,...i}}function I8(t,e){const s={};s[bo]=e;for(const n of t)if(""===n.path&&Xp(n)!==bo){const r=new Tl([],{});s[Xp(n)]=r}return s}function IS(t,e,s){return(!(t.hasChildren()||e.length>0)||"full"!==s.pathMatch)&&""===s.path}class N8{constructor(e,s,n,r,i,a,c){this.injector=e,this.configLoader=s,this.rootComponentType=n,this.config=r,this.urlTree=i,this.paramsInheritanceStrategy=a,this.urlSerializer=c,this.allowRedirects=!0,this.applyRedirects=new E8(this.urlSerializer,this.urlTree)}noMatchError(e){return new En(4002,!1)}recognize(){const e=j$(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,e,bo).pipe(h_(s=>{if(s instanceof W$)return this.allowRedirects=!1,this.urlTree=s.urlTree,this.match(s.urlTree);throw s instanceof SS?this.noMatchError(s):s}),Xn(s=>{const n=new wS([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},bo,this.rootComponentType,null,{}),r=new Pm(n,s),i=new N$("",r),a=function CK(t,e,s=null,n=null){return x$(b$(t),e,s,n)}(n,[],this.urlTree.queryParams,this.urlTree.fragment);return a.queryParams=this.urlTree.queryParams,i.url=this.urlSerializer.serialize(a),this.inheritParamsAndData(i._root),{state:i,tree:a}}))}match(e){return this.processSegmentGroup(this.injector,this.config,e.root,bo).pipe(h_(n=>{throw n instanceof SS?this.noMatchError(n):n}))}inheritParamsAndData(e){const s=e.value,n=R$(s,this.paramsInheritanceStrategy);s.params=Object.freeze(n.params),s.data=Object.freeze(n.data),e.children.forEach(r=>this.inheritParamsAndData(r))}processSegmentGroup(e,s,n,r){return 0===n.segments.length&&n.hasChildren()?this.processChildren(e,s,n):this.processSegment(e,s,n,n.segments,r,!0)}processChildren(e,s,n){const r=[];for(const i of Object.keys(n.children))"primary"===i?r.unshift(i):r.push(i);return Hi(r).pipe(lb(i=>{const a=n.children[i],c=function JK(t,e){const s=t.filter(n=>Xp(n)===e);return s.push(...t.filter(n=>Xp(n)!==e)),s}(s,i);return this.processSegmentGroup(e,c,a,i)}),function eK(t,e){return Dn(function q6(t,e,s,n,r){return(i,a)=>{let c=s,f=e,g=0;i.subscribe(ps(a,E=>{const A=g++;f=c?t(f,E,A):(c=!0,E),n&&a.next(f)},r&&(()=>{c&&a.next(f),a.complete()})))}}(t,e,arguments.length>=2,!0))}((i,a)=>(i.push(...a),i)),pS(null),function tK(t,e){const s=arguments.length>=2;return n=>n.pipe(t?tc((r,i)=>t(r,i,n)):v,pO(1),s?pS(e):o$(()=>new hS))}(),no(i=>{if(null===i)return xb(n);const a=G$(i);return function M8(t){t.sort((e,s)=>e.value.outlet===bo?-1:s.value.outlet===bo?1:e.value.outlet.localeCompare(s.value.outlet))}(a),Xs(a)}))}processSegment(e,s,n,r,i,a){return Hi(s).pipe(lb(c=>this.processSegmentAgainstRoute(c._injector??e,s,c,n,r,i,a).pipe(h_(f=>{if(f instanceof SS)return Xs(null);throw f}))),e0(c=>!!c),h_(c=>{if(U$(c))return function O8(t,e,s){return 0===e.length&&!t.children[s]}(n,r,i)?Xs([]):xb(n);throw c}))}processSegmentAgainstRoute(e,s,n,r,i,a,c){return function k8(t,e,s,n){return!!(Xp(t)===n||n!==bo&&IS(e,s,t))&&("**"===t.path||kO(e,t,s).matched)}(n,r,i,a)?void 0===n.redirectTo?this.matchSegmentAgainstRoute(e,r,n,i,a,c):c&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,r,s,n,i,a):xb(r):xb(r)}expandSegmentAgainstRouteUsingRedirect(e,s,n,r,i,a){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,r,a):this.expandRegularSegmentAgainstRouteUsingRedirect(e,s,n,r,i,a)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,s,n,r){const i=this.applyRedirects.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?H$(i):this.applyRedirects.lineralizeSegments(n,i).pipe(no(a=>{const c=new Tl(a,{});return this.processSegment(e,s,c,a,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,s,n,r,i,a){const{matched:c,consumedSegments:f,remainingSegments:g,positionalParamSegments:E}=kO(s,r,i);if(!c)return xb(s);const A=this.applyRedirects.applyRedirectCommands(f,r.redirectTo,E);return r.redirectTo.startsWith("/")?H$(A):this.applyRedirects.lineralizeSegments(r,A).pipe(no(Y=>this.processSegment(e,n,s,Y.concat(g),a,!1)))}matchSegmentAgainstRoute(e,s,n,r,i,a){let c;if("**"===n.path){const f=r.length>0?c$(r).parameters:{};c=Xs({snapshot:new wS(r,f,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,K$(n),Xp(n),n.component??n._loadedComponent??null,n,X$(n)),consumedSegments:[],remainingSegments:[]}),s.children={}}else c=D8(s,n,r,e).pipe(Xn(({matched:f,consumedSegments:g,remainingSegments:E,parameters:A})=>f?{snapshot:new wS(g,A,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,K$(n),Xp(n),n.component??n._loadedComponent??null,n,X$(n)),consumedSegments:g,remainingSegments:E}:null));return c.pipe(Qi(f=>null===f?xb(s):this.getChildConfig(e=n._injector??e,n,r).pipe(Qi(({routes:g})=>{const E=n._loadedInjector??e,{snapshot:A,consumedSegments:Y,remainingSegments:ne}=f,{segmentGroup:Ee,slicedSegments:Ge}=j$(s,Y,ne,g);if(0===Ge.length&&Ee.hasChildren())return this.processChildren(E,g,Ee).pipe(Xn(Nt=>null===Nt?null:[new Pm(A,Nt)]));if(0===g.length&&0===Ge.length)return Xs([new Pm(A,[])]);const tt=Xp(n)===i;return this.processSegment(E,g,Ee,Ge,tt?bo:i,!0).pipe(Xn(Nt=>[new Pm(A,Nt)]))}))))}getChildConfig(e,s,n){return s.children?Xs({routes:s.children,injector:e}):s.loadChildren?void 0!==s._loadedRoutes?Xs({routes:s._loadedRoutes,injector:s._loadedInjector}):function b8(t,e,s,n){const r=e.canLoad;return void 0===r||0===r.length?Xs(!0):Xs(r.map(a=>{const c=vb(a,t);return p_(function o8(t){return t&&nC(t.canLoad)}(c)?c.canLoad(e,s):t.runInContext(()=>c(e,s)))})).pipe(bb(),z$())}(e,s,n).pipe(no(r=>r?this.configLoader.loadChildren(e,s).pipe(Kc(i=>{s._loadedRoutes=i.routes,s._loadedInjector=i.injector})):function C8(t){return pb(L$(!1,3))}())):Xs({routes:[],injector:e})}}function P8(t){const e=t.value.routeConfig;return e&&""===e.path}function G$(t){const e=[],s=new Set;for(const n of t){if(!P8(n)){e.push(n);continue}const r=e.find(i=>n.value.routeConfig===i.value.routeConfig);void 0!==r?(r.children.push(...n.children),s.add(r)):e.push(n)}for(const n of s){const r=G$(n.children);e.push(new Pm(n.value,r))}return e.filter(n=>!s.has(n))}function K$(t){return t.data||{}}function X$(t){return t.resolve||{}}function L8(t,e){return no(s=>{const{targetSnapshot:n,guards:{canActivateChecks:r}}=s;if(!r.length)return Xs(s);let i=0;return Hi(r).pipe(lb(a=>function $8(t,e,s,n){const r=t.routeConfig,i=t._resolve;return void 0!==r?.title&&!Y$(r)&&(i[Ww]=r.title),function B8(t,e,s,n){const r=function V8(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===r.length)return Xs({});const i={};return Hi(r).pipe(no(a=>function U8(t,e,s,n){const r=qw(e)??n,i=vb(t,r);return p_(i.resolve?i.resolve(e,s):r.runInContext(()=>i(e,s)))}(t[a],e,s,n).pipe(e0(),Kc(c=>{i[a]=c}))),pO(1),function a$(t){return Xn(()=>t)}(i),h_(a=>U$(a)?so:pb(a)))}(i,t,e,n).pipe(Xn(a=>(t._resolvedData=a,t.data=R$(t,s).resolve,r&&Y$(r)&&(t.data[Ww]=r.title),null)))}(a.route,n,t,e)),Kc(()=>i++),pO(1),no(a=>i===r.length?Xs(s):so))})}function Y$(t){return"string"==typeof t.title||null===t.title}function OO(t){return Qi(e=>{const s=t(e);return s?Hi(s).pipe(Xn(()=>e)):Xs(e)})}const wb=new Zn("ROUTES");let RO=(()=>{var t;class e{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=jn(cP)}loadComponent(n){if(this.componentLoaders.get(n))return this.componentLoaders.get(n);if(n._loadedComponent)return Xs(n._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(n);const r=p_(n.loadComponent()).pipe(Xn(Z$),Kc(a=>{this.onLoadEndListener&&this.onLoadEndListener(n),n._loadedComponent=a}),cb(()=>{this.componentLoaders.delete(n)})),i=new hO(r,()=>new Bt).pipe(dO());return this.componentLoaders.set(n,i),i}loadChildren(n,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Xs({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const a=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(Xn(f=>{this.onLoadEndListener&&this.onLoadEndListener(r);let g,E;return Array.isArray(f)?E=f:(g=f.create(n).injector,E=g.get(wb,[],Jt.Self|Jt.Optional).flat()),{routes:E.map(TO),injector:g}}),cb(()=>{this.childrenLoaders.delete(r)})),c=new hO(a,()=>new Bt).pipe(dO());return this.childrenLoaders.set(r,c),c}loadModuleFactoryOrRoutes(n){return p_(n()).pipe(Xn(Z$),no(r=>r instanceof Hp||Array.isArray(r)?Xs(r):Hi(this.compiler.compileModuleAsync(r))))}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function Z$(t){return function z8(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}let TS=(()=>{var t;class e{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.currentTransition=null,this.lastSuccessfulNavigation=null,this.events=new Bt,this.transitionAbortSubject=new Bt,this.configLoader=jn(RO),this.environmentInjector=jn(Yu),this.urlSerializer=jn(jw),this.rootContexts=jn(Qw),this.inputBindingEnabled=null!==jn(CS,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>Xs(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=i=>this.events.next(new PK(i)),this.configLoader.onLoadStartListener=i=>this.events.next(new MK(i))}complete(){this.transitions?.complete()}handleNavigationRequest(n){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...n,id:r})}setupNavigations(n,r,i){return this.transitions=new Di({id:0,currentUrlTree:r,currentRawUrl:r,currentBrowserUrl:r,extractedUrl:n.urlHandlingStrategy.extract(r),urlAfterRedirects:n.urlHandlingStrategy.extract(r),rawUrl:r,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:Yw,restoredState:null,currentSnapshot:i.snapshot,targetSnapshot:null,currentRouterState:i,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(tc(a=>0!==a.id),Xn(a=>({...a,extractedUrl:n.urlHandlingStrategy.extract(a.rawUrl)})),Qi(a=>{this.currentTransition=a;let c=!1,f=!1;return Xs(a).pipe(Kc(g=>{this.currentNavigation={id:g.id,initialUrl:g.rawUrl,extractedUrl:g.extractedUrl,trigger:g.source,extras:g.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),Qi(g=>{const E=g.currentBrowserUrl.toString(),A=!n.navigated||g.extractedUrl.toString()!==E||E!==g.currentUrlTree.toString();if(!A&&"reload"!==(g.extras.onSameUrlNavigation??n.onSameUrlNavigation)){const ne="";return this.events.next(new gb(g.id,this.urlSerializer.serialize(g.rawUrl),ne,0)),g.resolve(null),so}if(n.urlHandlingStrategy.shouldProcessUrl(g.rawUrl))return Xs(g).pipe(Qi(ne=>{const Ee=this.transitions?.getValue();return this.events.next(new bS(ne.id,this.urlSerializer.serialize(ne.extractedUrl),ne.source,ne.restoredState)),Ee!==this.transitions?.getValue()?so:Promise.resolve(ne)}),function F8(t,e,s,n,r,i){return no(a=>function R8(t,e,s,n,r,i,a="emptyOnly"){return new N8(t,e,s,n,r,a,i).recognize()}(t,e,s,n,a.extractedUrl,r,i).pipe(Xn(({state:c,tree:f})=>({...a,targetSnapshot:c,urlAfterRedirects:f}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,n.config,this.urlSerializer,n.paramsInheritanceStrategy),Kc(ne=>{a.targetSnapshot=ne.targetSnapshot,a.urlAfterRedirects=ne.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:ne.urlAfterRedirects};const Ee=new I$(ne.id,this.urlSerializer.serialize(ne.extractedUrl),this.urlSerializer.serialize(ne.urlAfterRedirects),ne.targetSnapshot);this.events.next(Ee)}));if(A&&n.urlHandlingStrategy.shouldProcessUrl(g.currentRawUrl)){const{id:ne,extractedUrl:Ee,source:Ge,restoredState:tt,extras:Nt}=g,kt=new bS(ne,this.urlSerializer.serialize(Ee),Ge,tt);this.events.next(kt);const on=O$(0,this.rootComponentType).snapshot;return this.currentTransition=a={...g,targetSnapshot:on,urlAfterRedirects:Ee,extras:{...Nt,skipLocationChange:!1,replaceUrl:!1}},Xs(a)}{const ne="";return this.events.next(new gb(g.id,this.urlSerializer.serialize(g.extractedUrl),ne,1)),g.resolve(null),so}}),Kc(g=>{const E=new kK(g.id,this.urlSerializer.serialize(g.extractedUrl),this.urlSerializer.serialize(g.urlAfterRedirects),g.targetSnapshot);this.events.next(E)}),Xn(g=>(this.currentTransition=a={...g,guards:t8(g.targetSnapshot,g.currentSnapshot,this.rootContexts)},a)),function h8(t,e){return no(s=>{const{targetSnapshot:n,currentSnapshot:r,guards:{canActivateChecks:i,canDeactivateChecks:a}}=s;return 0===a.length&&0===i.length?Xs({...s,guardsResult:!0}):function p8(t,e,s,n){return Hi(t).pipe(no(r=>function v8(t,e,s,n,r){const i=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return i&&0!==i.length?Xs(i.map(c=>{const f=qw(e)??r,g=vb(c,f);return p_(function c8(t){return t&&nC(t.canDeactivate)}(g)?g.canDeactivate(t,e,s,n):f.runInContext(()=>g(t,e,s,n))).pipe(e0())})).pipe(bb()):Xs(!0)}(r.component,r.route,s,e,n)),e0(r=>!0!==r,!0))}(a,n,r,t).pipe(no(c=>c&&function i8(t){return"boolean"==typeof t}(c)?function f8(t,e,s,n){return Hi(e).pipe(lb(r=>zw(function g8(t,e){return null!==t&&e&&e(new FK(t)),Xs(!0)}(r.route.parent,n),function m8(t,e){return null!==t&&e&&e(new $K(t)),Xs(!0)}(r.route,n),function y8(t,e,s){const n=e[e.length-1],i=e.slice(0,e.length-1).reverse().map(a=>function n8(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(a)).filter(a=>null!==a).map(a=>hb(()=>Xs(a.guards.map(f=>{const g=qw(a.node)??s,E=vb(f,g);return p_(function l8(t){return t&&nC(t.canActivateChild)}(E)?E.canActivateChild(n,t):g.runInContext(()=>E(n,t))).pipe(e0())})).pipe(bb())));return Xs(i).pipe(bb())}(t,r.path,s),function _8(t,e,s){const n=e.routeConfig?e.routeConfig.canActivate:null;if(!n||0===n.length)return Xs(!0);const r=n.map(i=>hb(()=>{const a=qw(e)??s,c=vb(i,a);return p_(function a8(t){return t&&nC(t.canActivate)}(c)?c.canActivate(e,t):a.runInContext(()=>c(e,t))).pipe(e0())}));return Xs(r).pipe(bb())}(t,r.route,s))),e0(r=>!0!==r,!0))}(n,i,t,e):Xs(c)),Xn(c=>({...s,guardsResult:c})))})}(this.environmentInjector,g=>this.events.next(g)),Kc(g=>{if(a.guardsResult=g.guardsResult,n0(g.guardsResult))throw F$(0,g.guardsResult);const E=new OK(g.id,this.urlSerializer.serialize(g.extractedUrl),this.urlSerializer.serialize(g.urlAfterRedirects),g.targetSnapshot,!!g.guardsResult);this.events.next(E)}),tc(g=>!!g.guardsResult||(this.cancelNavigationTransition(g,"",3),!1)),OO(g=>{if(g.guards.canActivateChecks.length)return Xs(g).pipe(Kc(E=>{const A=new RK(E.id,this.urlSerializer.serialize(E.extractedUrl),this.urlSerializer.serialize(E.urlAfterRedirects),E.targetSnapshot);this.events.next(A)}),Qi(E=>{let A=!1;return Xs(E).pipe(L8(n.paramsInheritanceStrategy,this.environmentInjector),Kc({next:()=>A=!0,complete:()=>{A||this.cancelNavigationTransition(E,"",2)}}))}),Kc(E=>{const A=new NK(E.id,this.urlSerializer.serialize(E.extractedUrl),this.urlSerializer.serialize(E.urlAfterRedirects),E.targetSnapshot);this.events.next(A)}))}),OO(g=>{const E=A=>{const Y=[];A.routeConfig?.loadComponent&&!A.routeConfig._loadedComponent&&Y.push(this.configLoader.loadComponent(A.routeConfig).pipe(Kc(ne=>{A.component=ne}),Xn(()=>{})));for(const ne of A.children)Y.push(...E(ne));return Y};return qy(E(g.targetSnapshot.root)).pipe(pS(),$l(1))}),OO(()=>this.afterPreactivation()),Xn(g=>{const E=function HK(t,e,s){const n=Jw(t,e._root,s?s._root:void 0);return new k$(n,e)}(n.routeReuseStrategy,g.targetSnapshot,g.currentRouterState);return this.currentTransition=a={...g,targetRouterState:E},a}),Kc(()=>{this.events.next(new vO)}),((t,e,s,n)=>Xn(r=>(new e8(e,r.targetRouterState,r.currentRouterState,s,n).activate(t),r)))(this.rootContexts,n.routeReuseStrategy,g=>this.events.next(g),this.inputBindingEnabled),$l(1),Kc({next:g=>{c=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new f_(g.id,this.urlSerializer.serialize(g.extractedUrl),this.urlSerializer.serialize(g.urlAfterRedirects))),n.titleStrategy?.updateTitle(g.targetRouterState.snapshot),g.resolve(!0)},complete:()=>{c=!0}}),fo(this.transitionAbortSubject.pipe(Kc(g=>{throw g}))),cb(()=>{c||f||this.cancelNavigationTransition(a,"",1),this.currentNavigation?.id===a.id&&(this.currentNavigation=null)}),h_(g=>{if(f=!0,$$(g))this.events.next(new Zw(a.id,this.urlSerializer.serialize(a.extractedUrl),g.message,g.cancellationCode)),function KK(t){return $$(t)&&n0(t.url)}(g)?this.events.next(new bO(g.url)):a.resolve(!1);else{this.events.next(new xS(a.id,this.urlSerializer.serialize(a.extractedUrl),g,a.targetSnapshot??void 0));try{a.resolve(n.errorHandler(g))}catch(E){a.reject(E)}}return so}))}))}cancelNavigationTransition(n,r,i){const a=new Zw(n.id,this.urlSerializer.serialize(n.extractedUrl),r,i);this.events.next(a),n.resolve(!1)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function Q$(t){return t!==Yw}let J$=(()=>{var t;class e{buildTitle(n){let r,i=n.root;for(;void 0!==i;)r=this.getResolvedTitleForRoute(i)??r,i=i.children.find(a=>a.outlet===bo);return r}getResolvedTitleForRoute(n){return n.data[Ww]}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(){return jn(W8)},providedIn:"root"}),e})(),W8=(()=>{var t;class e extends J${constructor(n){super(),this.title=n}updateTitle(n){const r=this.buildTitle(n);void 0!==r&&this.title.setTitle(r)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(kF))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),H8=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(){return jn(G8)},providedIn:"root"}),e})();class j8{shouldDetach(e){return!1}store(e,s){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,s){return e.routeConfig===s.routeConfig}}let G8=(()=>{var t;class e extends j8{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const AS=new Zn("",{providedIn:"root",factory:()=>({})});let K8=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:function(){return jn(X8)},providedIn:"root"}),e})(),X8=(()=>{var t;class e{shouldProcessUrl(n){return!0}extract(n){return n}merge(n,r){return n}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();var sC=function(t){return t[t.COMPLETE=0]="COMPLETE",t[t.FAILED=1]="FAILED",t[t.REDIRECTING=2]="REDIRECTING",t}(sC||{});function q$(t,e){t.events.pipe(tc(s=>s instanceof f_||s instanceof Zw||s instanceof xS||s instanceof gb),Xn(s=>s instanceof f_||s instanceof gb?sC.COMPLETE:s instanceof Zw&&(0===s.code||1===s.code)?sC.REDIRECTING:sC.FAILED),tc(s=>s!==sC.REDIRECTING),$l(1)).subscribe(()=>{e()})}function Y8(t){throw t}function Z8(t,e,s){return e.parse("/")}const Q8={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},J8={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let pp=(()=>{var t;class e{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){return"computed"!==this.canceledNavigationResolution?this.currentPageId:this.location.getState()?.\u0275routerPageId??this.currentPageId}get events(){return this._events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=jn(lP),this.isNgZoneEnabled=!1,this._events=new Bt,this.options=jn(AS,{optional:!0})||{},this.pendingTasks=jn(kD),this.errorHandler=this.options.errorHandler||Y8,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||Z8,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=jn(K8),this.routeReuseStrategy=jn(H8),this.titleStrategy=jn(J$),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=jn(wb,{optional:!0})?.flat()??[],this.navigationTransitions=jn(TS),this.urlSerializer=jn(jw),this.location=jn(Aw),this.componentInputBindingEnabled=!!jn(CS,{optional:!0}),this.eventsSubscription=new I,this.isNgZoneEnabled=jn(Gs)instanceof Gs&&Gs.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new mb,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=O$(0,null),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe(n=>{this.lastSuccessfulId=n.id,this.currentPageId=this.browserPageId},n=>{this.console.warn(`Unhandled Navigation Error: ${n}`)}),this.subscribeToNavigationEvents()}subscribeToNavigationEvents(){const n=this.navigationTransitions.events.subscribe(r=>{try{const{currentTransition:i}=this.navigationTransitions;if(null===i)return void(e3(r)&&this._events.next(r));if(r instanceof bS)Q$(i.source)&&(this.browserUrlTree=i.extractedUrl);else if(r instanceof gb)this.rawUrlTree=i.rawUrl;else if(r instanceof I$){if("eager"===this.urlUpdateStrategy){if(!i.extras.skipLocationChange){const a=this.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl);this.setBrowserUrl(a,i)}this.browserUrlTree=i.urlAfterRedirects}}else if(r instanceof vO)this.currentUrlTree=i.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl),this.routerState=i.targetRouterState,"deferred"===this.urlUpdateStrategy&&(i.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,i),this.browserUrlTree=i.urlAfterRedirects);else if(r instanceof Zw)0!==r.code&&1!==r.code&&(this.navigated=!0),(3===r.code||2===r.code)&&this.restoreHistory(i);else if(r instanceof bO){const a=this.urlHandlingStrategy.merge(r.url,i.currentRawUrl),c={skipLocationChange:i.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||Q$(i.source)};this.scheduleNavigation(a,Yw,null,c,{resolve:i.resolve,reject:i.reject,promise:i.promise})}r instanceof xS&&this.restoreHistory(i,!0),r instanceof f_&&(this.navigated=!0),e3(r)&&this._events.next(r)}catch(i){this.navigationTransitions.transitionAbortSubject.next(i)}});this.eventsSubscription.add(n)}resetRootComponentType(n){this.routerState.root.component=n,this.navigationTransitions.rootComponentType=n}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const n=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),Yw,n)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(n=>{const r="popstate"===n.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(n.url,r,n.state)},0)}))}navigateToSyncWithBrowser(n,r,i){const a={replaceUrl:!0},c=i?.navigationId?i:null;if(i){const g={...i};delete g.navigationId,delete g.\u0275routerPageId,0!==Object.keys(g).length&&(a.state=g)}const f=this.parseUrl(n);this.scheduleNavigation(f,r,c,a)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(n){this.config=n.map(TO),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(n,r={}){const{relativeTo:i,queryParams:a,fragment:c,queryParamsHandling:f,preserveFragment:g}=r,E=g?this.currentUrlTree.fragment:c;let Y,A=null;switch(f){case"merge":A={...this.currentUrlTree.queryParams,...a};break;case"preserve":A=this.currentUrlTree.queryParams;break;default:A=a||null}null!==A&&(A=this.removeEmptyProps(A));try{Y=b$(i?i.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof n[0]||!n[0].startsWith("/"))&&(n=[]),Y=this.currentUrlTree.root}return x$(Y,n,A,E??null)}navigateByUrl(n,r={skipLocationChange:!1}){const i=n0(n)?n:this.parseUrl(n),a=this.urlHandlingStrategy.merge(i,this.rawUrlTree);return this.scheduleNavigation(a,Yw,null,r)}navigate(n,r={skipLocationChange:!1}){return function q8(t){for(let e=0;e<t.length;e++)if(null==t[e])throw new En(4008,!1)}(n),this.navigateByUrl(this.createUrlTree(n,r),r)}serializeUrl(n){return this.urlSerializer.serialize(n)}parseUrl(n){let r;try{r=this.urlSerializer.parse(n)}catch(i){r=this.malformedUriErrorHandler(i,this.urlSerializer,n)}return r}isActive(n,r){let i;if(i=!0===r?{...Q8}:!1===r?{...J8}:r,n0(n))return d$(this.currentUrlTree,n,i);const a=this.parseUrl(n);return d$(this.currentUrlTree,a,i)}removeEmptyProps(n){return Object.keys(n).reduce((r,i)=>{const a=n[i];return null!=a&&(r[i]=a),r},{})}scheduleNavigation(n,r,i,a,c){if(this.disposed)return Promise.resolve(!1);let f,g,E;c?(f=c.resolve,g=c.reject,E=c.promise):E=new Promise((Y,ne)=>{f=Y,g=ne});const A=this.pendingTasks.add();return q$(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(A))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:i,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,currentBrowserUrl:this.browserUrlTree,rawUrl:n,extras:a,resolve:f,reject:g,promise:E,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),E.catch(Y=>Promise.reject(Y))}setBrowserUrl(n,r){const i=this.urlSerializer.serialize(n);if(this.location.isCurrentPathEqualTo(i)||r.extras.replaceUrl){const c={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(i,"",c)}else{const a={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId+1)};this.location.go(i,"",a)}}restoreHistory(n,r=!1){if("computed"===this.canceledNavigationResolution){const a=this.currentPageId-this.browserPageId;0!==a?this.location.historyGo(a):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===a&&(this.resetState(n),this.browserUrlTree=n.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(n),this.resetUrlToCurrentUrlTree())}resetState(n){this.routerState=n.currentRouterState,this.currentUrlTree=n.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(n,r){return"computed"===this.canceledNavigationResolution?{navigationId:n,\u0275routerPageId:r}:{navigationId:n}}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function e3(t){return!(t instanceof vO||t instanceof bO)}let kS=(()=>{var t;class e{constructor(n,r,i,a,c,f){this.router=n,this.route=r,this.tabIndexAttribute=i,this.renderer=a,this.el=c,this.locationStrategy=f,this.href=null,this.commands=null,this.onChanges=new Bt,this.preserveFragment=!1,this.skipLocationChange=!1,this.replaceUrl=!1;const g=c.nativeElement.tagName?.toLowerCase();this.isAnchorElement="a"===g||"area"===g,this.isAnchorElement?this.subscription=n.events.subscribe(E=>{E instanceof f_&&this.updateHref()}):this.setTabIndexIfNotOnNativeEl("0")}setTabIndexIfNotOnNativeEl(n){null!=this.tabIndexAttribute||this.isAnchorElement||this.applyAttributeValue("tabindex",n)}ngOnChanges(n){this.isAnchorElement&&this.updateHref(),this.onChanges.next(this)}set routerLink(n){null!=n?(this.commands=Array.isArray(n)?n:[n],this.setTabIndexIfNotOnNativeEl("0")):(this.commands=null,this.setTabIndexIfNotOnNativeEl(null))}onClick(n,r,i,a,c){return!!(null===this.urlTree||this.isAnchorElement&&(0!==n||r||i||a||c||"string"==typeof this.target&&"_self"!=this.target))||(this.router.navigateByUrl(this.urlTree,{skipLocationChange:this.skipLocationChange,replaceUrl:this.replaceUrl,state:this.state}),!this.isAnchorElement)}ngOnDestroy(){this.subscription?.unsubscribe()}updateHref(){this.href=null!==this.urlTree&&this.locationStrategy?this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)):null;const n=null===this.href?null:function yv(t,e,s){return function Ex(t,e){return"src"===e&&("embed"===t||"frame"===t||"iframe"===t||"media"===t||"script"===t)||"href"===e&&("base"===t||"link"===t)?_v:uy}(e,s)(t)}(this.href,this.el.nativeElement.tagName.toLowerCase(),"href");this.applyAttributeValue("href",n)}applyAttributeValue(n,r){const i=this.renderer,a=this.el.nativeElement;null!==r?i.setAttribute(a,n,r):i.removeAttribute(a,n)}get urlTree(){return null===this.commands?null:this.router.createUrlTree(this.commands,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:this.preserveFragment})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(pp),lt(yb),na("tabindex"),lt(th),lt(yr),lt(Yy))},t.\u0275dir=Gn({type:t,selectors:[["","routerLink",""]],hostVars:1,hostBindings:function(n,r){1&n&&qs("click",function(a){return r.onClick(a.button,a.ctrlKey,a.shiftKey,a.altKey,a.metaKey)}),2&n&&si("target",r.target)},inputs:{target:"target",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",state:"state",relativeTo:"relativeTo",preserveFragment:["preserveFragment","preserveFragment",tb],skipLocationChange:["skipLocationChange","skipLocationChange",tb],replaceUrl:["replaceUrl","replaceUrl",tb],routerLink:"routerLink"},standalone:!0,features:[nE,Ia]}),e})();class t3{}let n7=(()=>{var t;class e{constructor(n,r,i,a,c){this.router=n,this.injector=i,this.preloadingStrategy=a,this.loader=c}setUpPreloading(){this.subscription=this.router.events.pipe(tc(n=>n instanceof f_),lb(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(n,r){const i=[];for(const a of r){a.providers&&!a._injector&&(a._injector=xw(a.providers,n,`Route: ${a.path}`));const c=a._injector??n,f=a._loadedInjector??c;(a.loadChildren&&!a._loadedRoutes&&void 0===a.canLoad||a.loadComponent&&!a._loadedComponent)&&i.push(this.preloadConfig(c,a)),(a.children||a._loadedRoutes)&&i.push(this.processRoutes(f,a.children??a._loadedRoutes))}return Hi(i).pipe(Ka())}preloadConfig(n,r){return this.preloadingStrategy.preload(r,()=>{let i;i=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(n,r):Xs(null);const a=i.pipe(no(c=>null===c?Xs(void 0):(r._loadedRoutes=c.routes,r._loadedInjector=c.injector,this.processRoutes(c.injector??n,c.routes))));return r.loadComponent&&!r._loadedComponent?Hi([a,this.loader.loadComponent(r)]).pipe(Ka()):a})}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(pp),cn(cP),cn(Yu),cn(t3),cn(RO))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const NO=new Zn("");let n3=(()=>{var t;class e{constructor(n,r,i,a,c={}){this.urlSerializer=n,this.transitions=r,this.viewportScroller=i,this.zone=a,this.options=c,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},c.scrollPositionRestoration=c.scrollPositionRestoration||"disabled",c.anchorScrolling=c.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(n=>{n instanceof bS?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=n.navigationTrigger,this.restoredId=n.restoredState?n.restoredState.navigationId:0):n instanceof f_?(this.lastId=n.id,this.scheduleScrollEvent(n,this.urlSerializer.parse(n.urlAfterRedirects).fragment)):n instanceof gb&&0===n.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(n,this.urlSerializer.parse(n.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(n=>{n instanceof T$&&(n.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(n.position):n.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(n.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(n,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new T$(n,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return(t=e).\u0275fac=function(n){Tf()},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();function Fm(t,e){return{\u0275kind:t,\u0275providers:e}}function r3(){const t=jn(Wc);return e=>{const s=t.get(i_);if(e!==s.components[0])return;const n=t.get(pp),r=t.get(i3);1===t.get(MO)&&n.initialNavigation(),t.get(o3,null,Jt.Optional)?.setUpPreloading(),t.get(NO,null,Jt.Optional)?.init(),n.resetRootComponentType(s.componentTypes[0]),r.closed||(r.next(),r.complete(),r.unsubscribe())}}const i3=new Zn("",{factory:()=>new Bt}),MO=new Zn("",{providedIn:"root",factory:()=>1}),o3=new Zn("");function o7(t){return Fm(0,[{provide:o3,useExisting:n7},{provide:t3,useExisting:t}])}const a3=new Zn("ROUTER_FORROOT_GUARD"),l7=[Aw,{provide:jw,useClass:fO},pp,Qw,{provide:yb,useFactory:function s3(t){return t.routerState.root},deps:[pp]},RO,[]];function c7(){return new gP("Router",pp)}let l3=(()=>{var t;class e{constructor(n){}static forRoot(n,r){return{ngModule:e,providers:[l7,[],{provide:wb,multi:!0,useValue:n},{provide:a3,useFactory:p7,deps:[[pp,new wh,new Gh]]},{provide:AS,useValue:r||{}},r?.useHash?{provide:Yy,useClass:q5}:{provide:Yy,useClass:GP},{provide:NO,useFactory:()=>{const t=jn(_j),e=jn(Gs),s=jn(AS),n=jn(TS),r=jn(jw);return s.scrollOffset&&t.setOffset(s.scrollOffset),new n3(r,n,t,e,s)}},r?.preloadingStrategy?o7(r.preloadingStrategy).\u0275providers:[],{provide:gP,multi:!0,useFactory:c7},r?.initialNavigation?f7(r):[],r?.bindToComponentInputs?Fm(8,[P$,{provide:CS,useExisting:P$}]).\u0275providers:[],[{provide:c3,useFactory:r3},{provide:s2,multi:!0,useExisting:c3}]]}}static forChild(n){return{ngModule:e,providers:[{provide:wb,multi:!0,useValue:n}]}}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(a3,8))},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();function p7(t){return"guarded"}function f7(t){return["disabled"===t.initialNavigation?Fm(3,[{provide:Yk,multi:!0,useFactory:()=>{const e=jn(pp);return()=>{e.setUpLocationChangeListener()}}},{provide:MO,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?Fm(2,[{provide:MO,useValue:0},{provide:Yk,multi:!0,deps:[Wc],useFactory:e=>{const s=e.get(Q5,Promise.resolve());return()=>s.then(()=>new Promise(n=>{const r=e.get(pp),i=e.get(i3);q$(r,()=>{n(!0)}),e.get(TS).afterPreactivation=()=>(n(!0),i.closed?Xs(void 0):i),r.initialNavigation()}))}}]).\u0275providers:[]]}const c3=new Zn("");let PO;try{PO=typeof Intl<"u"&&Intl.v8BreakIterator}catch{PO=!1}let Cb,wc=(()=>{var t;class e{constructor(n){this._platformId=n,this.isBrowser=this._platformId?function gj(t){return t===uF}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!PO)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(qh))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const u3=["color","button","checkbox","date","datetime-local","email","file","hidden","image","month","number","password","radio","range","reset","search","submit","tel","text","time","url","week"];function d3(){if(Cb)return Cb;if("object"!=typeof document||!document)return Cb=new Set(u3),Cb;let t=document.createElement("input");return Cb=new Set(u3.filter(e=>(t.setAttribute("type",e),t.type===e))),Cb}let rC,OS,s0,FO;function Lm(t){return function g7(){if(null==rC&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>rC=!0}))}finally{rC=rC||!1}return rC}()?t:!!t.capture}function h3(){if(null==s0){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return s0=!1,s0;if("scrollBehavior"in document.documentElement.style)s0=!0;else{const t=Element.prototype.scrollTo;s0=!!t&&!/\{\s*\[native code\]\s*\}/.test(t.toString())}}return s0}function iC(){if("object"!=typeof document||!document)return 0;if(null==OS){const t=document.createElement("div"),e=t.style;t.dir="rtl",e.width="1px",e.overflow="auto",e.visibility="hidden",e.pointerEvents="none",e.position="absolute";const s=document.createElement("div"),n=s.style;n.width="2px",n.height="1px",t.appendChild(s),document.body.appendChild(t),OS=0,0===t.scrollLeft&&(t.scrollLeft=1,OS=0===t.scrollLeft?1:2),t.remove()}return OS}function LO(t){if(function _7(){if(null==FO){const t=typeof document<"u"?document.head:null;FO=!(!t||!t.createShadowRoot&&!t.attachShadow)}return FO}()){const e=t.getRootNode?t.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}function $O(){let t=typeof document<"u"&&document?document.activeElement:null;for(;t&&t.shadowRoot;){const e=t.shadowRoot.activeElement;if(e===t)break;t=e}return t}function kh(t){return t.composedPath?t.composedPath()[0]:t.target}function BO(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}function lh(t,...e){return e.length?e.some(s=>t[s]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}class O7 extends I{constructor(e,s){super()}schedule(e,s=0){return this}}const MS={setInterval(t,e,...s){const{delegate:n}=MS;return n?.setInterval?n.setInterval(t,e,...s):setInterval(t,e,...s)},clearInterval(t){const{delegate:e}=MS;return(e?.clearInterval||clearInterval)(t)},delegate:void 0};class UO extends O7{constructor(e,s){super(e,s),this.scheduler=e,this.work=s,this.pending=!1}schedule(e,s=0){var n;if(this.closed)return this;this.state=e;const r=this.id,i=this.scheduler;return null!=r&&(this.id=this.recycleAsyncId(i,r,s)),this.pending=!0,this.delay=s,this.id=null!==(n=this.id)&&void 0!==n?n:this.requestAsyncId(i,this.id,s),this}requestAsyncId(e,s,n=0){return MS.setInterval(e.flush.bind(e,this),n)}recycleAsyncId(e,s,n=0){if(null!=n&&this.delay===n&&!1===this.pending)return s;null!=s&&MS.clearInterval(s)}execute(e,s){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(e,s);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(e,s){let r,n=!1;try{this.work(e)}catch(i){n=!0,r=i||new Error("Scheduled action threw falsy error")}if(n)return this.unsubscribe(),r}unsubscribe(){if(!this.closed){const{id:e,scheduler:s}=this,{actions:n}=s;this.work=this.state=this.scheduler=null,this.pending=!1,F(n,this),null!=e&&(this.id=this.recycleAsyncId(s,e,null)),this.delay=null,super.unsubscribe()}}}const zO={now:()=>(zO.delegate||Date).now(),delegate:void 0};class aC{constructor(e,s=aC.now){this.schedulerActionCtor=e,this.now=s}schedule(e,s=0,n){return new this.schedulerActionCtor(this,e).schedule(n,s)}}aC.now=zO.now;class WO extends aC{constructor(e,s=aC.now){super(e,s),this.actions=[],this._active=!1}flush(e){const{actions:s}=this;if(this._active)return void s.push(e);let n;this._active=!0;do{if(n=e.execute(e.state,e.delay))break}while(e=s.shift());if(this._active=!1,n){for(;e=s.shift();)e.unsubscribe();throw n}}}const lC=new WO(UO),R7=lC;function g3(t,e=lC){return Dn((s,n)=>{let r=null,i=null,a=null;const c=()=>{if(r){r.unsubscribe(),r=null;const g=i;i=null,n.next(g)}};function f(){const g=a+t,E=e.now();if(E<g)return r=this.schedule(void 0,g-E),void n.add(r);c()}s.subscribe(ps(n,g=>{i=g,a=e.now(),r||(r=e.schedule(f,t),n.add(r))},()=>{c(),n.complete()},void 0,()=>{i=r=null}))})}function _3(t){return tc((e,s)=>t<=s)}function Yr(t){return null!=t&&"false"!=`${t}`}function Bl(t,e=0){return y3(t)?Number(t):e}function y3(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}function cC(t){return Array.isArray(t)?t:[t]}function yu(t){return null==t?"":"string"==typeof t?t:`${t}px`}function cu(t){return t instanceof yr?t.nativeElement:t}let N7=(()=>{var t;class e{create(n){return typeof MutationObserver>"u"?null:new MutationObserver(n)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),v3=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[N7]}),e})();const b3=new Set;let o0,M7=(()=>{var t;class e{constructor(n,r){this._platform=n,this._nonce=r,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):F7}matchMedia(n){return(this._platform.WEBKIT||this._platform.BLINK)&&function P7(t,e){if(!b3.has(t))try{o0||(o0=document.createElement("style"),e&&(o0.nonce=e),o0.setAttribute("type","text/css"),document.head.appendChild(o0)),o0.sheet&&(o0.sheet.insertRule(`@media ${t} {body{ }}`,0),b3.add(t))}catch(s){console.error(s)}}(n,this._nonce),this._matchMedia(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(wc),cn(by,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function F7(t){return{matches:"all"===t||""===t,media:t,addListener:()=>{},removeListener:()=>{}}}let L7=(()=>{var t;class e{constructor(n,r){this._mediaMatcher=n,this._zone=r,this._queries=new Map,this._destroySubject=new Bt}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(n){return x3(cC(n)).some(i=>this._registerQuery(i).mql.matches)}observe(n){let a=qy(x3(cC(n)).map(c=>this._registerQuery(c).observable));return a=zw(a.pipe($l(1)),a.pipe(_3(1),g3(0))),a.pipe(Xn(c=>{const f={matches:!1,breakpoints:{}};return c.forEach(({matches:g,query:E})=>{f.matches=f.matches||g,f.breakpoints[E]=g}),f}))}_registerQuery(n){if(this._queries.has(n))return this._queries.get(n);const r=this._mediaMatcher.matchMedia(n),a={observable:new Ue(c=>{const f=g=>this._zone.run(()=>c.next(g));return r.addListener(f),()=>{r.removeListener(f)}}).pipe(ed(r),Xn(({matches:c})=>({query:n,matches:c})),fo(this._destroySubject)),mql:r};return this._queries.set(n,a),a}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(M7),cn(Gs))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function x3(t){return t.map(e=>e.split(",")).reduce((e,s)=>e.concat(s)).map(e=>e.trim())}function HO(t,e,s){const n=PS(t,e);n.some(r=>r.trim()==s.trim())||(n.push(s.trim()),t.setAttribute(e,n.join(" ")))}function uC(t,e,s){const r=PS(t,e).filter(i=>i!=s.trim());r.length?t.setAttribute(e,r.join(" ")):t.removeAttribute(e)}function PS(t,e){return(t.getAttribute(e)||"").match(/\S+/g)||[]}const C3="cdk-describedby-message",FS="cdk-describedby-host";let jO=0,E3=(()=>{var t;class e{constructor(n,r){this._platform=r,this._messageRegistry=new Map,this._messagesContainer=null,this._id=""+jO++,this._document=n,this._id=jn(Sf)+"-"+jO++}describe(n,r,i){if(!this._canBeDescribed(n,r))return;const a=GO(r,i);"string"!=typeof r?(D3(r,this._id),this._messageRegistry.set(a,{messageElement:r,referenceCount:0})):this._messageRegistry.has(a)||this._createMessageElement(r,i),this._isElementDescribedByMessage(n,a)||this._addMessageReference(n,a)}removeDescription(n,r,i){if(!r||!this._isElementNode(n))return;const a=GO(r,i);if(this._isElementDescribedByMessage(n,a)&&this._removeMessageReference(n,a),"string"==typeof r){const c=this._messageRegistry.get(a);c&&0===c.referenceCount&&this._deleteMessageElement(a)}0===this._messagesContainer?.childNodes.length&&(this._messagesContainer.remove(),this._messagesContainer=null)}ngOnDestroy(){const n=this._document.querySelectorAll(`[${FS}="${this._id}"]`);for(let r=0;r<n.length;r++)this._removeCdkDescribedByReferenceIds(n[r]),n[r].removeAttribute(FS);this._messagesContainer?.remove(),this._messagesContainer=null,this._messageRegistry.clear()}_createMessageElement(n,r){const i=this._document.createElement("div");D3(i,this._id),i.textContent=n,r&&i.setAttribute("role",r),this._createMessagesContainer(),this._messagesContainer.appendChild(i),this._messageRegistry.set(GO(n,r),{messageElement:i,referenceCount:0})}_deleteMessageElement(n){this._messageRegistry.get(n)?.messageElement?.remove(),this._messageRegistry.delete(n)}_createMessagesContainer(){if(this._messagesContainer)return;const n="cdk-describedby-message-container",r=this._document.querySelectorAll(`.${n}[platform="server"]`);for(let a=0;a<r.length;a++)r[a].remove();const i=this._document.createElement("div");i.style.visibility="hidden",i.classList.add(n),i.classList.add("cdk-visually-hidden"),this._platform&&!this._platform.isBrowser&&i.setAttribute("platform","server"),this._document.body.appendChild(i),this._messagesContainer=i}_removeCdkDescribedByReferenceIds(n){const r=PS(n,"aria-describedby").filter(i=>0!=i.indexOf(C3));n.setAttribute("aria-describedby",r.join(" "))}_addMessageReference(n,r){const i=this._messageRegistry.get(r);HO(n,"aria-describedby",i.messageElement.id),n.setAttribute(FS,this._id),i.referenceCount++}_removeMessageReference(n,r){const i=this._messageRegistry.get(r);i.referenceCount--,uC(n,"aria-describedby",i.messageElement.id),n.removeAttribute(FS)}_isElementDescribedByMessage(n,r){const i=PS(n,"aria-describedby"),a=this._messageRegistry.get(r),c=a&&a.messageElement.id;return!!c&&-1!=i.indexOf(c)}_canBeDescribed(n,r){if(!this._isElementNode(n))return!1;if(r&&"object"==typeof r)return!0;const i=null==r?"":`${r}`.trim(),a=n.getAttribute("aria-label");return!(!i||a&&a.trim()===i)}_isElementNode(n){return n.nodeType===this._document.ELEMENT_NODE}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(wc))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function GO(t,e){return"string"==typeof t?`${e||""}/${t}`:t}function D3(t,e){t.id||(t.id=`${C3}-${e}-${jO++}`)}class S3{constructor(e){this._items=e,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new Bt,this._typeaheadSubscription=I.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._pageUpAndDown={enabled:!1,delta:10},this._skipPredicateFn=s=>s.disabled,this._pressedLetters=[],this.tabOut=new Bt,this.change=new Bt,e instanceof Ky&&(this._itemChangesSubscription=e.changes.subscribe(s=>{if(this._activeItem){const r=s.toArray().indexOf(this._activeItem);r>-1&&r!==this._activeItemIndex&&(this._activeItemIndex=r)}}))}skipPredicate(e){return this._skipPredicateFn=e,this}withWrap(e=!0){return this._wrap=e,this}withVerticalOrientation(e=!0){return this._vertical=e,this}withHorizontalOrientation(e){return this._horizontal=e,this}withAllowedModifierKeys(e){return this._allowedModifierKeys=e,this}withTypeAhead(e=200){return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe(Kc(s=>this._pressedLetters.push(s)),g3(e),tc(()=>this._pressedLetters.length>0),Xn(()=>this._pressedLetters.join(""))).subscribe(s=>{const n=this._getItemsArray();for(let r=1;r<n.length+1;r++){const i=(this._activeItemIndex+r)%n.length,a=n[i];if(!this._skipPredicateFn(a)&&0===a.getLabel().toUpperCase().trim().indexOf(s)){this.setActiveItem(i);break}}this._pressedLetters=[]}),this}cancelTypeahead(){return this._pressedLetters=[],this}withHomeAndEnd(e=!0){return this._homeAndEnd=e,this}withPageUpDown(e=!0,s=10){return this._pageUpAndDown={enabled:e,delta:s},this}setActiveItem(e){const s=this._activeItem;this.updateActiveItem(e),this._activeItem!==s&&this.change.next(this._activeItemIndex)}onKeydown(e){const s=e.keyCode,r=["altKey","ctrlKey","metaKey","shiftKey"].every(i=>!e[i]||this._allowedModifierKeys.indexOf(i)>-1);switch(s){case 9:return void this.tabOut.next();case 40:if(this._vertical&&r){this.setNextItemActive();break}return;case 38:if(this._vertical&&r){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&r){"rtl"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&r){"rtl"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&r){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&r){this.setLastItemActive();break}return;case 33:if(this._pageUpAndDown.enabled&&r){const i=this._activeItemIndex-this._pageUpAndDown.delta;this._setActiveItemByIndex(i>0?i:0,1);break}return;case 34:if(this._pageUpAndDown.enabled&&r){const i=this._activeItemIndex+this._pageUpAndDown.delta,a=this._getItemsArray().length;this._setActiveItemByIndex(i<a?i:a-1,-1);break}return;default:return void((r||lh(e,"shiftKey"))&&(e.key&&1===e.key.length?this._letterKeyStream.next(e.key.toLocaleUpperCase()):(s>=65&&s<=90||s>=48&&s<=57)&&this._letterKeyStream.next(String.fromCharCode(s))))}this._pressedLetters=[],e.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(e){const s=this._getItemsArray(),n="number"==typeof e?e:s.indexOf(e);this._activeItem=s[n]??null,this._activeItemIndex=n}destroy(){this._typeaheadSubscription.unsubscribe(),this._itemChangesSubscription?.unsubscribe(),this._letterKeyStream.complete(),this.tabOut.complete(),this.change.complete(),this._pressedLetters=[]}_setActiveItemByDelta(e){this._wrap?this._setActiveInWrapMode(e):this._setActiveInDefaultMode(e)}_setActiveInWrapMode(e){const s=this._getItemsArray();for(let n=1;n<=s.length;n++){const r=(this._activeItemIndex+e*n+s.length)%s.length;if(!this._skipPredicateFn(s[r]))return void this.setActiveItem(r)}}_setActiveInDefaultMode(e){this._setActiveItemByIndex(this._activeItemIndex+e,e)}_setActiveItemByIndex(e,s){const n=this._getItemsArray();if(n[e]){for(;this._skipPredicateFn(n[e]);)if(!n[e+=s])return;this.setActiveItem(e)}}_getItemsArray(){return this._items instanceof Ky?this._items.toArray():this._items}}class $7 extends S3{setActiveItem(e){this.activeItem&&this.activeItem.setInactiveStyles(),super.setActiveItem(e),this.activeItem&&this.activeItem.setActiveStyles()}}class I3 extends S3{constructor(){super(...arguments),this._origin="program"}setFocusOrigin(e){return this._origin=e,this}setActiveItem(e){super.setActiveItem(e),this.activeItem&&this.activeItem.focus(this._origin)}}let LS=(()=>{var t;class e{constructor(n){this._platform=n}isDisabled(n){return n.hasAttribute("disabled")}isVisible(n){return function V7(t){return!!(t.offsetWidth||t.offsetHeight||"function"==typeof t.getClientRects&&t.getClientRects().length)}(n)&&"visible"===getComputedStyle(n).visibility}isTabbable(n){if(!this._platform.isBrowser)return!1;const r=function B7(t){try{return t.frameElement}catch{return null}}(function X7(t){return t.ownerDocument&&t.ownerDocument.defaultView||window}(n));if(r&&(-1===A3(r)||!this.isVisible(r)))return!1;let i=n.nodeName.toLowerCase(),a=A3(n);return n.hasAttribute("contenteditable")?-1!==a:!("iframe"===i||"object"===i||this._platform.WEBKIT&&this._platform.IOS&&!function G7(t){let e=t.nodeName.toLowerCase(),s="input"===e&&t.type;return"text"===s||"password"===s||"select"===e||"textarea"===e}(n))&&("audio"===i?!!n.hasAttribute("controls")&&-1!==a:"video"===i?-1!==a&&(null!==a||this._platform.FIREFOX||n.hasAttribute("controls")):n.tabIndex>=0)}isFocusable(n,r){return function K7(t){return!function z7(t){return function H7(t){return"input"==t.nodeName.toLowerCase()}(t)&&"hidden"==t.type}(t)&&(function U7(t){let e=t.nodeName.toLowerCase();return"input"===e||"select"===e||"button"===e||"textarea"===e}(t)||function W7(t){return function j7(t){return"a"==t.nodeName.toLowerCase()}(t)&&t.hasAttribute("href")}(t)||t.hasAttribute("contenteditable")||T3(t))}(n)&&!this.isDisabled(n)&&(r?.ignoreVisibility||this.isVisible(n))}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(wc))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function T3(t){if(!t.hasAttribute("tabindex")||void 0===t.tabIndex)return!1;let e=t.getAttribute("tabindex");return!(!e||isNaN(parseInt(e,10)))}function A3(t){if(!T3(t))return null;const e=parseInt(t.getAttribute("tabindex")||"",10);return isNaN(e)?-1:e}class Y7{get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(e,this._startAnchor),this._toggleAnchorTabIndex(e,this._endAnchor))}constructor(e,s,n,r,i=!1){this._element=e,this._checker=s,this._ngZone=n,this._document=r,this._hasAttached=!1,this.startAnchorListener=()=>this.focusLastTabbableElement(),this.endAnchorListener=()=>this.focusFirstTabbableElement(),this._enabled=!0,i||this.attachAnchors()}destroy(){const e=this._startAnchor,s=this._endAnchor;e&&(e.removeEventListener("focus",this.startAnchorListener),e.remove()),s&&(s.removeEventListener("focus",this.endAnchorListener),s.remove()),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=>{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener("focus",this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener("focus",this.endAnchorListener))}),this._element.parentNode&&(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(e){return new Promise(s=>{this._executeOnStable(()=>s(this.focusInitialElement(e)))})}focusFirstTabbableElementWhenReady(e){return new Promise(s=>{this._executeOnStable(()=>s(this.focusFirstTabbableElement(e)))})}focusLastTabbableElementWhenReady(e){return new Promise(s=>{this._executeOnStable(()=>s(this.focusLastTabbableElement(e)))})}_getRegionBoundary(e){const s=this._element.querySelectorAll(`[cdk-focus-region-${e}], [cdkFocusRegion${e}], [cdk-focus-${e}]`);return"start"==e?s.length?s[0]:this._getFirstTabbableElement(this._element):s.length?s[s.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(e){const s=this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");if(s){if(!this._checker.isFocusable(s)){const n=this._getFirstTabbableElement(s);return n?.focus(e),!!n}return s.focus(e),!0}return this.focusFirstTabbableElement(e)}focusFirstTabbableElement(e){const s=this._getRegionBoundary("start");return s&&s.focus(e),!!s}focusLastTabbableElement(e){const s=this._getRegionBoundary("end");return s&&s.focus(e),!!s}hasAttached(){return this._hasAttached}_getFirstTabbableElement(e){if(this._checker.isFocusable(e)&&this._checker.isTabbable(e))return e;const s=e.children;for(let n=0;n<s.length;n++){const r=s[n].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(s[n]):null;if(r)return r}return null}_getLastTabbableElement(e){if(this._checker.isFocusable(e)&&this._checker.isTabbable(e))return e;const s=e.children;for(let n=s.length-1;n>=0;n--){const r=s[n].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(s[n]):null;if(r)return r}return null}_createAnchor(){const e=this._document.createElement("div");return this._toggleAnchorTabIndex(this._enabled,e),e.classList.add("cdk-visually-hidden"),e.classList.add("cdk-focus-trap-anchor"),e.setAttribute("aria-hidden","true"),e}_toggleAnchorTabIndex(e,s){e?s.setAttribute("tabindex","0"):s.removeAttribute("tabindex")}toggleAnchors(e){this._startAnchor&&this._endAnchor&&(this._toggleAnchorTabIndex(e,this._startAnchor),this._toggleAnchorTabIndex(e,this._endAnchor))}_executeOnStable(e){this._ngZone.isStable?e():this._ngZone.onStable.pipe($l(1)).subscribe(e)}}let KO=(()=>{var t;class e{constructor(n,r,i){this._checker=n,this._ngZone=r,this._document=i}create(n,r=!1){return new Y7(n,this._checker,this._ngZone,this._document,r)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(LS),cn(Gs),cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function XO(t){return 0===t.buttons||0===t.offsetX&&0===t.offsetY}function YO(t){const e=t.touches&&t.touches[0]||t.changedTouches&&t.changedTouches[0];return!(!e||-1!==e.identifier||null!=e.radiusX&&1!==e.radiusX||null!=e.radiusY&&1!==e.radiusY)}const Z7=new Zn("cdk-input-modality-detector-options"),Q7={ignoreKeys:[18,17,224,91,16]},Db=Lm({passive:!0,capture:!0});let J7=(()=>{var t;class e{get mostRecentModality(){return this._modality.value}constructor(n,r,i,a){this._platform=n,this._mostRecentTarget=null,this._modality=new Di(null),this._lastTouchMs=0,this._onKeydown=c=>{this._options?.ignoreKeys?.some(f=>f===c.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=kh(c))},this._onMousedown=c=>{Date.now()-this._lastTouchMs<650||(this._modality.next(XO(c)?"keyboard":"mouse"),this._mostRecentTarget=kh(c))},this._onTouchstart=c=>{YO(c)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=kh(c))},this._options={...Q7,...a},this.modalityDetected=this._modality.pipe(_3(1)),this.modalityChanged=this.modalityDetected.pipe(al()),n.isBrowser&&r.runOutsideAngular(()=>{i.addEventListener("keydown",this._onKeydown,Db),i.addEventListener("mousedown",this._onMousedown,Db),i.addEventListener("touchstart",this._onTouchstart,Db)})}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,Db),document.removeEventListener("mousedown",this._onMousedown,Db),document.removeEventListener("touchstart",this._onTouchstart,Db))}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(wc),cn(Gs),cn(yi),cn(Z7,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const q7=new Zn("liveAnnouncerElement",{providedIn:"root",factory:function e9(){return null}}),t9=new Zn("LIVE_ANNOUNCER_DEFAULT_OPTIONS");let n9=0,s9=(()=>{var t;class e{constructor(n,r,i,a){this._ngZone=r,this._defaultOptions=a,this._document=i,this._liveElement=n||this._createLiveElement()}announce(n,...r){const i=this._defaultOptions;let a,c;return 1===r.length&&"number"==typeof r[0]?c=r[0]:[a,c]=r,this.clear(),clearTimeout(this._previousTimeout),a||(a=i&&i.politeness?i.politeness:"polite"),null==c&&i&&(c=i.duration),this._liveElement.setAttribute("aria-live",a),this._liveElement.id&&this._exposeAnnouncerToModals(this._liveElement.id),this._ngZone.runOutsideAngular(()=>(this._currentPromise||(this._currentPromise=new Promise(f=>this._currentResolve=f)),clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=n,"number"==typeof c&&(this._previousTimeout=setTimeout(()=>this.clear(),c)),this._currentResolve(),this._currentPromise=this._currentResolve=void 0},100),this._currentPromise))}clear(){this._liveElement&&(this._liveElement.textContent="")}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement?.remove(),this._liveElement=null,this._currentResolve?.(),this._currentPromise=this._currentResolve=void 0}_createLiveElement(){const n="cdk-live-announcer-element",r=this._document.getElementsByClassName(n),i=this._document.createElement("div");for(let a=0;a<r.length;a++)r[a].remove();return i.classList.add(n),i.classList.add("cdk-visually-hidden"),i.setAttribute("aria-atomic","true"),i.setAttribute("aria-live","polite"),i.id="cdk-live-announcer-"+n9++,this._document.body.appendChild(i),i}_exposeAnnouncerToModals(n){const r=this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');for(let i=0;i<r.length;i++){const a=r[i],c=a.getAttribute("aria-owns");c?-1===c.indexOf(n)&&a.setAttribute("aria-owns",c+" "+n):a.setAttribute("aria-owns",n)}}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(q7,8),cn(Gs),cn(yi),cn(t9,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const r9=new Zn("cdk-focus-monitor-default-options"),$S=Lm({passive:!0,capture:!0});let $m=(()=>{var t;class e{constructor(n,r,i,a,c){this._ngZone=n,this._platform=r,this._inputModalityDetector=i,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new Bt,this._rootNodeFocusAndBlurListener=f=>{for(let E=kh(f);E;E=E.parentElement)"focus"===f.type?this._onFocus(f,E):this._onBlur(f,E)},this._document=a,this._detectionMode=c?.detectionMode||0}monitor(n,r=!1){const i=cu(n);if(!this._platform.isBrowser||1!==i.nodeType)return Xs();const a=LO(i)||this._getDocument(),c=this._elementInfo.get(i);if(c)return r&&(c.checkChildren=!0),c.subject;const f={checkChildren:r,subject:new Bt,rootNode:a};return this._elementInfo.set(i,f),this._registerGlobalListeners(f),f.subject}stopMonitoring(n){const r=cu(n),i=this._elementInfo.get(r);i&&(i.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(i))}focusVia(n,r,i){const a=cu(n);a===this._getDocument().activeElement?this._getClosestElementsInfo(a).forEach(([f,g])=>this._originChanged(f,r,g)):(this._setOrigin(r),"function"==typeof a.focus&&a.focus(i))}ngOnDestroy(){this._elementInfo.forEach((n,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(n){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(n)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:n&&this._isLastInteractionFromInputLabel(n)?"mouse":"program"}_shouldBeAttributedToTouch(n){return 1===this._detectionMode||!!n?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(n,r){n.classList.toggle("cdk-focused",!!r),n.classList.toggle("cdk-touch-focused","touch"===r),n.classList.toggle("cdk-keyboard-focused","keyboard"===r),n.classList.toggle("cdk-mouse-focused","mouse"===r),n.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(n,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=n,this._originFromTouchInteraction="touch"===n&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(n,r){const i=this._elementInfo.get(r),a=kh(n);!i||!i.checkChildren&&r!==a||this._originChanged(r,this._getFocusOrigin(a),i)}_onBlur(n,r){const i=this._elementInfo.get(r);!i||i.checkChildren&&n.relatedTarget instanceof Node&&r.contains(n.relatedTarget)||(this._setClasses(r),this._emitOrigin(i,null))}_emitOrigin(n,r){n.subject.observers.length&&this._ngZone.run(()=>n.subject.next(r))}_registerGlobalListeners(n){if(!this._platform.isBrowser)return;const r=n.rootNode,i=this._rootNodeFocusListenerCount.get(r)||0;i||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,$S),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,$S)}),this._rootNodeFocusListenerCount.set(r,i+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(fo(this._stopInputModalityDetector)).subscribe(a=>{this._setOrigin(a,!0)}))}_removeGlobalListeners(n){const r=n.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const i=this._rootNodeFocusListenerCount.get(r);i>1?this._rootNodeFocusListenerCount.set(r,i-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,$S),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,$S),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(n,r,i){this._setClasses(n,r),this._emitOrigin(i,r),this._lastFocusOrigin=r}_getClosestElementsInfo(n){const r=[];return this._elementInfo.forEach((i,a)=>{(a===n||i.checkChildren&&a.contains(n))&&r.push([a,i])}),r}_isLastInteractionFromInputLabel(n){const{_mostRecentTarget:r,mostRecentModality:i}=this._inputModalityDetector;if("mouse"!==i||!r||r===n||"INPUT"!==n.nodeName&&"TEXTAREA"!==n.nodeName||n.disabled)return!1;const a=n.labels;if(a)for(let c=0;c<a.length;c++)if(a[c].contains(r))return!0;return!1}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Gs),cn(wc),cn(J7),cn(yi,8),cn(r9,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const O3="cdk-high-contrast-black-on-white",R3="cdk-high-contrast-white-on-black",ZO="cdk-high-contrast-active";let N3=(()=>{var t;class e{constructor(n,r){this._platform=n,this._document=r,this._breakpointSubscription=jn(L7).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const n=this._document.createElement("div");n.style.backgroundColor="rgb(1,2,3)",n.style.position="absolute",this._document.body.appendChild(n);const r=this._document.defaultView||window,i=r&&r.getComputedStyle?r.getComputedStyle(n):null,a=(i&&i.backgroundColor||"").replace(/ /g,"");switch(n.remove(),a){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const n=this._document.body.classList;n.remove(ZO,O3,R3),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?n.add(ZO,O3):2===r&&n.add(ZO,R3)}}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(wc),cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),M3=(()=>{var t;class e{constructor(n){n._applyBodyHighContrastModeCssClasses()}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(N3))},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[v3]}),e})();const i9=new Zn("cdk-dir-doc",{providedIn:"root",factory:function o9(){return jn(yi)}}),a9=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let td=(()=>{var t;class e{constructor(n){this.value="ltr",this.change=new Rr,n&&(this.value=function l9(t){const e=t?.toLowerCase()||"";return"auto"===e&&typeof navigator<"u"&&navigator?.language?a9.test(navigator.language)?"rtl":"ltr":"rtl"===e?"rtl":"ltr"}((n.body?n.body.dir:null)||(n.documentElement?n.documentElement.dir:null)||"ltr"))}ngOnDestroy(){this.change.complete()}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(i9,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),dC=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();const c9=["text"];function u9(t,e){if(1&t&&ti(0,"mat-pseudo-checkbox",6),2&t){const s=bs();Yn("disabled",s.disabled)("state",s.selected?"checked":"unchecked")}}function d9(t,e){1&t&&ti(0,"mat-pseudo-checkbox",7),2&t&&Yn("disabled",bs().disabled)}function h9(t,e){if(1&t&&(yn(0,"span",8),Ys(1),In()),2&t){const s=bs();Un(1),pd("(",s.group.label,")")}}const p9=[[["mat-icon"]],"*"],f9=["mat-icon","*"];let m9=(()=>{var t;class e{}return(t=e).STANDARD_CURVE="cubic-bezier(0.4,0.0,0.2,1)",t.DECELERATION_CURVE="cubic-bezier(0.0,0.0,0.2,1)",t.ACCELERATION_CURVE="cubic-bezier(0.4,0.0,1,1)",t.SHARP_CURVE="cubic-bezier(0.4,0.0,0.6,1)",e})(),g9=(()=>{var t;class e{}return(t=e).COMPLEX="375ms",t.ENTERING="225ms",t.EXITING="195ms",e})();const y9=new Zn("mat-sanity-checks",{providedIn:"root",factory:function _9(){return!0}});let nl=(()=>{var t;class e{constructor(n,r,i){this._sanityChecks=r,this._document=i,this._hasDoneGlobalChecks=!1,n._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(n){return!BO()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[n])}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(N3),cn(y9,8),cn(yi))},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[dC,dC]}),e})();function Sb(t){return class extends t{get disabled(){return this._disabled}set disabled(e){this._disabled=Yr(e)}constructor(...e){super(...e),this._disabled=!1}}}function Ib(t,e){return class extends t{get color(){return this._color}set color(s){const n=s||this.defaultColor;n!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),n&&this._elementRef.nativeElement.classList.add(`mat-${n}`),this._color=n)}constructor(...s){super(...s),this.defaultColor=e,this.color=e}}}function BS(t){return class extends t{get disableRipple(){return this._disableRipple}set disableRipple(e){this._disableRipple=Yr(e)}constructor(...e){super(...e),this._disableRipple=!1}}}function hC(t,e=0){return class extends t{get tabIndex(){return this.disabled?-1:this._tabIndex}set tabIndex(s){this._tabIndex=null!=s?Bl(s):this.defaultTabIndex}constructor(...s){super(...s),this._tabIndex=e,this.defaultTabIndex=e}}}function QO(t){return class extends t{updateErrorState(){const e=this.errorState,i=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);i!==e&&(this.errorState=i,this.stateChanges.next())}constructor(...e){super(...e),this.errorState=!1}}}function $3(t){return class extends t{constructor(...e){super(...e),this._isInitialized=!1,this._pendingSubscribers=[],this.initialized=new Ue(s=>{this._isInitialized?this._notifySubscriber(s):this._pendingSubscribers.push(s)})}_markInitialized(){this._isInitialized=!0,this._pendingSubscribers.forEach(this._notifySubscriber),this._pendingSubscribers=null}_notifySubscriber(e){e.next(),e.complete()}}}let VS=(()=>{var t;class e{isErrorState(n,r){return!!(n&&n.invalid&&(n.touched||r&&r.submitted))}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();class b9{constructor(e,s,n,r=!1){this._renderer=e,this.element=s,this.config=n,this._animationForciblyDisabledThroughCss=r,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const B3=Lm({passive:!0,capture:!0});class x9{constructor(){this._events=new Map,this._delegateEventHandler=e=>{const s=kh(e);s&&this._events.get(e.type)?.forEach((n,r)=>{(r===s||r.contains(s))&&n.forEach(i=>i.handleEvent(e))})}}addHandler(e,s,n,r){const i=this._events.get(s);if(i){const a=i.get(n);a?a.add(r):i.set(n,new Set([r]))}else this._events.set(s,new Map([[n,new Set([r])]])),e.runOutsideAngular(()=>{document.addEventListener(s,this._delegateEventHandler,B3)})}removeHandler(e,s,n){const r=this._events.get(e);if(!r)return;const i=r.get(s);i&&(i.delete(n),0===i.size&&r.delete(s),0===r.size&&(this._events.delete(e),document.removeEventListener(e,this._delegateEventHandler,B3)))}}const V3={enterDuration:225,exitDuration:150},U3=Lm({passive:!0,capture:!0}),z3=["mousedown","touchstart"],W3=["mouseup","mouseleave","touchend","touchcancel"];class fC{constructor(e,s,n,r){this._target=e,this._ngZone=s,this._platform=r,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,r.isBrowser&&(this._containerElement=cu(n))}fadeInRipple(e,s,n={}){const r=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i={...V3,...n.animation};n.centered&&(e=r.left+r.width/2,s=r.top+r.height/2);const a=n.radius||function C9(t,e,s){const n=Math.max(Math.abs(t-s.left),Math.abs(t-s.right)),r=Math.max(Math.abs(e-s.top),Math.abs(e-s.bottom));return Math.sqrt(n*n+r*r)}(e,s,r),c=e-r.left,f=s-r.top,g=i.enterDuration,E=document.createElement("div");E.classList.add("mat-ripple-element"),E.style.left=c-a+"px",E.style.top=f-a+"px",E.style.height=2*a+"px",E.style.width=2*a+"px",null!=n.color&&(E.style.backgroundColor=n.color),E.style.transitionDuration=`${g}ms`,this._containerElement.appendChild(E);const A=window.getComputedStyle(E),ne=A.transitionDuration,Ee="none"===A.transitionProperty||"0s"===ne||"0s, 0s"===ne||0===r.width&&0===r.height,Ge=new b9(this,E,n,Ee);E.style.transform="scale3d(1, 1, 1)",Ge.state=0,n.persistent||(this._mostRecentTransientRipple=Ge);let tt=null;return!Ee&&(g||i.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const Nt=()=>this._finishRippleTransition(Ge),kt=()=>this._destroyRipple(Ge);E.addEventListener("transitionend",Nt),E.addEventListener("transitioncancel",kt),tt={onTransitionEnd:Nt,onTransitionCancel:kt}}),this._activeRipples.set(Ge,tt),(Ee||!g)&&this._finishRippleTransition(Ge),Ge}fadeOutRipple(e){if(2===e.state||3===e.state)return;const s=e.element,n={...V3,...e.config.animation};s.style.transitionDuration=`${n.exitDuration}ms`,s.style.opacity="0",e.state=2,(e._animationForciblyDisabledThroughCss||!n.exitDuration)&&this._finishRippleTransition(e)}fadeOutAll(){this._getActiveRipples().forEach(e=>e.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(e=>{e.config.persistent||e.fadeOut()})}setupTriggerEvents(e){const s=cu(e);!this._platform.isBrowser||!s||s===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=s,z3.forEach(n=>{fC._eventManager.addHandler(this._ngZone,n,s,this)}))}handleEvent(e){"mousedown"===e.type?this._onMousedown(e):"touchstart"===e.type?this._onTouchStart(e):this._onPointerUp(),this._pointerUpEventsRegistered||(this._ngZone.runOutsideAngular(()=>{W3.forEach(s=>{this._triggerElement.addEventListener(s,this,U3)})}),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(e){0===e.state?this._startFadeOutTransition(e):2===e.state&&this._destroyRipple(e)}_startFadeOutTransition(e){const s=e===this._mostRecentTransientRipple,{persistent:n}=e.config;e.state=1,!n&&(!s||!this._isPointerDown)&&e.fadeOut()}_destroyRipple(e){const s=this._activeRipples.get(e)??null;this._activeRipples.delete(e),this._activeRipples.size||(this._containerRect=null),e===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),e.state=3,null!==s&&(e.element.removeEventListener("transitionend",s.onTransitionEnd),e.element.removeEventListener("transitioncancel",s.onTransitionCancel)),e.element.remove()}_onMousedown(e){const s=XO(e),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!s&&!n&&(this._isPointerDown=!0,this.fadeInRipple(e.clientX,e.clientY,this._target.rippleConfig))}_onTouchStart(e){if(!this._target.rippleDisabled&&!YO(e)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const s=e.changedTouches;if(s)for(let n=0;n<s.length;n++)this.fadeInRipple(s[n].clientX,s[n].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._getActiveRipples().forEach(e=>{!e.config.persistent&&(1===e.state||e.config.terminateOnPointerUp&&0===e.state)&&e.fadeOut()}))}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){const e=this._triggerElement;e&&(z3.forEach(s=>fC._eventManager.removeHandler(s,e,this)),this._pointerUpEventsRegistered&&W3.forEach(s=>e.removeEventListener(s,this,U3)))}}fC._eventManager=new x9;const mC=new Zn("mat-ripple-global-options");let US=(()=>{var t;class e{get disabled(){return this._disabled}set disabled(n){n&&this.fadeOutAllNonPersistent(),this._disabled=n,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(n){this._trigger=n,this._setupTriggerEventsIfEnabled()}constructor(n,r,i,a,c){this._elementRef=n,this._animationMode=c,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=a||{},this._rippleRenderer=new fC(this,r,n,i)}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(n,r=0,i){return"number"==typeof n?this._rippleRenderer.fadeInRipple(n,r,{...this.rippleConfig,...i}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...n})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Gs),lt(wc),lt(mC,8),lt(ac,8))},t.\u0275dir=Gn({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),e})(),zS=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,nl]}),e})(),E9=(()=>{var t;class e{constructor(n){this._animationMode=n,this.state="unchecked",this.disabled=!1,this.appearance="full"}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(ac,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-pseudo-checkbox"]],hostAttrs:[1,"mat-pseudo-checkbox"],hostVars:12,hostBindings:function(n,r){2&n&&Ei("mat-pseudo-checkbox-indeterminate","indeterminate"===r.state)("mat-pseudo-checkbox-checked","checked"===r.state)("mat-pseudo-checkbox-disabled",r.disabled)("mat-pseudo-checkbox-minimal","minimal"===r.appearance)("mat-pseudo-checkbox-full","full"===r.appearance)("_mat-animation-noopable","NoopAnimations"===r._animationMode)},inputs:{state:"state",disabled:"disabled",appearance:"appearance"},decls:0,vars:0,template:function(n,r){},styles:['.mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-full{border:2px solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}'],encapsulation:2,changeDetection:0}),e})(),D9=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl]}),e})();const H3=new Zn("MAT_OPTION_PARENT_COMPONENT"),j3=new Zn("MatOptgroup");let S9=0;class G3{constructor(e,s=!1){this.source=e,this.isUserInput=s}}let I9=(()=>{var t;class e{get multiple(){return this._parent&&this._parent.multiple}get selected(){return this._selected}get disabled(){return this.group&&this.group.disabled||this._disabled}set disabled(n){this._disabled=Yr(n)}get disableRipple(){return!(!this._parent||!this._parent.disableRipple)}get hideSingleSelectionIndicator(){return!(!this._parent||!this._parent.hideSingleSelectionIndicator)}constructor(n,r,i,a){this._element=n,this._changeDetectorRef=r,this._parent=i,this.group=a,this._selected=!1,this._active=!1,this._disabled=!1,this._mostRecentViewValue="",this.id="mat-option-"+S9++,this.onSelectionChange=new Rr,this._stateChanges=new Bt}get active(){return this._active}get viewValue(){return(this._text?.nativeElement.textContent||"").trim()}select(n=!0){this._selected||(this._selected=!0,this._changeDetectorRef.markForCheck(),n&&this._emitSelectionChangeEvent())}deselect(n=!0){this._selected&&(this._selected=!1,this._changeDetectorRef.markForCheck(),n&&this._emitSelectionChangeEvent())}focus(n,r){const i=this._getHostElement();"function"==typeof i.focus&&i.focus(r)}setActiveStyles(){this._active||(this._active=!0,this._changeDetectorRef.markForCheck())}setInactiveStyles(){this._active&&(this._active=!1,this._changeDetectorRef.markForCheck())}getLabel(){return this.viewValue}_handleKeydown(n){(13===n.keyCode||32===n.keyCode)&&!lh(n)&&(this._selectViaInteraction(),n.preventDefault())}_selectViaInteraction(){this.disabled||(this._selected=!this.multiple||!this._selected,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent(!0))}_getTabIndex(){return this.disabled?"-1":"0"}_getHostElement(){return this._element.nativeElement}ngAfterViewChecked(){if(this._selected){const n=this.viewValue;n!==this._mostRecentViewValue&&(this._mostRecentViewValue&&this._stateChanges.next(),this._mostRecentViewValue=n)}}ngOnDestroy(){this._stateChanges.complete()}_emitSelectionChangeEvent(n=!1){this.onSelectionChange.emit(new G3(this,n))}}return(t=e).\u0275fac=function(n){Tf()},t.\u0275dir=Gn({type:t,viewQuery:function(n,r){if(1&n&&qo(c9,7),2&n){let i;Ar(i=kr())&&(r._text=i.first)}},inputs:{value:"value",id:"id",disabled:"disabled"},outputs:{onSelectionChange:"onSelectionChange"}}),e})(),K3=(()=>{var t;class e extends I9{constructor(n,r,i,a){super(n,r,i,a)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Ll),lt(H3,8),lt(j3,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-option"]],hostAttrs:["role","option",1,"mat-mdc-option","mdc-list-item"],hostVars:11,hostBindings:function(n,r){1&n&&qs("click",function(){return r._selectViaInteraction()})("keydown",function(a){return r._handleKeydown(a)}),2&n&&(ih("id",r.id),si("aria-selected",r.selected)("aria-disabled",r.disabled.toString()),Ei("mdc-list-item--selected",r.selected)("mat-mdc-option-multiple",r.multiple)("mat-mdc-option-active",r.active)("mdc-list-item--disabled",r.disabled))},exportAs:["matOption"],features:[Ps],ngContentSelectors:f9,decls:8,vars:5,consts:[["class","mat-mdc-option-pseudo-checkbox","aria-hidden","true",3,"disabled","state",4,"ngIf"],[1,"mdc-list-item__primary-text"],["text",""],["class","mat-mdc-option-pseudo-checkbox","state","checked","aria-hidden","true","appearance","minimal",3,"disabled",4,"ngIf"],["class","cdk-visually-hidden",4,"ngIf"],["aria-hidden","true","mat-ripple","",1,"mat-mdc-option-ripple","mat-mdc-focus-indicator",3,"matRippleTrigger","matRippleDisabled"],["aria-hidden","true",1,"mat-mdc-option-pseudo-checkbox",3,"disabled","state"],["state","checked","aria-hidden","true","appearance","minimal",1,"mat-mdc-option-pseudo-checkbox",3,"disabled"],[1,"cdk-visually-hidden"]],template:function(n,r){1&n&&(Pl(p9),Fs(0,u9,1,2,"mat-pseudo-checkbox",0),ri(1),yn(2,"span",1,2),ri(4,1),In(),Fs(5,d9,1,1,"mat-pseudo-checkbox",3),Fs(6,h9,2,1,"span",4),ti(7,"div",5)),2&n&&(Yn("ngIf",r.multiple),Un(5),Yn("ngIf",!r.multiple&&r.selected&&!r.hideSingleSelectionIndicator),Un(1),Yn("ngIf",r.group&&r.group._inert),Un(1),Yn("matRippleTrigger",r._getHostElement())("matRippleDisabled",r.disabled||r.disableRipple))},dependencies:[US,$d,E9],styles:['.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color);font-family:var(--mat-option-label-text-font);line-height:var(--mat-option-label-text-line-height);font-size:var(--mat-option-label-text-size);letter-spacing:var(--mat-option-label-text-tracking);font-weight:var(--mat-option-label-text-weight);min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color)}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color)}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active .mat-mdc-focus-indicator::before{content:""}'],encapsulation:2,changeDetection:0}),e})();let WS=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[zS,Ah,nl,D9]}),e})();const Z3={capture:!0},Q3=["focus","click","mouseenter","touchstart"],JO="mat-ripple-loader-uninitialized",qO="mat-ripple-loader-class-name",J3="mat-ripple-loader-centered",HS="mat-ripple-loader-disabled";let q3=(()=>{var t;class e{constructor(){this._document=jn(yi,{optional:!0}),this._animationMode=jn(ac,{optional:!0}),this._globalRippleOptions=jn(mC,{optional:!0}),this._platform=jn(wc),this._ngZone=jn(Gs),this._onInteraction=n=>{if(!(n.target instanceof HTMLElement))return;const i=n.target.closest(`[${JO}]`);i&&this.createRipple(i)},this._ngZone.runOutsideAngular(()=>{for(const n of Q3)this._document?.addEventListener(n,this._onInteraction,Z3)})}ngOnDestroy(){for(const n of Q3)this._document?.removeEventListener(n,this._onInteraction,Z3)}configureRipple(n,r){n.setAttribute(JO,""),(r.className||!n.hasAttribute(qO))&&n.setAttribute(qO,r.className||""),r.centered&&n.setAttribute(J3,""),r.disabled&&n.setAttribute(HS,"")}getRipple(n){return n.matRipple?n.matRipple:this.createRipple(n)}setDisabled(n,r){const i=n.matRipple;i?i.disabled=r:r?n.setAttribute(HS,""):n.removeAttribute(HS)}createRipple(n){if(!this._document)return;n.querySelector(".mat-ripple")?.remove();const r=this._document.createElement("span");r.classList.add("mat-ripple",n.getAttribute(qO)),n.append(r);const i=new US(new yr(r),this._ngZone,this._platform,this._globalRippleOptions?this._globalRippleOptions:void 0,this._animationMode?this._animationMode:void 0);return i._isInitialized=!0,i.trigger=n,i.centered=n.hasAttribute(J3),i.disabled=n.hasAttribute(HS),this.attachRipple(n,i),i}attachRipple(n,r){n.removeAttribute(JO),n.matRipple=r}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const T9=["*"],A9=[[["mat-card-title"],["mat-card-subtitle"],["","mat-card-title",""],["","mat-card-subtitle",""],["","matCardTitle",""],["","matCardSubtitle",""]],[["","mat-card-image",""],["","matCardImage",""],["","mat-card-sm-image",""],["","matCardImageSmall",""],["","mat-card-md-image",""],["","matCardImageMedium",""],["","mat-card-lg-image",""],["","matCardImageLarge",""],["","mat-card-xl-image",""],["","matCardImageXLarge",""]],"*"],k9=["mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]","[mat-card-image], [matCardImage],\n                    [mat-card-sm-image], [matCardImageSmall],\n                    [mat-card-md-image], [matCardImageMedium],\n                    [mat-card-lg-image], [matCardImageLarge],\n                    [mat-card-xl-image], [matCardImageXLarge]","*"],O9=[[["","mat-card-avatar",""],["","matCardAvatar",""]],[["mat-card-title"],["mat-card-subtitle"],["","mat-card-title",""],["","mat-card-subtitle",""],["","matCardTitle",""],["","matCardSubtitle",""]],"*"],R9=["[mat-card-avatar], [matCardAvatar]","mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]","*"],N9=new Zn("MAT_CARD_CONFIG");let gC=(()=>{var t;class e{constructor(n){this.appearance=n?.appearance||"raised"}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(N9,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-card"]],hostAttrs:[1,"mat-mdc-card","mdc-card"],hostVars:4,hostBindings:function(n,r){2&n&&Ei("mat-mdc-card-outlined","outlined"===r.appearance)("mdc-card--outlined","outlined"===r.appearance)},inputs:{appearance:"appearance"},exportAs:["matCard"],ngContentSelectors:T9,decls:1,vars:0,template:function(n,r){1&n&&(Pl(),ri(0))},styles:['.mdc-card{display:flex;flex-direction:column;box-sizing:border-box}.mdc-card::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none;pointer-events:none}@media screen and (forced-colors: active){.mdc-card::after{border-color:CanvasText}}.mdc-card--outlined::after{border:none}.mdc-card__content{border-radius:inherit;height:100%}.mdc-card__media{position:relative;box-sizing:border-box;background-repeat:no-repeat;background-position:center;background-size:cover}.mdc-card__media::before{display:block;content:""}.mdc-card__media:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__media:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__media--square::before{margin-top:100%}.mdc-card__media--16-9::before{margin-top:56.25%}.mdc-card__media-content{position:absolute;top:0;right:0;bottom:0;left:0;box-sizing:border-box}.mdc-card__primary-action{display:flex;flex-direction:column;box-sizing:border-box;position:relative;outline:none;color:inherit;text-decoration:none;cursor:pointer;overflow:hidden}.mdc-card__primary-action:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__primary-action:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__actions{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;min-height:52px;padding:8px}.mdc-card__actions--full-bleed{padding:0}.mdc-card__action-buttons,.mdc-card__action-icons{display:flex;flex-direction:row;align-items:center;box-sizing:border-box}.mdc-card__action-icons{color:rgba(0, 0, 0, 0.6);flex-grow:1;justify-content:flex-end}.mdc-card__action-buttons+.mdc-card__action-icons{margin-left:16px;margin-right:0}[dir=rtl] .mdc-card__action-buttons+.mdc-card__action-icons,.mdc-card__action-buttons+.mdc-card__action-icons[dir=rtl]{margin-left:0;margin-right:16px}.mdc-card__action{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;justify-content:center;cursor:pointer;user-select:none}.mdc-card__action:focus{outline:none}.mdc-card__action--button{margin-left:0;margin-right:8px;padding:0 8px}[dir=rtl] .mdc-card__action--button,.mdc-card__action--button[dir=rtl]{margin-left:8px;margin-right:0}.mdc-card__action--button:last-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-card__action--button:last-child,.mdc-card__action--button:last-child[dir=rtl]{margin-left:0;margin-right:0}.mdc-card__actions--full-bleed .mdc-card__action--button{justify-content:space-between;width:100%;height:auto;max-height:none;margin:0;padding:8px 16px;text-align:left}[dir=rtl] .mdc-card__actions--full-bleed .mdc-card__action--button,.mdc-card__actions--full-bleed .mdc-card__action--button[dir=rtl]{text-align:right}.mdc-card__action--icon{margin:-6px 0;padding:12px}.mdc-card__action--icon:not(:disabled){color:rgba(0, 0, 0, 0.6)}.mat-mdc-card{border-radius:var(--mdc-elevated-card-container-shape);background-color:var(--mdc-elevated-card-container-color);border-width:0;border-style:solid;border-color:var(--mdc-elevated-card-container-color);box-shadow:var(--mdc-elevated-card-container-elevation);--mdc-elevated-card-container-shape:4px;--mdc-outlined-card-container-shape:4px;--mdc-outlined-card-outline-width:1px}.mat-mdc-card .mdc-card::after{border-radius:var(--mdc-elevated-card-container-shape)}.mat-mdc-card-outlined{border-width:var(--mdc-outlined-card-outline-width);border-style:solid;border-color:var(--mdc-outlined-card-outline-color);border-radius:var(--mdc-outlined-card-container-shape);background-color:var(--mdc-outlined-card-container-color);box-shadow:var(--mdc-outlined-card-container-elevation)}.mat-mdc-card-outlined .mdc-card::after{border-radius:var(--mdc-outlined-card-container-shape)}.mat-mdc-card-title{font-family:var(--mat-card-title-text-font);line-height:var(--mat-card-title-text-line-height);font-size:var(--mat-card-title-text-size);letter-spacing:var(--mat-card-title-text-tracking);font-weight:var(--mat-card-title-text-weight)}.mat-mdc-card-subtitle{color:var(--mat-card-subtitle-text-color);font-family:var(--mat-card-subtitle-text-font);line-height:var(--mat-card-subtitle-text-line-height);font-size:var(--mat-card-subtitle-text-size);letter-spacing:var(--mat-card-subtitle-text-tracking);font-weight:var(--mat-card-subtitle-text-weight)}.mat-mdc-card{position:relative}.mat-mdc-card-title,.mat-mdc-card-subtitle{display:block;margin:0}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle{padding:16px 16px 0}.mat-mdc-card-header{display:flex;padding:16px 16px 0}.mat-mdc-card-content{display:block;padding:0 16px}.mat-mdc-card-content:first-child{padding-top:16px}.mat-mdc-card-content:last-child{padding-bottom:16px}.mat-mdc-card-title-group{display:flex;justify-content:space-between;width:100%}.mat-mdc-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;margin-bottom:16px;object-fit:cover}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title{line-height:normal}.mat-mdc-card-sm-image{width:80px;height:80px}.mat-mdc-card-md-image{width:112px;height:112px}.mat-mdc-card-lg-image{width:152px;height:152px}.mat-mdc-card-xl-image{width:240px;height:240px}.mat-mdc-card-subtitle~.mat-mdc-card-title,.mat-mdc-card-title~.mat-mdc-card-subtitle,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-title-group .mat-mdc-card-title,.mat-mdc-card-title-group .mat-mdc-card-subtitle{padding-top:0}.mat-mdc-card-content>:last-child:not(.mat-mdc-card-footer){margin-bottom:0}.mat-mdc-card-actions-align-end{justify-content:flex-end}'],encapsulation:2,changeDetection:0}),e})(),eR=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-card-title"],["","mat-card-title",""],["","matCardTitle",""]],hostAttrs:[1,"mat-mdc-card-title"]}),e})(),eB=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275cmp=sr({type:t,selectors:[["mat-card-title-group"]],hostAttrs:[1,"mat-mdc-card-title-group"],ngContentSelectors:k9,decls:4,vars:0,template:function(n,r){1&n&&(Pl(A9),yn(0,"div"),ri(1),In(),ri(2,1),ri(3,2))},encapsulation:2,changeDetection:0}),e})(),jS=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-card-content"]],hostAttrs:[1,"mat-mdc-card-content"]}),e})(),GS=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-card-subtitle"],["","mat-card-subtitle",""],["","matCardSubtitle",""]],hostAttrs:[1,"mat-mdc-card-subtitle"]}),e})(),tB=(()=>{var t;class e{constructor(){this.align="start"}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-card-actions"]],hostAttrs:[1,"mat-mdc-card-actions","mdc-card__actions"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("mat-mdc-card-actions-align-end","end"===r.align)},inputs:{align:"align"},exportAs:["matCardActions"]}),e})(),nB=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275cmp=sr({type:t,selectors:[["mat-card-header"]],hostAttrs:[1,"mat-mdc-card-header"],ngContentSelectors:R9,decls:4,vars:0,consts:[[1,"mat-mdc-card-header-text"]],template:function(n,r){1&n&&(Pl(O9),ri(0),yn(1,"div",0),ri(2,1),In(),ri(3,2))},encapsulation:2,changeDetection:0}),e})(),sB=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["","mat-card-xl-image",""],["","matCardImageXLarge",""]],hostAttrs:[1,"mat-mdc-card-xl-image","mdc-card__media"]}),e})(),B9=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,Ah,nl]}),e})();const V9=["*"];let KS;function _C(t){return function U9(){if(void 0===KS&&(KS=null,typeof window<"u")){const t=window;void 0!==t.trustedTypes&&(KS=t.trustedTypes.createPolicy("angular#components",{createHTML:e=>e}))}return KS}()?.createHTML(t)||t}function rB(t){return Error(`Unable to find icon with the name "${t}"`)}function iB(t){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`)}function oB(t){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`)}class a0{constructor(e,s,n){this.url=e,this.svgText=s,this.options=n}}let XS=(()=>{var t;class e{constructor(n,r,i,a){this._httpClient=n,this._sanitizer=r,this._errorHandler=a,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass=["material-icons","mat-ligature-font"],this._document=i}addSvgIcon(n,r,i){return this.addSvgIconInNamespace("",n,r,i)}addSvgIconLiteral(n,r,i){return this.addSvgIconLiteralInNamespace("",n,r,i)}addSvgIconInNamespace(n,r,i,a){return this._addSvgIconConfig(n,r,new a0(i,null,a))}addSvgIconResolver(n){return this._resolvers.push(n),this}addSvgIconLiteralInNamespace(n,r,i,a){const c=this._sanitizer.sanitize(nu.HTML,i);if(!c)throw oB(i);const f=_C(c);return this._addSvgIconConfig(n,r,new a0("",f,a))}addSvgIconSet(n,r){return this.addSvgIconSetInNamespace("",n,r)}addSvgIconSetLiteral(n,r){return this.addSvgIconSetLiteralInNamespace("",n,r)}addSvgIconSetInNamespace(n,r,i){return this._addSvgIconSetConfig(n,new a0(r,null,i))}addSvgIconSetLiteralInNamespace(n,r,i){const a=this._sanitizer.sanitize(nu.HTML,r);if(!a)throw oB(r);const c=_C(a);return this._addSvgIconSetConfig(n,new a0("",c,i))}registerFontClassAlias(n,r=n){return this._fontCssClassesByAlias.set(n,r),this}classNameForFontAlias(n){return this._fontCssClassesByAlias.get(n)||n}setDefaultFontSetClass(...n){return this._defaultFontSetClass=n,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(n){const r=this._sanitizer.sanitize(nu.RESOURCE_URL,n);if(!r)throw iB(n);const i=this._cachedIconsByUrl.get(r);return i?Xs(YS(i)):this._loadSvgIconFromConfig(new a0(n,null)).pipe(Kc(a=>this._cachedIconsByUrl.set(r,a)),Xn(a=>YS(a)))}getNamedSvgIcon(n,r=""){const i=aB(r,n);let a=this._svgIconConfigs.get(i);if(a)return this._getSvgFromConfig(a);if(a=this._getIconConfigFromResolvers(r,n),a)return this._svgIconConfigs.set(i,a),this._getSvgFromConfig(a);const c=this._iconSetConfigs.get(r);return c?this._getSvgFromIconSetConfigs(n,c):pb(rB(i))}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(n){return n.svgText?Xs(YS(this._svgElementFromConfig(n))):this._loadSvgIconFromConfig(n).pipe(Xn(r=>YS(r)))}_getSvgFromIconSetConfigs(n,r){const i=this._extractIconWithNameFromAnySet(n,r);return i?Xs(i):LF(r.filter(c=>!c.svgText).map(c=>this._loadSvgIconSetFromConfig(c).pipe(h_(f=>{const E=`Loading icon set URL: ${this._sanitizer.sanitize(nu.RESOURCE_URL,c.url)} failed: ${f.message}`;return this._errorHandler.handleError(new Error(E)),Xs(null)})))).pipe(Xn(()=>{const c=this._extractIconWithNameFromAnySet(n,r);if(!c)throw rB(n);return c}))}_extractIconWithNameFromAnySet(n,r){for(let i=r.length-1;i>=0;i--){const a=r[i];if(a.svgText&&a.svgText.toString().indexOf(n)>-1){const c=this._svgElementFromConfig(a),f=this._extractSvgIconFromSet(c,n,a.options);if(f)return f}}return null}_loadSvgIconFromConfig(n){return this._fetchIcon(n).pipe(Kc(r=>n.svgText=r),Xn(()=>this._svgElementFromConfig(n)))}_loadSvgIconSetFromConfig(n){return n.svgText?Xs(null):this._fetchIcon(n).pipe(Kc(r=>n.svgText=r))}_extractSvgIconFromSet(n,r,i){const a=n.querySelector(`[id="${r}"]`);if(!a)return null;const c=a.cloneNode(!0);if(c.removeAttribute("id"),"svg"===c.nodeName.toLowerCase())return this._setSvgAttributes(c,i);if("symbol"===c.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(c),i);const f=this._svgElementFromString(_C("<svg></svg>"));return f.appendChild(c),this._setSvgAttributes(f,i)}_svgElementFromString(n){const r=this._document.createElement("DIV");r.innerHTML=n;const i=r.querySelector("svg");if(!i)throw Error("<svg> tag not found");return i}_toSvgElement(n){const r=this._svgElementFromString(_C("<svg></svg>")),i=n.attributes;for(let a=0;a<i.length;a++){const{name:c,value:f}=i[a];"id"!==c&&r.setAttribute(c,f)}for(let a=0;a<n.childNodes.length;a++)n.childNodes[a].nodeType===this._document.ELEMENT_NODE&&r.appendChild(n.childNodes[a].cloneNode(!0));return r}_setSvgAttributes(n,r){return n.setAttribute("fit",""),n.setAttribute("height","100%"),n.setAttribute("width","100%"),n.setAttribute("preserveAspectRatio","xMidYMid meet"),n.setAttribute("focusable","false"),r&&r.viewBox&&n.setAttribute("viewBox",r.viewBox),n}_fetchIcon(n){const{url:r,options:i}=n,a=i?.withCredentials??!1;if(!this._httpClient)throw function z9(){return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.")}();if(null==r)throw Error(`Cannot fetch icon from URL "${r}".`);const c=this._sanitizer.sanitize(nu.RESOURCE_URL,r);if(!c)throw iB(r);const f=this._inProgressUrlFetches.get(c);if(f)return f;const g=this._httpClient.get(c,{responseType:"text",withCredentials:a}).pipe(Xn(E=>_C(E)),cb(()=>this._inProgressUrlFetches.delete(c)),ro());return this._inProgressUrlFetches.set(c,g),g}_addSvgIconConfig(n,r,i){return this._svgIconConfigs.set(aB(n,r),i),this}_addSvgIconSetConfig(n,r){const i=this._iconSetConfigs.get(n);return i?i.push(r):this._iconSetConfigs.set(n,[r]),this}_svgElementFromConfig(n){if(!n.svgElement){const r=this._svgElementFromString(n.svgText);this._setSvgAttributes(r,n.options),n.svgElement=r}return n.svgElement}_getIconConfigFromResolvers(n,r){for(let i=0;i<this._resolvers.length;i++){const a=this._resolvers[i](r,n);if(a)return H9(a)?new a0(a.url,null,a.options):new a0(a,null)}}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Vw,8),cn(V2),cn(yi,8),cn(nh))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();function YS(t){return t.cloneNode(!0)}function aB(t,e){return t+":"+e}function H9(t){return!(!t.url||!t.options)}const j9=Ib(class{constructor(t){this._elementRef=t}}),G9=new Zn("MAT_ICON_DEFAULT_OPTIONS"),K9=new Zn("mat-icon-location",{providedIn:"root",factory:function X9(){const t=jn(yi),e=t?t.location:null;return{getPathname:()=>e?e.pathname+e.search:""}}}),lB=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],Y9=lB.map(t=>`[${t}]`).join(", "),Z9=/^url\(['"]?#(.*?)['"]?\)$/;let yC=(()=>{var t;class e extends j9{get inline(){return this._inline}set inline(n){this._inline=Yr(n)}get svgIcon(){return this._svgIcon}set svgIcon(n){n!==this._svgIcon&&(n?this._updateSvgIcon(n):this._svgIcon&&this._clearSvgElement(),this._svgIcon=n)}get fontSet(){return this._fontSet}set fontSet(n){const r=this._cleanupFontValue(n);r!==this._fontSet&&(this._fontSet=r,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(n){const r=this._cleanupFontValue(n);r!==this._fontIcon&&(this._fontIcon=r,this._updateFontIconClasses())}constructor(n,r,i,a,c,f){super(n),this._iconRegistry=r,this._location=a,this._errorHandler=c,this._inline=!1,this._previousFontSetClass=[],this._currentIconFetch=I.EMPTY,f&&(f.color&&(this.color=this.defaultColor=f.color),f.fontSet&&(this.fontSet=f.fontSet)),i||n.nativeElement.setAttribute("aria-hidden","true")}_splitIconName(n){if(!n)return["",""];const r=n.split(":");switch(r.length){case 1:return["",r[0]];case 2:return r;default:throw Error(`Invalid icon name: "${n}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const n=this._elementsWithExternalReferences;if(n&&n.size){const r=this._location.getPathname();r!==this._previousPath&&(this._previousPath=r,this._prependPathToReferences(r))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(n){this._clearSvgElement();const r=this._location.getPathname();this._previousPath=r,this._cacheChildrenWithExternalReferences(n),this._prependPathToReferences(r),this._elementRef.nativeElement.appendChild(n)}_clearSvgElement(){const n=this._elementRef.nativeElement;let r=n.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();r--;){const i=n.childNodes[r];(1!==i.nodeType||"svg"===i.nodeName.toLowerCase())&&i.remove()}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const n=this._elementRef.nativeElement,r=(this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/):this._iconRegistry.getDefaultFontSetClass()).filter(i=>i.length>0);this._previousFontSetClass.forEach(i=>n.classList.remove(i)),r.forEach(i=>n.classList.add(i)),this._previousFontSetClass=r,this.fontIcon!==this._previousFontIconClass&&!r.includes("mat-ligature-font")&&(this._previousFontIconClass&&n.classList.remove(this._previousFontIconClass),this.fontIcon&&n.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(n){return"string"==typeof n?n.trim().split(" ")[0]:n}_prependPathToReferences(n){const r=this._elementsWithExternalReferences;r&&r.forEach((i,a)=>{i.forEach(c=>{a.setAttribute(c.name,`url('${n}#${c.value}')`)})})}_cacheChildrenWithExternalReferences(n){const r=n.querySelectorAll(Y9),i=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let a=0;a<r.length;a++)lB.forEach(c=>{const f=r[a],g=f.getAttribute(c),E=g?g.match(Z9):null;if(E){let A=i.get(f);A||(A=[],i.set(f,A)),A.push({name:c,value:E[1]})}})}_updateSvgIcon(n){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),n){const[r,i]=this._splitIconName(n);r&&(this._svgNamespace=r),i&&(this._svgName=i),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(i,r).pipe($l(1)).subscribe(a=>this._setSvgElement(a),a=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${r}:${i}! ${a.message}`))})}}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(XS),na("aria-hidden"),lt(K9),lt(nh),lt(G9,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:8,hostBindings:function(n,r){2&n&&(si("data-mat-icon-type",r._usingFontIcon()?"font":"svg")("data-mat-icon-name",r._svgName||r.fontIcon)("data-mat-icon-namespace",r._svgNamespace||r.fontSet)("fontIcon",r._usingFontIcon()?r.fontIcon:null),Ei("mat-icon-inline",r.inline)("mat-icon-no-color","primary"!==r.color&&"accent"!==r.color&&"warn"!==r.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[Ps],ngContentSelectors:V9,decls:1,vars:0,template:function(n,r){1&n&&(Pl(),ri(0))},styles:["mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"],encapsulation:2,changeDetection:0}),e})(),Q9=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,nl]}),e})();class cB{}class J9{}const Bm="*";function nd(t,e){return{type:7,name:t,definitions:e,options:{}}}function nc(t,e=null){return{type:4,styles:e,timings:t}}function uB(t,e=null){return{type:2,steps:t,options:e}}function Mi(t){return{type:6,styles:t,offset:null}}function Vl(t,e,s){return{type:0,name:t,styles:e,options:s}}function ZS(t){return{type:5,steps:t}}function sc(t,e,s=null){return{type:1,expr:t,animation:e,options:s}}function QS(t=null){return{type:9,options:t}}function JS(t,e,s=null){return{type:11,selector:t,animation:e,options:s}}class vC{constructor(e=0,s=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=e+s}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(e=>e()),this._onDoneFns=[])}onStart(e){this._originalOnStartFns.push(e),this._onStartFns.push(e)}onDone(e){this._originalOnDoneFns.push(e),this._onDoneFns.push(e)}onDestroy(e){this._onDestroyFns.push(e)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){queueMicrotask(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(e=>e()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(e=>e()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(e){this._position=this.totalTime?e*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(e){const s="start"==e?this._onStartFns:this._onDoneFns;s.forEach(n=>n()),s.length=0}}class dB{constructor(e){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=e;let s=0,n=0,r=0;const i=this.players.length;0==i?queueMicrotask(()=>this._onFinish()):this.players.forEach(a=>{a.onDone(()=>{++s==i&&this._onFinish()}),a.onDestroy(()=>{++n==i&&this._onDestroy()}),a.onStart(()=>{++r==i&&this._onStart()})}),this.totalTime=this.players.reduce((a,c)=>Math.max(a,c.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(e=>e()),this._onDoneFns=[])}init(){this.players.forEach(e=>e.init())}onStart(e){this._onStartFns.push(e)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(e=>e()),this._onStartFns=[])}onDone(e){this._onDoneFns.push(e)}onDestroy(e){this._onDestroyFns.push(e)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(e=>e.play())}pause(){this.players.forEach(e=>e.pause())}restart(){this.players.forEach(e=>e.restart())}finish(){this._onFinish(),this.players.forEach(e=>e.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(e=>e.destroy()),this._onDestroyFns.forEach(e=>e()),this._onDestroyFns=[])}reset(){this.players.forEach(e=>e.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(e){const s=e*this.totalTime;this.players.forEach(n=>{const r=n.totalTime?Math.min(1,s/n.totalTime):1;n.setPosition(r)})}getPosition(){const e=this.players.reduce((s,n)=>null===s||n.totalTime>s.totalTime?n:s,null);return null!=e?e.getPosition():0}beforeDestroy(){this.players.forEach(e=>{e.beforeDestroy&&e.beforeDestroy()})}triggerCallback(e){const s="start"==e?this._onStartFns:this._onDoneFns;s.forEach(n=>n()),s.length=0}}function sR(t=0,e,s=R7){let n=-1;return null!=e&&(fc(e)?s=e:n=e),new Ue(r=>{let i=function q9(t){return t instanceof Date&&!isNaN(t)}(t)?+t-s.now():t;i<0&&(i=0);let a=0;return s.schedule(function(){r.closed||(r.next(a++),0<=n?this.schedule(void 0,n):r.complete())},i)})}function hB(t=0,e=lC){return t<0&&(t=0),sR(t,t,e)}class ch{constructor(e,s,n,r,i,a,c){this.title=e,this.author=s,this.genre=n,this.beatsPerMinute=r,this.duration=i,this.sourcePath=a,this.sourceLink=c}}class eX{static getTracks(){return[new ch("Track 1","DRUMSTATION","Boom Bap",90,0,"./assets/track1.mp3","https://youtu.be/_hY9bDJ0dSE?si=cztyIvkvaZntGflu"),new ch("Track 2","prod.dailydailydaily","Neo Soul",75,0,"./assets/track2.mp3","https://youtu.be/pSPs0uvY1ts?si=vFBplHTZHfAEJxCv"),new ch("Track 3","DRUMSTATION","Hip Hop",88,0,"./assets/track3.mp3","https://youtu.be/JNjYXdaK4Qo?si=5Nz-hX0_kTFzd8Z5"),new ch("Track 11","JunzMuzik","Funk",120,0,"./assets/track11.mp3","https://youtu.be/_mSxePYM7-8?si=E0828eCos069YAA4"),new ch("Track 4","JunzMuzik","Funk",100,0,"./assets/track4.mp3","https://youtu.be/nfwaDgXvjnk?si=nT5Vz9rjOPFsnOll"),new ch("Track 12","prod.dailydailydaily","Neo Soul 6/8",75,0,"./assets/track12.mp3","https://youtu.be/gxOeTKuYZhs?si=H2wwQpkCpHiAwejE"),new ch("Track 5","DRUMSTATION","Funk",92,0,"./assets/track5.mp3","https://youtu.be/PjfTULbvvos?si=1PZL1vhUXbKNoa-W"),new ch("Track 6","DRUMSTATION","Hip Hop RNB",106,0,"./assets/track6.mp3","https://youtu.be/lAI1zIwGmcI?si=Z5cjgiWCZi7MwDx1"),new ch("Track 14","prod.dailydailydaily","Neo Soul",80,0,"./assets/track14.mp3","https://youtu.be/49ttJ4W6R60?si=A9EnUOqtMuOs4uoK"),new ch("Track 7","DRUMSTATION","Hip Hop Boom Bap",93,0,"./assets/track7.mp3","https://youtu.be/vW99nqdhuXo?si=vzkogI0Frb62hbNn"),new ch("Track 13","prod.dailydailydaily","Neo Soul",80,0,"./assets/track13.mp3","https://youtu.be/43xqSxWNkX0?si=LyTFMuYXhvhjscOt"),new ch("Track 8","DRUMSTATION","Angry Hip Hop Boom Bap",95,0,"./assets/track8.mp3","https://youtu.be/HtAub7iF2zQ?si=Msbyg5mQZOcuhv-6"),new ch("Track 9","DRUMSTATION","Funk Hip Hop",85,0,"./assets/track9.mp3","https://youtu.be/K0NHrjvJg28?si=Cyivs4MCXImX45rn"),new ch("Track 10","DRUMSTATION","Boom Bap",87,0,"./assets/track10.mp3","https://youtu.be/f3ja_RCQabs?si=K_NrIPpQXCsVoP4y")]}}let pB=(()=>{var t;class e{constructor(){this.db=null}openDatabase(n,r){return new Promise((i,a)=>{const c=indexedDB.open(n,r);c.onupgradeneeded=f=>{const g=f.target.result;if(!g.objectStoreNames.contains("tracks")){const E=g.createObjectStore("tracks",{keyPath:"title"});E.createIndex("beatsPerMinute","beatsPerMinute",{unique:!1}),E.createIndex("genre","genre",{unique:!1}),E.createIndex("sourcePath","sourcePath",{unique:!0})}},c.onsuccess=f=>{this.db=f.target.result;const g=this.db.transaction("tracks","readonly"),E=g.objectStore("tracks"),A=[];g.oncomplete=()=>{i(A)},g.onerror=ne=>{console.error("Error opening database:",ne),a(ne)},E.openCursor().onsuccess=ne=>{const Ee=ne.target.result;Ee&&(A.push(Ee.value),Ee.continue())}},c.onerror=f=>{console.error("Failed to open the database:",f.target.error),a(f.target.error)}})}addDefaultTracks(){return new Promise((n,r)=>{if(!this.db)return void r(new Error("Database is not open."));const i=this.db.transaction(["tracks"],"readwrite"),a=i.objectStore("tracks"),c=[];eX.getTracks().forEach(f=>{a.add(f).onsuccess=()=>{console.log("Added a default track to the database!"),c.push(f)}}),i.oncomplete=()=>{console.log("Done adding all default tracks!"),n(c)},i.onerror=()=>{i.onerror=f=>{console.error("Error adding default tracks to database:",f.target.error),r(f.target.error)}}})}clearDatabase(){return new Promise((n,r)=>{if(!this.db)return void r(new Error("Database is not open."));const i=this.db.transaction("tracks","readwrite"),a=i.objectStore("tracks");i.oncomplete=()=>{n()},i.onerror=f=>{console.error("Error clearing database:",f.target.error),r(f.target.error)},a.clear().onsuccess=()=>{console.log("Database cleared.")}})}getAllTracks(){return new Promise((n,r)=>{if(!this.db)return void r(new Error("Database is not open."));const i=this.db.transaction("tracks","readonly"),a=i.objectStore("tracks"),c=[];i.oncomplete=()=>{n(c)},i.onerror=g=>{console.error("Error retrieving tracks:",g.target.error),r(g.target.error)},a.openCursor().onsuccess=g=>{const E=g.target.result;E&&(c.push(E.value),E.continue())}})}updateTrack(n){return new Promise((r,i)=>{if(!this.db)return void i(new Error("Database is not open."));const f=this.db.transaction("tracks","readwrite").objectStore("tracks").put(n);f.onsuccess=()=>{console.log(`Track updated: ${n.title}`),r()},f.onerror=g=>{console.error(`Error updating track: ${n.title}`,g.target.error),i(g.target.error)}})}updateTrackDurationIfZero(n){return new Promise((r,i)=>{if(!this.db)return void i(new Error("Database is not open."));const c=this.db.transaction("tracks","readwrite").objectStore("tracks"),f=c.get(n.title);f.onsuccess=g=>{const E=g.target.result;if(E&&0===E.duration){E.duration=n.duration;const A=c.put(E);A.onsuccess=()=>{console.log(`Track duration updated: ${E.title}`),r()},A.onerror=Y=>{console.error(`Error updating track duration: ${E.title}`,Y.target.error),i(Y.target.error)}}else console.log(`No update needed for track: ${n.title}`),r()},f.onerror=g=>{console.error(`Error getting track: ${n.title}`,g.target.error),i(g.target.error)}})}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),rR=(()=>{var t;class e{constructor(n){this.http=n,this.backTrackDuration=0,this.backTrackEnded=!1,this.audioBuffer=null,this.bufferSubject=new Bt,this.startedLoadingBuffer=!1,this.playbackSubject=new Bt,this.currentTimeSubject=new Bt,this.volumeSubject=new Di(100),this.audioContext=new AudioContext,this.backTrack=new Audio,this.backTrackSourceNode=this.audioContext.createMediaElementSource(this.backTrack),this.gainNode=this.audioContext.createGain(),this.panNode=this.audioContext.createStereoPanner(),this.compressorNode=this.audioContext.createDynamicsCompressor(),this.compressorNode.threshold.value=0,this.compressorNode.knee.value=5,this.compressorNode.ratio.value=12,this.compressorNode.attack.value=.001,this.compressorNode.release.value=.003,this.lowBandFilterNode=this.audioContext.createBiquadFilter(),this.midBandFilterNode=this.audioContext.createBiquadFilter(),this.highBandFilterNode=this.audioContext.createBiquadFilter(),this.lowBandFilterNode.type="lowshelf",this.lowBandFilterNode.frequency.value=250,this.midBandFilterNode.type="peaking",this.midBandFilterNode.frequency.value=1e3,this.highBandFilterNode.type="highshelf",this.highBandFilterNode.frequency.value=4e3,this.backTrackSourceNode.connect(this.compressorNode).connect(this.panNode).connect(this.lowBandFilterNode).connect(this.midBandFilterNode).connect(this.highBandFilterNode).connect(this.gainNode).connect(this.audioContext.destination),this.backTrack.addEventListener("play",()=>{this.playBackTrack()}),this.backTrack.addEventListener("pause",()=>this.pauseBackTrack()),this.backTrack.addEventListener("ended",()=>this.endBackTrack()),this.backTrack.addEventListener("loadedmetadata",()=>this.setDuration()),this.backTrack.addEventListener("timeupdate",()=>{this.currentTimeSubject.next(this.backTrack.currentTime)})}ngOnDestroy(){this.backTrackSourceNode.disconnect(),this.gainNode.disconnect(),this.panNode.disconnect(),this.compressorNode.disconnect(),this.lowBandFilterNode.disconnect(),this.midBandFilterNode.disconnect(),this.highBandFilterNode.disconnect(),this.audioContext.close()}getAudioBuffer(){return this.bufferSubject.asObservable()}getPlaybackState(){return this.playbackSubject.asObservable()}getCurrentTime(){return this.currentTimeSubject.asObservable()}getVolumeLevel(){return this.volumeSubject.asObservable()}playBackTrack(){return this.backTrackEnded=!1,this.playbackSubject.next(!0)}pauseBackTrack(){return this.playbackSubject.next(!1)}endBackTrack(){return this.backTrackEnded=!0,this.cleanUpBackTrackAudio(),this.playbackSubject.next(!1)}playOnLoad(n){this.http.get(n,{responseType:"blob"}).subscribe(r=>{const i=URL.createObjectURL(r);this.backTrack.src=i,this.backTrack.load(),this.backTrack.play()})}loadAudioBuffer(n){this.startedLoadingBuffer=!0,this.http.get(n,{responseType:"arraybuffer"}).subscribe(r=>{this.audioContext.decodeAudioData(r,i=>{this.startedLoadingBuffer=!1,this.audioBuffer=i,this.bufferSubject.next(i)},i=>{console.error("Error decoding audio data:",i),this.bufferSubject.next(null),this.startedLoadingBuffer=!1})},r=>{console.error("Error loading audio data:",r),this.bufferSubject.next(null),this.startedLoadingBuffer=!1})}setDuration(){this.backTrackDuration=this.backTrack.duration,console.log("Track duration:",this.backTrackDuration)}cleanUpBackTrackAudio(){this.backTrack.pause(),this.backTrack.currentTime=0,URL.revokeObjectURL(this.backTrack.src)}playBackTrackAudio(n){if("suspended"===this.audioContext.state&&this.audioContext.resume(),""!=this.backTrack.src&&this.backTrack.paused&&this.backTrack.currentTime>0)return console.log("audio is paused!"),void this.backTrack.play();this.playOnLoad(n)}pauseBackTrackAudio(){this.backTrack.pause()}stopBackTrackAudio(){this.cleanUpBackTrackAudio()}setBackTrackVolume(n){const r=Math.min(100,Math.max(0,n));this.gainNode.gain.setValueAtTime(r/100,this.audioContext.currentTime),this.volumeSubject.next(r)}setBackTrackPan(n){const r=Math.min(1,Math.max(0,n/100));this.panNode.pan.value=r}setBackTrackCompressionThreshold(n){const r=Math.max(-60,Math.min(0,n));this.compressorNode.threshold.setValueAtTime(r,this.audioContext.currentTime)}setBackTrackCompressionKnee(n){const r=Math.max(0,Math.min(40,n));this.compressorNode.knee.setValueAtTime(r,this.audioContext.currentTime)}setBackTrackCompressionRatio(n){const r=Math.max(1,Math.min(20,n));this.compressorNode.ratio.setValueAtTime(r,this.audioContext.currentTime)}setBackTrackCompressionAttack(n){const r=Math.max(0,Math.min(1,n));this.compressorNode.attack.setValueAtTime(r,this.audioContext.currentTime)}setBackTrackCompressionRelease(n){const r=Math.max(0,Math.min(1,n));this.compressorNode.release.setValueAtTime(r,this.audioContext.currentTime)}setLowBandGain(n){const r=Math.max(-12,Math.min(12,n));this.lowBandFilterNode.gain.setValueAtTime(r,this.audioContext.currentTime)}setMidBandGain(n){const r=Math.max(-12,Math.min(12,n));this.midBandFilterNode.gain.setValueAtTime(r,this.audioContext.currentTime)}setHighBandGain(n){const r=Math.max(-12,Math.min(12,n));this.highBandFilterNode.gain.setValueAtTime(r,this.audioContext.currentTime)}fadeOut(n,r=!1){const i=this.gainNode.gain.value,c=this.audioContext.currentTime+n;this.gainNode.gain.setValueAtTime(i,this.audioContext.currentTime),this.gainNode.gain.linearRampToValueAtTime(0,c);const g=Math.ceil(1e3*n/50),E=i/g;for(let A=0;A<g;A++)setTimeout(()=>{this.setBackTrackVolume(i-A*E)},50*A)}fadeIn(n){this.gainNode.gain.setValueAtTime(0,this.audioContext.currentTime);const r=this.gainNode.gain.value,c=this.audioContext.currentTime;this.gainNode.gain.setValueAtTime(r,c),this.gainNode.gain.linearRampToValueAtTime(1,c+n);const g=Math.ceil(1e3*n/50),E=(1-r)/g;for(let A=0;A<g;A++)setTimeout(()=>{this.setBackTrackVolume(r+A*E)},50*A)}createAnalyserNode(){const n=this.audioContext.createAnalyser();return n.fftSize=2048,n.smoothingTimeConstant=.8,this.compressorNode.connect(n),n}getAudioSourceNode(){return"suspended"===this.audioContext.state&&this.audioContext.resume(),this.backTrackSourceNode}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Vw))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),iR=(()=>{var t;class e{constructor(){this.tracklistSubject=new Di([]),this.tracklist$=this.tracklistSubject.asObservable(),this.removeTrackSubject=new Bt,this.removeTrack$=this.removeTrackSubject.asObservable()}updateTracklist(n){console.log("updated track list!"),this.tracklistSubject.next(n)}getTracklist(){return this.tracklistSubject.value}removeTrack(n){this.removeTrackSubject.next(n)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const tX=["mat-button",""],oR=[[["",8,"material-icons",3,"iconPositionEnd",""],["mat-icon",3,"iconPositionEnd",""],["","matButtonIcon","",3,"iconPositionEnd",""]],"*",[["","iconPositionEnd","",8,"material-icons"],["mat-icon","iconPositionEnd",""],["","matButtonIcon","","iconPositionEnd",""]]],aR=[".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])","*",".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"],sX=["mat-fab",""],rX=["mat-mini-fab",""],oX=["mat-icon-button",""],aX=["*"],lX=[{selector:"mat-button",mdcClasses:["mdc-button","mat-mdc-button"]},{selector:"mat-flat-button",mdcClasses:["mdc-button","mdc-button--unelevated","mat-mdc-unelevated-button"]},{selector:"mat-raised-button",mdcClasses:["mdc-button","mdc-button--raised","mat-mdc-raised-button"]},{selector:"mat-stroked-button",mdcClasses:["mdc-button","mdc-button--outlined","mat-mdc-outlined-button"]},{selector:"mat-fab",mdcClasses:["mdc-fab","mat-mdc-fab"]},{selector:"mat-mini-fab",mdcClasses:["mdc-fab","mdc-fab--mini","mat-mdc-mini-fab"]},{selector:"mat-icon-button",mdcClasses:["mdc-icon-button","mat-mdc-icon-button"]}],cX=Ib(Sb(BS(class{constructor(t){this._elementRef=t}})));let qS=(()=>{var t;class e extends cX{get ripple(){return this._rippleLoader?.getRipple(this._elementRef.nativeElement)}set ripple(n){this._rippleLoader?.attachRipple(this._elementRef.nativeElement,n)}get disableRipple(){return this._disableRipple}set disableRipple(n){this._disableRipple=Yr(n),this._updateRippleDisabled()}get disabled(){return this._disabled}set disabled(n){this._disabled=Yr(n),this._updateRippleDisabled()}constructor(n,r,i,a){super(n),this._platform=r,this._ngZone=i,this._animationMode=a,this._focusMonitor=jn($m),this._rippleLoader=jn(q3),this._isFab=!1,this._disableRipple=!1,this._disabled=!1,this._rippleLoader?.configureRipple(this._elementRef.nativeElement,{className:"mat-mdc-button-ripple"});const c=n.nativeElement.classList;for(const f of lX)this._hasHostAttributes(f.selector)&&f.mdcClasses.forEach(g=>{c.add(g)})}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(n="program",r){n?this._focusMonitor.focusVia(this._elementRef.nativeElement,n,r):this._elementRef.nativeElement.focus(r)}_hasHostAttributes(...n){return n.some(r=>this._elementRef.nativeElement.hasAttribute(r))}_updateRippleDisabled(){this._rippleLoader?.setDisabled(this._elementRef.nativeElement,this.disableRipple||this.disabled)}}return(t=e).\u0275fac=function(n){Tf()},t.\u0275dir=Gn({type:t,features:[Ps]}),e})(),dX=(()=>{var t;class e extends qS{constructor(n,r,i,a){super(n,r,i,a)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(wc),lt(Gs),lt(ac,8))},t.\u0275cmp=sr({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-flat-button",""],["button","mat-stroked-button",""]],hostVars:7,hostBindings:function(n,r){2&n&&(si("disabled",r.disabled||null),Ei("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Ps],attrs:tX,ngContentSelectors:aR,decls:7,vars:4,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],[1,"mat-mdc-button-touch-target"]],template:function(n,r){1&n&&(Pl(oR),ti(0,"span",0),ri(1),yn(2,"span",1),ri(3,1),In(),ri(4,2),ti(5,"span",2)(6,"span",3)),2&n&&Ei("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab)},styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%;line-height:initial}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),e})();const fB=new Zn("mat-mdc-fab-default-options",{providedIn:"root",factory:mB});function mB(){return{color:"accent"}}const eI=mB();let gB=(()=>{var t;class e extends qS{get extended(){return this._extended}set extended(n){this._extended=Yr(n)}constructor(n,r,i,a,c){super(n,r,i,a),this._options=c,this._isFab=!0,this._options=this._options||eI,this.color=this.defaultColor=this._options.color||eI.color}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(wc),lt(Gs),lt(ac,8),lt(fB,8))},t.\u0275cmp=sr({type:t,selectors:[["button","mat-fab",""]],hostVars:11,hostBindings:function(n,r){2&n&&(si("disabled",r.disabled||null),Ei("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0)("mdc-fab--extended",r.extended)("mat-mdc-extended-fab",r.extended))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color",tabIndex:"tabIndex",extended:"extended"},exportAs:["matButton"],features:[Ps],attrs:sX,ngContentSelectors:aR,decls:7,vars:4,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],[1,"mat-mdc-button-touch-target"]],template:function(n,r){1&n&&(Pl(oR),ti(0,"span",0),ri(1),yn(2,"span",1),ri(3,1),In(),ri(4,2),ti(5,"span",2)(6,"span",3)),2&n&&Ei("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab)},styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--mdc-elevation-overlay-color)}.mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab[hidden]{display:none}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab:hover{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mdc-fab.mdc-ripple-upgraded--background-focused,.mdc-fab:not(.mdc-ripple-upgraded):focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mdc-fab .mdc-fab__focus-ring{position:absolute}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    )}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}.mdc-fab:active,.mdc-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mdc-typography-button-font-family);font-size:var(--mdc-typography-button-font-size);line-height:var(--mdc-typography-button-line-height);font-weight:var(--mdc-typography-button-font-weight);letter-spacing:var(--mdc-typography-button-letter-spacing);text-decoration:var(--mdc-typography-button-text-decoration);text-transform:var(--mdc-typography-button-text-transform);border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-fab::before{border-color:CanvasText}}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mat-mdc-fab,.mat-mdc-mini-fab{background-color:var(--mdc-fab-container-color);--mdc-fab-container-shape:50%;--mdc-fab-icon-size:24px}.mat-mdc-fab .mdc-fab__icon,.mat-mdc-mini-fab .mdc-fab__icon{width:var(--mdc-fab-icon-size);height:var(--mdc-fab-icon-size);font-size:var(--mdc-fab-icon-size)}.mat-mdc-fab:not(:disabled) .mdc-fab__icon,.mat-mdc-mini-fab:not(:disabled) .mdc-fab__icon{color:var(--mdc-fab-icon-color)}.mat-mdc-fab:not(.mdc-fab--extended),.mat-mdc-mini-fab:not(.mdc-fab--extended){border-radius:var(--mdc-fab-container-shape)}.mat-mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple,.mat-mdc-mini-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:var(--mdc-fab-container-shape)}.mat-mdc-extended-fab{font-family:var(--mdc-extended-fab-label-text-font);font-size:var(--mdc-extended-fab-label-text-size);font-weight:var(--mdc-extended-fab-label-text-weight);letter-spacing:var(--mdc-extended-fab-label-text-tracking)}.mat-mdc-fab,.mat-mdc-mini-fab{-webkit-tap-highlight-color:rgba(0,0,0,0);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);color:var(--mat-mdc-fab-color, inherit);flex-shrink:0}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-fab .mat-ripple-element,.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-fab .mdc-button__label,.mat-mdc-mini-fab .mdc-button__label{z-index:1}.mat-mdc-fab .mat-mdc-focus-indicator,.mat-mdc-mini-fab .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab:focus .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-fab .mat-mdc-button-touch-target,.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-fab._mat-animation-noopable,.mat-mdc-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab:hover,.mat-mdc-fab:focus,.mat-mdc-mini-fab:hover,.mat-mdc-mini-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:active,.mat-mdc-fab:focus:active,.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mat-mdc-fab[disabled],.mat-mdc-mini-fab[disabled]{cursor:default;pointer-events:none;box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-mini-fab:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}.mat-mdc-fab .mat-icon,.mat-mdc-fab .material-icons,.mat-mdc-mini-fab .mat-icon,.mat-mdc-mini-fab .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons,.mat-mdc-extended-fab>.mat-icon[dir=rtl],.mat-mdc-extended-fab>.material-icons[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-extended-fab .mdc-button__label+.material-icons[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'],encapsulation:2,changeDetection:0}),e})(),hX=(()=>{var t;class e extends qS{constructor(n,r,i,a,c){super(n,r,i,a),this._options=c,this._isFab=!0,this._options=this._options||eI,this.color=this.defaultColor=this._options.color||eI.color}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(wc),lt(Gs),lt(ac,8),lt(fB,8))},t.\u0275cmp=sr({type:t,selectors:[["button","mat-mini-fab",""]],hostVars:7,hostBindings:function(n,r){2&n&&(si("disabled",r.disabled||null),Ei("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Ps],attrs:rX,ngContentSelectors:aR,decls:7,vars:4,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],[1,"mat-mdc-button-touch-target"]],template:function(n,r){1&n&&(Pl(oR),ti(0,"span",0),ri(1),yn(2,"span",1),ri(3,1),In(),ri(4,2),ti(5,"span",2)(6,"span",3)),2&n&&Ei("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab)},styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--mdc-elevation-overlay-color)}.mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab[hidden]{display:none}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab:hover{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mdc-fab.mdc-ripple-upgraded--background-focused,.mdc-fab:not(.mdc-ripple-upgraded):focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mdc-fab .mdc-fab__focus-ring{position:absolute}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    )}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}.mdc-fab:active,.mdc-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mdc-typography-button-font-family);font-size:var(--mdc-typography-button-font-size);line-height:var(--mdc-typography-button-line-height);font-weight:var(--mdc-typography-button-font-weight);letter-spacing:var(--mdc-typography-button-letter-spacing);text-decoration:var(--mdc-typography-button-text-decoration);text-transform:var(--mdc-typography-button-text-transform);border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-fab::before{border-color:CanvasText}}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mat-mdc-fab,.mat-mdc-mini-fab{background-color:var(--mdc-fab-container-color);--mdc-fab-container-shape:50%;--mdc-fab-icon-size:24px}.mat-mdc-fab .mdc-fab__icon,.mat-mdc-mini-fab .mdc-fab__icon{width:var(--mdc-fab-icon-size);height:var(--mdc-fab-icon-size);font-size:var(--mdc-fab-icon-size)}.mat-mdc-fab:not(:disabled) .mdc-fab__icon,.mat-mdc-mini-fab:not(:disabled) .mdc-fab__icon{color:var(--mdc-fab-icon-color)}.mat-mdc-fab:not(.mdc-fab--extended),.mat-mdc-mini-fab:not(.mdc-fab--extended){border-radius:var(--mdc-fab-container-shape)}.mat-mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple,.mat-mdc-mini-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:var(--mdc-fab-container-shape)}.mat-mdc-extended-fab{font-family:var(--mdc-extended-fab-label-text-font);font-size:var(--mdc-extended-fab-label-text-size);font-weight:var(--mdc-extended-fab-label-text-weight);letter-spacing:var(--mdc-extended-fab-label-text-tracking)}.mat-mdc-fab,.mat-mdc-mini-fab{-webkit-tap-highlight-color:rgba(0,0,0,0);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);color:var(--mat-mdc-fab-color, inherit);flex-shrink:0}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-fab .mat-ripple-element,.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-fab .mdc-button__label,.mat-mdc-mini-fab .mdc-button__label{z-index:1}.mat-mdc-fab .mat-mdc-focus-indicator,.mat-mdc-mini-fab .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab:focus .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-fab .mat-mdc-button-touch-target,.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-fab._mat-animation-noopable,.mat-mdc-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab:hover,.mat-mdc-fab:focus,.mat-mdc-mini-fab:hover,.mat-mdc-mini-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:active,.mat-mdc-fab:focus:active,.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mat-mdc-fab[disabled],.mat-mdc-mini-fab[disabled]{cursor:default;pointer-events:none;box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-mini-fab:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}.mat-mdc-fab .mat-icon,.mat-mdc-fab .material-icons,.mat-mdc-mini-fab .mat-icon,.mat-mdc-mini-fab .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons,.mat-mdc-extended-fab>.mat-icon[dir=rtl],.mat-mdc-extended-fab>.material-icons[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-extended-fab .mdc-button__label+.material-icons[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'],encapsulation:2,changeDetection:0}),e})(),lR=(()=>{var t;class e extends qS{constructor(n,r,i,a){super(n,r,i,a),this._rippleLoader.configureRipple(this._elementRef.nativeElement,{centered:!0})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(wc),lt(Gs),lt(ac,8))},t.\u0275cmp=sr({type:t,selectors:[["button","mat-icon-button",""]],hostVars:7,hostBindings:function(n,r){2&n&&(si("disabled",r.disabled||null),Ei("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Ps],attrs:oX,ngContentSelectors:aX,decls:4,vars:0,consts:[[1,"mat-mdc-button-persistent-ripple","mdc-icon-button__ripple"],[1,"mat-mdc-focus-indicator"],[1,"mat-mdc-button-touch-target"]],template:function(n,r){1&n&&(Pl(),ti(0,"span",0),ri(1),ti(2,"span",1)(3,"span",2))},styles:['.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{display:block}}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button[hidden]{display:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%;display:none}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring{border-color:CanvasText}}.mdc-icon-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring::after{border-color:CanvasText}}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}.mat-mdc-icon-button{height:var(--mdc-icon-button-state-layer-size);width:var(--mdc-icon-button-state-layer-size);color:var(--mdc-icon-button-icon-color);--mdc-icon-button-state-layer-size:48px;--mdc-icon-button-icon-size:24px;--mdc-icon-button-disabled-icon-color:black;--mdc-icon-button-disabled-icon-opacity:0.38}.mat-mdc-icon-button .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size)}.mat-mdc-icon-button svg,.mat-mdc-icon-button img{width:var(--mdc-icon-button-icon-size);height:var(--mdc-icon-button-icon-size)}.mat-mdc-icon-button:disabled{opacity:var(--mdc-icon-button-disabled-icon-opacity)}.mat-mdc-icon-button:disabled{color:var(--mdc-icon-button-disabled-icon-color)}.mat-mdc-icon-button{padding:12px;font-size:var(--mdc-icon-button-icon-size);border-radius:50%;flex-shrink:0;text-align:center;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-icon-button svg{vertical-align:baseline}.mat-mdc-icon-button[disabled]{cursor:default;pointer-events:none;opacity:1}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-icon-button .mdc-button__label{z-index:1}.mat-mdc-icon-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),e})(),_B=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,zS,nl]}),e})();class pX{}function cR(t){return t&&"function"==typeof t.connect&&!(t instanceof hO)}class yB{applyChanges(e,s,n,r,i){e.forEachOperation((a,c,f)=>{let g,E;if(null==a.previousIndex){const A=n(a,c,f);g=s.createEmbeddedView(A.templateRef,A.context,A.index),E=1}else null==f?(s.remove(c),E=3):(g=s.get(c),s.move(g,f),E=2);i&&i({context:g?.context,operation:E,record:a})})}detach(){}}class fX{get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}constructor(e=!1,s,n=!0,r){this._multiple=e,this._emitChanges=n,this.compareWith=r,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new Bt,s&&s.length&&(e?s.forEach(i=>this._markSelected(i)):this._markSelected(s[0]),this._selectedToEmit.length=0)}select(...e){this._verifyValueAssignment(e),e.forEach(n=>this._markSelected(n));const s=this._hasQueuedChanges();return this._emitChangeEvent(),s}deselect(...e){this._verifyValueAssignment(e),e.forEach(n=>this._unmarkSelected(n));const s=this._hasQueuedChanges();return this._emitChangeEvent(),s}setSelection(...e){this._verifyValueAssignment(e);const s=this.selected,n=new Set(e);e.forEach(i=>this._markSelected(i)),s.filter(i=>!n.has(i)).forEach(i=>this._unmarkSelected(i));const r=this._hasQueuedChanges();return this._emitChangeEvent(),r}toggle(e){return this.isSelected(e)?this.deselect(e):this.select(e)}clear(e=!0){this._unmarkAll();const s=this._hasQueuedChanges();return e&&this._emitChangeEvent(),s}isSelected(e){return this._selection.has(this._getConcreteValue(e))}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(e){this._multiple&&this.selected&&this._selected.sort(e)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(e){e=this._getConcreteValue(e),this.isSelected(e)||(this._multiple||this._unmarkAll(),this.isSelected(e)||this._selection.add(e),this._emitChanges&&this._selectedToEmit.push(e))}_unmarkSelected(e){e=this._getConcreteValue(e),this.isSelected(e)&&(this._selection.delete(e),this._emitChanges&&this._deselectedToEmit.push(e))}_unmarkAll(){this.isEmpty()||this._selection.forEach(e=>this._unmarkSelected(e))}_verifyValueAssignment(e){}_hasQueuedChanges(){return!(!this._deselectedToEmit.length&&!this._selectedToEmit.length)}_getConcreteValue(e){if(this.compareWith){for(let s of this._selection)if(this.compareWith(e,s))return s;return e}return e}}let bB=(()=>{var t;class e{constructor(){this._listeners=[]}notify(n,r){for(let i of this._listeners)i(n,r)}listen(n){return this._listeners.push(n),()=>{this._listeners=this._listeners.filter(r=>n!==r)}}ngOnDestroy(){this._listeners=[]}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const bC=new Zn("_ViewRepeater");let mX=0;const uR=new Zn("CdkAccordion");let gX=(()=>{var t;class e{constructor(){this._stateChanges=new Bt,this._openCloseAllActions=new Bt,this.id="cdk-accordion-"+mX++,this._multi=!1}get multi(){return this._multi}set multi(n){this._multi=Yr(n)}openAll(){this._multi&&this._openCloseAllActions.next(!0)}closeAll(){this._openCloseAllActions.next(!1)}ngOnChanges(n){this._stateChanges.next(n)}ngOnDestroy(){this._stateChanges.complete(),this._openCloseAllActions.complete()}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["cdk-accordion"],["","cdkAccordion",""]],inputs:{multi:"multi"},exportAs:["cdkAccordion"],features:[vr([{provide:uR,useExisting:t}]),Ia]}),e})(),_X=0,yX=(()=>{var t;class e{get expanded(){return this._expanded}set expanded(n){n=Yr(n),this._expanded!==n&&(this._expanded=n,this.expandedChange.emit(n),n?(this.opened.emit(),this._expansionDispatcher.notify(this.id,this.accordion?this.accordion.id:this.id)):this.closed.emit(),this._changeDetectorRef.markForCheck())}get disabled(){return this._disabled}set disabled(n){this._disabled=Yr(n)}constructor(n,r,i){this.accordion=n,this._changeDetectorRef=r,this._expansionDispatcher=i,this._openCloseAllSubscription=I.EMPTY,this.closed=new Rr,this.opened=new Rr,this.destroyed=new Rr,this.expandedChange=new Rr,this.id="cdk-accordion-child-"+_X++,this._expanded=!1,this._disabled=!1,this._removeUniqueSelectionListener=()=>{},this._removeUniqueSelectionListener=i.listen((a,c)=>{this.accordion&&!this.accordion.multi&&this.accordion.id===c&&this.id!==a&&(this.expanded=!1)}),this.accordion&&(this._openCloseAllSubscription=this._subscribeToOpenCloseAllActions())}ngOnDestroy(){this.opened.complete(),this.closed.complete(),this.destroyed.emit(),this.destroyed.complete(),this._removeUniqueSelectionListener(),this._openCloseAllSubscription.unsubscribe()}toggle(){this.disabled||(this.expanded=!this.expanded)}close(){this.disabled||(this.expanded=!1)}open(){this.disabled||(this.expanded=!0)}_subscribeToOpenCloseAllActions(){return this.accordion._openCloseAllActions.subscribe(n=>{this.disabled||(this.expanded=n)})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(uR,12),lt(Ll),lt(bB))},t.\u0275dir=Gn({type:t,selectors:[["cdk-accordion-item"],["","cdkAccordionItem",""]],inputs:{expanded:"expanded",disabled:"disabled"},outputs:{closed:"closed",opened:"opened",destroyed:"destroyed",expandedChange:"expandedChange"},exportAs:["cdkAccordionItem"],features:[vr([{provide:uR,useValue:void 0}])]}),e})(),vX=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();class dR{attach(e){return this._attachedHost=e,e.attach(this)}detach(){let e=this._attachedHost;null!=e&&(this._attachedHost=null,e.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(e){this._attachedHost=e}}class tI extends dR{constructor(e,s,n,r,i){super(),this.component=e,this.viewContainerRef=s,this.injector=n,this.componentFactoryResolver=r,this.projectableNodes=i}}class xC extends dR{constructor(e,s,n,r){super(),this.templateRef=e,this.viewContainerRef=s,this.context=n,this.injector=r}get origin(){return this.templateRef.elementRef}attach(e,s=this.context){return this.context=s,super.attach(e)}detach(){return this.context=void 0,super.detach()}}class bX extends dR{constructor(e){super(),this.element=e instanceof yr?e.nativeElement:e}}class hR{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(e){return e instanceof tI?(this._attachedPortal=e,this.attachComponentPortal(e)):e instanceof xC?(this._attachedPortal=e,this.attachTemplatePortal(e)):this.attachDomPortal&&e instanceof bX?(this._attachedPortal=e,this.attachDomPortal(e)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(e){this._disposeFn=e}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class xX extends hR{constructor(e,s,n,r,i){super(),this.outletElement=e,this._componentFactoryResolver=s,this._appRef=n,this._defaultInjector=r,this.attachDomPortal=a=>{const c=a.element,f=this._document.createComment("dom-portal");c.parentNode.insertBefore(f,c),this.outletElement.appendChild(c),this._attachedPortal=a,super.setDisposeFn(()=>{f.parentNode&&f.parentNode.replaceChild(c,f)})},this._document=i}attachComponentPortal(e){const n=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component);let r;return e.viewContainerRef?(r=e.viewContainerRef.createComponent(n,e.viewContainerRef.length,e.injector||e.viewContainerRef.injector,e.projectableNodes||void 0),this.setDisposeFn(()=>r.destroy())):(r=n.create(e.injector||this._defaultInjector||Wc.NULL),this._appRef.attachView(r.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(r.hostView),r.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(r)),this._attachedPortal=e,r}attachTemplatePortal(e){let s=e.viewContainerRef,n=s.createEmbeddedView(e.templateRef,e.context,{injector:e.injector});return n.rootNodes.forEach(r=>this.outletElement.appendChild(r)),n.detectChanges(),this.setDisposeFn(()=>{let r=s.indexOf(n);-1!==r&&s.remove(r)}),this._attachedPortal=e,n}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(e){return e.hostView.rootNodes[0]}}let nI=(()=>{var t;class e extends hR{constructor(n,r,i){super(),this._componentFactoryResolver=n,this._viewContainerRef=r,this._isInitialized=!1,this.attached=new Rr,this.attachDomPortal=a=>{const c=a.element,f=this._document.createComment("dom-portal");a.setAttachedHost(this),c.parentNode.insertBefore(f,c),this._getRootNode().appendChild(c),this._attachedPortal=a,super.setDisposeFn(()=>{f.parentNode&&f.parentNode.replaceChild(c,f)})},this._document=i}get portal(){return this._attachedPortal}set portal(n){this.hasAttached()&&!n&&!this._isInitialized||(this.hasAttached()&&super.detach(),n&&super.attach(n),this._attachedPortal=n||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedRef=this._attachedPortal=null}attachComponentPortal(n){n.setAttachedHost(this);const r=null!=n.viewContainerRef?n.viewContainerRef:this._viewContainerRef,a=(n.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(n.component),c=r.createComponent(a,r.length,n.injector||r.injector,n.projectableNodes||void 0);return r!==this._viewContainerRef&&this._getRootNode().appendChild(c.hostView.rootNodes[0]),super.setDisposeFn(()=>c.destroy()),this._attachedPortal=n,this._attachedRef=c,this.attached.emit(c),c}attachTemplatePortal(n){n.setAttachedHost(this);const r=this._viewContainerRef.createEmbeddedView(n.templateRef,n.context,{injector:n.injector});return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=n,this._attachedRef=r,this.attached.emit(r),r}_getRootNode(){const n=this._viewContainerRef.element.nativeElement;return n.nodeType===n.ELEMENT_NODE?n:n.parentNode}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(lc),lt(jc),lt(yi))},t.\u0275dir=Gn({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[Ps]}),e})(),wC=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();const wX=["body"];function CX(t,e){}const EX=[[["mat-expansion-panel-header"]],"*",[["mat-action-row"]]],DX=["mat-expansion-panel-header","*","mat-action-row"];function SX(t,e){1&t&&ti(0,"span",2),2&t&&Yn("@indicatorRotate",bs()._getExpandedState())}const IX=[[["mat-panel-title"]],[["mat-panel-description"]],"*"],TX=["mat-panel-title","mat-panel-description","*"],pR=new Zn("MAT_ACCORDION"),xB="225ms cubic-bezier(0.4,0.0,0.2,1)",wB={indicatorRotate:nd("indicatorRotate",[Vl("collapsed, void",Mi({transform:"rotate(0deg)"})),Vl("expanded",Mi({transform:"rotate(180deg)"})),sc("expanded <=> collapsed, void => collapsed",nc(xB))]),bodyExpansion:nd("bodyExpansion",[Vl("collapsed, void",Mi({height:"0px",visibility:"hidden"})),Vl("expanded",Mi({height:"*",visibility:""})),sc("expanded <=> collapsed, void => collapsed",nc(xB))])},CB=new Zn("MAT_EXPANSION_PANEL");let AX=(()=>{var t;class e{constructor(n,r){this._template=n,this._expansionPanel=r}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc),lt(CB,8))},t.\u0275dir=Gn({type:t,selectors:[["ng-template","matExpansionPanelContent",""]]}),e})(),kX=0;const EB=new Zn("MAT_EXPANSION_PANEL_DEFAULT_OPTIONS");let fR=(()=>{var t;class e extends yX{get hideToggle(){return this._hideToggle||this.accordion&&this.accordion.hideToggle}set hideToggle(n){this._hideToggle=Yr(n)}get togglePosition(){return this._togglePosition||this.accordion&&this.accordion.togglePosition}set togglePosition(n){this._togglePosition=n}constructor(n,r,i,a,c,f,g){super(n,r,i),this._viewContainerRef=a,this._animationMode=f,this._hideToggle=!1,this.afterExpand=new Rr,this.afterCollapse=new Rr,this._inputChanges=new Bt,this._headerId="mat-expansion-panel-header-"+kX++,this._bodyAnimationDone=new Bt,this.accordion=n,this._document=c,this._bodyAnimationDone.pipe(al((E,A)=>E.fromState===A.fromState&&E.toState===A.toState)).subscribe(E=>{"void"!==E.fromState&&("expanded"===E.toState?this.afterExpand.emit():"collapsed"===E.toState&&this.afterCollapse.emit())}),g&&(this.hideToggle=g.hideToggle)}_hasSpacing(){return!!this.accordion&&this.expanded&&"default"===this.accordion.displayMode}_getExpandedState(){return this.expanded?"expanded":"collapsed"}toggle(){this.expanded=!this.expanded}close(){this.expanded=!1}open(){this.expanded=!0}ngAfterContentInit(){this._lazyContent&&this._lazyContent._expansionPanel===this&&this.opened.pipe(ed(null),tc(()=>this.expanded&&!this._portal),$l(1)).subscribe(()=>{this._portal=new xC(this._lazyContent._template,this._viewContainerRef)})}ngOnChanges(n){this._inputChanges.next(n)}ngOnDestroy(){super.ngOnDestroy(),this._bodyAnimationDone.complete(),this._inputChanges.complete()}_containsFocus(){if(this._body){const n=this._document.activeElement,r=this._body.nativeElement;return n===r||r.contains(n)}return!1}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(pR,12),lt(Ll),lt(bB),lt(jc),lt(yi),lt(ac,8),lt(EB,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-expansion-panel"]],contentQueries:function(n,r,i){if(1&n&&ea(i,AX,5),2&n){let a;Ar(a=kr())&&(r._lazyContent=a.first)}},viewQuery:function(n,r){if(1&n&&qo(wX,5),2&n){let i;Ar(i=kr())&&(r._body=i.first)}},hostAttrs:[1,"mat-expansion-panel"],hostVars:6,hostBindings:function(n,r){2&n&&Ei("mat-expanded",r.expanded)("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-expansion-panel-spacing",r._hasSpacing())},inputs:{disabled:"disabled",expanded:"expanded",hideToggle:"hideToggle",togglePosition:"togglePosition"},outputs:{opened:"opened",closed:"closed",expandedChange:"expandedChange",afterExpand:"afterExpand",afterCollapse:"afterCollapse"},exportAs:["matExpansionPanel"],features:[vr([{provide:pR,useValue:void 0},{provide:CB,useExisting:t}]),Ps,Ia],ngContentSelectors:DX,decls:7,vars:4,consts:[["role","region",1,"mat-expansion-panel-content",3,"id"],["body",""],[1,"mat-expansion-panel-body"],[3,"cdkPortalOutlet"]],template:function(n,r){1&n&&(Pl(EX),ri(0),yn(1,"div",0,1),qs("@bodyExpansion.done",function(a){return r._bodyAnimationDone.next(a)}),yn(3,"div",2),ri(4,1),Fs(5,CX,0,0,"ng-template",3),In(),ri(6,2),In()),2&n&&(Un(1),Yn("@bodyExpansion",r._getExpandedState())("id",r.id),si("aria-labelledby",r._headerId),Un(4),Yn("cdkPortalOutlet",r._portal))},dependencies:[nI],styles:['.mat-expansion-panel{--mat-expansion-container-shape:4px;box-sizing:content-box;display:block;margin:0;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);position:relative;background:var(--mat-expansion-container-background-color);color:var(--mat-expansion-container-text-color);border-radius:var(--mat-expansion-container-shape)}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:var(--mat-expansion-container-shape);border-top-left-radius:var(--mat-expansion-container-shape)}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:var(--mat-expansion-container-shape);border-bottom-left-radius:var(--mat-expansion-container-shape)}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible;font-family:var(--mat-expansion-container-text-font);font-size:var(--mat-expansion-container-text-size);font-weight:var(--mat-expansion-container-text-weight);line-height:var(--mat-expansion-container-text-line-height);letter-spacing:var(--mat-expansion-container-text-tracking)}.mat-expansion-panel-content[style*="visibility: hidden"] *{visibility:hidden !important}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px;border-top-color:var(--mat-expansion-actions-divider-color)}.mat-action-row .mat-button-base,.mat-action-row .mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row .mat-button-base,[dir=rtl] .mat-action-row .mat-mdc-button-base{margin-left:0;margin-right:8px}'],encapsulation:2,data:{animation:[wB.bodyExpansion]},changeDetection:0}),e})();class OX{}const RX=hC(OX);let mR=(()=>{var t;class e extends RX{constructor(n,r,i,a,c,f,g){super(),this.panel=n,this._element=r,this._focusMonitor=i,this._changeDetectorRef=a,this._animationMode=f,this._parentChangeSubscription=I.EMPTY;const E=n.accordion?n.accordion._stateChanges.pipe(tc(A=>!(!A.hideToggle&&!A.togglePosition))):so;this.tabIndex=parseInt(g||"")||0,this._parentChangeSubscription=ji(n.opened,n.closed,E,n._inputChanges.pipe(tc(A=>!!(A.hideToggle||A.disabled||A.togglePosition)))).subscribe(()=>this._changeDetectorRef.markForCheck()),n.closed.pipe(tc(()=>n._containsFocus())).subscribe(()=>i.focusVia(r,"program")),c&&(this.expandedHeight=c.expandedHeight,this.collapsedHeight=c.collapsedHeight)}get disabled(){return this.panel.disabled}_toggle(){this.disabled||this.panel.toggle()}_isExpanded(){return this.panel.expanded}_getExpandedState(){return this.panel._getExpandedState()}_getPanelId(){return this.panel.id}_getTogglePosition(){return this.panel.togglePosition}_showToggle(){return!this.panel.hideToggle&&!this.panel.disabled}_getHeaderHeight(){const n=this._isExpanded();return n&&this.expandedHeight?this.expandedHeight:!n&&this.collapsedHeight?this.collapsedHeight:null}_keydown(n){switch(n.keyCode){case 32:case 13:lh(n)||(n.preventDefault(),this._toggle());break;default:return void(this.panel.accordion&&this.panel.accordion._handleHeaderKeydown(n))}}focus(n,r){n?this._focusMonitor.focusVia(this._element,n,r):this._element.nativeElement.focus(r)}ngAfterViewInit(){this._focusMonitor.monitor(this._element).subscribe(n=>{n&&this.panel.accordion&&this.panel.accordion._handleHeaderFocus(this)})}ngOnDestroy(){this._parentChangeSubscription.unsubscribe(),this._focusMonitor.stopMonitoring(this._element)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(fR,1),lt(yr),lt($m),lt(Ll),lt(EB,8),lt(ac,8),na("tabindex"))},t.\u0275cmp=sr({type:t,selectors:[["mat-expansion-panel-header"]],hostAttrs:["role","button",1,"mat-expansion-panel-header","mat-focus-indicator"],hostVars:15,hostBindings:function(n,r){1&n&&qs("click",function(){return r._toggle()})("keydown",function(a){return r._keydown(a)}),2&n&&(si("id",r.panel._headerId)("tabindex",r.tabIndex)("aria-controls",r._getPanelId())("aria-expanded",r._isExpanded())("aria-disabled",r.panel.disabled),Ju("height",r._getHeaderHeight()),Ei("mat-expanded",r._isExpanded())("mat-expansion-toggle-indicator-after","after"===r._getTogglePosition())("mat-expansion-toggle-indicator-before","before"===r._getTogglePosition())("_mat-animation-noopable","NoopAnimations"===r._animationMode))},inputs:{tabIndex:"tabIndex",expandedHeight:"expandedHeight",collapsedHeight:"collapsedHeight"},features:[Ps],ngContentSelectors:TX,decls:5,vars:3,consts:[[1,"mat-content"],["class","mat-expansion-indicator",4,"ngIf"],[1,"mat-expansion-indicator"]],template:function(n,r){1&n&&(Pl(IX),yn(0,"span",0),ri(1),ri(2,1),ri(3,2),In(),Fs(4,SX,1,1,"span",1)),2&n&&(Ei("mat-content-hide-toggle",!r._showToggle()),Un(4),Yn("ngIf",r._showToggle()))},dependencies:[$d],styles:['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;transition:height 225ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-expansion-header-collapsed-state-height);font-family:var(--mat-expansion-header-text-font);font-size:var(--mat-expansion-header-text-size);font-weight:var(--mat-expansion-header-text-weight);line-height:var(--mat-expansion-header-text-line-height);letter-spacing:var(--mat-expansion-header-text-tracking)}.mat-expansion-panel-header.mat-expanded{height:var(--mat-expansion-header-expanded-state-height)}.mat-expansion-panel-header[aria-disabled=true]{color:var(--mat-expansion-header-disabled-state-text-color)}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-header-hover-state-layer-color)}@media(hover: none){.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-container-background-color)}}.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-keyboard-focused,.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-program-focused{background:var(--mat-expansion-header-focus-state-layer-color)}.mat-expansion-panel-header._mat-animation-noopable{transition:none}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-content.mat-content-hide-toggle{margin-right:8px}[dir=rtl] .mat-content.mat-content-hide-toggle{margin-right:0;margin-left:8px}.mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-left:24px;margin-right:0}[dir=rtl] .mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-right:24px;margin-left:0}.mat-expansion-panel-header-title{color:var(--mat-expansion-header-text-color)}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;flex-basis:0;margin-right:16px;align-items:center}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description{color:inherit}.mat-expansion-panel-header-description{flex-grow:2;color:var(--mat-expansion-header-description-color)}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle;color:var(--mat-expansion-header-indicator-color)}.cdk-high-contrast-active .mat-expansion-panel-content{border-top:1px solid;border-top-left-radius:0;border-top-right-radius:0}'],encapsulation:2,data:{animation:[wB.indicatorRotate]},changeDetection:0}),e})(),NX=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-panel-description"]],hostAttrs:[1,"mat-expansion-panel-header-description"]}),e})(),DB=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-panel-title"]],hostAttrs:[1,"mat-expansion-panel-header-title"]}),e})(),MX=(()=>{var t;class e extends gX{constructor(){super(...arguments),this._ownHeaders=new Ky,this._hideToggle=!1,this.displayMode="default",this.togglePosition="after"}get hideToggle(){return this._hideToggle}set hideToggle(n){this._hideToggle=Yr(n)}ngAfterContentInit(){this._headers.changes.pipe(ed(this._headers)).subscribe(n=>{this._ownHeaders.reset(n.filter(r=>r.panel.accordion===this)),this._ownHeaders.notifyOnChanges()}),this._keyManager=new I3(this._ownHeaders).withWrap().withHomeAndEnd()}_handleHeaderKeydown(n){this._keyManager.onKeydown(n)}_handleHeaderFocus(n){this._keyManager.updateActiveItem(n)}ngOnDestroy(){super.ngOnDestroy(),this._keyManager?.destroy(),this._ownHeaders.destroy()}}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["mat-accordion"]],contentQueries:function(n,r,i){if(1&n&&ea(i,mR,5),2&n){let a;Ar(a=kr())&&(r._headers=a)}},hostAttrs:[1,"mat-accordion"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("mat-accordion-multi",r.multi)},inputs:{multi:"multi",hideToggle:"hideToggle",displayMode:"displayMode",togglePosition:"togglePosition"},exportAs:["matAccordion"],features:[vr([{provide:pR,useExisting:t}]),Ps]}),e})(),PX=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[Ah,nl,vX,wC]}),e})();const FX=new Zn("MAT_PROGRESS_BAR_DEFAULT_OPTIONS"),$X=Ib(class{constructor(t){this._elementRef=t}},"primary");let gR=(()=>{var t;class e extends $X{constructor(n,r,i,a,c){super(n),this._ngZone=r,this._changeDetectorRef=i,this._animationMode=a,this._isNoopAnimation=!1,this._value=0,this._bufferValue=0,this.animationEnd=new Rr,this._mode="determinate",this._transitionendHandler=f=>{0===this.animationEnd.observers.length||!f.target||!f.target.classList.contains("mdc-linear-progress__primary-bar")||("determinate"===this.mode||"buffer"===this.mode)&&this._ngZone.run(()=>this.animationEnd.next({value:this.value}))},this._isNoopAnimation="NoopAnimations"===a,c&&(c.color&&(this.color=this.defaultColor=c.color),this.mode=c.mode||this.mode)}get value(){return this._value}set value(n){this._value=SB(Bl(n)),this._changeDetectorRef.markForCheck()}get bufferValue(){return this._bufferValue||0}set bufferValue(n){this._bufferValue=SB(Bl(n)),this._changeDetectorRef.markForCheck()}get mode(){return this._mode}set mode(n){this._mode=n,this._changeDetectorRef.markForCheck()}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>{this._elementRef.nativeElement.addEventListener("transitionend",this._transitionendHandler)})}ngOnDestroy(){this._elementRef.nativeElement.removeEventListener("transitionend",this._transitionendHandler)}_getPrimaryBarTransform(){return`scaleX(${this._isIndeterminate()?1:this.value/100})`}_getBufferBarFlexBasis(){return`${"buffer"===this.mode?this.bufferValue:100}%`}_isIndeterminate(){return"indeterminate"===this.mode||"query"===this.mode}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Gs),lt(Ll),lt(ac,8),lt(FX,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-progress-bar"]],hostAttrs:["role","progressbar","aria-valuemin","0","aria-valuemax","100","tabindex","-1",1,"mat-mdc-progress-bar","mdc-linear-progress"],hostVars:8,hostBindings:function(n,r){2&n&&(si("aria-valuenow",r._isIndeterminate()?null:r.value)("mode",r.mode),Ei("_mat-animation-noopable",r._isNoopAnimation)("mdc-linear-progress--animation-ready",!r._isNoopAnimation)("mdc-linear-progress--indeterminate",r._isIndeterminate()))},inputs:{color:"color",value:"value",bufferValue:"bufferValue",mode:"mode"},outputs:{animationEnd:"animationEnd"},exportAs:["matProgressBar"],features:[Ps],decls:7,vars:4,consts:[["aria-hidden","true",1,"mdc-linear-progress__buffer"],[1,"mdc-linear-progress__buffer-bar"],[1,"mdc-linear-progress__buffer-dots"],["aria-hidden","true",1,"mdc-linear-progress__bar","mdc-linear-progress__primary-bar"],[1,"mdc-linear-progress__bar-inner"],["aria-hidden","true",1,"mdc-linear-progress__bar","mdc-linear-progress__secondary-bar"]],template:function(n,r){1&n&&(yn(0,"div",0),ti(1,"div",1)(2,"div",2),In(),yn(3,"div",3),ti(4,"span",4),In(),yn(5,"div",5),ti(6,"span",4),In()),2&n&&(Un(1),Ju("flex-basis",r._getBufferBarFlexBasis()),Un(2),Ju("transform",r._getPrimaryBarTransform()))},styles:["@keyframes mdc-linear-progress-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(var(--mdc-linear-progress-primary-half))}100%{transform:translateX(var(--mdc-linear-progress-primary-full))}}@keyframes mdc-linear-progress-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mdc-linear-progress-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(var(--mdc-linear-progress-secondary-quarter))}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(var(--mdc-linear-progress-secondary-half))}100%{transform:translateX(var(--mdc-linear-progress-secondary-full))}}@keyframes mdc-linear-progress-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mdc-linear-progress-primary-indeterminate-translate-reverse{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(var(--mdc-linear-progress-primary-half-neg))}100%{transform:translateX(var(--mdc-linear-progress-primary-full-neg))}}@keyframes mdc-linear-progress-secondary-indeterminate-translate-reverse{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(var(--mdc-linear-progress-secondary-quarter-neg))}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(var(--mdc-linear-progress-secondary-half-neg))}100%{transform:translateX(var(--mdc-linear-progress-secondary-full-neg))}}@keyframes mdc-linear-progress-buffering-reverse{from{transform:translateX(-10px)}}.mdc-linear-progress{position:relative;width:100%;transform:translateZ(0);outline:1px solid rgba(0,0,0,0);overflow-x:hidden;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}@media screen and (forced-colors: active){.mdc-linear-progress{outline-color:CanvasText}}.mdc-linear-progress__bar{position:absolute;top:0;bottom:0;margin:auto 0;width:100%;animation:none;transform-origin:top left;transition:transform 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-linear-progress__bar-inner{display:inline-block;position:absolute;width:100%;animation:none;border-top-style:solid}.mdc-linear-progress__buffer{display:flex;position:absolute;top:0;bottom:0;margin:auto 0;width:100%;overflow:hidden}.mdc-linear-progress__buffer-dots{background-repeat:repeat-x;flex:auto;transform:rotate(180deg);-webkit-mask-image:url(\"data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E\");animation:mdc-linear-progress-buffering 250ms infinite linear}.mdc-linear-progress__buffer-bar{flex:0 1 100%;transition:flex-basis 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-linear-progress__primary-bar{transform:scaleX(0)}.mdc-linear-progress__secondary-bar{display:none}.mdc-linear-progress--indeterminate .mdc-linear-progress__bar{transition:none}.mdc-linear-progress--indeterminate .mdc-linear-progress__primary-bar{left:-145.166611%}.mdc-linear-progress--indeterminate .mdc-linear-progress__secondary-bar{left:-54.888891%;display:block}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar{animation:mdc-linear-progress-primary-indeterminate-translate 2s infinite linear}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar>.mdc-linear-progress__bar-inner{animation:mdc-linear-progress-primary-indeterminate-scale 2s infinite linear}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar{animation:mdc-linear-progress-secondary-indeterminate-translate 2s infinite linear}.mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar>.mdc-linear-progress__bar-inner{animation:mdc-linear-progress-secondary-indeterminate-scale 2s infinite linear}[dir=rtl] .mdc-linear-progress:not([dir=ltr]) .mdc-linear-progress__bar,.mdc-linear-progress[dir=rtl]:not([dir=ltr]) .mdc-linear-progress__bar{right:0;-webkit-transform-origin:center right;transform-origin:center right}[dir=rtl] .mdc-linear-progress:not([dir=ltr]).mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar,.mdc-linear-progress[dir=rtl]:not([dir=ltr]).mdc-linear-progress--animation-ready .mdc-linear-progress__primary-bar{animation-name:mdc-linear-progress-primary-indeterminate-translate-reverse}[dir=rtl] .mdc-linear-progress:not([dir=ltr]).mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar,.mdc-linear-progress[dir=rtl]:not([dir=ltr]).mdc-linear-progress--animation-ready .mdc-linear-progress__secondary-bar{animation-name:mdc-linear-progress-secondary-indeterminate-translate-reverse}[dir=rtl] .mdc-linear-progress:not([dir=ltr]) .mdc-linear-progress__buffer-dots,.mdc-linear-progress[dir=rtl]:not([dir=ltr]) .mdc-linear-progress__buffer-dots{animation:mdc-linear-progress-buffering-reverse 250ms infinite linear;transform:rotate(0)}[dir=rtl] .mdc-linear-progress:not([dir=ltr]).mdc-linear-progress--indeterminate .mdc-linear-progress__primary-bar,.mdc-linear-progress[dir=rtl]:not([dir=ltr]).mdc-linear-progress--indeterminate .mdc-linear-progress__primary-bar{right:-145.166611%;left:auto}[dir=rtl] .mdc-linear-progress:not([dir=ltr]).mdc-linear-progress--indeterminate .mdc-linear-progress__secondary-bar,.mdc-linear-progress[dir=rtl]:not([dir=ltr]).mdc-linear-progress--indeterminate .mdc-linear-progress__secondary-bar{right:-54.888891%;left:auto}.mdc-linear-progress--closed{opacity:0}.mdc-linear-progress--closed-animation-off .mdc-linear-progress__buffer-dots{animation:none}.mdc-linear-progress--closed-animation-off.mdc-linear-progress--indeterminate .mdc-linear-progress__bar,.mdc-linear-progress--closed-animation-off.mdc-linear-progress--indeterminate .mdc-linear-progress__bar .mdc-linear-progress__bar-inner{animation:none}@keyframes mdc-linear-progress-buffering{from{transform:rotate(180deg) translateX(calc(var(--mdc-linear-progress-track-height) * -2.5))}}.mdc-linear-progress__bar-inner{border-color:var(--mdc-linear-progress-active-indicator-color)}@media(forced-colors: active){.mdc-linear-progress__buffer-dots{background-color:ButtonBorder}}@media all and (-ms-high-contrast: none),(-ms-high-contrast: active){.mdc-linear-progress__buffer-dots{background-color:rgba(0,0,0,0);background-image:url(\"data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='none slice'%3E%3Ccircle cx='1' cy='1' r='1' fill=''/%3E%3C/svg%3E\")}}.mdc-linear-progress{height:max(var(--mdc-linear-progress-track-height), var(--mdc-linear-progress-active-indicator-height))}@media all and (-ms-high-contrast: none),(-ms-high-contrast: active){.mdc-linear-progress{height:4px}}.mdc-linear-progress__bar{height:var(--mdc-linear-progress-active-indicator-height)}.mdc-linear-progress__bar-inner{border-top-width:var(--mdc-linear-progress-active-indicator-height)}.mdc-linear-progress__buffer{height:var(--mdc-linear-progress-track-height)}@media all and (-ms-high-contrast: none),(-ms-high-contrast: active){.mdc-linear-progress__buffer-dots{background-size:10px var(--mdc-linear-progress-track-height)}}.mdc-linear-progress__buffer{border-radius:var(--mdc-linear-progress-track-shape)}.mat-mdc-progress-bar{--mdc-linear-progress-active-indicator-height:4px;--mdc-linear-progress-track-height:4px;--mdc-linear-progress-track-shape:0}.mat-mdc-progress-bar{display:block;text-align:left;--mdc-linear-progress-primary-half: 83.67142%;--mdc-linear-progress-primary-full: 200.611057%;--mdc-linear-progress-secondary-quarter: 37.651913%;--mdc-linear-progress-secondary-half: 84.386165%;--mdc-linear-progress-secondary-full: 160.277782%;--mdc-linear-progress-primary-half-neg: -83.67142%;--mdc-linear-progress-primary-full-neg: -200.611057%;--mdc-linear-progress-secondary-quarter-neg: -37.651913%;--mdc-linear-progress-secondary-half-neg: -84.386165%;--mdc-linear-progress-secondary-full-neg: -160.277782%}[dir=rtl] .mat-mdc-progress-bar{text-align:right}.mat-mdc-progress-bar[mode=query]{transform:scaleX(-1)}.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__buffer-dots,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__primary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__secondary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__bar-inner.mdc-linear-progress__bar-inner{animation:none}.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__primary-bar,.mat-mdc-progress-bar._mat-animation-noopable .mdc-linear-progress__buffer-bar{transition:transform 1ms}"],encapsulation:2,changeDetection:0}),e})();function SB(t,e=0,s=100){return Math.max(e,Math.min(s,t))}let BX=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl]}),e})();const VX=["knob"],UX=["valueIndicatorContainer"];function zX(t,e){if(1&t&&(yn(0,"div",4,5)(2,"div",6)(3,"span",7),Ys(4),In()()()),2&t){const s=bs();Un(4),zu(s.valueIndicatorText)}}const WX=["trackActive"];function HX(t,e){if(1&t&&ti(0,"div"),2&t){const s=e.$implicit,n=e.index,r=bs(3);(function BE(t){Sh(QA,lp,t,!0)})(0===s?"mdc-slider__tick-mark--active":"mdc-slider__tick-mark--inactive"),Ju("transform",r._calcTickMarkTransform(n))}}function jX(t,e){if(1&t&&(dd(0),Fs(1,HX,1,4,"div",11),hd()),2&t){const s=bs(2);Un(1),Yn("ngForOf",s._tickMarks)}}function GX(t,e){if(1&t&&(yn(0,"div",8,9),Fs(2,jX,2,1,"ng-container",10),In()),2&t){const s=bs();Un(2),Yn("ngIf",s._cachedWidth)}}function KX(t,e){if(1&t&&ti(0,"mat-slider-visual-thumb",7),2&t){const s=bs();Yn("discrete",s.discrete)("thumbPosition",1)("valueIndicatorText",s.startValueIndicatorText)}}const XX=["*"],sI=new Zn("_MatSlider"),IB=new Zn("_MatSliderThumb"),TB=new Zn("_MatSliderRangeThumb"),AB=new Zn("_MatSliderVisualThumb");let YX=(()=>{var t;class e{constructor(n,r,i,a){this._cdr=n,this._ngZone=r,this._slider=a,this._isHovered=!1,this._isActive=!1,this._isValueIndicatorVisible=!1,this._onPointerMove=c=>{if(this._sliderInput._isFocused)return;const f=this._hostElement.getBoundingClientRect(),g=this._slider._isCursorOnSliderThumb(c,f);this._isHovered=g,g?this._showHoverRipple():this._hideRipple(this._hoverRippleRef)},this._onMouseLeave=()=>{this._isHovered=!1,this._hideRipple(this._hoverRippleRef)},this._onFocus=()=>{this._hideRipple(this._hoverRippleRef),this._showFocusRipple(),this._hostElement.classList.add("mdc-slider__thumb--focused")},this._onBlur=()=>{this._isActive||this._hideRipple(this._focusRippleRef),this._isHovered&&this._showHoverRipple(),this._hostElement.classList.remove("mdc-slider__thumb--focused")},this._onDragStart=c=>{0===c.button&&(this._isActive=!0,this._showActiveRipple())},this._onDragEnd=()=>{this._isActive=!1,this._hideRipple(this._activeRippleRef),this._sliderInput._isFocused||this._hideRipple(this._focusRippleRef)},this._hostElement=i.nativeElement}ngAfterViewInit(){this._ripple.radius=24,this._sliderInput=this._slider._getInput(this.thumbPosition),this._sliderInputEl=this._sliderInput._hostElement;const n=this._sliderInputEl;this._ngZone.runOutsideAngular(()=>{n.addEventListener("pointermove",this._onPointerMove),n.addEventListener("pointerdown",this._onDragStart),n.addEventListener("pointerup",this._onDragEnd),n.addEventListener("pointerleave",this._onMouseLeave),n.addEventListener("focus",this._onFocus),n.addEventListener("blur",this._onBlur)})}ngOnDestroy(){const n=this._sliderInputEl;n.removeEventListener("pointermove",this._onPointerMove),n.removeEventListener("pointerdown",this._onDragStart),n.removeEventListener("pointerup",this._onDragEnd),n.removeEventListener("pointerleave",this._onMouseLeave),n.removeEventListener("focus",this._onFocus),n.removeEventListener("blur",this._onBlur)}_showHoverRipple(){this._isShowingRipple(this._hoverRippleRef)||(this._hoverRippleRef=this._showRipple({enterDuration:0,exitDuration:0}),this._hoverRippleRef?.element.classList.add("mat-mdc-slider-hover-ripple"))}_showFocusRipple(){this._isShowingRipple(this._focusRippleRef)||(this._focusRippleRef=this._showRipple({enterDuration:0,exitDuration:0},!0),this._focusRippleRef?.element.classList.add("mat-mdc-slider-focus-ripple"))}_showActiveRipple(){this._isShowingRipple(this._activeRippleRef)||(this._activeRippleRef=this._showRipple({enterDuration:225,exitDuration:400}),this._activeRippleRef?.element.classList.add("mat-mdc-slider-active-ripple"))}_isShowingRipple(n){return 0===n?.state||1===n?.state}_showRipple(n,r){if(!this._slider.disabled&&(this._showValueIndicator(),this._slider._isRange&&this._slider._getThumb(1===this.thumbPosition?2:1)._showValueIndicator(),!this._slider._globalRippleOptions?.disabled||r))return this._ripple.launch({animation:this._slider._noopAnimations?{enterDuration:0,exitDuration:0}:n,centered:!0,persistent:!0})}_hideRipple(n){if(n?.fadeOut(),this._isShowingAnyRipple())return;this._slider._isRange||this._hideValueIndicator();const r=this._getSibling();r._isShowingAnyRipple()||(this._hideValueIndicator(),r._hideValueIndicator())}_showValueIndicator(){this._hostElement.classList.add("mdc-slider__thumb--with-indicator")}_hideValueIndicator(){this._hostElement.classList.remove("mdc-slider__thumb--with-indicator")}_getSibling(){return this._slider._getThumb(1===this.thumbPosition?2:1)}_getValueIndicatorContainer(){return this._valueIndicatorContainer?.nativeElement}_getKnob(){return this._knob.nativeElement}_isShowingAnyRipple(){return this._isShowingRipple(this._hoverRippleRef)||this._isShowingRipple(this._focusRippleRef)||this._isShowingRipple(this._activeRippleRef)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Ll),lt(Gs),lt(yr),lt(sI))},t.\u0275cmp=sr({type:t,selectors:[["mat-slider-visual-thumb"]],viewQuery:function(n,r){if(1&n&&(qo(US,5),qo(VX,5),qo(UX,5)),2&n){let i;Ar(i=kr())&&(r._ripple=i.first),Ar(i=kr())&&(r._knob=i.first),Ar(i=kr())&&(r._valueIndicatorContainer=i.first)}},hostAttrs:[1,"mdc-slider__thumb","mat-mdc-slider-visual-thumb"],inputs:{discrete:"discrete",thumbPosition:"thumbPosition",valueIndicatorText:"valueIndicatorText"},features:[vr([{provide:AB,useExisting:t}])],decls:4,vars:2,consts:[["class","mdc-slider__value-indicator-container",4,"ngIf"],[1,"mdc-slider__thumb-knob"],["knob",""],["matRipple","",1,"mat-mdc-focus-indicator",3,"matRippleDisabled"],[1,"mdc-slider__value-indicator-container"],["valueIndicatorContainer",""],[1,"mdc-slider__value-indicator"],[1,"mdc-slider__value-indicator-text"]],template:function(n,r){1&n&&(Fs(0,zX,5,1,"div",0),ti(1,"div",1,2)(3,"div",3)),2&n&&(Yn("ngIf",r.discrete),Un(3),Yn("matRippleDisabled",!0))},dependencies:[$d,US],styles:[".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}"],encapsulation:2,changeDetection:0}),e})();const ZX=Ib(BS(class{constructor(t){this._elementRef=t}}),"primary");let QX=(()=>{var t;class e extends ZX{get disabled(){return this._disabled}set disabled(n){this._disabled=Yr(n);const r=this._getInput(2),i=this._getInput(1);r&&(r.disabled=this._disabled),i&&(i.disabled=this._disabled)}get discrete(){return this._discrete}set discrete(n){this._discrete=Yr(n),this._updateValueIndicatorUIs()}get showTickMarks(){return this._showTickMarks}set showTickMarks(n){this._showTickMarks=Yr(n)}get min(){return this._min}set min(n){const r=Bl(n,this._min);this._min!==r&&this._updateMin(r)}_updateMin(n){const r=this._min;this._min=n,this._isRange?this._updateMinRange({old:r,new:n}):this._updateMinNonRange(n),this._onMinMaxOrStepChange()}_updateMinRange(n){const r=this._getInput(2),i=this._getInput(1),a=r.value,c=i.value;i.min=n.new,r.min=Math.max(n.new,i.value),i.max=Math.min(r.max,r.value),i._updateWidthInactive(),r._updateWidthInactive(),n.new<n.old?this._onTranslateXChangeBySideEffect(r,i):this._onTranslateXChangeBySideEffect(i,r),a!==r.value&&this._onValueChange(r),c!==i.value&&this._onValueChange(i)}_updateMinNonRange(n){const r=this._getInput(2);if(r){const i=r.value;r.min=n,r._updateThumbUIByValue(),this._updateTrackUI(r),i!==r.value&&this._onValueChange(r)}}get max(){return this._max}set max(n){const r=Bl(n,this._max);this._max!==r&&this._updateMax(r)}_updateMax(n){const r=this._max;this._max=n,this._isRange?this._updateMaxRange({old:r,new:n}):this._updateMaxNonRange(n),this._onMinMaxOrStepChange()}_updateMaxRange(n){const r=this._getInput(2),i=this._getInput(1),a=r.value,c=i.value;r.max=n.new,i.max=Math.min(n.new,r.value),r.min=i.value,r._updateWidthInactive(),i._updateWidthInactive(),n.new>n.old?this._onTranslateXChangeBySideEffect(i,r):this._onTranslateXChangeBySideEffect(r,i),a!==r.value&&this._onValueChange(r),c!==i.value&&this._onValueChange(i)}_updateMaxNonRange(n){const r=this._getInput(2);if(r){const i=r.value;r.max=n,r._updateThumbUIByValue(),this._updateTrackUI(r),i!==r.value&&this._onValueChange(r)}}get step(){return this._step}set step(n){const r=Bl(n,this._step);this._step!==r&&this._updateStep(r)}_updateStep(n){this._step=n,this._isRange?this._updateStepRange():this._updateStepNonRange(),this._onMinMaxOrStepChange()}_updateStepRange(){const n=this._getInput(2),r=this._getInput(1),i=n.value,a=r.value,c=r.value;n.min=this._min,r.max=this._max,n.step=this._step,r.step=this._step,this._platform.SAFARI&&(n.value=n.value,r.value=r.value),n.min=Math.max(this._min,r.value),r.max=Math.min(this._max,n.value),r._updateWidthInactive(),n._updateWidthInactive(),n.value<c?this._onTranslateXChangeBySideEffect(r,n):this._onTranslateXChangeBySideEffect(n,r),i!==n.value&&this._onValueChange(n),a!==r.value&&this._onValueChange(r)}_updateStepNonRange(){const n=this._getInput(2);if(n){const r=n.value;n.step=this._step,this._platform.SAFARI&&(n.value=n.value),n._updateThumbUIByValue(),r!==n.value&&this._onValueChange(n)}}constructor(n,r,i,a,c,f){super(i),this._ngZone=n,this._cdr=r,this._dir=a,this._globalRippleOptions=c,this._disabled=!1,this._discrete=!1,this._showTickMarks=!1,this._min=0,this._max=100,this._step=1,this.displayWith=g=>`${g}`,this._rippleRadius=24,this.startValueIndicatorText="",this.endValueIndicatorText="",this._isRange=!1,this._isRtl=!1,this._hasViewInitialized=!1,this._tickMarkTrackWidth=0,this._hasAnimation=!1,this._resizeTimer=null,this._platform=jn(wc),this._knobRadius=8,this._thumbsOverlap=!1,this._noopAnimations="NoopAnimations"===f,this._dirChangeSubscription=this._dir.change.subscribe(()=>this._onDirChange()),this._isRtl="rtl"===this._dir.value}ngAfterViewInit(){this._platform.isBrowser&&this._updateDimensions();const n=this._getInput(2),r=this._getInput(1);this._isRange=!!n&&!!r,this._cdr.detectChanges();const i=this._getThumb(2);this._rippleRadius=i._ripple.radius,this._inputPadding=this._rippleRadius-this._knobRadius,this._inputOffset=this._knobRadius,this._isRange?this._initUIRange(n,r):this._initUINonRange(n),this._updateTrackUI(n),this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._observeHostResize(),this._cdr.detectChanges()}_initUINonRange(n){n.initProps(),n.initUI(),this._updateValueIndicatorUI(n),this._hasViewInitialized=!0,n._updateThumbUIByValue()}_initUIRange(n,r){n.initProps(),n.initUI(),r.initProps(),r.initUI(),n._updateMinMax(),r._updateMinMax(),n._updateStaticStyles(),r._updateStaticStyles(),this._updateValueIndicatorUIs(),this._hasViewInitialized=!0,n._updateThumbUIByValue(),r._updateThumbUIByValue()}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._resizeObserver?.disconnect(),this._resizeObserver=null}_onDirChange(){this._isRtl="rtl"===this._dir.value,this._isRange?this._onDirChangeRange():this._onDirChangeNonRange(),this._updateTickMarkUI()}_onDirChangeRange(){const n=this._getInput(2),r=this._getInput(1);n._setIsLeftThumb(),r._setIsLeftThumb(),n.translateX=n._calcTranslateXByValue(),r.translateX=r._calcTranslateXByValue(),n._updateStaticStyles(),r._updateStaticStyles(),n._updateWidthInactive(),r._updateWidthInactive(),n._updateThumbUIByValue(),r._updateThumbUIByValue()}_onDirChangeNonRange(){this._getInput(2)._updateThumbUIByValue()}_observeHostResize(){typeof ResizeObserver>"u"||!ResizeObserver||this._ngZone.runOutsideAngular(()=>{this._resizeObserver=new ResizeObserver(()=>{this._isActive()||(this._resizeTimer&&clearTimeout(this._resizeTimer),this._onResize())}),this._resizeObserver.observe(this._elementRef.nativeElement)})}_isActive(){return this._getThumb(1)._isActive||this._getThumb(2)._isActive}_getValue(n=2){const r=this._getInput(n);return r?r.value:this.min}_skipUpdate(){return!(!this._getInput(1)?._skipUIUpdate&&!this._getInput(2)?._skipUIUpdate)}_updateDimensions(){this._cachedWidth=this._elementRef.nativeElement.offsetWidth,this._cachedLeft=this._elementRef.nativeElement.getBoundingClientRect().left}_setTrackActiveStyles(n){const r=this._trackActive.nativeElement.style;r.left=n.left,r.right=n.right,r.transformOrigin=n.transformOrigin,r.transform=n.transform}_calcTickMarkTransform(n){return`translateX(${n*(this._tickMarkTrackWidth/(this._tickMarks.length-1))}px`}_onTranslateXChange(n){this._hasViewInitialized&&(this._updateThumbUI(n),this._updateTrackUI(n),this._updateOverlappingThumbUI(n))}_onTranslateXChangeBySideEffect(n,r){this._hasViewInitialized&&(n._updateThumbUIByValue(),r._updateThumbUIByValue())}_onValueChange(n){this._hasViewInitialized&&(this._updateValueIndicatorUI(n),this._updateTickMarkUI(),this._cdr.detectChanges())}_onMinMaxOrStepChange(){this._hasViewInitialized&&(this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.markForCheck())}_onResize(){if(this._hasViewInitialized){if(this._updateDimensions(),this._isRange){const n=this._getInput(2),r=this._getInput(1);n._updateThumbUIByValue(),r._updateThumbUIByValue(),n._updateStaticStyles(),r._updateStaticStyles(),n._updateMinMax(),r._updateMinMax(),n._updateWidthInactive(),r._updateWidthInactive()}else{const n=this._getInput(2);n&&n._updateThumbUIByValue()}this._updateTickMarkUI(),this._updateTickMarkTrackUI(),this._cdr.detectChanges()}}_areThumbsOverlapping(){const n=this._getInput(1),r=this._getInput(2);return!(!n||!r)&&r.translateX-n.translateX<20}_updateOverlappingThumbClassNames(n){const r=n.getSibling(),i=this._getThumb(n.thumbPosition);this._getThumb(r.thumbPosition)._hostElement.classList.remove("mdc-slider__thumb--top"),i._hostElement.classList.toggle("mdc-slider__thumb--top",this._thumbsOverlap)}_updateOverlappingThumbUI(n){!this._isRange||this._skipUpdate()||this._thumbsOverlap!==this._areThumbsOverlapping()&&(this._thumbsOverlap=!this._thumbsOverlap,this._updateOverlappingThumbClassNames(n))}_updateThumbUI(n){this._skipUpdate()||(this._getThumb(2===n.thumbPosition?2:1)._hostElement.style.transform=`translateX(${n.translateX}px)`)}_updateValueIndicatorUI(n){if(this._skipUpdate())return;const r=this.displayWith(n.value);if(this._hasViewInitialized?n._valuetext=r:n._hostElement.setAttribute("aria-valuetext",r),this.discrete){1===n.thumbPosition?this.startValueIndicatorText=r:this.endValueIndicatorText=r;const i=this._getThumb(n.thumbPosition);r.length<3?i._hostElement.classList.add("mdc-slider__thumb--short-value"):i._hostElement.classList.remove("mdc-slider__thumb--short-value")}}_updateValueIndicatorUIs(){const n=this._getInput(2),r=this._getInput(1);n&&this._updateValueIndicatorUI(n),r&&this._updateValueIndicatorUI(r)}_updateTickMarkTrackUI(){if(!this.showTickMarks||this._skipUpdate())return;const n=this._step&&this._step>0?this._step:1,i=(Math.floor(this.max/n)*n-this.min)/(this.max-this.min);this._tickMarkTrackWidth=this._cachedWidth*i-6}_updateTrackUI(n){this._skipUpdate()||(this._isRange?this._updateTrackUIRange(n):this._updateTrackUINonRange(n))}_updateTrackUIRange(n){const r=n.getSibling();if(!r||!this._cachedWidth)return;const i=Math.abs(r.translateX-n.translateX)/this._cachedWidth;this._setTrackActiveStyles(n._isLeftThumb&&this._cachedWidth?{left:"auto",right:this._cachedWidth-r.translateX+"px",transformOrigin:"right",transform:`scaleX(${i})`}:{left:`${r.translateX}px`,right:"auto",transformOrigin:"left",transform:`scaleX(${i})`})}_updateTrackUINonRange(n){this._setTrackActiveStyles(this._isRtl?{left:"auto",right:"0px",transformOrigin:"right",transform:`scaleX(${1-n.fillPercentage})`}:{left:"0px",right:"auto",transformOrigin:"left",transform:`scaleX(${n.fillPercentage})`})}_updateTickMarkUI(){if(!this.showTickMarks||void 0===this.step||void 0===this.min||void 0===this.max)return;const n=this.step>0?this.step:1;this._isRange?this._updateTickMarkUIRange(n):this._updateTickMarkUINonRange(n),this._isRtl&&this._tickMarks.reverse()}_updateTickMarkUINonRange(n){const r=this._getValue();let i=Math.max(Math.round((r-this.min)/n),0),a=Math.max(Math.round((this.max-r)/n),0);this._isRtl?i++:a++,this._tickMarks=Array(i).fill(0).concat(Array(a).fill(1))}_updateTickMarkUIRange(n){const r=this._getValue(),i=this._getValue(1),a=Math.max(Math.floor((i-this.min)/n),0),c=Math.max(Math.floor((r-i)/n)+1,0),f=Math.max(Math.floor((this.max-r)/n),0);this._tickMarks=Array(a).fill(1).concat(Array(c).fill(0),Array(f).fill(1))}_getInput(n){return 2===n&&this._input?this._input:this._inputs?.length?1===n?this._inputs.first:this._inputs.last:void 0}_getThumb(n){return 2===n?this._thumbs?.last:this._thumbs?.first}_setTransition(n){this._hasAnimation=!this._platform.IOS&&n&&!this._noopAnimations,this._elementRef.nativeElement.classList.toggle("mat-mdc-slider-with-animation",this._hasAnimation)}_isCursorOnSliderThumb(n,r){const i=r.width/2,g=n.clientY-(r.y+i);return Math.pow(n.clientX-(r.x+i),2)+Math.pow(g,2)<Math.pow(i,2)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Gs),lt(Ll),lt(yr),lt(td,8),lt(mC,8),lt(ac,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-slider"]],contentQueries:function(n,r,i){if(1&n&&(ea(i,IB,5),ea(i,TB,4)),2&n){let a;Ar(a=kr())&&(r._input=a.first),Ar(a=kr())&&(r._inputs=a)}},viewQuery:function(n,r){if(1&n&&(qo(WX,5),qo(AB,5)),2&n){let i;Ar(i=kr())&&(r._trackActive=i.first),Ar(i=kr())&&(r._thumbs=i)}},hostAttrs:[1,"mat-mdc-slider","mdc-slider"],hostVars:10,hostBindings:function(n,r){2&n&&Ei("mdc-slider--range",r._isRange)("mdc-slider--disabled",r.disabled)("mdc-slider--discrete",r.discrete)("mdc-slider--tick-marks",r.showTickMarks)("_mat-animation-noopable",r._noopAnimations)},inputs:{color:"color",disableRipple:"disableRipple",disabled:"disabled",discrete:"discrete",showTickMarks:"showTickMarks",min:"min",max:"max",step:"step",displayWith:"displayWith"},exportAs:["matSlider"],features:[vr([{provide:sI,useExisting:t}]),Ps],ngContentSelectors:XX,decls:9,vars:5,consts:[[1,"mdc-slider__track"],[1,"mdc-slider__track--inactive"],[1,"mdc-slider__track--active"],[1,"mdc-slider__track--active_fill"],["trackActive",""],["class","mdc-slider__tick-marks",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText",4,"ngIf"],[3,"discrete","thumbPosition","valueIndicatorText"],[1,"mdc-slider__tick-marks"],["tickMarkContainer",""],[4,"ngIf"],[3,"class","transform",4,"ngFor","ngForOf"]],template:function(n,r){1&n&&(Pl(),ri(0),yn(1,"div",0),ti(2,"div",1),yn(3,"div",2),ti(4,"div",3,4),In(),Fs(6,GX,3,1,"div",5),In(),Fs(7,KX,1,3,"mat-slider-visual-thumb",6),ti(8,"mat-slider-visual-thumb",7)),2&n&&(Un(6),Yn("ngIf",r.showTickMarks),Un(1),Yn("ngIf",r._isRange),Un(1),Yn("discrete",r.discrete)("thumbPosition",2)("valueIndicatorText",r.endValueIndicatorText))},dependencies:[Rw,$d,YX],styles:['.mdc-slider{cursor:pointer;height:48px;margin:0 24px;position:relative;touch-action:pan-y}.mdc-slider .mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%}.mdc-slider .mdc-slider__track--active,.mdc-slider .mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider .mdc-slider__track--active{overflow:hidden}.mdc-slider .mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;-webkit-transform-origin:left;transform-origin:left}[dir=rtl] .mdc-slider .mdc-slider__track--active_fill,.mdc-slider .mdc-slider__track--active_fill[dir=rtl]{-webkit-transform-origin:right;transform-origin:right}.mdc-slider .mdc-slider__track--inactive{left:0;top:0}.mdc-slider .mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider .mdc-slider__value-indicator-container{bottom:44px;left:var(--slider-value-indicator-container-left, 50%);pointer-events:none;position:absolute;right:var(--slider-value-indicator-container-right);transform:var(--slider-value-indicator-container-transform, translateX(-50%))}.mdc-slider .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);align-items:center;border-radius:4px;display:flex;height:32px;padding:0 12px;transform:scale(0);transform-origin:bottom}.mdc-slider .mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:"";height:0;left:var(--slider-value-indicator-caret-left, 50%);position:absolute;right:var(--slider-value-indicator-caret-right);transform:var(--slider-value-indicator-caret-transform, translateX(-50%));width:0}.mdc-slider .mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}@media(prefers-reduced-motion){.mdc-slider .mdc-slider__value-indicator,.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:none}}.mdc-slider .mdc-slider__thumb{display:flex;left:-24px;outline:none;position:absolute;user-select:none;height:48px;width:48px}.mdc-slider .mdc-slider__thumb--top{z-index:1}.mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-style:solid;border-width:1px;box-sizing:content-box}.mdc-slider .mdc-slider__thumb-knob{box-sizing:border-box;left:50%;position:absolute;top:50%;transform:translate(-50%, -50%)}.mdc-slider .mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:transform 80ms ease}@media(prefers-reduced-motion){.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:none}}.mdc-slider--disabled{cursor:auto}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;pointer-events:none;position:absolute;top:2px;width:44px}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;margin-left:8px;margin-right:8px;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider .mdc-slider__thumb-knob{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000));border-color:var(--mdc-slider-disabled-handle-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb::before,.mat-mdc-slider .mdc-slider__thumb::after{background-color:var(--mdc-slider-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover::before,.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before{opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mat-mdc-slider .mdc-slider__track--active_fill{border-color:var(--mdc-slider-active-track-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mdc-slider-disabled-active-track-color, var(--mdc-theme-on-surface, #000))}.mat-mdc-slider .mdc-slider__track--inactive{background-color:var(--mdc-slider-inactive-track-color, var(--mdc-theme-primary, #6200ee));opacity:.24}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mdc-slider-disabled-inactive-track-color, var(--mdc-theme-on-surface, #000));opacity:.24}.mat-mdc-slider .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color, var(--mdc-theme-on-primary, #fff));opacity:var(--mdc-slider-with-tick-marks-active-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-inactive-container-color, var(--mdc-theme-primary, #6200ee));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-disabled-container-color, var(--mdc-theme-on-surface, #000));opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity, 0.6)}.mat-mdc-slider .mdc-slider__value-indicator{background-color:var(--mdc-slider-label-container-color, #666666);opacity:1}.mat-mdc-slider .mdc-slider__value-indicator::before{border-top-color:var(--mdc-slider-label-container-color, #666666)}.mat-mdc-slider .mdc-slider__value-indicator{color:var(--mdc-slider-label-label-text-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slider .mdc-slider__track{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__track--active{height:var(--mdc-slider-active-track-height, 6px);top:calc((var(--mdc-slider-inactive-track-height, 4px) - var(--mdc-slider-active-track-height, 6px)) / 2)}.mat-mdc-slider .mdc-slider__track--active_fill{border-top-width:var(--mdc-slider-active-track-height, 6px)}.mat-mdc-slider .mdc-slider__track--inactive{height:var(--mdc-slider-inactive-track-height, 4px)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{height:var(--mdc-slider-with-tick-marks-container-size, 2px);width:var(--mdc-slider-with-tick-marks-container-size, 2px)}.mat-mdc-slider.mdc-slider--disabled{opacity:0.38}.mat-mdc-slider .mdc-slider__value-indicator-text{letter-spacing:var(--mdc-slider-label-label-text-tracking, 0.0071428571em);font-size:var(--mdc-slider-label-label-text-size, 0.875rem);font-family:var(--mdc-slider-label-label-text-font, Roboto, sans-serif);font-weight:var(--mdc-slider-label-label-text-weight, 500);line-height:var(--mdc-slider-label-label-text-line-height, 1.375rem)}.mat-mdc-slider .mdc-slider__track--active{border-radius:var(--mdc-slider-active-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__track--inactive{border-radius:var(--mdc-slider-inactive-track-shape, 9999px)}.mat-mdc-slider .mdc-slider__thumb-knob{border-radius:var(--mdc-slider-handle-shape, 50%);width:var(--mdc-slider-handle-width, 20px);height:var(--mdc-slider-handle-height, 20px);border-style:solid;border-width:calc(var(--mdc-slider-handle-height, 20px) / 2) calc(var(--mdc-slider-handle-width, 20px) / 2)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{border-radius:var(--mdc-slider-with-tick-marks-container-shape, 50%)}.mat-mdc-slider .mdc-slider__thumb-knob{box-shadow:var(--mdc-slider-handle-elevation, 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-hover-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee));border-color:var(--mdc-slider-focus-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:var(--mdc-slider-with-overlap-handle-outline-color, #fff);border-width:var(--mdc-slider-with-overlap-handle-outline-width, 1px)}.mat-mdc-slider .mdc-slider__input{box-sizing:content-box;pointer-events:auto}.mat-mdc-slider .mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mat-mdc-slider .mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__value-indicator{word-break:normal}.mat-mdc-slider .mdc-slider__track,.mat-mdc-slider .mdc-slider__thumb{pointer-events:none}.mat-mdc-slider .mdc-slider__value-indicator{opacity:var(--mat-mdc-slider-value-indicator-opacity, 1)}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-mdc-slider-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-mdc-slider-hover-ripple-color, transparent)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-mdc-slider-focus-ripple-color, transparent)}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-mdc-focus-indicator::before{border-radius:50%}.mdc-slider__thumb--focused .mat-mdc-focus-indicator::before{content:""}'],encapsulation:2,changeDetection:0}),e})();const qX={provide:ah,useExisting:Br(()=>_R),multi:!0};let _R=(()=>{var t;class e{get value(){return Bl(this._hostElement.value)}set value(n){const r=Bl(n).toString();this._hasSetInitialValue?this._isActive||(this._hostElement.value=r,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges(),this._slider._cdr.markForCheck()):this._initialValue=r}get translateX(){return this._slider.min>=this._slider.max?(this._translateX=0,this._translateX):(void 0===this._translateX&&(this._translateX=this._calcTranslateXByValue()),this._translateX)}set translateX(n){this._translateX=n}get min(){return Bl(this._hostElement.min)}set min(n){this._hostElement.min=Bl(n).toString(),this._cdr.detectChanges()}get max(){return Bl(this._hostElement.max)}set max(n){this._hostElement.max=Bl(n).toString(),this._cdr.detectChanges()}get step(){return Bl(this._hostElement.step)}set step(n){this._hostElement.step=Bl(n).toString(),this._cdr.detectChanges()}get disabled(){return Yr(this._hostElement.disabled)}set disabled(n){this._hostElement.disabled=Yr(n),this._cdr.detectChanges(),this._slider.disabled!==this.disabled&&(this._slider.disabled=this.disabled)}get percentage(){return this._slider.min>=this._slider.max?this._slider._isRtl?1:0:(this.value-this._slider.min)/(this._slider.max-this._slider.min)}get fillPercentage(){return this._slider._cachedWidth?0===this._translateX?0:this.translateX/this._slider._cachedWidth:this._slider._isRtl?1:0}_setIsFocused(n){this._isFocused=n}constructor(n,r,i,a){this._ngZone=n,this._elementRef=r,this._cdr=i,this._slider=a,this.valueChange=new Rr,this.dragStart=new Rr,this.dragEnd=new Rr,this.thumbPosition=2,this._knobRadius=8,this._isActive=!1,this._isFocused=!1,this._hasSetInitialValue=!1,this._destroyed=new Bt,this._skipUIUpdate=!1,this._onTouchedFn=()=>{},this._isControlInitialized=!1,this._platform=jn(wc),this._hostElement=r.nativeElement,this._ngZone.runOutsideAngular(()=>{this._hostElement.addEventListener("pointerdown",this._onPointerDown.bind(this)),this._hostElement.addEventListener("pointermove",this._onPointerMove.bind(this)),this._hostElement.addEventListener("pointerup",this._onPointerUp.bind(this))})}ngOnDestroy(){this._hostElement.removeEventListener("pointerdown",this._onPointerDown),this._hostElement.removeEventListener("pointermove",this._onPointerMove),this._hostElement.removeEventListener("pointerup",this._onPointerUp),this._destroyed.next(),this._destroyed.complete(),this.dragStart.complete(),this.dragEnd.complete()}initProps(){this._updateWidthInactive(),this.disabled!==this._slider.disabled&&(this._slider.disabled=!0),this.step=this._slider.step,this.min=this._slider.min,this.max=this._slider.max,this._initValue()}initUI(){this._updateThumbUIByValue()}_initValue(){this._hasSetInitialValue=!0,void 0===this._initialValue?this.value=this._getDefaultValue():(this._hostElement.value=this._initialValue,this._updateThumbUIByValue(),this._slider._onValueChange(this),this._cdr.detectChanges())}_getDefaultValue(){return this.min}_onBlur(){this._setIsFocused(!1),this._onTouchedFn()}_onFocus(){this._setIsFocused(!0)}_onChange(){this.valueChange.emit(this.value),this._isActive&&this._updateThumbUIByValue({withAnimation:!0})}_onInput(){this._onChangeFn?.(this.value),(this._slider.step||!this._isActive)&&this._updateThumbUIByValue({withAnimation:!0}),this._slider._onValueChange(this)}_onNgControlValueChange(){(!this._isActive||!this._isFocused)&&(this._slider._onValueChange(this),this._updateThumbUIByValue()),this._slider.disabled=this._formControl.disabled}_onPointerDown(n){if(!this.disabled&&0===n.button){if(this._platform.IOS){const r=this._slider._isCursorOnSliderThumb(n,this._slider._getThumb(this.thumbPosition)._hostElement.getBoundingClientRect());return this._isActive=r,this._updateWidthActive(),void this._slider._updateDimensions()}this._isActive=!0,this._setIsFocused(!0),this._updateWidthActive(),this._slider._updateDimensions(),this._slider.step||this._updateThumbUIByPointerEvent(n,{withAnimation:!0}),this.disabled||(this._handleValueCorrection(n),this.dragStart.emit({source:this,parent:this._slider,value:this.value}))}}_handleValueCorrection(n){this._skipUIUpdate=!0,setTimeout(()=>{this._skipUIUpdate=!1,this._fixValue(n)},0)}_fixValue(n){const r=n.clientX-this._slider._cachedLeft,i=this._slider._cachedWidth,a=0===this._slider.step?1:this._slider.step,c=Math.floor((this._slider.max-this._slider.min)/a),E=Math.round((this._slider._isRtl?1-r/i:r/i)*c)/c*(this._slider.max-this._slider.min)+this._slider.min,A=Math.round(E/a)*a;if(A===this.value)return this._slider._onValueChange(this),void(this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(n,{withAnimation:this._slider._hasAnimation}));this.value=A,this.valueChange.emit(this.value),this._onChangeFn?.(this.value),this._slider._onValueChange(this),this._slider.step>0?this._updateThumbUIByValue():this._updateThumbUIByPointerEvent(n,{withAnimation:this._slider._hasAnimation})}_onPointerMove(n){!this._slider.step&&this._isActive&&this._updateThumbUIByPointerEvent(n)}_onPointerUp(){this._isActive&&(this._isActive=!1,this.dragEnd.emit({source:this,parent:this._slider,value:this.value}),setTimeout(()=>this._updateWidthInactive(),this._platform.IOS?10:0))}_clamp(n){return Math.max(Math.min(n,this._slider._cachedWidth),0)}_calcTranslateXByValue(){return this._slider._isRtl?(1-this.percentage)*this._slider._cachedWidth:this.percentage*this._slider._cachedWidth}_calcTranslateXByPointerEvent(n){return n.clientX-this._slider._cachedLeft}_updateWidthActive(){this._hostElement.style.padding=`0 ${this._slider._inputPadding}px`,this._hostElement.style.width=`calc(100% + ${this._slider._inputPadding}px)`}_updateWidthInactive(){this._hostElement.style.padding="0px",this._hostElement.style.width="calc(100% + 48px)",this._hostElement.style.left="-24px"}_updateThumbUIByValue(n){this.translateX=this._clamp(this._calcTranslateXByValue()),this._updateThumbUI(n)}_updateThumbUIByPointerEvent(n,r){this.translateX=this._clamp(this._calcTranslateXByPointerEvent(n)),this._updateThumbUI(r)}_updateThumbUI(n){this._slider._setTransition(!!n?.withAnimation),this._slider._onTranslateXChange(this)}writeValue(n){(this._isControlInitialized||null!==n)&&(this.value=n)}registerOnChange(n){this._onChangeFn=n,this._isControlInitialized=!0}registerOnTouched(n){this._onTouchedFn=n}setDisabledState(n){this.disabled=n}focus(){this._hostElement.focus()}blur(){this._hostElement.blur()}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Gs),lt(yr),lt(Ll),lt(sI))},t.\u0275dir=Gn({type:t,selectors:[["input","matSliderThumb",""]],hostAttrs:["type","range",1,"mdc-slider__input"],hostVars:1,hostBindings:function(n,r){1&n&&qs("change",function(){return r._onChange()})("input",function(){return r._onInput()})("blur",function(){return r._onBlur()})("focus",function(){return r._onFocus()}),2&n&&si("aria-valuetext",r._valuetext)},inputs:{value:"value"},outputs:{valueChange:"valueChange",dragStart:"dragStart",dragEnd:"dragEnd"},exportAs:["matSliderThumb"],features:[vr([qX,{provide:IB,useExisting:t}])]}),e})(),nY=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,Ah,zS]}),e})();const sY=["addListener","removeListener"],rY=["addEventListener","removeEventListener"],iY=["on","off"];function l0(t,e,s,n){if(U(s)&&(n=s,s=void 0),n)return l0(t,e,s).pipe(U2(n));const[r,i]=function lY(t){return U(t.addEventListener)&&U(t.removeEventListener)}(t)?rY.map(a=>c=>t[a](e,c,s)):function oY(t){return U(t.addListener)&&U(t.removeListener)}(t)?sY.map(kB(t,e)):function aY(t){return U(t.on)&&U(t.off)}(t)?iY.map(kB(t,e)):[];if(!r&&ui(t))return no(a=>l0(a,e,s))(Jr(t));if(!r)throw new TypeError("Invalid event target");return new Ue(a=>{const c=(...f)=>a.next(1<f.length?f:f[0]);return r(c),()=>i(c)})}function kB(t,e){return s=>n=>t[s](e,n)}const CC={schedule(t){let e=requestAnimationFrame,s=cancelAnimationFrame;const{delegate:n}=CC;n&&(e=n.requestAnimationFrame,s=n.cancelAnimationFrame);const r=e(i=>{s=void 0,t(i)});return new I(()=>s?.(r))},requestAnimationFrame(...t){const{delegate:e}=CC;return(e?.requestAnimationFrame||requestAnimationFrame)(...t)},cancelAnimationFrame(...t){const{delegate:e}=CC;return(e?.cancelAnimationFrame||cancelAnimationFrame)(...t)},delegate:void 0},OB=new class uY extends WO{flush(e){this._active=!0;const s=this._scheduled;this._scheduled=void 0;const{actions:n}=this;let r;e=e||n.shift();do{if(r=e.execute(e.state,e.delay))break}while((e=n[0])&&e.id===s&&n.shift());if(this._active=!1,r){for(;(e=n[0])&&e.id===s&&n.shift();)e.unsubscribe();throw r}}}(class cY extends UO{constructor(e,s){super(e,s),this.scheduler=e,this.work=s}requestAsyncId(e,s,n=0){return null!==n&&n>0?super.requestAsyncId(e,s,n):(e.actions.push(this),e._scheduled||(e._scheduled=CC.requestAnimationFrame(()=>e.flush(void 0))))}recycleAsyncId(e,s,n=0){var r;if(null!=n?n>0:this.delay>0)return super.recycleAsyncId(e,s,n);const{actions:i}=e;null!=s&&(null===(r=i[i.length-1])||void 0===r?void 0:r.id)!==s&&(CC.cancelAnimationFrame(s),e._scheduled=void 0)}});let yR,dY=1;const rI={};function RB(t){return t in rI&&(delete rI[t],!0)}const hY={setImmediate(t){const e=dY++;return rI[e]=!0,yR||(yR=Promise.resolve()),yR.then(()=>RB(e)&&t()),e},clearImmediate(t){RB(t)}},{setImmediate:pY,clearImmediate:fY}=hY,iI={setImmediate(...t){const{delegate:e}=iI;return(e?.setImmediate||pY)(...t)},clearImmediate(t){const{delegate:e}=iI;return(e?.clearImmediate||fY)(t)},delegate:void 0},_Y=new class gY extends WO{flush(e){this._active=!0;const s=this._scheduled;this._scheduled=void 0;const{actions:n}=this;let r;e=e||n.shift();do{if(r=e.execute(e.state,e.delay))break}while((e=n[0])&&e.id===s&&n.shift());if(this._active=!1,r){for(;(e=n[0])&&e.id===s&&n.shift();)e.unsubscribe();throw r}}}(class mY extends UO{constructor(e,s){super(e,s),this.scheduler=e,this.work=s}requestAsyncId(e,s,n=0){return null!==n&&n>0?super.requestAsyncId(e,s,n):(e.actions.push(this),e._scheduled||(e._scheduled=iI.setImmediate(e.flush.bind(e,void 0))))}recycleAsyncId(e,s,n=0){var r;if(null!=n?n>0:this.delay>0)return super.recycleAsyncId(e,s,n);const{actions:i}=e;null!=s&&(null===(r=i[i.length-1])||void 0===r?void 0:r.id)!==s&&(iI.clearImmediate(s),e._scheduled===s&&(e._scheduled=void 0))}});function vR(t,e=lC){return function yY(t){return Dn((e,s)=>{let n=!1,r=null,i=null,a=!1;const c=()=>{if(i?.unsubscribe(),i=null,n){n=!1;const g=r;r=null,s.next(g)}a&&s.complete()},f=()=>{i=null,a&&s.complete()};e.subscribe(ps(s,g=>{n=!0,r=g,i||Jr(t(g)).subscribe(i=ps(s,c,f))},()=>{a=!0,(!n||!i||i.closed)&&s.complete()}))})}(()=>sR(t,e))}const vY=["contentWrapper"],bY=["*"],xY=new Zn("VIRTUAL_SCROLL_STRATEGY");let Tb=(()=>{var t;class e{constructor(n,r,i){this._ngZone=n,this._platform=r,this._scrolled=new Bt,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=i}register(n){this.scrollContainers.has(n)||this.scrollContainers.set(n,n.elementScrolled().subscribe(()=>this._scrolled.next(n)))}deregister(n){const r=this.scrollContainers.get(n);r&&(r.unsubscribe(),this.scrollContainers.delete(n))}scrolled(n=20){return this._platform.isBrowser?new Ue(r=>{this._globalSubscription||this._addGlobalListener();const i=n>0?this._scrolled.pipe(vR(n)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{i.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Xs()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((n,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(n,r){const i=this.getAncestorScrollContainers(n);return this.scrolled(r).pipe(tc(a=>!a||i.indexOf(a)>-1))}getAncestorScrollContainers(n){const r=[];return this.scrollContainers.forEach((i,a)=>{this._scrollableContainsElement(a,n)&&r.push(a)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(n,r){let i=cu(r),a=n.getElementRef().nativeElement;do{if(i==a)return!0}while(i=i.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>l0(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Gs),cn(wc),cn(yi,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),NB=(()=>{var t;class e{constructor(n,r,i,a){this.elementRef=n,this.scrollDispatcher=r,this.ngZone=i,this.dir=a,this._destroyed=new Bt,this._elementScrolled=new Ue(c=>this.ngZone.runOutsideAngular(()=>l0(this.elementRef.nativeElement,"scroll").pipe(fo(this._destroyed)).subscribe(c)))}ngOnInit(){this.scrollDispatcher.register(this)}ngOnDestroy(){this.scrollDispatcher.deregister(this),this._destroyed.next(),this._destroyed.complete()}elementScrolled(){return this._elementScrolled}getElementRef(){return this.elementRef}scrollTo(n){const r=this.elementRef.nativeElement,i=this.dir&&"rtl"==this.dir.value;null==n.left&&(n.left=i?n.end:n.start),null==n.right&&(n.right=i?n.start:n.end),null!=n.bottom&&(n.top=r.scrollHeight-r.clientHeight-n.bottom),i&&0!=iC()?(null!=n.left&&(n.right=r.scrollWidth-r.clientWidth-n.left),2==iC()?n.left=n.right:1==iC()&&(n.left=n.right?-n.right:n.right)):null!=n.right&&(n.left=r.scrollWidth-r.clientWidth-n.right),this._applyScrollToOptions(n)}_applyScrollToOptions(n){const r=this.elementRef.nativeElement;h3()?r.scrollTo(n):(null!=n.top&&(r.scrollTop=n.top),null!=n.left&&(r.scrollLeft=n.left))}measureScrollOffset(n){const r="left",i="right",a=this.elementRef.nativeElement;if("top"==n)return a.scrollTop;if("bottom"==n)return a.scrollHeight-a.clientHeight-a.scrollTop;const c=this.dir&&"rtl"==this.dir.value;return"start"==n?n=c?i:r:"end"==n&&(n=c?r:i),c&&2==iC()?n==r?a.scrollWidth-a.clientWidth-a.scrollLeft:a.scrollLeft:c&&1==iC()?n==r?a.scrollLeft+a.scrollWidth-a.clientWidth:-a.scrollLeft:n==r?a.scrollLeft:a.scrollWidth-a.clientWidth-a.scrollLeft}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Tb),lt(Gs),lt(td,8))},t.\u0275dir=Gn({type:t,selectors:[["","cdk-scrollable",""],["","cdkScrollable",""]],standalone:!0}),e})(),c0=(()=>{var t;class e{constructor(n,r,i){this._platform=n,this._change=new Bt,this._changeListener=a=>{this._change.next(a)},this._document=i,r.runOutsideAngular(()=>{if(n.isBrowser){const a=this._getWindow();a.addEventListener("resize",this._changeListener),a.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const n=this._getWindow();n.removeEventListener("resize",this._changeListener),n.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const n={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),n}getViewportRect(){const n=this.getViewportScrollPosition(),{width:r,height:i}=this.getViewportSize();return{top:n.top,left:n.left,bottom:n.top+i,right:n.left+r,height:i,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const n=this._document,r=this._getWindow(),i=n.documentElement,a=i.getBoundingClientRect();return{top:-a.top||n.body.scrollTop||r.scrollY||i.scrollTop||0,left:-a.left||n.body.scrollLeft||r.scrollX||i.scrollLeft||0}}change(n=20){return n>0?this._change.pipe(vR(n)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const n=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:n.innerWidth,height:n.innerHeight}:{width:0,height:0}}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(wc),cn(Gs),cn(yi,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const MB=new Zn("VIRTUAL_SCROLLABLE");let EY=(()=>{var t;class e extends NB{constructor(n,r,i,a){super(n,r,i,a)}measureViewportSize(n){const r=this.elementRef.nativeElement;return"horizontal"===n?r.clientWidth:r.clientHeight}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Tb),lt(Gs),lt(td,8))},t.\u0275dir=Gn({type:t,features:[Ps]}),e})();const SY=typeof requestAnimationFrame<"u"?OB:_Y;let IY=(()=>{var t;class e extends EY{get orientation(){return this._orientation}set orientation(n){this._orientation!==n&&(this._orientation=n,this._calculateSpacerSize())}get appendOnly(){return this._appendOnly}set appendOnly(n){this._appendOnly=Yr(n)}constructor(n,r,i,a,c,f,g,E){super(n,f,i,c),this.elementRef=n,this._changeDetectorRef=r,this._scrollStrategy=a,this.scrollable=E,this._platform=jn(wc),this._detachedSubject=new Bt,this._renderedRangeSubject=new Bt,this._orientation="vertical",this._appendOnly=!1,this.scrolledIndexChange=new Ue(A=>this._scrollStrategy.scrolledIndexChange.subscribe(Y=>Promise.resolve().then(()=>this.ngZone.run(()=>A.next(Y))))),this.renderedRangeStream=this._renderedRangeSubject,this._totalContentSize=0,this._totalContentWidth="",this._totalContentHeight="",this._renderedRange={start:0,end:0},this._dataLength=0,this._viewportSize=0,this._renderedContentOffset=0,this._renderedContentOffsetNeedsRewrite=!1,this._isChangeDetectionPending=!1,this._runAfterChangeDetection=[],this._viewportChanges=I.EMPTY,this._viewportChanges=g.change().subscribe(()=>{this.checkViewportSize()}),this.scrollable||(this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable"),this.scrollable=this)}ngOnInit(){this._platform.isBrowser&&(this.scrollable===this&&super.ngOnInit(),this.ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>{this._measureViewportSize(),this._scrollStrategy.attach(this),this.scrollable.elementScrolled().pipe(ed(null),vR(0,SY)).subscribe(()=>this._scrollStrategy.onContentScrolled()),this._markChangeDetectionNeeded()})))}ngOnDestroy(){this.detach(),this._scrollStrategy.detach(),this._renderedRangeSubject.complete(),this._detachedSubject.complete(),this._viewportChanges.unsubscribe(),super.ngOnDestroy()}attach(n){this.ngZone.runOutsideAngular(()=>{this._forOf=n,this._forOf.dataStream.pipe(fo(this._detachedSubject)).subscribe(r=>{const i=r.length;i!==this._dataLength&&(this._dataLength=i,this._scrollStrategy.onDataLengthChanged()),this._doChangeDetection()})})}detach(){this._forOf=null,this._detachedSubject.next()}getDataLength(){return this._dataLength}getViewportSize(){return this._viewportSize}getRenderedRange(){return this._renderedRange}measureBoundingClientRectWithScrollOffset(n){return this.getElementRef().nativeElement.getBoundingClientRect()[n]}setTotalContentSize(n){this._totalContentSize!==n&&(this._totalContentSize=n,this._calculateSpacerSize(),this._markChangeDetectionNeeded())}setRenderedRange(n){(function DY(t,e){return t.start==e.start&&t.end==e.end})(this._renderedRange,n)||(this.appendOnly&&(n={start:0,end:Math.max(this._renderedRange.end,n.end)}),this._renderedRangeSubject.next(this._renderedRange=n),this._markChangeDetectionNeeded(()=>this._scrollStrategy.onContentRendered()))}getOffsetToRenderedContentStart(){return this._renderedContentOffsetNeedsRewrite?null:this._renderedContentOffset}setRenderedContentOffset(n,r="to-start"){n=this.appendOnly&&"to-start"===r?0:n;const a="horizontal"==this.orientation,c=a?"X":"Y";let g=`translate${c}(${Number((a&&this.dir&&"rtl"==this.dir.value?-1:1)*n)}px)`;this._renderedContentOffset=n,"to-end"===r&&(g+=` translate${c}(-100%)`,this._renderedContentOffsetNeedsRewrite=!0),this._renderedContentTransform!=g&&(this._renderedContentTransform=g,this._markChangeDetectionNeeded(()=>{this._renderedContentOffsetNeedsRewrite?(this._renderedContentOffset-=this.measureRenderedContentSize(),this._renderedContentOffsetNeedsRewrite=!1,this.setRenderedContentOffset(this._renderedContentOffset)):this._scrollStrategy.onRenderedOffsetChanged()}))}scrollToOffset(n,r="auto"){const i={behavior:r};"horizontal"===this.orientation?i.start=n:i.top=n,this.scrollable.scrollTo(i)}scrollToIndex(n,r="auto"){this._scrollStrategy.scrollToIndex(n,r)}measureScrollOffset(n){let r;return r=this.scrollable==this?i=>super.measureScrollOffset(i):i=>this.scrollable.measureScrollOffset(i),Math.max(0,r(n??("horizontal"===this.orientation?"start":"top"))-this.measureViewportOffset())}measureViewportOffset(n){let r;const i="left",a="right",c="rtl"==this.dir?.value;r="start"==n?c?a:i:"end"==n?c?i:a:n||("horizontal"===this.orientation?"left":"top");const f=this.scrollable.measureBoundingClientRectWithScrollOffset(r);return this.elementRef.nativeElement.getBoundingClientRect()[r]-f}measureRenderedContentSize(){const n=this._contentWrapper.nativeElement;return"horizontal"===this.orientation?n.offsetWidth:n.offsetHeight}measureRangeSize(n){return this._forOf?this._forOf.measureRangeSize(n,this.orientation):0}checkViewportSize(){this._measureViewportSize(),this._scrollStrategy.onDataLengthChanged()}_measureViewportSize(){this._viewportSize=this.scrollable.measureViewportSize(this.orientation)}_markChangeDetectionNeeded(n){n&&this._runAfterChangeDetection.push(n),this._isChangeDetectionPending||(this._isChangeDetectionPending=!0,this.ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>{this._doChangeDetection()})))}_doChangeDetection(){this._isChangeDetectionPending=!1,this._contentWrapper.nativeElement.style.transform=this._renderedContentTransform,this.ngZone.run(()=>this._changeDetectorRef.markForCheck());const n=this._runAfterChangeDetection;this._runAfterChangeDetection=[];for(const r of n)r()}_calculateSpacerSize(){this._totalContentHeight="horizontal"===this.orientation?"":`${this._totalContentSize}px`,this._totalContentWidth="horizontal"===this.orientation?`${this._totalContentSize}px`:""}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Ll),lt(Gs),lt(xY,8),lt(td,8),lt(Tb),lt(c0),lt(MB,8))},t.\u0275cmp=sr({type:t,selectors:[["cdk-virtual-scroll-viewport"]],viewQuery:function(n,r){if(1&n&&qo(vY,7),2&n){let i;Ar(i=kr())&&(r._contentWrapper=i.first)}},hostAttrs:[1,"cdk-virtual-scroll-viewport"],hostVars:4,hostBindings:function(n,r){2&n&&Ei("cdk-virtual-scroll-orientation-horizontal","horizontal"===r.orientation)("cdk-virtual-scroll-orientation-vertical","horizontal"!==r.orientation)},inputs:{orientation:"orientation",appendOnly:"appendOnly"},outputs:{scrolledIndexChange:"scrolledIndexChange"},standalone:!0,features:[vr([{provide:NB,useFactory:(s,n)=>s||n,deps:[[new wh,new R0(MB)],t]}]),Ps,Pk],ngContentSelectors:bY,decls:4,vars:4,consts:[[1,"cdk-virtual-scroll-content-wrapper"],["contentWrapper",""],[1,"cdk-virtual-scroll-spacer"]],template:function(n,r){1&n&&(Pl(),yn(0,"div",0,1),ri(2),In(),ti(3,"div",2)),2&n&&(Un(3),Ju("width",r._totalContentWidth)("height",r._totalContentHeight))},styles:["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],encapsulation:2,changeDetection:0}),e})(),Ab=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})(),bR=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[dC,Ab,dC,Ab]}),e})();const PB=h3();class AY{constructor(e,s){this._viewportRuler=e,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=s}attach(){}enable(){if(this._canBeEnabled()){const e=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=e.style.left||"",this._previousHTMLStyles.top=e.style.top||"",e.style.left=yu(-this._previousScrollPosition.left),e.style.top=yu(-this._previousScrollPosition.top),e.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const e=this._document.documentElement,n=e.style,r=this._document.body.style,i=n.scrollBehavior||"",a=r.scrollBehavior||"";this._isEnabled=!1,n.left=this._previousHTMLStyles.left,n.top=this._previousHTMLStyles.top,e.classList.remove("cdk-global-scrollblock"),PB&&(n.scrollBehavior=r.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),PB&&(n.scrollBehavior=i,r.scrollBehavior=a)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const s=this._document.body,n=this._viewportRuler.getViewportSize();return s.scrollHeight>n.height||s.scrollWidth>n.width}}class kY{constructor(e,s,n,r){this._scrollDispatcher=e,this._ngZone=s,this._viewportRuler=n,this._config=r,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(e){this._overlayRef=e}enable(){if(this._scrollSubscription)return;const e=this._scrollDispatcher.scrolled(0).pipe(tc(s=>!s||!this._overlayRef.overlayElement.contains(s.getElementRef().nativeElement)));this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=e.subscribe(()=>{const s=this._viewportRuler.getViewportScrollPosition().top;Math.abs(s-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=e.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class FB{enable(){}disable(){}attach(){}}function xR(t,e){return e.some(s=>t.bottom<s.top||t.top>s.bottom||t.right<s.left||t.left>s.right)}function LB(t,e){return e.some(s=>t.top<s.top||t.bottom>s.bottom||t.left<s.left||t.right>s.right)}class OY{constructor(e,s,n,r){this._scrollDispatcher=e,this._viewportRuler=s,this._ngZone=n,this._config=r,this._scrollSubscription=null}attach(e){this._overlayRef=e}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const s=this._overlayRef.overlayElement.getBoundingClientRect(),{width:n,height:r}=this._viewportRuler.getViewportSize();xR(s,[{width:n,height:r,bottom:r,right:n,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let RY=(()=>{var t;class e{constructor(n,r,i,a){this._scrollDispatcher=n,this._viewportRuler=r,this._ngZone=i,this.noop=()=>new FB,this.close=c=>new kY(this._scrollDispatcher,this._ngZone,this._viewportRuler,c),this.block=()=>new AY(this._viewportRuler,this._document),this.reposition=c=>new OY(this._scrollDispatcher,this._viewportRuler,this._ngZone,c),this._document=a}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Tb),cn(c0),cn(Gs),cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();class oI{constructor(e){if(this.scrollStrategy=new FB,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,e){const s=Object.keys(e);for(const n of s)void 0!==e[n]&&(this[n]=e[n])}}}class NY{constructor(e,s){this.connectionPair=e,this.scrollableViewProperties=s}}let $B=(()=>{var t;class e{constructor(n){this._attachedOverlays=[],this._document=n}ngOnDestroy(){this.detach()}add(n){this.remove(n),this._attachedOverlays.push(n)}remove(n){const r=this._attachedOverlays.indexOf(n);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),MY=(()=>{var t;class e extends $B{constructor(n,r){super(n),this._ngZone=r,this._keydownListener=i=>{const a=this._attachedOverlays;for(let c=a.length-1;c>-1;c--)if(a[c]._keydownEvents.observers.length>0){const f=a[c]._keydownEvents;this._ngZone?this._ngZone.run(()=>f.next(i)):f.next(i);break}}}add(n){super.add(n),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(Gs,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),PY=(()=>{var t;class e extends $B{constructor(n,r,i){super(n),this._platform=r,this._ngZone=i,this._cursorStyleIsSet=!1,this._pointerDownListener=a=>{this._pointerDownEventTarget=kh(a)},this._clickListener=a=>{const c=kh(a),f="click"===a.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:c;this._pointerDownEventTarget=null;const g=this._attachedOverlays.slice();for(let E=g.length-1;E>-1;E--){const A=g[E];if(A._outsidePointerEvents.observers.length<1||!A.hasAttached())continue;if(A.overlayElement.contains(c)||A.overlayElement.contains(f))break;const Y=A._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>Y.next(a)):Y.next(a)}}}add(n){if(super.add(n),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const n=this._document.body;n.removeEventListener("pointerdown",this._pointerDownListener,!0),n.removeEventListener("click",this._clickListener,!0),n.removeEventListener("auxclick",this._clickListener,!0),n.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(n.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(n){n.addEventListener("pointerdown",this._pointerDownListener,!0),n.addEventListener("click",this._clickListener,!0),n.addEventListener("auxclick",this._clickListener,!0),n.addEventListener("contextmenu",this._clickListener,!0)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(wc),cn(Gs,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),aI=(()=>{var t;class e{constructor(n,r){this._platform=r,this._document=n}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const n="cdk-overlay-container";if(this._platform.isBrowser||BO()){const i=this._document.querySelectorAll(`.${n}[platform="server"], .${n}[platform="test"]`);for(let a=0;a<i.length;a++)i[a].remove()}const r=this._document.createElement("div");r.classList.add(n),BO()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(wc))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();class EC{constructor(e,s,n,r,i,a,c,f,g,E=!1){this._portalOutlet=e,this._host=s,this._pane=n,this._config=r,this._ngZone=i,this._keyboardDispatcher=a,this._document=c,this._location=f,this._outsideClickDispatcher=g,this._animationsDisabled=E,this._backdropElement=null,this._backdropClick=new Bt,this._attachments=new Bt,this._detachments=new Bt,this._locationChanges=I.EMPTY,this._backdropClickHandler=A=>this._backdropClick.next(A),this._backdropTransitionendHandler=A=>{this._disposeBackdrop(A.target)},this._keydownEvents=new Bt,this._outsidePointerEvents=new Bt,r.scrollStrategy&&(this._scrollStrategy=r.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=r.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(e){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const s=this._portalOutlet.attach(e);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe($l(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof s?.onDestroy&&s.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),s}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const e=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),e}dispose(){const e=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,e&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(e){e!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=e,this.hasAttached()&&(e.attach(this),this.updatePosition()))}updateSize(e){this._config={...this._config,...e},this._updateElementSize()}setDirection(e){this._config={...this._config,direction:e},this._updateElementDirection()}addPanelClass(e){this._pane&&this._toggleClasses(this._pane,e,!0)}removePanelClass(e){this._pane&&this._toggleClasses(this._pane,e,!1)}getDirection(){const e=this._config.direction;return e?"string"==typeof e?e:e.value:"ltr"}updateScrollStrategy(e){e!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=e,this.hasAttached()&&(e.attach(this),e.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const e=this._pane.style;e.width=yu(this._config.width),e.height=yu(this._config.height),e.minWidth=yu(this._config.minWidth),e.minHeight=yu(this._config.minHeight),e.maxWidth=yu(this._config.maxWidth),e.maxHeight=yu(this._config.maxHeight)}_togglePointerEvents(e){this._pane.style.pointerEvents=e?"":"none"}_attachBackdrop(){const e="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(e)})}):this._backdropElement.classList.add(e)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const e=this._backdropElement;if(e){if(this._animationsDisabled)return void this._disposeBackdrop(e);e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",this._backdropTransitionendHandler)}),e.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(e)},500))}}_toggleClasses(e,s,n){const r=cC(s||[]).filter(i=>!!i);r.length&&(n?e.classList.add(...r):e.classList.remove(...r))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const e=this._ngZone.onStable.pipe(fo(ji(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),e.unsubscribe())})})}_disposeScrollStrategy(){const e=this._scrollStrategy;e&&(e.disable(),e.detach&&e.detach())}_disposeBackdrop(e){e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",this._backdropTransitionendHandler),e.remove(),this._backdropElement===e&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const BB="cdk-overlay-connected-position-bounding-box",FY=/([A-Za-z%]+)$/;class LY{get positions(){return this._preferredPositions}constructor(e,s,n,r,i){this._viewportRuler=s,this._document=n,this._platform=r,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Bt,this._resizeSubscription=I.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(e)}attach(e){this._validatePositions(),e.hostElement.classList.add(BB),this._overlayRef=e,this._boundingBox=e.hostElement,this._pane=e.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._originRect,s=this._overlayRect,n=this._viewportRect,r=this._containerRect,i=[];let a;for(let c of this._preferredPositions){let f=this._getOriginPoint(e,r,c),g=this._getOverlayPoint(f,s,c),E=this._getOverlayFit(g,s,n,c);if(E.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(c,f);this._canFitWithFlexibleDimensions(E,g,n)?i.push({position:c,origin:f,overlayRect:s,boundingBoxRect:this._calculateBoundingBoxRect(f,c)}):(!a||a.overlayFit.visibleArea<E.visibleArea)&&(a={overlayFit:E,overlayPoint:g,originPoint:f,position:c,overlayRect:s})}if(i.length){let c=null,f=-1;for(const g of i){const E=g.boundingBoxRect.width*g.boundingBoxRect.height*(g.position.weight||1);E>f&&(f=E,c=g)}return this._isPushed=!1,void this._applyPosition(c.position,c.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(a.position,a.originPoint);this._applyPosition(a.position,a.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&u0(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(BB),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const e=this._lastPosition;if(e){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const s=this._getOriginPoint(this._originRect,this._containerRect,e);this._applyPosition(e,s)}else this.apply()}withScrollableContainers(e){return this._scrollables=e,this}withPositions(e){return this._preferredPositions=e,-1===e.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(e){return this._viewportMargin=e,this}withFlexibleDimensions(e=!0){return this._hasFlexibleDimensions=e,this}withGrowAfterOpen(e=!0){return this._growAfterOpen=e,this}withPush(e=!0){return this._canPush=e,this}withLockedPosition(e=!0){return this._positionLocked=e,this}setOrigin(e){return this._origin=e,this}withDefaultOffsetX(e){return this._offsetX=e,this}withDefaultOffsetY(e){return this._offsetY=e,this}withTransformOriginOn(e){return this._transformOriginSelector=e,this}_getOriginPoint(e,s,n){let r,i;if("center"==n.originX)r=e.left+e.width/2;else{const a=this._isRtl()?e.right:e.left,c=this._isRtl()?e.left:e.right;r="start"==n.originX?a:c}return s.left<0&&(r-=s.left),i="center"==n.originY?e.top+e.height/2:"top"==n.originY?e.top:e.bottom,s.top<0&&(i-=s.top),{x:r,y:i}}_getOverlayPoint(e,s,n){let r,i;return r="center"==n.overlayX?-s.width/2:"start"===n.overlayX?this._isRtl()?-s.width:0:this._isRtl()?0:-s.width,i="center"==n.overlayY?-s.height/2:"top"==n.overlayY?0:-s.height,{x:e.x+r,y:e.y+i}}_getOverlayFit(e,s,n,r){const i=UB(s);let{x:a,y:c}=e,f=this._getOffset(r,"x"),g=this._getOffset(r,"y");f&&(a+=f),g&&(c+=g);let Y=0-c,ne=c+i.height-n.height,Ee=this._subtractOverflows(i.width,0-a,a+i.width-n.width),Ge=this._subtractOverflows(i.height,Y,ne),tt=Ee*Ge;return{visibleArea:tt,isCompletelyWithinViewport:i.width*i.height===tt,fitsInViewportVertically:Ge===i.height,fitsInViewportHorizontally:Ee==i.width}}_canFitWithFlexibleDimensions(e,s,n){if(this._hasFlexibleDimensions){const r=n.bottom-s.y,i=n.right-s.x,a=VB(this._overlayRef.getConfig().minHeight),c=VB(this._overlayRef.getConfig().minWidth);return(e.fitsInViewportVertically||null!=a&&a<=r)&&(e.fitsInViewportHorizontally||null!=c&&c<=i)}return!1}_pushOverlayOnScreen(e,s,n){if(this._previousPushAmount&&this._positionLocked)return{x:e.x+this._previousPushAmount.x,y:e.y+this._previousPushAmount.y};const r=UB(s),i=this._viewportRect,a=Math.max(e.x+r.width-i.width,0),c=Math.max(e.y+r.height-i.height,0),f=Math.max(i.top-n.top-e.y,0),g=Math.max(i.left-n.left-e.x,0);let E=0,A=0;return E=r.width<=i.width?g||-a:e.x<this._viewportMargin?i.left-n.left-e.x:0,A=r.height<=i.height?f||-c:e.y<this._viewportMargin?i.top-n.top-e.y:0,this._previousPushAmount={x:E,y:A},{x:e.x+E,y:e.y+A}}_applyPosition(e,s){if(this._setTransformOrigin(e),this._setOverlayElementStyles(s,e),this._setBoundingBoxStyles(s,e),e.panelClass&&this._addPanelClasses(e.panelClass),this._lastPosition=e,this._positionChanges.observers.length){const n=this._getScrollVisibility(),r=new NY(e,n);this._positionChanges.next(r)}this._isInitialRender=!1}_setTransformOrigin(e){if(!this._transformOriginSelector)return;const s=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,r=e.overlayY;n="center"===e.overlayX?"center":this._isRtl()?"start"===e.overlayX?"right":"left":"start"===e.overlayX?"left":"right";for(let i=0;i<s.length;i++)s[i].style.transformOrigin=`${n} ${r}`}_calculateBoundingBoxRect(e,s){const n=this._viewportRect,r=this._isRtl();let i,a,c,E,A,Y;if("top"===s.overlayY)a=e.y,i=n.height-a+this._viewportMargin;else if("bottom"===s.overlayY)c=n.height-e.y+2*this._viewportMargin,i=n.height-c+this._viewportMargin;else{const ne=Math.min(n.bottom-e.y+n.top,e.y),Ee=this._lastBoundingBoxSize.height;i=2*ne,a=e.y-ne,i>Ee&&!this._isInitialRender&&!this._growAfterOpen&&(a=e.y-Ee/2)}if("end"===s.overlayX&&!r||"start"===s.overlayX&&r)Y=n.width-e.x+this._viewportMargin,E=e.x-this._viewportMargin;else if("start"===s.overlayX&&!r||"end"===s.overlayX&&r)A=e.x,E=n.right-e.x;else{const ne=Math.min(n.right-e.x+n.left,e.x),Ee=this._lastBoundingBoxSize.width;E=2*ne,A=e.x-ne,E>Ee&&!this._isInitialRender&&!this._growAfterOpen&&(A=e.x-Ee/2)}return{top:a,left:A,bottom:c,right:Y,width:E,height:i}}_setBoundingBoxStyles(e,s){const n=this._calculateBoundingBoxRect(e,s);!this._isInitialRender&&!this._growAfterOpen&&(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const r={};if(this._hasExactPosition())r.top=r.left="0",r.bottom=r.right=r.maxHeight=r.maxWidth="",r.width=r.height="100%";else{const i=this._overlayRef.getConfig().maxHeight,a=this._overlayRef.getConfig().maxWidth;r.height=yu(n.height),r.top=yu(n.top),r.bottom=yu(n.bottom),r.width=yu(n.width),r.left=yu(n.left),r.right=yu(n.right),r.alignItems="center"===s.overlayX?"center":"end"===s.overlayX?"flex-end":"flex-start",r.justifyContent="center"===s.overlayY?"center":"bottom"===s.overlayY?"flex-end":"flex-start",i&&(r.maxHeight=yu(i)),a&&(r.maxWidth=yu(a))}this._lastBoundingBoxSize=n,u0(this._boundingBox.style,r)}_resetBoundingBoxStyles(){u0(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){u0(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(e,s){const n={},r=this._hasExactPosition(),i=this._hasFlexibleDimensions,a=this._overlayRef.getConfig();if(r){const E=this._viewportRuler.getViewportScrollPosition();u0(n,this._getExactOverlayY(s,e,E)),u0(n,this._getExactOverlayX(s,e,E))}else n.position="static";let c="",f=this._getOffset(s,"x"),g=this._getOffset(s,"y");f&&(c+=`translateX(${f}px) `),g&&(c+=`translateY(${g}px)`),n.transform=c.trim(),a.maxHeight&&(r?n.maxHeight=yu(a.maxHeight):i&&(n.maxHeight="")),a.maxWidth&&(r?n.maxWidth=yu(a.maxWidth):i&&(n.maxWidth="")),u0(this._pane.style,n)}_getExactOverlayY(e,s,n){let r={top:"",bottom:""},i=this._getOverlayPoint(s,this._overlayRect,e);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n)),"bottom"===e.overlayY?r.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":r.top=yu(i.y),r}_getExactOverlayX(e,s,n){let a,r={left:"",right:""},i=this._getOverlayPoint(s,this._overlayRect,e);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n)),a=this._isRtl()?"end"===e.overlayX?"left":"right":"end"===e.overlayX?"right":"left","right"===a?r.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":r.left=yu(i.x),r}_getScrollVisibility(){const e=this._getOriginRect(),s=this._pane.getBoundingClientRect(),n=this._scrollables.map(r=>r.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:LB(e,n),isOriginOutsideView:xR(e,n),isOverlayClipped:LB(s,n),isOverlayOutsideView:xR(s,n)}}_subtractOverflows(e,...s){return s.reduce((n,r)=>n-Math.max(r,0),e)}_getNarrowedViewportRect(){const e=this._document.documentElement.clientWidth,s=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+e-this._viewportMargin,bottom:n.top+s-this._viewportMargin,width:e-2*this._viewportMargin,height:s-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(e,s){return"x"===s?null==e.offsetX?this._offsetX:e.offsetX:null==e.offsetY?this._offsetY:e.offsetY}_validatePositions(){}_addPanelClasses(e){this._pane&&cC(e).forEach(s=>{""!==s&&-1===this._appliedPanelClasses.indexOf(s)&&(this._appliedPanelClasses.push(s),this._pane.classList.add(s))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(e=>{this._pane.classList.remove(e)}),this._appliedPanelClasses=[])}_getOriginRect(){const e=this._origin;if(e instanceof yr)return e.nativeElement.getBoundingClientRect();if(e instanceof Element)return e.getBoundingClientRect();const s=e.width||0,n=e.height||0;return{top:e.y,bottom:e.y+n,left:e.x,right:e.x+s,height:n,width:s}}}function u0(t,e){for(let s in e)e.hasOwnProperty(s)&&(t[s]=e[s]);return t}function VB(t){if("number"!=typeof t&&null!=t){const[e,s]=t.split(FY);return s&&"px"!==s?null:parseFloat(e)}return t||null}function UB(t){return{top:Math.floor(t.top),right:Math.floor(t.right),bottom:Math.floor(t.bottom),left:Math.floor(t.left),width:Math.floor(t.width),height:Math.floor(t.height)}}const zB="cdk-global-overlay-wrapper";class $Y{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(e){const s=e.getConfig();this._overlayRef=e,this._width&&!s.width&&e.updateSize({width:this._width}),this._height&&!s.height&&e.updateSize({height:this._height}),e.hostElement.classList.add(zB),this._isDisposed=!1}top(e=""){return this._bottomOffset="",this._topOffset=e,this._alignItems="flex-start",this}left(e=""){return this._xOffset=e,this._xPosition="left",this}bottom(e=""){return this._topOffset="",this._bottomOffset=e,this._alignItems="flex-end",this}right(e=""){return this._xOffset=e,this._xPosition="right",this}start(e=""){return this._xOffset=e,this._xPosition="start",this}end(e=""){return this._xOffset=e,this._xPosition="end",this}width(e=""){return this._overlayRef?this._overlayRef.updateSize({width:e}):this._width=e,this}height(e=""){return this._overlayRef?this._overlayRef.updateSize({height:e}):this._height=e,this}centerHorizontally(e=""){return this.left(e),this._xPosition="center",this}centerVertically(e=""){return this.top(e),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const e=this._overlayRef.overlayElement.style,s=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:r,height:i,maxWidth:a,maxHeight:c}=n,f=!("100%"!==r&&"100vw"!==r||a&&"100%"!==a&&"100vw"!==a),g=!("100%"!==i&&"100vh"!==i||c&&"100%"!==c&&"100vh"!==c),E=this._xPosition,A=this._xOffset,Y="rtl"===this._overlayRef.getConfig().direction;let ne="",Ee="",Ge="";f?Ge="flex-start":"center"===E?(Ge="center",Y?Ee=A:ne=A):Y?"left"===E||"end"===E?(Ge="flex-end",ne=A):("right"===E||"start"===E)&&(Ge="flex-start",Ee=A):"left"===E||"start"===E?(Ge="flex-start",ne=A):("right"===E||"end"===E)&&(Ge="flex-end",Ee=A),e.position=this._cssPosition,e.marginLeft=f?"0":ne,e.marginTop=g?"0":this._topOffset,e.marginBottom=this._bottomOffset,e.marginRight=f?"0":Ee,s.justifyContent=Ge,s.alignItems=g?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const e=this._overlayRef.overlayElement.style,s=this._overlayRef.hostElement,n=s.style;s.classList.remove(zB),n.justifyContent=n.alignItems=e.marginTop=e.marginBottom=e.marginLeft=e.marginRight=e.position="",this._overlayRef=null,this._isDisposed=!0}}let BY=(()=>{var t;class e{constructor(n,r,i,a){this._viewportRuler=n,this._document=r,this._platform=i,this._overlayContainer=a}global(){return new $Y}flexibleConnectedTo(n){return new LY(n,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(c0),cn(yi),cn(wc),cn(aI))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),VY=0,fp=(()=>{var t;class e{constructor(n,r,i,a,c,f,g,E,A,Y,ne,Ee){this.scrollStrategies=n,this._overlayContainer=r,this._componentFactoryResolver=i,this._positionBuilder=a,this._keyboardDispatcher=c,this._injector=f,this._ngZone=g,this._document=E,this._directionality=A,this._location=Y,this._outsideClickDispatcher=ne,this._animationsModuleType=Ee}create(n){const r=this._createHostElement(),i=this._createPaneElement(r),a=this._createPortalOutlet(i),c=new oI(n);return c.direction=c.direction||this._directionality.value,new EC(a,r,i,c,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(n){const r=this._document.createElement("div");return r.id="cdk-overlay-"+VY++,r.classList.add("cdk-overlay-pane"),n.appendChild(r),r}_createHostElement(){const n=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(n),n}_createPortalOutlet(n){return this._appRef||(this._appRef=this._injector.get(i_)),new xX(n,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(RY),cn(aI),cn(lc),cn(BY),cn(MY),cn(Wc),cn(Gs),cn(yi),cn(td),cn(Aw),cn(PY),cn(ac,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const UY=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom"},{originX:"end",originY:"top",overlayX:"end",overlayY:"bottom"},{originX:"end",originY:"bottom",overlayX:"end",overlayY:"top"}],WB=new Zn("cdk-connected-overlay-scroll-strategy");let wR=(()=>{var t;class e{constructor(n){this.elementRef=n}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["","cdk-overlay-origin",""],["","overlay-origin",""],["","cdkOverlayOrigin",""]],exportAs:["cdkOverlayOrigin"],standalone:!0}),e})(),HB=(()=>{var t;class e{get offsetX(){return this._offsetX}set offsetX(n){this._offsetX=n,this._position&&this._updatePositionStrategy(this._position)}get offsetY(){return this._offsetY}set offsetY(n){this._offsetY=n,this._position&&this._updatePositionStrategy(this._position)}get hasBackdrop(){return this._hasBackdrop}set hasBackdrop(n){this._hasBackdrop=Yr(n)}get lockPosition(){return this._lockPosition}set lockPosition(n){this._lockPosition=Yr(n)}get flexibleDimensions(){return this._flexibleDimensions}set flexibleDimensions(n){this._flexibleDimensions=Yr(n)}get growAfterOpen(){return this._growAfterOpen}set growAfterOpen(n){this._growAfterOpen=Yr(n)}get push(){return this._push}set push(n){this._push=Yr(n)}constructor(n,r,i,a,c){this._overlay=n,this._dir=c,this._hasBackdrop=!1,this._lockPosition=!1,this._growAfterOpen=!1,this._flexibleDimensions=!1,this._push=!1,this._backdropSubscription=I.EMPTY,this._attachSubscription=I.EMPTY,this._detachSubscription=I.EMPTY,this._positionSubscription=I.EMPTY,this.viewportMargin=0,this.open=!1,this.disableClose=!1,this.backdropClick=new Rr,this.positionChange=new Rr,this.attach=new Rr,this.detach=new Rr,this.overlayKeydown=new Rr,this.overlayOutsideClick=new Rr,this._templatePortal=new xC(r,i),this._scrollStrategyFactory=a,this.scrollStrategy=this._scrollStrategyFactory()}get overlayRef(){return this._overlayRef}get dir(){return this._dir?this._dir.value:"ltr"}ngOnDestroy(){this._attachSubscription.unsubscribe(),this._detachSubscription.unsubscribe(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this._overlayRef&&this._overlayRef.dispose()}ngOnChanges(n){this._position&&(this._updatePositionStrategy(this._position),this._overlayRef.updateSize({width:this.width,minWidth:this.minWidth,height:this.height,minHeight:this.minHeight}),n.origin&&this.open&&this._position.apply()),n.open&&(this.open?this._attachOverlay():this._detachOverlay())}_createOverlay(){(!this.positions||!this.positions.length)&&(this.positions=UY);const n=this._overlayRef=this._overlay.create(this._buildConfig());this._attachSubscription=n.attachments().subscribe(()=>this.attach.emit()),this._detachSubscription=n.detachments().subscribe(()=>this.detach.emit()),n.keydownEvents().subscribe(r=>{this.overlayKeydown.next(r),27===r.keyCode&&!this.disableClose&&!lh(r)&&(r.preventDefault(),this._detachOverlay())}),this._overlayRef.outsidePointerEvents().subscribe(r=>{this.overlayOutsideClick.next(r)})}_buildConfig(){const n=this._position=this.positionStrategy||this._createPositionStrategy(),r=new oI({direction:this._dir,positionStrategy:n,scrollStrategy:this.scrollStrategy,hasBackdrop:this.hasBackdrop});return(this.width||0===this.width)&&(r.width=this.width),(this.height||0===this.height)&&(r.height=this.height),(this.minWidth||0===this.minWidth)&&(r.minWidth=this.minWidth),(this.minHeight||0===this.minHeight)&&(r.minHeight=this.minHeight),this.backdropClass&&(r.backdropClass=this.backdropClass),this.panelClass&&(r.panelClass=this.panelClass),r}_updatePositionStrategy(n){const r=this.positions.map(i=>({originX:i.originX,originY:i.originY,overlayX:i.overlayX,overlayY:i.overlayY,offsetX:i.offsetX||this.offsetX,offsetY:i.offsetY||this.offsetY,panelClass:i.panelClass||void 0}));return n.setOrigin(this._getFlexibleConnectedPositionStrategyOrigin()).withPositions(r).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector)}_createPositionStrategy(){const n=this._overlay.position().flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin());return this._updatePositionStrategy(n),n}_getFlexibleConnectedPositionStrategyOrigin(){return this.origin instanceof wR?this.origin.elementRef:this.origin}_attachOverlay(){this._overlayRef?this._overlayRef.getConfig().hasBackdrop=this.hasBackdrop:this._createOverlay(),this._overlayRef.hasAttached()||this._overlayRef.attach(this._templatePortal),this.hasBackdrop?this._backdropSubscription=this._overlayRef.backdropClick().subscribe(n=>{this.backdropClick.emit(n)}):this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this.positionChange.observers.length>0&&(this._positionSubscription=this._position.positionChanges.pipe(function TY(t,e=!1){return Dn((s,n)=>{let r=0;s.subscribe(ps(n,i=>{const a=t(i,r++);(a||e)&&n.next(i),!a&&n.complete()}))})}(()=>this.positionChange.observers.length>0)).subscribe(n=>{this.positionChange.emit(n),0===this.positionChange.observers.length&&this._positionSubscription.unsubscribe()}))}_detachOverlay(){this._overlayRef&&this._overlayRef.detach(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe()}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(fp),lt(Hc),lt(jc),lt(WB),lt(td,8))},t.\u0275dir=Gn({type:t,selectors:[["","cdk-connected-overlay",""],["","connected-overlay",""],["","cdkConnectedOverlay",""]],inputs:{origin:["cdkConnectedOverlayOrigin","origin"],positions:["cdkConnectedOverlayPositions","positions"],positionStrategy:["cdkConnectedOverlayPositionStrategy","positionStrategy"],offsetX:["cdkConnectedOverlayOffsetX","offsetX"],offsetY:["cdkConnectedOverlayOffsetY","offsetY"],width:["cdkConnectedOverlayWidth","width"],height:["cdkConnectedOverlayHeight","height"],minWidth:["cdkConnectedOverlayMinWidth","minWidth"],minHeight:["cdkConnectedOverlayMinHeight","minHeight"],backdropClass:["cdkConnectedOverlayBackdropClass","backdropClass"],panelClass:["cdkConnectedOverlayPanelClass","panelClass"],viewportMargin:["cdkConnectedOverlayViewportMargin","viewportMargin"],scrollStrategy:["cdkConnectedOverlayScrollStrategy","scrollStrategy"],open:["cdkConnectedOverlayOpen","open"],disableClose:["cdkConnectedOverlayDisableClose","disableClose"],transformOriginSelector:["cdkConnectedOverlayTransformOriginOn","transformOriginSelector"],hasBackdrop:["cdkConnectedOverlayHasBackdrop","hasBackdrop"],lockPosition:["cdkConnectedOverlayLockPosition","lockPosition"],flexibleDimensions:["cdkConnectedOverlayFlexibleDimensions","flexibleDimensions"],growAfterOpen:["cdkConnectedOverlayGrowAfterOpen","growAfterOpen"],push:["cdkConnectedOverlayPush","push"]},outputs:{backdropClick:"backdropClick",positionChange:"positionChange",attach:"attach",detach:"detach",overlayKeydown:"overlayKeydown",overlayOutsideClick:"overlayOutsideClick"},exportAs:["cdkConnectedOverlay"],standalone:!0,features:[Ia]}),e})();const WY={provide:WB,deps:[fp],useFactory:function zY(t){return()=>t.scrollStrategies.reposition()}};let DC=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[fp,WY],imports:[dC,wC,bR,bR]}),e})();class HY extends Bt{constructor(e=1/0,s=1/0,n=zO){super(),this._bufferSize=e,this._windowTime=s,this._timestampProvider=n,this._buffer=[],this._infiniteTimeWindow=!0,this._infiniteTimeWindow=s===1/0,this._bufferSize=Math.max(1,e),this._windowTime=Math.max(1,s)}next(e){const{isStopped:s,_buffer:n,_infiniteTimeWindow:r,_timestampProvider:i,_windowTime:a}=this;s||(n.push(e),!r&&n.push(i.now()+a)),this._trimBuffer(),super.next(e)}_subscribe(e){this._throwIfClosed(),this._trimBuffer();const s=this._innerSubscribe(e),{_infiniteTimeWindow:n,_buffer:r}=this,i=r.slice();for(let a=0;a<i.length&&!e.closed;a+=n?1:2)e.next(i[a]);return this._checkFinalizedStatuses(e),s}_trimBuffer(){const{_bufferSize:e,_timestampProvider:s,_buffer:n,_infiniteTimeWindow:r}=this,i=(r?1:2)*e;if(e<1/0&&i<n.length&&n.splice(0,n.length-i),!r){const a=s.now();let c=0;for(let f=1;f<n.length&&n[f]<=a;f+=2)c=f;c&&n.splice(0,c+1)}}}class GY{constructor(e){this._box=e,this._destroyed=new Bt,this._resizeSubject=new Bt,this._elementObservables=new Map,typeof ResizeObserver<"u"&&(this._resizeObserver=new ResizeObserver(s=>this._resizeSubject.next(s)))}observe(e){return this._elementObservables.has(e)||this._elementObservables.set(e,new Ue(s=>{const n=this._resizeSubject.subscribe(s);return this._resizeObserver?.observe(e,{box:this._box}),()=>{this._resizeObserver?.unobserve(e),n.unsubscribe(),this._elementObservables.delete(e)}}).pipe(tc(s=>s.some(n=>n.target===e)),function jY(t,e,s){let n,r=!1;return t&&"object"==typeof t?({bufferSize:n=1/0,windowTime:e=1/0,refCount:r=!1,scheduler:s}=t):n=t??1/0,ro({connector:()=>new HY(n,e,s),resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:r})}({bufferSize:1,refCount:!0}),fo(this._destroyed))),this._elementObservables.get(e)}destroy(){this._destroyed.next(),this._destroyed.complete(),this._resizeSubject.complete(),this._elementObservables.clear()}}let KY=(()=>{var t;class e{constructor(){this._observers=new Map,this._ngZone=jn(Gs)}ngOnDestroy(){for(const[,n]of this._observers)n.destroy();this._observers.clear()}observe(n,r){const i=r?.box||"content-box";return this._observers.has(i)||this._observers.set(i,new GY(i)),this._observers.get(i).observe(n)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const XY=["notch"],YY=["matFormFieldNotchedOutline",""],ZY=["*"],QY=["textField"],JY=["iconPrefixContainer"],qY=["textPrefixContainer"];function eZ(t,e){1&t&&ti(0,"span",19)}function tZ(t,e){if(1&t&&(yn(0,"label",17),ri(1,1),Fs(2,eZ,1,0,"span",18),In()),2&t){const s=bs(2);Yn("floating",s._shouldLabelFloat())("monitorResize",s._hasOutline())("id",s._labelId),si("for",s._control.id),Un(2),Yn("ngIf",!s.hideRequiredMarker&&s._control.required)}}function nZ(t,e){1&t&&Fs(0,tZ,3,5,"label",16),2&t&&Yn("ngIf",bs()._hasFloatingLabel())}function sZ(t,e){1&t&&ti(0,"div",20)}function rZ(t,e){}function iZ(t,e){1&t&&Fs(0,rZ,0,0,"ng-template",22),2&t&&(bs(2),Yn("ngTemplateOutlet",zp(1)))}function oZ(t,e){if(1&t&&(yn(0,"div",21),Fs(1,iZ,1,1,"ng-template",9),In()),2&t){const s=bs();Yn("matFormFieldNotchedOutlineOpen",s._shouldLabelFloat()),Un(1),Yn("ngIf",!s._forceDisplayInfixLabel())}}function aZ(t,e){1&t&&(yn(0,"div",23,24),ri(2,2),In())}function lZ(t,e){1&t&&(yn(0,"div",25,26),ri(2,3),In())}function cZ(t,e){}function uZ(t,e){1&t&&Fs(0,cZ,0,0,"ng-template",22),2&t&&(bs(),Yn("ngTemplateOutlet",zp(1)))}function dZ(t,e){1&t&&(yn(0,"div",27),ri(1,4),In())}function hZ(t,e){1&t&&(yn(0,"div",28),ri(1,5),In())}function pZ(t,e){1&t&&ti(0,"div",29)}function fZ(t,e){1&t&&(yn(0,"div",30),ri(1,6),In()),2&t&&Yn("@transitionMessages",bs()._subscriptAnimationState)}function mZ(t,e){if(1&t&&(yn(0,"mat-hint",34),Ys(1),In()),2&t){const s=bs(2);Yn("id",s._hintLabelId),Un(1),zu(s.hintLabel)}}function gZ(t,e){if(1&t&&(yn(0,"div",31),Fs(1,mZ,2,2,"mat-hint",32),ri(2,7),ti(3,"div",33),ri(4,8),In()),2&t){const s=bs();Yn("@transitionMessages",s._subscriptAnimationState),Un(1),Yn("ngIf",s.hintLabel)}}const _Z=["*",[["mat-label"]],[["","matPrefix",""],["","matIconPrefix",""]],[["","matTextPrefix",""]],[["","matTextSuffix",""]],[["","matSuffix",""],["","matIconSuffix",""]],[["mat-error"],["","matError",""]],[["mat-hint",3,"align","end"]],[["mat-hint","align","end"]]],yZ=["*","mat-label","[matPrefix], [matIconPrefix]","[matTextPrefix]","[matTextSuffix]","[matSuffix], [matIconSuffix]","mat-error, [matError]","mat-hint:not([align='end'])","mat-hint[align='end']"];let CR=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-label"]]}),e})();const vZ=new Zn("MatError");let bZ=0,jB=(()=>{var t;class e{constructor(){this.align="start",this.id="mat-mdc-hint-"+bZ++}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t,selectors:[["mat-hint"]],hostAttrs:[1,"mat-mdc-form-field-hint","mat-mdc-form-field-bottom-align"],hostVars:4,hostBindings:function(n,r){2&n&&(ih("id",r.id),si("align",null),Ei("mat-mdc-form-field-hint-end","end"===r.align))},inputs:{align:"align",id:"id"}}),e})();const xZ=new Zn("MatPrefix"),wZ=new Zn("MatSuffix"),GB=new Zn("FloatingLabelParent");let KB=(()=>{var t;class e{get floating(){return this._floating}set floating(n){this._floating=n,this.monitorResize&&this._handleResize()}get monitorResize(){return this._monitorResize}set monitorResize(n){this._monitorResize=n,this._monitorResize?this._subscribeToResize():this._resizeSubscription.unsubscribe()}constructor(n){this._elementRef=n,this._floating=!1,this._monitorResize=!1,this._resizeObserver=jn(KY),this._ngZone=jn(Gs),this._parent=jn(GB),this._resizeSubscription=new I}ngOnDestroy(){this._resizeSubscription.unsubscribe()}getWidth(){return function CZ(t){if(null!==t.offsetParent)return t.scrollWidth;const s=t.cloneNode(!0);s.style.setProperty("position","absolute"),s.style.setProperty("transform","translate(-9999px, -9999px)"),document.documentElement.appendChild(s);const n=s.scrollWidth;return s.remove(),n}(this._elementRef.nativeElement)}get element(){return this._elementRef.nativeElement}_handleResize(){setTimeout(()=>this._parent._handleLabelResized())}_subscribeToResize(){this._resizeSubscription.unsubscribe(),this._ngZone.runOutsideAngular(()=>{this._resizeSubscription=this._resizeObserver.observe(this._elementRef.nativeElement,{box:"border-box"}).subscribe(()=>this._handleResize())})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["label","matFormFieldFloatingLabel",""]],hostAttrs:[1,"mdc-floating-label","mat-mdc-floating-label"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("mdc-floating-label--float-above",r.floating)},inputs:{floating:"floating",monitorResize:"monitorResize"}}),e})();const XB="mdc-line-ripple--active",lI="mdc-line-ripple--deactivating";let YB=(()=>{var t;class e{constructor(n,r){this._elementRef=n,this._handleTransitionEnd=i=>{const a=this._elementRef.nativeElement.classList,c=a.contains(lI);"opacity"===i.propertyName&&c&&a.remove(XB,lI)},r.runOutsideAngular(()=>{n.nativeElement.addEventListener("transitionend",this._handleTransitionEnd)})}activate(){const n=this._elementRef.nativeElement.classList;n.remove(lI),n.add(XB)}deactivate(){this._elementRef.nativeElement.classList.add(lI)}ngOnDestroy(){this._elementRef.nativeElement.removeEventListener("transitionend",this._handleTransitionEnd)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Gs))},t.\u0275dir=Gn({type:t,selectors:[["div","matFormFieldLineRipple",""]],hostAttrs:[1,"mdc-line-ripple"]}),e})(),ZB=(()=>{var t;class e{constructor(n,r){this._elementRef=n,this._ngZone=r,this.open=!1}ngAfterViewInit(){const n=this._elementRef.nativeElement.querySelector(".mdc-floating-label");n?(this._elementRef.nativeElement.classList.add("mdc-notched-outline--upgraded"),"function"==typeof requestAnimationFrame&&(n.style.transitionDuration="0s",this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>n.style.transitionDuration="")}))):this._elementRef.nativeElement.classList.add("mdc-notched-outline--no-label")}_setNotchWidth(n){this._notch.nativeElement.style.width=this.open&&n?`calc(${n}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + 9px)`:""}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Gs))},t.\u0275cmp=sr({type:t,selectors:[["div","matFormFieldNotchedOutline",""]],viewQuery:function(n,r){if(1&n&&qo(XY,5),2&n){let i;Ar(i=kr())&&(r._notch=i.first)}},hostAttrs:[1,"mdc-notched-outline"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("mdc-notched-outline--notched",r.open)},inputs:{open:["matFormFieldNotchedOutlineOpen","open"]},attrs:YY,ngContentSelectors:ZY,decls:5,vars:0,consts:[[1,"mdc-notched-outline__leading"],[1,"mdc-notched-outline__notch"],["notch",""],[1,"mdc-notched-outline__trailing"]],template:function(n,r){1&n&&(Pl(),ti(0,"div",0),yn(1,"div",1,2),ri(3),In(),ti(4,"div",3))},encapsulation:2,changeDetection:0}),e})();const EZ={transitionMessages:nd("transitionMessages",[Vl("enter",Mi({opacity:1,transform:"translateY(0%)"})),sc("void => enter",[Mi({opacity:0,transform:"translateY(-5px)"}),nc("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])])};let cI=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275dir=Gn({type:t}),e})();const SC=new Zn("MatFormField"),DZ=new Zn("MAT_FORM_FIELD_DEFAULT_OPTIONS");let QB=0,eV=(()=>{var t;class e{get hideRequiredMarker(){return this._hideRequiredMarker}set hideRequiredMarker(n){this._hideRequiredMarker=Yr(n)}get floatLabel(){return this._floatLabel||this._defaults?.floatLabel||"auto"}set floatLabel(n){n!==this._floatLabel&&(this._floatLabel=n,this._changeDetectorRef.markForCheck())}get appearance(){return this._appearance}set appearance(n){const r=this._appearance;this._appearance=n||this._defaults?.appearance||"fill","outline"===this._appearance&&this._appearance!==r&&(this._needsOutlineLabelOffsetUpdateOnStable=!0)}get subscriptSizing(){return this._subscriptSizing||this._defaults?.subscriptSizing||"fixed"}set subscriptSizing(n){this._subscriptSizing=n||this._defaults?.subscriptSizing||"fixed"}get hintLabel(){return this._hintLabel}set hintLabel(n){this._hintLabel=n,this._processHints()}get _control(){return this._explicitFormFieldControl||this._formFieldControl}set _control(n){this._explicitFormFieldControl=n}constructor(n,r,i,a,c,f,g,E){this._elementRef=n,this._changeDetectorRef=r,this._ngZone=i,this._dir=a,this._platform=c,this._defaults=f,this._animationMode=g,this._hideRequiredMarker=!1,this.color="primary",this._appearance="fill",this._subscriptSizing=null,this._hintLabel="",this._hasIconPrefix=!1,this._hasTextPrefix=!1,this._hasIconSuffix=!1,this._hasTextSuffix=!1,this._labelId="mat-mdc-form-field-label-"+QB++,this._hintLabelId="mat-mdc-hint-"+QB++,this._subscriptAnimationState="",this._destroyed=new Bt,this._isFocused=null,this._needsOutlineLabelOffsetUpdateOnStable=!1,f&&(f.appearance&&(this.appearance=f.appearance),this._hideRequiredMarker=!!f?.hideRequiredMarker,f.color&&(this.color=f.color))}ngAfterViewInit(){this._updateFocusState(),this._subscriptAnimationState="enter",this._changeDetectorRef.detectChanges()}ngAfterContentInit(){this._assertFormFieldControl(),this._initializeControl(),this._initializeSubscript(),this._initializePrefixAndSuffix(),this._initializeOutlineLabelOffsetSubscriptions()}ngAfterContentChecked(){this._assertFormFieldControl()}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete()}getLabelId(){return this._hasFloatingLabel()?this._labelId:null}getConnectedOverlayOrigin(){return this._textField||this._elementRef}_animateAndLockLabel(){this._hasFloatingLabel()&&(this.floatLabel="always")}_initializeControl(){const n=this._control;n.controlType&&this._elementRef.nativeElement.classList.add(`mat-mdc-form-field-type-${n.controlType}`),n.stateChanges.subscribe(()=>{this._updateFocusState(),this._syncDescribedByIds(),this._changeDetectorRef.markForCheck()}),n.ngControl&&n.ngControl.valueChanges&&n.ngControl.valueChanges.pipe(fo(this._destroyed)).subscribe(()=>this._changeDetectorRef.markForCheck())}_checkPrefixAndSuffixTypes(){this._hasIconPrefix=!!this._prefixChildren.find(n=>!n._isText),this._hasTextPrefix=!!this._prefixChildren.find(n=>n._isText),this._hasIconSuffix=!!this._suffixChildren.find(n=>!n._isText),this._hasTextSuffix=!!this._suffixChildren.find(n=>n._isText)}_initializePrefixAndSuffix(){this._checkPrefixAndSuffixTypes(),ji(this._prefixChildren.changes,this._suffixChildren.changes).subscribe(()=>{this._checkPrefixAndSuffixTypes(),this._changeDetectorRef.markForCheck()})}_initializeSubscript(){this._hintChildren.changes.subscribe(()=>{this._processHints(),this._changeDetectorRef.markForCheck()}),this._errorChildren.changes.subscribe(()=>{this._syncDescribedByIds(),this._changeDetectorRef.markForCheck()}),this._validateHints(),this._syncDescribedByIds()}_assertFormFieldControl(){}_updateFocusState(){this._control.focused&&!this._isFocused?(this._isFocused=!0,this._lineRipple?.activate()):!this._control.focused&&(this._isFocused||null===this._isFocused)&&(this._isFocused=!1,this._lineRipple?.deactivate()),this._textField?.nativeElement.classList.toggle("mdc-text-field--focused",this._control.focused)}_initializeOutlineLabelOffsetSubscriptions(){this._prefixChildren.changes.subscribe(()=>this._needsOutlineLabelOffsetUpdateOnStable=!0),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.pipe(fo(this._destroyed)).subscribe(()=>{this._needsOutlineLabelOffsetUpdateOnStable&&(this._needsOutlineLabelOffsetUpdateOnStable=!1,this._updateOutlineLabelOffset())})}),this._dir.change.pipe(fo(this._destroyed)).subscribe(()=>this._needsOutlineLabelOffsetUpdateOnStable=!0)}_shouldAlwaysFloat(){return"always"===this.floatLabel}_hasOutline(){return"outline"===this.appearance}_forceDisplayInfixLabel(){return!this._platform.isBrowser&&this._prefixChildren.length&&!this._shouldLabelFloat()}_hasFloatingLabel(){return!!this._labelChildNonStatic||!!this._labelChildStatic}_shouldLabelFloat(){return this._control.shouldLabelFloat||this._shouldAlwaysFloat()}_shouldForward(n){const r=this._control?this._control.ngControl:null;return r&&r[n]}_getDisplayedMessages(){return this._errorChildren&&this._errorChildren.length>0&&this._control.errorState?"error":"hint"}_handleLabelResized(){this._refreshOutlineNotchWidth()}_refreshOutlineNotchWidth(){this._hasOutline()&&this._floatingLabel&&this._shouldLabelFloat()?this._notchedOutline?._setNotchWidth(this._floatingLabel.getWidth()):this._notchedOutline?._setNotchWidth(0)}_processHints(){this._validateHints(),this._syncDescribedByIds()}_validateHints(){}_syncDescribedByIds(){if(this._control){let n=[];if(this._control.userAriaDescribedBy&&"string"==typeof this._control.userAriaDescribedBy&&n.push(...this._control.userAriaDescribedBy.split(" ")),"hint"===this._getDisplayedMessages()){const r=this._hintChildren?this._hintChildren.find(a=>"start"===a.align):null,i=this._hintChildren?this._hintChildren.find(a=>"end"===a.align):null;r?n.push(r.id):this._hintLabel&&n.push(this._hintLabelId),i&&n.push(i.id)}else this._errorChildren&&n.push(...this._errorChildren.map(r=>r.id));this._control.setDescribedByIds(n)}}_updateOutlineLabelOffset(){if(!this._platform.isBrowser||!this._hasOutline()||!this._floatingLabel)return;const n=this._floatingLabel.element;if(!this._iconPrefixContainer&&!this._textPrefixContainer)return void(n.style.transform="");if(!this._isAttachedToDom())return void(this._needsOutlineLabelOffsetUpdateOnStable=!0);const r=this._iconPrefixContainer?.nativeElement,i=this._textPrefixContainer?.nativeElement,a=r?.getBoundingClientRect().width??0,c=i?.getBoundingClientRect().width??0;n.style.transform=`var(\n        --mat-mdc-form-field-label-transform,\n        translateY(-50%) translateX(calc(${"rtl"===this._dir.value?"-1":"1"} * (${a+c}px + var(--mat-mdc-form-field-label-offset-x, 0px))))\n    )`}_isAttachedToDom(){const n=this._elementRef.nativeElement;if(n.getRootNode){const r=n.getRootNode();return r&&r!==n}return document.documentElement.contains(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Ll),lt(Gs),lt(td),lt(wc),lt(DZ,8),lt(ac,8),lt(yi))},t.\u0275cmp=sr({type:t,selectors:[["mat-form-field"]],contentQueries:function(n,r,i){if(1&n&&(ea(i,CR,5),ea(i,CR,7),ea(i,cI,5),ea(i,xZ,5),ea(i,wZ,5),ea(i,vZ,5),ea(i,jB,5)),2&n){let a;Ar(a=kr())&&(r._labelChildNonStatic=a.first),Ar(a=kr())&&(r._labelChildStatic=a.first),Ar(a=kr())&&(r._formFieldControl=a.first),Ar(a=kr())&&(r._prefixChildren=a),Ar(a=kr())&&(r._suffixChildren=a),Ar(a=kr())&&(r._errorChildren=a),Ar(a=kr())&&(r._hintChildren=a)}},viewQuery:function(n,r){if(1&n&&(qo(QY,5),qo(JY,5),qo(qY,5),qo(KB,5),qo(ZB,5),qo(YB,5)),2&n){let i;Ar(i=kr())&&(r._textField=i.first),Ar(i=kr())&&(r._iconPrefixContainer=i.first),Ar(i=kr())&&(r._textPrefixContainer=i.first),Ar(i=kr())&&(r._floatingLabel=i.first),Ar(i=kr())&&(r._notchedOutline=i.first),Ar(i=kr())&&(r._lineRipple=i.first)}},hostAttrs:[1,"mat-mdc-form-field"],hostVars:42,hostBindings:function(n,r){2&n&&Ei("mat-mdc-form-field-label-always-float",r._shouldAlwaysFloat())("mat-mdc-form-field-has-icon-prefix",r._hasIconPrefix)("mat-mdc-form-field-has-icon-suffix",r._hasIconSuffix)("mat-form-field-invalid",r._control.errorState)("mat-form-field-disabled",r._control.disabled)("mat-form-field-autofilled",r._control.autofilled)("mat-form-field-no-animations","NoopAnimations"===r._animationMode)("mat-form-field-appearance-fill","fill"==r.appearance)("mat-form-field-appearance-outline","outline"==r.appearance)("mat-form-field-hide-placeholder",r._hasFloatingLabel()&&!r._shouldLabelFloat())("mat-focused",r._control.focused)("mat-primary","accent"!==r.color&&"warn"!==r.color)("mat-accent","accent"===r.color)("mat-warn","warn"===r.color)("ng-untouched",r._shouldForward("untouched"))("ng-touched",r._shouldForward("touched"))("ng-pristine",r._shouldForward("pristine"))("ng-dirty",r._shouldForward("dirty"))("ng-valid",r._shouldForward("valid"))("ng-invalid",r._shouldForward("invalid"))("ng-pending",r._shouldForward("pending"))},inputs:{hideRequiredMarker:"hideRequiredMarker",color:"color",floatLabel:"floatLabel",appearance:"appearance",subscriptSizing:"subscriptSizing",hintLabel:"hintLabel"},exportAs:["matFormField"],features:[vr([{provide:SC,useExisting:t},{provide:GB,useExisting:t}])],ngContentSelectors:yZ,decls:18,vars:23,consts:[["labelTemplate",""],[1,"mat-mdc-text-field-wrapper","mdc-text-field",3,"click"],["textField",""],["class","mat-mdc-form-field-focus-overlay",4,"ngIf"],[1,"mat-mdc-form-field-flex"],["matFormFieldNotchedOutline","",3,"matFormFieldNotchedOutlineOpen",4,"ngIf"],["class","mat-mdc-form-field-icon-prefix",4,"ngIf"],["class","mat-mdc-form-field-text-prefix",4,"ngIf"],[1,"mat-mdc-form-field-infix"],[3,"ngIf"],["class","mat-mdc-form-field-text-suffix",4,"ngIf"],["class","mat-mdc-form-field-icon-suffix",4,"ngIf"],["matFormFieldLineRipple","",4,"ngIf"],[1,"mat-mdc-form-field-subscript-wrapper","mat-mdc-form-field-bottom-align",3,"ngSwitch"],["class","mat-mdc-form-field-error-wrapper",4,"ngSwitchCase"],["class","mat-mdc-form-field-hint-wrapper",4,"ngSwitchCase"],["matFormFieldFloatingLabel","",3,"floating","monitorResize","id",4,"ngIf"],["matFormFieldFloatingLabel","",3,"floating","monitorResize","id"],["aria-hidden","true","class","mat-mdc-form-field-required-marker mdc-floating-label--required",4,"ngIf"],["aria-hidden","true",1,"mat-mdc-form-field-required-marker","mdc-floating-label--required"],[1,"mat-mdc-form-field-focus-overlay"],["matFormFieldNotchedOutline","",3,"matFormFieldNotchedOutlineOpen"],[3,"ngTemplateOutlet"],[1,"mat-mdc-form-field-icon-prefix"],["iconPrefixContainer",""],[1,"mat-mdc-form-field-text-prefix"],["textPrefixContainer",""],[1,"mat-mdc-form-field-text-suffix"],[1,"mat-mdc-form-field-icon-suffix"],["matFormFieldLineRipple",""],[1,"mat-mdc-form-field-error-wrapper"],[1,"mat-mdc-form-field-hint-wrapper"],[3,"id",4,"ngIf"],[1,"mat-mdc-form-field-hint-spacer"],[3,"id"]],template:function(n,r){1&n&&(Pl(_Z),Fs(0,nZ,1,1,"ng-template",null,0,Jv),yn(2,"div",1,2),qs("click",function(a){return r._control.onContainerClick(a)}),Fs(4,sZ,1,0,"div",3),yn(5,"div",4),Fs(6,oZ,2,2,"div",5),Fs(7,aZ,3,0,"div",6),Fs(8,lZ,3,0,"div",7),yn(9,"div",8),Fs(10,uZ,1,1,"ng-template",9),ri(11),In(),Fs(12,dZ,2,0,"div",10),Fs(13,hZ,2,0,"div",11),In(),Fs(14,pZ,1,0,"div",12),In(),yn(15,"div",13),Fs(16,fZ,2,1,"div",14),Fs(17,gZ,5,2,"div",15),In()),2&n&&(Un(2),Ei("mdc-text-field--filled",!r._hasOutline())("mdc-text-field--outlined",r._hasOutline())("mdc-text-field--no-label",!r._hasFloatingLabel())("mdc-text-field--disabled",r._control.disabled)("mdc-text-field--invalid",r._control.errorState),Un(2),Yn("ngIf",!r._hasOutline()&&!r._control.disabled),Un(2),Yn("ngIf",r._hasOutline()),Un(1),Yn("ngIf",r._hasIconPrefix),Un(1),Yn("ngIf",r._hasTextPrefix),Un(2),Yn("ngIf",!r._hasOutline()||r._forceDisplayInfixLabel()),Un(2),Yn("ngIf",r._hasTextSuffix),Un(1),Yn("ngIf",r._hasIconSuffix),Un(1),Yn("ngIf",!r._hasOutline()),Un(1),Ei("mat-mdc-form-field-subscript-dynamic-size","dynamic"===r.subscriptSizing),Yn("ngSwitch",r._getDisplayedMessages()),Un(1),Yn("ngSwitchCase","error"),Un(1),Yn("ngSwitchCase","hint"))},dependencies:[$d,S2,sb,KD,jB,KB,ZB,YB],styles:['.mdc-text-field{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:0;border-bottom-left-radius:0;display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-text-field__input{height:28px;width:100%;min-width:0;border:none;border-radius:0;background:none;appearance:none;padding:0}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media all{.mdc-text-field__input::placeholder{opacity:0}}@media all{.mdc-text-field__input:-ms-input-placeholder{opacity:0}}@media all{.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{opacity:1}}@media all{.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{opacity:1}}.mdc-text-field__affix{height:28px;opacity:0;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens: none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field__affix--prefix,.mdc-text-field__affix--prefix[dir=rtl]{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl]{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field__affix--suffix,.mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-text-field--filled .mdc-floating-label{left:16px;right:initial}[dir=rtl] .mdc-text-field--filled .mdc-floating-label,.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled.mdc-text-field--no-label::before{display:none}@supports(-webkit-hyphens: none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-shape-small, 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:rgba(0,0,0,0)}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{flex-direction:column;align-items:center;width:auto;height:auto;padding:0}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{flex-grow:1;height:auto;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;box-sizing:border-box;resize:none;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--filled::before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-top:23px;margin-bottom:9px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::after{display:inline-block;width:0;height:16px;content:"";vertical-align:-16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer,.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl]{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateX(1px) translateY(1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl]{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon,.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 48px);left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}[dir=rtl] .mdc-text-field--with-trailing-icon,.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 96px / 0.75)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}@media screen and (forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix{direction:ltr}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading{order:1}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{order:2}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input{order:3}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{order:4}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing{order:5}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix{padding-right:12px}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix{padding-left:2px}.mdc-floating-label{position:absolute;left:0;-webkit-transform-origin:left top;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:1px;margin-right:0px;content:"*"}[dir=rtl] .mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after,.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)[dir=rtl]::after{margin-left:0;margin-right:1px}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;pointer-events:none}.mdc-notched-outline__trailing{flex-grow:1}.mdc-notched-outline__notch{flex:0 0 auto;width:auto}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{z-index:1}.mdc-line-ripple::after{transform:scaleX(0);opacity:0;z-index:2}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-top:1px solid;border-bottom:1px solid}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{max-width:calc(100% - 12px * 2)}.mdc-line-ripple::before{border-bottom-width:1px}.mdc-line-ripple::after{border-bottom-width:2px}.mdc-text-field--filled{--mdc-filled-text-field-active-indicator-height:1px;--mdc-filled-text-field-focus-active-indicator-height:2px;--mdc-filled-text-field-container-shape:4px;border-top-left-radius:var(--mdc-filled-text-field-container-shape);border-top-right-radius:var(--mdc-filled-text-field-container-shape);border-bottom-right-radius:0;border-bottom-left-radius:0}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-caret-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-error-caret-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-filled-text-field-input-text-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-filled-text-field-disabled-input-text-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-label-text-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-focus-label-text-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-disabled-label-text-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-error-label-text-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-error-focus-label-text-color)}.mdc-text-field--filled .mdc-floating-label{font-family:var(--mdc-filled-text-field-label-text-font);font-size:var(--mdc-filled-text-field-label-text-size);font-weight:var(--mdc-filled-text-field-label-text-weight);letter-spacing:var(--mdc-filled-text-field-label-text-tracking)}@media all{.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}}@media all{.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:var(--mdc-filled-text-field-container-color)}.mdc-text-field--filled.mdc-text-field--disabled{background-color:var(--mdc-filled-text-field-disabled-container-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-active-indicator-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-hover-active-indicator-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-focus-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-disabled-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-hover-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-error-focus-active-indicator-color)}.mdc-text-field--filled .mdc-line-ripple::before{border-bottom-width:var(--mdc-filled-text-field-active-indicator-height)}.mdc-text-field--filled .mdc-line-ripple::after{border-bottom-width:var(--mdc-filled-text-field-focus-active-indicator-height)}.mdc-text-field--outlined{--mdc-outlined-text-field-outline-width:1px;--mdc-outlined-text-field-focus-outline-width:2px;--mdc-outlined-text-field-container-shape:4px}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-caret-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-error-caret-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-outlined-text-field-input-text-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-outlined-text-field-disabled-input-text-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-label-text-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-focus-label-text-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-disabled-label-text-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-error-label-text-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-error-focus-label-text-color)}.mdc-text-field--outlined .mdc-floating-label{font-family:var(--mdc-outlined-text-field-label-text-font);font-size:var(--mdc-outlined-text-field-label-text-size);font-weight:var(--mdc-outlined-text-field-label-text-weight);letter-spacing:var(--mdc-outlined-text-field-label-text-tracking)}@media all{.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color)}}@media all{.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:var(--mdc-outlined-text-field-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-outlined-text-field-container-shape))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-outlined-text-field-container-shape))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:var(--mdc-outlined-text-field-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-outlined-text-field-container-shape))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-hover-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-focus-outline-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-disabled-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-hover-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-focus-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__trailing{border-width:var(--mdc-outlined-text-field-outline-width)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__trailing{border-width:var(--mdc-outlined-text-field-focus-outline-width)}.mat-mdc-form-field-textarea-control{vertical-align:middle;resize:vertical;box-sizing:border-box;height:auto;margin:0;padding:0;border:none;overflow:auto}.mat-mdc-form-field-input-control.mat-mdc-form-field-input-control{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font:inherit;letter-spacing:inherit;text-decoration:inherit;text-transform:inherit;border:none}.mat-mdc-form-field .mat-mdc-floating-label.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;line-height:normal;pointer-events:all}.mdc-text-field--no-label:not(.mdc-text-field--textarea) .mat-mdc-form-field-input-control.mdc-text-field__input,.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control{height:auto}.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control.mdc-text-field__input[type=color]{height:23px}.mat-mdc-text-field-wrapper{height:auto;flex:auto}.mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-left:0;--mat-mdc-form-field-label-offset-x: -16px}.mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-right:0}[dir=rtl] .mat-mdc-text-field-wrapper{padding-left:16px;padding-right:16px}[dir=rtl] .mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-left:0}[dir=rtl] .mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-right:0}.mat-form-field-disabled .mdc-text-field__input::placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input::-moz-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input::-webkit-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input:-ms-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-mdc-form-field-label-always-float .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mat-mdc-text-field-wrapper .mat-mdc-form-field-infix .mat-mdc-floating-label{left:auto;right:auto}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-text-field__input{display:inline-block}.mat-mdc-form-field .mat-mdc-text-field-wrapper.mdc-text-field .mdc-notched-outline__notch{padding-top:0}.mat-mdc-text-field-wrapper::before{content:none}.mat-mdc-form-field-subscript-wrapper{box-sizing:border-box;width:100%;position:relative}.mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-error-wrapper{position:absolute;top:0;left:0;right:0;padding:0 16px}.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-error-wrapper{position:static}.mat-mdc-form-field-bottom-align::before{content:"";display:inline-block;height:16px}.mat-mdc-form-field-bottom-align.mat-mdc-form-field-subscript-dynamic-size::before{content:unset}.mat-mdc-form-field-hint-end{order:1}.mat-mdc-form-field-hint-wrapper{display:flex}.mat-mdc-form-field-hint-spacer{flex:1 0 1em}.mat-mdc-form-field-error{display:block}.mat-mdc-form-field-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;opacity:0;pointer-events:none}select.mat-mdc-form-field-input-control{-moz-appearance:none;-webkit-appearance:none;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box}select.mat-mdc-form-field-input-control:not(:disabled){cursor:pointer}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;right:0;top:50%;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{right:auto;left:0}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:15px}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:0;padding-left:15px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-mdc-text-field-wrapper{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-form-field-disabled .mat-mdc-text-field-wrapper{outline-color:GrayText}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-mdc-text-field-wrapper{outline:dashed 3px}.cdk-high-contrast-active .mat-mdc-form-field.mat-focused .mdc-notched-outline{border:dashed 3px}.mat-mdc-form-field-input-control[type=date],.mat-mdc-form-field-input-control[type=datetime],.mat-mdc-form-field-input-control[type=datetime-local],.mat-mdc-form-field-input-control[type=month],.mat-mdc-form-field-input-control[type=week],.mat-mdc-form-field-input-control[type=time]{line-height:1}.mat-mdc-form-field-input-control::-webkit-datetime-edit{line-height:1;padding:0;margin-bottom:-2px}.mat-mdc-form-field{--mat-mdc-form-field-floating-label-scale: 0.75;display:inline-flex;flex-direction:column;min-width:0;text-align:left;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-form-field-container-text-font);line-height:var(--mat-form-field-container-text-line-height);font-size:var(--mat-form-field-container-text-size);letter-spacing:var(--mat-form-field-container-text-tracking);font-weight:var(--mat-form-field-container-text-weight)}[dir=rtl] .mat-mdc-form-field{text-align:right}.mat-mdc-form-field .mdc-text-field--outlined .mdc-floating-label--float-above{font-size:calc(var(--mat-form-field-outlined-label-text-populated-size) * var(--mat-mdc-form-field-floating-label-scale))}.mat-mdc-form-field .mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:var(--mat-form-field-outlined-label-text-populated-size)}.mat-mdc-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-mdc-text-field-wrapper{width:100%}.mat-mdc-form-field-icon-prefix,.mat-mdc-form-field-icon-suffix{align-self:center;line-height:0;pointer-events:auto;position:relative;z-index:1}.mat-mdc-form-field-icon-prefix,[dir=rtl] .mat-mdc-form-field-icon-suffix{padding:0 4px 0 0}.mat-mdc-form-field-icon-suffix,[dir=rtl] .mat-mdc-form-field-icon-prefix{padding:0 0 0 4px}.mat-mdc-form-field-icon-prefix>.mat-icon,.mat-mdc-form-field-icon-suffix>.mat-icon{padding:12px;box-sizing:content-box}.mat-mdc-form-field-subscript-wrapper .mat-icon,.mat-mdc-form-field label .mat-icon{width:1em;height:1em;font-size:inherit}.mat-mdc-form-field-infix{flex:auto;min-width:0;width:180px;position:relative;box-sizing:border-box}.mat-mdc-form-field .mdc-notched-outline__notch{margin-left:-1px;-webkit-clip-path:inset(-9em -999em -9em 1px);clip-path:inset(-9em -999em -9em 1px)}[dir=rtl] .mat-mdc-form-field .mdc-notched-outline__notch{margin-left:0;margin-right:-1px;-webkit-clip-path:inset(-9em 1px -9em -999em);clip-path:inset(-9em 1px -9em -999em)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__affix{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple::before,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea{transition:none}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}[dir=rtl] .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-floating-label{transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-notched-outline .mdc-floating-label{max-width:calc(100% + 1px)}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(133.3333333333% + 1px)}'],encapsulation:2,data:{animation:[EZ.transitionMessages]},changeDetection:0}),e})(),uI=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,Ah,v3,nl]}),e})();const TZ=["trigger"],AZ=["panel"];function kZ(t,e){if(1&t&&(yn(0,"span",10),Ys(1),In()),2&t){const s=bs();Un(1),zu(s.placeholder)}}function OZ(t,e){if(1&t&&(yn(0,"span",14),Ys(1),In()),2&t){const s=bs(2);Un(1),zu(s.triggerValue)}}function RZ(t,e){1&t&&ri(0,0,["*ngSwitchCase","true"])}function NZ(t,e){1&t&&(yn(0,"span",11),Fs(1,OZ,2,1,"span",12),Fs(2,RZ,1,0,"ng-content",13),In()),2&t&&(Yn("ngSwitch",!!bs().customTrigger),Un(2),Yn("ngSwitchCase",!0))}function MZ(t,e){if(1&t){const s=iu();Gu(),Ip(),yn(0,"div",15,16),qs("@transformPanel.done",function(r){return hr(s),gs(bs()._panelDoneAnimatingStream.next(r.toState))})("keydown",function(r){return hr(s),gs(bs()._handleKeydown(r))}),ri(2,1),In()}if(2&t){const s=bs();(function eD(t,e,s){Sh(Xu,lp,Gg(Fn(),t,e,s),!0)})("mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ",s._getPanelTheme(),""),Yn("ngClass",s.panelClass)("@transformPanel","showing"),si("id",s.id+"-panel")("aria-multiselectable",s.multiple)("aria-label",s.ariaLabel||null)("aria-labelledby",s._getPanelAriaLabelledby())}}const PZ=[[["mat-select-trigger"]],"*"],FZ=["mat-select-trigger","*"],LZ={transformPanelWrap:nd("transformPanelWrap",[sc("* => void",JS("@transformPanel",[QS()],{optional:!0}))]),transformPanel:nd("transformPanel",[Vl("void",Mi({opacity:0,transform:"scale(1, 0.8)"})),sc("void => showing",nc("120ms cubic-bezier(0, 0, 0.2, 1)",Mi({opacity:1,transform:"scale(1, 1)"}))),sc("* => void",nc("100ms linear",Mi({opacity:0})))])};let tV=0;const nV=new Zn("mat-select-scroll-strategy"),BZ=new Zn("MAT_SELECT_CONFIG"),VZ={provide:nV,deps:[fp],useFactory:function $Z(t){return()=>t.scrollStrategies.reposition()}},UZ=new Zn("MatSelectTrigger");class zZ{constructor(e,s){this.source=e,this.value=s}}const WZ=BS(hC(Sb(QO(class{constructor(t,e,s,n,r){this._elementRef=t,this._defaultErrorStateMatcher=e,this._parentForm=s,this._parentFormGroup=n,this.ngControl=r,this.stateChanges=new Bt}}))));let HZ=(()=>{var t;class e extends WZ{get focused(){return this._focused||this._panelOpen}get placeholder(){return this._placeholder}set placeholder(n){this._placeholder=n,this.stateChanges.next()}get required(){return this._required??this.ngControl?.control?.hasValidator(z2.required)??!1}set required(n){this._required=Yr(n),this.stateChanges.next()}get multiple(){return this._multiple}set multiple(n){this._multiple=Yr(n)}get disableOptionCentering(){return this._disableOptionCentering}set disableOptionCentering(n){this._disableOptionCentering=Yr(n)}get compareWith(){return this._compareWith}set compareWith(n){this._compareWith=n,this._selectionModel&&this._initializeSelection()}get value(){return this._value}set value(n){this._assignValue(n)&&this._onChange(n)}get typeaheadDebounceInterval(){return this._typeaheadDebounceInterval}set typeaheadDebounceInterval(n){this._typeaheadDebounceInterval=Bl(n)}get id(){return this._id}set id(n){this._id=n||this._uid,this.stateChanges.next()}constructor(n,r,i,a,c,f,g,E,A,Y,ne,Ee,Ge,tt){super(c,a,g,E,Y),this._viewportRuler=n,this._changeDetectorRef=r,this._ngZone=i,this._dir=f,this._parentFormField=A,this._liveAnnouncer=Ge,this._defaultOptions=tt,this._panelOpen=!1,this._compareWith=(Nt,kt)=>Nt===kt,this._uid="mat-select-"+tV++,this._triggerAriaLabelledBy=null,this._destroy=new Bt,this._onChange=()=>{},this._onTouched=()=>{},this._valueId="mat-select-value-"+tV++,this._panelDoneAnimatingStream=new Bt,this._overlayPanelClass=this._defaultOptions?.overlayPanelClass||"",this._focused=!1,this.controlType="mat-select",this._multiple=!1,this._disableOptionCentering=this._defaultOptions?.disableOptionCentering??!1,this.ariaLabel="",this.optionSelectionChanges=hb(()=>{const Nt=this.options;return Nt?Nt.changes.pipe(ed(Nt),Qi(()=>ji(...Nt.map(kt=>kt.onSelectionChange)))):this._ngZone.onStable.pipe($l(1),Qi(()=>this.optionSelectionChanges))}),this.openedChange=new Rr,this._openedStream=this.openedChange.pipe(tc(Nt=>Nt),Xn(()=>{})),this._closedStream=this.openedChange.pipe(tc(Nt=>!Nt),Xn(()=>{})),this.selectionChange=new Rr,this.valueChange=new Rr,this._trackedModal=null,this.ngControl&&(this.ngControl.valueAccessor=this),null!=tt?.typeaheadDebounceInterval&&(this._typeaheadDebounceInterval=tt.typeaheadDebounceInterval),this._scrollStrategyFactory=Ee,this._scrollStrategy=this._scrollStrategyFactory(),this.tabIndex=parseInt(ne)||0,this.id=this.id}ngOnInit(){this._selectionModel=new fX(this.multiple),this.stateChanges.next(),this._panelDoneAnimatingStream.pipe(al(),fo(this._destroy)).subscribe(()=>this._panelDoneAnimating(this.panelOpen))}ngAfterContentInit(){this._initKeyManager(),this._selectionModel.changed.pipe(fo(this._destroy)).subscribe(n=>{n.added.forEach(r=>r.select()),n.removed.forEach(r=>r.deselect())}),this.options.changes.pipe(ed(null),fo(this._destroy)).subscribe(()=>{this._resetOptions(),this._initializeSelection()})}ngDoCheck(){const n=this._getTriggerAriaLabelledby(),r=this.ngControl;if(n!==this._triggerAriaLabelledBy){const i=this._elementRef.nativeElement;this._triggerAriaLabelledBy=n,n?i.setAttribute("aria-labelledby",n):i.removeAttribute("aria-labelledby")}r&&(this._previousControl!==r.control&&(void 0!==this._previousControl&&null!==r.disabled&&r.disabled!==this.disabled&&(this.disabled=r.disabled),this._previousControl=r.control),this.updateErrorState())}ngOnChanges(n){(n.disabled||n.userAriaDescribedBy)&&this.stateChanges.next(),n.typeaheadDebounceInterval&&this._keyManager&&this._keyManager.withTypeAhead(this._typeaheadDebounceInterval)}ngOnDestroy(){this._keyManager?.destroy(),this._destroy.next(),this._destroy.complete(),this.stateChanges.complete(),this._clearFromModal()}toggle(){this.panelOpen?this.close():this.open()}open(){this._canOpen()&&(this._applyModalPanelOwnership(),this._panelOpen=!0,this._keyManager.withHorizontalOrientation(null),this._highlightCorrectOption(),this._changeDetectorRef.markForCheck())}_applyModalPanelOwnership(){const n=this._elementRef.nativeElement.closest('body > .cdk-overlay-container [aria-modal="true"]');if(!n)return;const r=`${this.id}-panel`;this._trackedModal&&uC(this._trackedModal,"aria-owns",r),HO(n,"aria-owns",r),this._trackedModal=n}_clearFromModal(){this._trackedModal&&(uC(this._trackedModal,"aria-owns",`${this.id}-panel`),this._trackedModal=null)}close(){this._panelOpen&&(this._panelOpen=!1,this._keyManager.withHorizontalOrientation(this._isRtl()?"rtl":"ltr"),this._changeDetectorRef.markForCheck(),this._onTouched())}writeValue(n){this._assignValue(n)}registerOnChange(n){this._onChange=n}registerOnTouched(n){this._onTouched=n}setDisabledState(n){this.disabled=n,this._changeDetectorRef.markForCheck(),this.stateChanges.next()}get panelOpen(){return this._panelOpen}get selected(){return this.multiple?this._selectionModel?.selected||[]:this._selectionModel?.selected[0]}get triggerValue(){if(this.empty)return"";if(this._multiple){const n=this._selectionModel.selected.map(r=>r.viewValue);return this._isRtl()&&n.reverse(),n.join(", ")}return this._selectionModel.selected[0].viewValue}_isRtl(){return!!this._dir&&"rtl"===this._dir.value}_handleKeydown(n){this.disabled||(this.panelOpen?this._handleOpenKeydown(n):this._handleClosedKeydown(n))}_handleClosedKeydown(n){const r=n.keyCode,i=40===r||38===r||37===r||39===r,a=13===r||32===r,c=this._keyManager;if(!c.isTyping()&&a&&!lh(n)||(this.multiple||n.altKey)&&i)n.preventDefault(),this.open();else if(!this.multiple){const f=this.selected;c.onKeydown(n);const g=this.selected;g&&f!==g&&this._liveAnnouncer.announce(g.viewValue,1e4)}}_handleOpenKeydown(n){const r=this._keyManager,i=n.keyCode,a=40===i||38===i,c=r.isTyping();if(a&&n.altKey)n.preventDefault(),this.close();else if(c||13!==i&&32!==i||!r.activeItem||lh(n))if(!c&&this._multiple&&65===i&&n.ctrlKey){n.preventDefault();const f=this.options.some(g=>!g.disabled&&!g.selected);this.options.forEach(g=>{g.disabled||(f?g.select():g.deselect())})}else{const f=r.activeItemIndex;r.onKeydown(n),this._multiple&&a&&n.shiftKey&&r.activeItem&&r.activeItemIndex!==f&&r.activeItem._selectViaInteraction()}else n.preventDefault(),r.activeItem._selectViaInteraction()}_onFocus(){this.disabled||(this._focused=!0,this.stateChanges.next())}_onBlur(){this._focused=!1,this._keyManager?.cancelTypeahead(),!this.disabled&&!this.panelOpen&&(this._onTouched(),this._changeDetectorRef.markForCheck(),this.stateChanges.next())}_onAttached(){this._overlayDir.positionChange.pipe($l(1)).subscribe(()=>{this._changeDetectorRef.detectChanges(),this._positioningSettled()})}_getPanelTheme(){return this._parentFormField?`mat-${this._parentFormField.color}`:""}get empty(){return!this._selectionModel||this._selectionModel.isEmpty()}_initializeSelection(){Promise.resolve().then(()=>{this.ngControl&&(this._value=this.ngControl.value),this._setSelectionByValue(this._value),this.stateChanges.next()})}_setSelectionByValue(n){if(this.options.forEach(r=>r.setInactiveStyles()),this._selectionModel.clear(),this.multiple&&n)Array.isArray(n),n.forEach(r=>this._selectOptionByValue(r)),this._sortValues();else{const r=this._selectOptionByValue(n);r?this._keyManager.updateActiveItem(r):this.panelOpen||this._keyManager.updateActiveItem(-1)}this._changeDetectorRef.markForCheck()}_selectOptionByValue(n){const r=this.options.find(i=>{if(this._selectionModel.isSelected(i))return!1;try{return null!=i.value&&this._compareWith(i.value,n)}catch{return!1}});return r&&this._selectionModel.select(r),r}_assignValue(n){return!!(n!==this._value||this._multiple&&Array.isArray(n))&&(this.options&&this._setSelectionByValue(n),this._value=n,!0)}_skipPredicate(n){return n.disabled}_initKeyManager(){this._keyManager=new $7(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl()?"rtl":"ltr").withHomeAndEnd().withPageUpDown().withAllowedModifierKeys(["shiftKey"]).skipPredicate(this._skipPredicate),this._keyManager.tabOut.subscribe(()=>{this.panelOpen&&(!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction(),this.focus(),this.close())}),this._keyManager.change.subscribe(()=>{this._panelOpen&&this.panel?this._scrollOptionIntoView(this._keyManager.activeItemIndex||0):!this._panelOpen&&!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction()})}_resetOptions(){const n=ji(this.options.changes,this._destroy);this.optionSelectionChanges.pipe(fo(n)).subscribe(r=>{this._onSelect(r.source,r.isUserInput),r.isUserInput&&!this.multiple&&this._panelOpen&&(this.close(),this.focus())}),ji(...this.options.map(r=>r._stateChanges)).pipe(fo(n)).subscribe(()=>{this._changeDetectorRef.detectChanges(),this.stateChanges.next()})}_onSelect(n,r){const i=this._selectionModel.isSelected(n);null!=n.value||this._multiple?(i!==n.selected&&(n.selected?this._selectionModel.select(n):this._selectionModel.deselect(n)),r&&this._keyManager.setActiveItem(n),this.multiple&&(this._sortValues(),r&&this.focus())):(n.deselect(),this._selectionModel.clear(),null!=this.value&&this._propagateChanges(n.value)),i!==this._selectionModel.isSelected(n)&&this._propagateChanges(),this.stateChanges.next()}_sortValues(){if(this.multiple){const n=this.options.toArray();this._selectionModel.sort((r,i)=>this.sortComparator?this.sortComparator(r,i,n):n.indexOf(r)-n.indexOf(i)),this.stateChanges.next()}}_propagateChanges(n){let r=null;r=this.multiple?this.selected.map(i=>i.value):this.selected?this.selected.value:n,this._value=r,this.valueChange.emit(r),this._onChange(r),this.selectionChange.emit(this._getChangeEvent(r)),this._changeDetectorRef.markForCheck()}_highlightCorrectOption(){if(this._keyManager)if(this.empty){let n=-1;for(let r=0;r<this.options.length;r++)if(!this.options.get(r).disabled){n=r;break}this._keyManager.setActiveItem(n)}else this._keyManager.setActiveItem(this._selectionModel.selected[0])}_canOpen(){return!this._panelOpen&&!this.disabled&&this.options?.length>0}focus(n){this._elementRef.nativeElement.focus(n)}_getPanelAriaLabelledby(){if(this.ariaLabel)return null;const n=this._parentFormField?.getLabelId();return this.ariaLabelledby?(n?n+" ":"")+this.ariaLabelledby:n}_getAriaActiveDescendant(){return this.panelOpen&&this._keyManager&&this._keyManager.activeItem?this._keyManager.activeItem.id:null}_getTriggerAriaLabelledby(){if(this.ariaLabel)return null;const n=this._parentFormField?.getLabelId();let r=(n?n+" ":"")+this._valueId;return this.ariaLabelledby&&(r+=" "+this.ariaLabelledby),r}_panelDoneAnimating(n){this.openedChange.emit(n)}setDescribedByIds(n){n.length?this._elementRef.nativeElement.setAttribute("aria-describedby",n.join(" ")):this._elementRef.nativeElement.removeAttribute("aria-describedby")}onContainerClick(){this.focus(),this.open()}get shouldLabelFloat(){return this._panelOpen||!this.empty||this._focused&&!!this._placeholder}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(c0),lt(Ll),lt(Gs),lt(VS),lt(yr),lt(td,8),lt(ob,8),lt(ab,8),lt(SC,8),lt(Kp,10),na("tabindex"),lt(nV),lt(s9),lt(BZ,8))},t.\u0275dir=Gn({type:t,viewQuery:function(n,r){if(1&n&&(qo(TZ,5),qo(AZ,5),qo(HB,5)),2&n){let i;Ar(i=kr())&&(r.trigger=i.first),Ar(i=kr())&&(r.panel=i.first),Ar(i=kr())&&(r._overlayDir=i.first)}},inputs:{userAriaDescribedBy:["aria-describedby","userAriaDescribedBy"],panelClass:"panelClass",placeholder:"placeholder",required:"required",multiple:"multiple",disableOptionCentering:"disableOptionCentering",compareWith:"compareWith",value:"value",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],errorStateMatcher:"errorStateMatcher",typeaheadDebounceInterval:"typeaheadDebounceInterval",sortComparator:"sortComparator",id:"id"},outputs:{openedChange:"openedChange",_openedStream:"opened",_closedStream:"closed",selectionChange:"selectionChange",valueChange:"valueChange"},features:[Ps,Ia]}),e})(),jZ=(()=>{var t;class e extends HZ{constructor(){super(...arguments),this.panelWidth=this._defaultOptions&&typeof this._defaultOptions.panelWidth<"u"?this._defaultOptions.panelWidth:"auto",this._positions=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"end",originY:"bottom",overlayX:"end",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom",panelClass:"mat-mdc-select-panel-above"},{originX:"end",originY:"top",overlayX:"end",overlayY:"bottom",panelClass:"mat-mdc-select-panel-above"}],this._hideSingleSelectionIndicator=this._defaultOptions?.hideSingleSelectionIndicator??!1,this._skipPredicate=n=>!this.panelOpen&&n.disabled}get shouldLabelFloat(){return this.panelOpen||!this.empty||this.focused&&!!this.placeholder}ngOnInit(){super.ngOnInit(),this._viewportRuler.change().pipe(fo(this._destroy)).subscribe(()=>{this.panelOpen&&(this._overlayWidth=this._getOverlayWidth(this._preferredOverlayOrigin),this._changeDetectorRef.detectChanges())})}open(){this._parentFormField&&(this._preferredOverlayOrigin=this._parentFormField.getConnectedOverlayOrigin()),this._overlayWidth=this._getOverlayWidth(this._preferredOverlayOrigin),super.open(),this.stateChanges.next()}close(){super.close(),this.stateChanges.next()}_scrollOptionIntoView(n){const r=this.options.toArray()[n];if(r){const i=this.panel.nativeElement,a=function X3(t,e,s){if(s.length){let n=e.toArray(),r=s.toArray(),i=0;for(let a=0;a<t+1;a++)n[a].group&&n[a].group===r[i]&&i++;return i}return 0}(n,this.options,this.optionGroups),c=r._getHostElement();i.scrollTop=0===n&&1===a?0:function Y3(t,e,s,n){return t<s?t:t+e>s+n?Math.max(0,t-n+e):s}(c.offsetTop,c.offsetHeight,i.scrollTop,i.offsetHeight)}}_positioningSettled(){this._scrollOptionIntoView(this._keyManager.activeItemIndex||0)}_getChangeEvent(n){return new zZ(this,n)}_getOverlayWidth(n){return"auto"===this.panelWidth?(n instanceof wR?n.elementRef:n||this._elementRef).nativeElement.getBoundingClientRect().width:null===this.panelWidth?"":this.panelWidth}get hideSingleSelectionIndicator(){return this._hideSingleSelectionIndicator}set hideSingleSelectionIndicator(n){this._hideSingleSelectionIndicator=Yr(n),this._syncParentProperties()}_syncParentProperties(){if(this.options)for(const n of this.options)n._changeDetectorRef.markForCheck()}}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275cmp=sr({type:t,selectors:[["mat-select"]],contentQueries:function(n,r,i){if(1&n&&(ea(i,UZ,5),ea(i,K3,5),ea(i,j3,5)),2&n){let a;Ar(a=kr())&&(r.customTrigger=a.first),Ar(a=kr())&&(r.options=a),Ar(a=kr())&&(r.optionGroups=a)}},hostAttrs:["role","combobox","aria-autocomplete","none","aria-haspopup","listbox","ngSkipHydration","",1,"mat-mdc-select"],hostVars:19,hostBindings:function(n,r){1&n&&qs("keydown",function(a){return r._handleKeydown(a)})("focus",function(){return r._onFocus()})("blur",function(){return r._onBlur()}),2&n&&(si("id",r.id)("tabindex",r.tabIndex)("aria-controls",r.panelOpen?r.id+"-panel":null)("aria-expanded",r.panelOpen)("aria-label",r.ariaLabel||null)("aria-required",r.required.toString())("aria-disabled",r.disabled.toString())("aria-invalid",r.errorState)("aria-activedescendant",r._getAriaActiveDescendant()),Ei("mat-mdc-select-disabled",r.disabled)("mat-mdc-select-invalid",r.errorState)("mat-mdc-select-required",r.required)("mat-mdc-select-empty",r.empty)("mat-mdc-select-multiple",r.multiple))},inputs:{disabled:"disabled",disableRipple:"disableRipple",tabIndex:"tabIndex",panelWidth:"panelWidth",hideSingleSelectionIndicator:"hideSingleSelectionIndicator"},exportAs:["matSelect"],features:[vr([{provide:cI,useExisting:t},{provide:H3,useExisting:t}]),Ps],ngContentSelectors:FZ,decls:11,vars:10,consts:[["cdk-overlay-origin","",1,"mat-mdc-select-trigger",3,"click"],["fallbackOverlayOrigin","cdkOverlayOrigin","trigger",""],[1,"mat-mdc-select-value",3,"ngSwitch"],["class","mat-mdc-select-placeholder mat-mdc-select-min-line",4,"ngSwitchCase"],["class","mat-mdc-select-value-text",3,"ngSwitch",4,"ngSwitchCase"],[1,"mat-mdc-select-arrow-wrapper"],[1,"mat-mdc-select-arrow"],["viewBox","0 0 24 24","width","24px","height","24px","focusable","false","aria-hidden","true"],["d","M7 10l5 5 5-5z"],["cdk-connected-overlay","","cdkConnectedOverlayLockPosition","","cdkConnectedOverlayHasBackdrop","","cdkConnectedOverlayBackdropClass","cdk-overlay-transparent-backdrop",3,"cdkConnectedOverlayPanelClass","cdkConnectedOverlayScrollStrategy","cdkConnectedOverlayOrigin","cdkConnectedOverlayOpen","cdkConnectedOverlayPositions","cdkConnectedOverlayWidth","backdropClick","attach","detach"],[1,"mat-mdc-select-placeholder","mat-mdc-select-min-line"],[1,"mat-mdc-select-value-text",3,"ngSwitch"],["class","mat-mdc-select-min-line",4,"ngSwitchDefault"],[4,"ngSwitchCase"],[1,"mat-mdc-select-min-line"],["role","listbox","tabindex","-1",3,"ngClass","keydown"],["panel",""]],template:function(n,r){if(1&n&&(Pl(PZ),yn(0,"div",0,1),qs("click",function(){return r.toggle()}),yn(3,"div",2),Fs(4,kZ,2,1,"span",3),Fs(5,NZ,3,2,"span",4),In(),yn(6,"div",5)(7,"div",6),Gu(),yn(8,"svg",7),ti(9,"path",8),In()()()(),Fs(10,MZ,3,9,"ng-template",9),qs("backdropClick",function(){return r.close()})("attach",function(){return r._onAttached()})("detach",function(){return r.close()})),2&n){const i=zp(1);Un(3),Yn("ngSwitch",r.empty),si("id",r._valueId),Un(1),Yn("ngSwitchCase",!0),Un(1),Yn("ngSwitchCase",!1),Un(5),Yn("cdkConnectedOverlayPanelClass",r._overlayPanelClass)("cdkConnectedOverlayScrollStrategy",r._scrollStrategy)("cdkConnectedOverlayOrigin",r._preferredOverlayOrigin||i)("cdkConnectedOverlayOpen",r.panelOpen)("cdkConnectedOverlayPositions",r._positions)("cdkConnectedOverlayWidth",r._overlayWidth)}},dependencies:[E2,sb,KD,aF,HB,wR],styles:['.mat-mdc-select{display:inline-block;width:100%;outline:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-select-enabled-trigger-text-color);font-family:var(--mat-select-trigger-text-font);line-height:var(--mat-select-trigger-text-line-height);font-size:var(--mat-select-trigger-text-size);font-weight:var(--mat-select-trigger-text-weight);letter-spacing:var(--mat-select-trigger-text-tracking)}.mat-mdc-select-disabled{color:var(--mat-select-disabled-trigger-text-color)}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:translateY(-8px)}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-select-arrow{width:10px;height:5px;position:relative;color:var(--mat-select-enabled-arrow-color)}.mat-mdc-form-field.mat-focused .mat-mdc-select-arrow{color:var(--mat-select-focused-arrow-color)}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-invalid .mat-mdc-select-arrow{color:var(--mat-select-invalid-arrow-color)}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-disabled .mat-mdc-select-arrow{color:var(--mat-select-disabled-arrow-color)}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:GrayText}div.mat-mdc-select-panel{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);width:100%;max-height:275px;outline:0;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:static;background-color:var(--mat-select-panel-background-color)}.cdk-high-contrast-active div.mat-mdc-select-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) div.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above div.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);color:var(--mat-select-placeholder-text-color)}._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper{cursor:pointer}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}'],encapsulation:2,data:{animation:[LZ.transformPanel]},changeDetection:0}),e})(),sV=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[VZ],imports:[Ah,DC,WS,nl,Ab,uI,WS,nl]}),e})();const GZ=["tooltip"],rV=new Zn("mat-tooltip-scroll-strategy"),YZ={provide:rV,deps:[fp],useFactory:function XZ(t){return()=>t.scrollStrategies.reposition({scrollThrottle:20})}},QZ=new Zn("mat-tooltip-default-options",{providedIn:"root",factory:function ZZ(){return{showDelay:0,hideDelay:0,touchendHideDelay:1500}}}),iV="tooltip-panel",oV=Lm({passive:!0});let sQ=(()=>{var t;class e{get position(){return this._position}set position(n){n!==this._position&&(this._position=n,this._overlayRef&&(this._updatePosition(this._overlayRef),this._tooltipInstance?.show(0),this._overlayRef.updatePosition()))}get positionAtOrigin(){return this._positionAtOrigin}set positionAtOrigin(n){this._positionAtOrigin=Yr(n),this._detach(),this._overlayRef=null}get disabled(){return this._disabled}set disabled(n){this._disabled=Yr(n),this._disabled?this.hide(0):this._setupPointerEnterEventsIfNeeded()}get showDelay(){return this._showDelay}set showDelay(n){this._showDelay=Bl(n)}get hideDelay(){return this._hideDelay}set hideDelay(n){this._hideDelay=Bl(n),this._tooltipInstance&&(this._tooltipInstance._mouseLeaveHideDelay=this._hideDelay)}get message(){return this._message}set message(n){this._ariaDescriber.removeDescription(this._elementRef.nativeElement,this._message,"tooltip"),this._message=null!=n?String(n).trim():"",!this._message&&this._isTooltipVisible()?this.hide(0):(this._setupPointerEnterEventsIfNeeded(),this._updateTooltipMessage(),this._ngZone.runOutsideAngular(()=>{Promise.resolve().then(()=>{this._ariaDescriber.describe(this._elementRef.nativeElement,this.message,"tooltip")})}))}get tooltipClass(){return this._tooltipClass}set tooltipClass(n){this._tooltipClass=n,this._tooltipInstance&&this._setTooltipClass(this._tooltipClass)}constructor(n,r,i,a,c,f,g,E,A,Y,ne,Ee){this._overlay=n,this._elementRef=r,this._scrollDispatcher=i,this._viewContainerRef=a,this._ngZone=c,this._platform=f,this._ariaDescriber=g,this._focusMonitor=E,this._dir=Y,this._defaultOptions=ne,this._position="below",this._positionAtOrigin=!1,this._disabled=!1,this._viewInitialized=!1,this._pointerExitEventsInitialized=!1,this._viewportMargin=8,this._cssClassPrefix="mat",this.touchGestures="auto",this._message="",this._passiveListeners=[],this._destroyed=new Bt,this._scrollStrategy=A,this._document=Ee,ne&&(this._showDelay=ne.showDelay,this._hideDelay=ne.hideDelay,ne.position&&(this.position=ne.position),ne.positionAtOrigin&&(this.positionAtOrigin=ne.positionAtOrigin),ne.touchGestures&&(this.touchGestures=ne.touchGestures)),Y.change.pipe(fo(this._destroyed)).subscribe(()=>{this._overlayRef&&this._updatePosition(this._overlayRef)})}ngAfterViewInit(){this._viewInitialized=!0,this._setupPointerEnterEventsIfNeeded(),this._focusMonitor.monitor(this._elementRef).pipe(fo(this._destroyed)).subscribe(n=>{n?"keyboard"===n&&this._ngZone.run(()=>this.show()):this._ngZone.run(()=>this.hide(0))})}ngOnDestroy(){const n=this._elementRef.nativeElement;clearTimeout(this._touchstartTimeout),this._overlayRef&&(this._overlayRef.dispose(),this._tooltipInstance=null),this._passiveListeners.forEach(([r,i])=>{n.removeEventListener(r,i,oV)}),this._passiveListeners.length=0,this._destroyed.next(),this._destroyed.complete(),this._ariaDescriber.removeDescription(n,this.message,"tooltip"),this._focusMonitor.stopMonitoring(n)}show(n=this.showDelay,r){if(this.disabled||!this.message||this._isTooltipVisible())return void this._tooltipInstance?._cancelPendingAnimations();const i=this._createOverlay(r);this._detach(),this._portal=this._portal||new tI(this._tooltipComponent,this._viewContainerRef);const a=this._tooltipInstance=i.attach(this._portal).instance;a._triggerElement=this._elementRef.nativeElement,a._mouseLeaveHideDelay=this._hideDelay,a.afterHidden().pipe(fo(this._destroyed)).subscribe(()=>this._detach()),this._setTooltipClass(this._tooltipClass),this._updateTooltipMessage(),a.show(n)}hide(n=this.hideDelay){const r=this._tooltipInstance;r&&(r.isVisible()?r.hide(n):(r._cancelPendingAnimations(),this._detach()))}toggle(n){this._isTooltipVisible()?this.hide():this.show(void 0,n)}_isTooltipVisible(){return!!this._tooltipInstance&&this._tooltipInstance.isVisible()}_createOverlay(n){if(this._overlayRef){const a=this._overlayRef.getConfig().positionStrategy;if((!this.positionAtOrigin||!n)&&a._origin instanceof yr)return this._overlayRef;this._detach()}const r=this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),i=this._overlay.position().flexibleConnectedTo(this.positionAtOrigin&&n||this._elementRef).withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`).withFlexibleDimensions(!1).withViewportMargin(this._viewportMargin).withScrollableContainers(r);return i.positionChanges.pipe(fo(this._destroyed)).subscribe(a=>{this._updateCurrentPositionClass(a.connectionPair),this._tooltipInstance&&a.scrollableViewProperties.isOverlayClipped&&this._tooltipInstance.isVisible()&&this._ngZone.run(()=>this.hide(0))}),this._overlayRef=this._overlay.create({direction:this._dir,positionStrategy:i,panelClass:`${this._cssClassPrefix}-${iV}`,scrollStrategy:this._scrollStrategy()}),this._updatePosition(this._overlayRef),this._overlayRef.detachments().pipe(fo(this._destroyed)).subscribe(()=>this._detach()),this._overlayRef.outsidePointerEvents().pipe(fo(this._destroyed)).subscribe(()=>this._tooltipInstance?._handleBodyInteraction()),this._overlayRef.keydownEvents().pipe(fo(this._destroyed)).subscribe(a=>{this._isTooltipVisible()&&27===a.keyCode&&!lh(a)&&(a.preventDefault(),a.stopPropagation(),this._ngZone.run(()=>this.hide(0)))}),this._defaultOptions?.disableTooltipInteractivity&&this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`),this._overlayRef}_detach(){this._overlayRef&&this._overlayRef.hasAttached()&&this._overlayRef.detach(),this._tooltipInstance=null}_updatePosition(n){const r=n.getConfig().positionStrategy,i=this._getOrigin(),a=this._getOverlayPosition();r.withPositions([this._addOffset({...i.main,...a.main}),this._addOffset({...i.fallback,...a.fallback})])}_addOffset(n){return n}_getOrigin(){const n=!this._dir||"ltr"==this._dir.value,r=this.position;let i;"above"==r||"below"==r?i={originX:"center",originY:"above"==r?"top":"bottom"}:"before"==r||"left"==r&&n||"right"==r&&!n?i={originX:"start",originY:"center"}:("after"==r||"right"==r&&n||"left"==r&&!n)&&(i={originX:"end",originY:"center"});const{x:a,y:c}=this._invertPosition(i.originX,i.originY);return{main:i,fallback:{originX:a,originY:c}}}_getOverlayPosition(){const n=!this._dir||"ltr"==this._dir.value,r=this.position;let i;"above"==r?i={overlayX:"center",overlayY:"bottom"}:"below"==r?i={overlayX:"center",overlayY:"top"}:"before"==r||"left"==r&&n||"right"==r&&!n?i={overlayX:"end",overlayY:"center"}:("after"==r||"right"==r&&n||"left"==r&&!n)&&(i={overlayX:"start",overlayY:"center"});const{x:a,y:c}=this._invertPosition(i.overlayX,i.overlayY);return{main:i,fallback:{overlayX:a,overlayY:c}}}_updateTooltipMessage(){this._tooltipInstance&&(this._tooltipInstance.message=this.message,this._tooltipInstance._markForCheck(),this._ngZone.onMicrotaskEmpty.pipe($l(1),fo(this._destroyed)).subscribe(()=>{this._tooltipInstance&&this._overlayRef.updatePosition()}))}_setTooltipClass(n){this._tooltipInstance&&(this._tooltipInstance.tooltipClass=n,this._tooltipInstance._markForCheck())}_invertPosition(n,r){return"above"===this.position||"below"===this.position?"top"===r?r="bottom":"bottom"===r&&(r="top"):"end"===n?n="start":"start"===n&&(n="end"),{x:n,y:r}}_updateCurrentPositionClass(n){const{overlayY:r,originX:i,originY:a}=n;let c;if(c="center"===r?this._dir&&"rtl"===this._dir.value?"end"===i?"left":"right":"start"===i?"left":"right":"bottom"===r&&"top"===a?"above":"below",c!==this._currentPosition){const f=this._overlayRef;if(f){const g=`${this._cssClassPrefix}-${iV}-`;f.removePanelClass(g+this._currentPosition),f.addPanelClass(g+c)}this._currentPosition=c}}_setupPointerEnterEventsIfNeeded(){this._disabled||!this.message||!this._viewInitialized||this._passiveListeners.length||(this._platformSupportsMouseEvents()?this._passiveListeners.push(["mouseenter",n=>{let r;this._setupPointerExitEventsIfNeeded(),void 0!==n.x&&void 0!==n.y&&(r=n),this.show(void 0,r)}]):"off"!==this.touchGestures&&(this._disableNativeGesturesIfNecessary(),this._passiveListeners.push(["touchstart",n=>{const r=n.targetTouches?.[0],i=r?{x:r.clientX,y:r.clientY}:void 0;this._setupPointerExitEventsIfNeeded(),clearTimeout(this._touchstartTimeout),this._touchstartTimeout=setTimeout(()=>this.show(void 0,i),500)}])),this._addListeners(this._passiveListeners))}_setupPointerExitEventsIfNeeded(){if(this._pointerExitEventsInitialized)return;this._pointerExitEventsInitialized=!0;const n=[];if(this._platformSupportsMouseEvents())n.push(["mouseleave",r=>{const i=r.relatedTarget;(!i||!this._overlayRef?.overlayElement.contains(i))&&this.hide()}],["wheel",r=>this._wheelListener(r)]);else if("off"!==this.touchGestures){this._disableNativeGesturesIfNecessary();const r=()=>{clearTimeout(this._touchstartTimeout),this.hide(this._defaultOptions.touchendHideDelay)};n.push(["touchend",r],["touchcancel",r])}this._addListeners(n),this._passiveListeners.push(...n)}_addListeners(n){n.forEach(([r,i])=>{this._elementRef.nativeElement.addEventListener(r,i,oV)})}_platformSupportsMouseEvents(){return!this._platform.IOS&&!this._platform.ANDROID}_wheelListener(n){if(this._isTooltipVisible()){const r=this._document.elementFromPoint(n.clientX,n.clientY),i=this._elementRef.nativeElement;r!==i&&!i.contains(r)&&this.hide()}}_disableNativeGesturesIfNecessary(){const n=this.touchGestures;if("off"!==n){const r=this._elementRef.nativeElement,i=r.style;("on"===n||"INPUT"!==r.nodeName&&"TEXTAREA"!==r.nodeName)&&(i.userSelect=i.msUserSelect=i.webkitUserSelect=i.MozUserSelect="none"),("on"===n||!r.draggable)&&(i.webkitUserDrag="none"),i.touchAction="none",i.webkitTapHighlightColor="transparent"}}}return(t=e).\u0275fac=function(n){Tf()},t.\u0275dir=Gn({type:t,inputs:{position:["matTooltipPosition","position"],positionAtOrigin:["matTooltipPositionAtOrigin","positionAtOrigin"],disabled:["matTooltipDisabled","disabled"],showDelay:["matTooltipShowDelay","showDelay"],hideDelay:["matTooltipHideDelay","hideDelay"],touchGestures:["matTooltipTouchGestures","touchGestures"],message:["matTooltip","message"],tooltipClass:["matTooltipClass","tooltipClass"]}}),e})(),rQ=(()=>{var t;class e extends sQ{constructor(n,r,i,a,c,f,g,E,A,Y,ne,Ee){super(n,r,i,a,c,f,g,E,A,Y,ne,Ee),this._tooltipComponent=oQ,this._cssClassPrefix="mat-mdc",this._viewportMargin=8}_addOffset(n){const i=!this._dir||"ltr"==this._dir.value;return"top"===n.originY?n.offsetY=-8:"bottom"===n.originY?n.offsetY=8:"start"===n.originX?n.offsetX=i?-8:8:"end"===n.originX&&(n.offsetX=i?8:-8),n}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(fp),lt(yr),lt(Tb),lt(jc),lt(Gs),lt(wc),lt(E3),lt($m),lt(rV),lt(td,8),lt(QZ,8),lt(yi))},t.\u0275dir=Gn({type:t,selectors:[["","matTooltip",""]],hostAttrs:[1,"mat-mdc-tooltip-trigger"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("mat-mdc-tooltip-disabled",r.disabled)},exportAs:["matTooltip"],features:[Ps]}),e})(),iQ=(()=>{var t;class e{constructor(n,r){this._changeDetectorRef=n,this._closeOnInteraction=!1,this._isVisible=!1,this._onHide=new Bt,this._animationsDisabled="NoopAnimations"===r}show(n){null!=this._hideTimeoutId&&clearTimeout(this._hideTimeoutId),this._showTimeoutId=setTimeout(()=>{this._toggleVisibility(!0),this._showTimeoutId=void 0},n)}hide(n){null!=this._showTimeoutId&&clearTimeout(this._showTimeoutId),this._hideTimeoutId=setTimeout(()=>{this._toggleVisibility(!1),this._hideTimeoutId=void 0},n)}afterHidden(){return this._onHide}isVisible(){return this._isVisible}ngOnDestroy(){this._cancelPendingAnimations(),this._onHide.complete(),this._triggerElement=null}_handleBodyInteraction(){this._closeOnInteraction&&this.hide(0)}_markForCheck(){this._changeDetectorRef.markForCheck()}_handleMouseLeave({relatedTarget:n}){(!n||!this._triggerElement.contains(n))&&(this.isVisible()?this.hide(this._mouseLeaveHideDelay):this._finalizeAnimation(!1))}_onShow(){}_handleAnimationEnd({animationName:n}){(n===this._showAnimation||n===this._hideAnimation)&&this._finalizeAnimation(n===this._showAnimation)}_cancelPendingAnimations(){null!=this._showTimeoutId&&clearTimeout(this._showTimeoutId),null!=this._hideTimeoutId&&clearTimeout(this._hideTimeoutId),this._showTimeoutId=this._hideTimeoutId=void 0}_finalizeAnimation(n){n?this._closeOnInteraction=!0:this.isVisible()||this._onHide.next()}_toggleVisibility(n){const r=this._tooltip.nativeElement,i=this._showAnimation,a=this._hideAnimation;if(r.classList.remove(n?a:i),r.classList.add(n?i:a),this._isVisible=n,n&&!this._animationsDisabled&&"function"==typeof getComputedStyle){const c=getComputedStyle(r);("0s"===c.getPropertyValue("animation-duration")||"none"===c.getPropertyValue("animation-name"))&&(this._animationsDisabled=!0)}n&&this._onShow(),this._animationsDisabled&&(r.classList.add("_mat-animation-noopable"),this._finalizeAnimation(n))}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Ll),lt(ac,8))},t.\u0275dir=Gn({type:t}),e})(),oQ=(()=>{var t;class e extends iQ{constructor(n,r,i){super(n,i),this._elementRef=r,this._isMultiline=!1,this._showAnimation="mat-mdc-tooltip-show",this._hideAnimation="mat-mdc-tooltip-hide"}_onShow(){this._isMultiline=this._isTooltipMultiline(),this._markForCheck()}_isTooltipMultiline(){const n=this._elementRef.nativeElement.getBoundingClientRect();return n.height>24&&n.width>=200}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Ll),lt(yr),lt(ac,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-tooltip-component"]],viewQuery:function(n,r){if(1&n&&qo(GZ,7),2&n){let i;Ar(i=kr())&&(r._tooltip=i.first)}},hostAttrs:["aria-hidden","true"],hostVars:2,hostBindings:function(n,r){1&n&&qs("mouseleave",function(a){return r._handleMouseLeave(a)}),2&n&&Ju("zoom",r.isVisible()?1:null)},features:[Ps],decls:4,vars:4,consts:[[1,"mdc-tooltip","mdc-tooltip--shown","mat-mdc-tooltip",3,"ngClass","animationend"],["tooltip",""],[1,"mdc-tooltip__surface","mdc-tooltip__surface-animation"]],template:function(n,r){1&n&&(yn(0,"div",0,1),qs("animationend",function(a){return r._handleAnimationEnd(a)}),yn(2,"div",2),Ys(3),In()()),2&n&&(Ei("mdc-tooltip--multiline",r._isMultiline),Yn("ngClass",r.tooltipClass),Un(3),zu(r.message))},dependencies:[E2],styles:['.mdc-tooltip__surface{word-break:break-all;word-break:var(--mdc-tooltip-word-break, normal);overflow-wrap:anywhere}.mdc-tooltip--showing-transition .mdc-tooltip__surface-animation{transition:opacity 150ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-tooltip--hide-transition .mdc-tooltip__surface-animation{transition:opacity 75ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-tooltip{position:fixed;display:none;z-index:9}.mdc-tooltip-wrapper--rich{position:relative}.mdc-tooltip--shown,.mdc-tooltip--showing,.mdc-tooltip--hide{display:inline-flex}.mdc-tooltip--shown.mdc-tooltip--rich,.mdc-tooltip--showing.mdc-tooltip--rich,.mdc-tooltip--hide.mdc-tooltip--rich{display:inline-block;left:-320px;position:absolute}.mdc-tooltip__surface{line-height:16px;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center}.mdc-tooltip__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-tooltip__surface::before{border-color:CanvasText}}.mdc-tooltip--rich .mdc-tooltip__surface{align-items:flex-start;display:flex;flex-direction:column;min-height:24px;min-width:40px;max-width:320px;position:relative}.mdc-tooltip--multiline .mdc-tooltip__surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mdc-tooltip__surface,.mdc-tooltip--multiline .mdc-tooltip__surface[dir=rtl]{text-align:right}.mdc-tooltip__surface .mdc-tooltip__title{margin:0 8px}.mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(200px - (2 * 8px));margin:8px;text-align:left}[dir=rtl] .mdc-tooltip__surface .mdc-tooltip__content,.mdc-tooltip__surface .mdc-tooltip__content[dir=rtl]{text-align:right}.mdc-tooltip--rich .mdc-tooltip__surface .mdc-tooltip__content{max-width:calc(320px - (2 * 8px));align-self:stretch}.mdc-tooltip__surface .mdc-tooltip__content-link{text-decoration:none}.mdc-tooltip--rich-actions,.mdc-tooltip__content,.mdc-tooltip__title{z-index:1}.mdc-tooltip__surface-animation{opacity:0;transform:scale(0.8);will-change:transform,opacity}.mdc-tooltip--shown .mdc-tooltip__surface-animation{transform:scale(1);opacity:1}.mdc-tooltip--hide .mdc-tooltip__surface-animation{transform:scale(1)}.mdc-tooltip__caret-surface-top,.mdc-tooltip__caret-surface-bottom{position:absolute;height:24px;width:24px;transform:rotate(35deg) skewY(20deg) scaleX(0.9396926208)}.mdc-tooltip__caret-surface-top .mdc-elevation-overlay,.mdc-tooltip__caret-surface-bottom .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-tooltip__caret-surface-bottom{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);outline:1px solid rgba(0,0,0,0);z-index:-1}@media screen and (forced-colors: active){.mdc-tooltip__caret-surface-bottom{outline-color:CanvasText}}.mat-mdc-tooltip{--mdc-plain-tooltip-container-shape:4px;--mdc-plain-tooltip-supporting-text-line-height:16px}.mat-mdc-tooltip .mdc-tooltip__surface{background-color:var(--mdc-plain-tooltip-container-color)}.mat-mdc-tooltip .mdc-tooltip__surface{border-radius:var(--mdc-plain-tooltip-container-shape)}.mat-mdc-tooltip .mdc-tooltip__caret-surface-top,.mat-mdc-tooltip .mdc-tooltip__caret-surface-bottom{border-radius:var(--mdc-plain-tooltip-container-shape)}.mat-mdc-tooltip .mdc-tooltip__surface{color:var(--mdc-plain-tooltip-supporting-text-color)}.mat-mdc-tooltip .mdc-tooltip__surface{font-family:var(--mdc-plain-tooltip-supporting-text-font);line-height:var(--mdc-plain-tooltip-supporting-text-line-height);font-size:var(--mdc-plain-tooltip-supporting-text-size);font-weight:var(--mdc-plain-tooltip-supporting-text-weight);letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking)}.mat-mdc-tooltip{position:relative;transform:scale(0)}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}'],encapsulation:2,changeDetection:0}),e})(),aQ=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[YZ],imports:[M3,Ah,DC,nl,nl,Ab]}),e})();function lQ(t,e){if(1&t&&(yn(0,"mat-option",19),Ys(1),In()),2&t){const s=e.$implicit;Yn("value",s),Un(1),pd(" ",s," ")}}function cQ(t,e){if(1&t){const s=iu();yn(0,"mat-form-field",16)(1,"mat-select",17),qs("selectionChange",function(r){return hr(s),gs(bs(2)._changePageSize(r.value))}),Fs(2,lQ,2,2,"mat-option",18),In()()}if(2&t){const s=bs(2);Yn("appearance",s._formFieldAppearance)("color",s.color),Un(1),Yn("value",s.pageSize)("disabled",s.disabled)("aria-labelledby",s._pageSizeLabelId)("panelClass",s.selectConfig.panelClass||"")("disableOptionCentering",s.selectConfig.disableOptionCentering),Un(1),Yn("ngForOf",s._displayedPageSizeOptions)}}function uQ(t,e){if(1&t&&(yn(0,"div",20),Ys(1),In()),2&t){const s=bs(2);Un(1),zu(s.pageSize)}}function dQ(t,e){if(1&t&&(yn(0,"div",12)(1,"div",13),Ys(2),In(),Fs(3,cQ,3,8,"mat-form-field",14),Fs(4,uQ,2,1,"div",15),In()),2&t){const s=bs();Un(1),Hv("id",s._pageSizeLabelId),Un(1),pd(" ",s._intl.itemsPerPageLabel," "),Un(1),Yn("ngIf",s._displayedPageSizeOptions.length>1),Un(1),Yn("ngIf",s._displayedPageSizeOptions.length<=1)}}function hQ(t,e){if(1&t){const s=iu();yn(0,"button",21),qs("click",function(){return hr(s),gs(bs().firstPage())}),Gu(),yn(1,"svg",7),ti(2,"path",22),In()()}if(2&t){const s=bs();Yn("matTooltip",s._intl.firstPageLabel)("matTooltipDisabled",s._previousButtonsDisabled())("matTooltipPosition","above")("disabled",s._previousButtonsDisabled()),si("aria-label",s._intl.firstPageLabel)}}function pQ(t,e){if(1&t){const s=iu();Gu(),Ip(),yn(0,"button",23),qs("click",function(){return hr(s),gs(bs().lastPage())}),Gu(),yn(1,"svg",7),ti(2,"path",24),In()()}if(2&t){const s=bs();Yn("matTooltip",s._intl.lastPageLabel)("matTooltipDisabled",s._nextButtonsDisabled())("matTooltipPosition","above")("disabled",s._nextButtonsDisabled()),si("aria-label",s._intl.lastPageLabel)}}let dI=(()=>{var t;class e{constructor(){this.changes=new Bt,this.itemsPerPageLabel="Items per page:",this.nextPageLabel="Next page",this.previousPageLabel="Previous page",this.firstPageLabel="First page",this.lastPageLabel="Last page",this.getRangeLabel=(n,r,i)=>{if(0==i||0==r)return`0 of ${i}`;const a=n*r;return`${a+1} \u2013 ${a<(i=Math.max(i,0))?Math.min(a+r,i):a+r} of ${i}`}}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const mQ={provide:dI,deps:[[new wh,new Gh,dI]],useFactory:function fQ(t){return t||new dI}},_Q=new Zn("MAT_PAGINATOR_DEFAULT_OPTIONS"),yQ=Sb($3(class{}));let vQ=(()=>{var t;class e extends yQ{get pageIndex(){return this._pageIndex}set pageIndex(n){this._pageIndex=Math.max(Bl(n),0),this._changeDetectorRef.markForCheck()}get length(){return this._length}set length(n){this._length=Bl(n),this._changeDetectorRef.markForCheck()}get pageSize(){return this._pageSize}set pageSize(n){this._pageSize=Math.max(Bl(n),0),this._updateDisplayedPageSizeOptions()}get pageSizeOptions(){return this._pageSizeOptions}set pageSizeOptions(n){this._pageSizeOptions=(n||[]).map(r=>Bl(r)),this._updateDisplayedPageSizeOptions()}get hidePageSize(){return this._hidePageSize}set hidePageSize(n){this._hidePageSize=Yr(n)}get showFirstLastButtons(){return this._showFirstLastButtons}set showFirstLastButtons(n){this._showFirstLastButtons=Yr(n)}constructor(n,r,i){if(super(),this._intl=n,this._changeDetectorRef=r,this._pageIndex=0,this._length=0,this._pageSizeOptions=[],this._hidePageSize=!1,this._showFirstLastButtons=!1,this.selectConfig={},this.page=new Rr,this._intlChanges=n.changes.subscribe(()=>this._changeDetectorRef.markForCheck()),i){const{pageSize:a,pageSizeOptions:c,hidePageSize:f,showFirstLastButtons:g}=i;null!=a&&(this._pageSize=a),null!=c&&(this._pageSizeOptions=c),null!=f&&(this._hidePageSize=f),null!=g&&(this._showFirstLastButtons=g)}}ngOnInit(){this._initialized=!0,this._updateDisplayedPageSizeOptions(),this._markInitialized()}ngOnDestroy(){this._intlChanges.unsubscribe()}nextPage(){if(!this.hasNextPage())return;const n=this.pageIndex;this.pageIndex=this.pageIndex+1,this._emitPageEvent(n)}previousPage(){if(!this.hasPreviousPage())return;const n=this.pageIndex;this.pageIndex=this.pageIndex-1,this._emitPageEvent(n)}firstPage(){if(!this.hasPreviousPage())return;const n=this.pageIndex;this.pageIndex=0,this._emitPageEvent(n)}lastPage(){if(!this.hasNextPage())return;const n=this.pageIndex;this.pageIndex=this.getNumberOfPages()-1,this._emitPageEvent(n)}hasPreviousPage(){return this.pageIndex>=1&&0!=this.pageSize}hasNextPage(){const n=this.getNumberOfPages()-1;return this.pageIndex<n&&0!=this.pageSize}getNumberOfPages(){return this.pageSize?Math.ceil(this.length/this.pageSize):0}_changePageSize(n){const i=this.pageIndex;this.pageIndex=Math.floor(this.pageIndex*this.pageSize/n)||0,this.pageSize=n,this._emitPageEvent(i)}_nextButtonsDisabled(){return this.disabled||!this.hasNextPage()}_previousButtonsDisabled(){return this.disabled||!this.hasPreviousPage()}_updateDisplayedPageSizeOptions(){this._initialized&&(this.pageSize||(this._pageSize=0!=this.pageSizeOptions.length?this.pageSizeOptions[0]:50),this._displayedPageSizeOptions=this.pageSizeOptions.slice(),-1===this._displayedPageSizeOptions.indexOf(this.pageSize)&&this._displayedPageSizeOptions.push(this.pageSize),this._displayedPageSizeOptions.sort((n,r)=>n-r),this._changeDetectorRef.markForCheck())}_emitPageEvent(n){this.page.emit({previousPageIndex:n,pageIndex:this.pageIndex,pageSize:this.pageSize,length:this.length})}}return(t=e).\u0275fac=function(n){Tf()},t.\u0275dir=Gn({type:t,inputs:{color:"color",pageIndex:"pageIndex",length:"length",pageSize:"pageSize",pageSizeOptions:"pageSizeOptions",hidePageSize:"hidePageSize",showFirstLastButtons:"showFirstLastButtons",selectConfig:"selectConfig"},outputs:{page:"page"},features:[Ps]}),e})(),bQ=0,aV=(()=>{var t;class e extends vQ{constructor(n,r,i){super(n,r,i),this._pageSizeLabelId="mat-paginator-page-size-label-"+bQ++,this._formFieldAppearance=i?.formFieldAppearance||"outline"}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(dI),lt(Ll),lt(_Q,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-paginator"]],hostAttrs:["role","group",1,"mat-mdc-paginator"],inputs:{disabled:"disabled"},exportAs:["matPaginator"],features:[Ps],decls:14,vars:14,consts:[[1,"mat-mdc-paginator-outer-container"],[1,"mat-mdc-paginator-container"],["class","mat-mdc-paginator-page-size",4,"ngIf"],[1,"mat-mdc-paginator-range-actions"],["aria-live","polite",1,"mat-mdc-paginator-range-label"],["mat-icon-button","","type","button","class","mat-mdc-paginator-navigation-first",3,"matTooltip","matTooltipDisabled","matTooltipPosition","disabled","click",4,"ngIf"],["mat-icon-button","","type","button",1,"mat-mdc-paginator-navigation-previous",3,"matTooltip","matTooltipDisabled","matTooltipPosition","disabled","click"],["viewBox","0 0 24 24","focusable","false","aria-hidden","true",1,"mat-mdc-paginator-icon"],["d","M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"],["mat-icon-button","","type","button",1,"mat-mdc-paginator-navigation-next",3,"matTooltip","matTooltipDisabled","matTooltipPosition","disabled","click"],["d","M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"],["mat-icon-button","","type","button","class","mat-mdc-paginator-navigation-last",3,"matTooltip","matTooltipDisabled","matTooltipPosition","disabled","click",4,"ngIf"],[1,"mat-mdc-paginator-page-size"],[1,"mat-mdc-paginator-page-size-label",3,"id"],["class","mat-mdc-paginator-page-size-select",3,"appearance","color",4,"ngIf"],["class","mat-mdc-paginator-page-size-value",4,"ngIf"],[1,"mat-mdc-paginator-page-size-select",3,"appearance","color"],["hideSingleSelectionIndicator","",3,"value","disabled","aria-labelledby","panelClass","disableOptionCentering","selectionChange"],[3,"value",4,"ngFor","ngForOf"],[3,"value"],[1,"mat-mdc-paginator-page-size-value"],["mat-icon-button","","type","button",1,"mat-mdc-paginator-navigation-first",3,"matTooltip","matTooltipDisabled","matTooltipPosition","disabled","click"],["d","M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"],["mat-icon-button","","type","button",1,"mat-mdc-paginator-navigation-last",3,"matTooltip","matTooltipDisabled","matTooltipPosition","disabled","click"],["d","M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"]],template:function(n,r){1&n&&(yn(0,"div",0)(1,"div",1),Fs(2,dQ,5,4,"div",2),yn(3,"div",3)(4,"div",4),Ys(5),In(),Fs(6,hQ,3,5,"button",5),yn(7,"button",6),qs("click",function(){return r.previousPage()}),Gu(),yn(8,"svg",7),ti(9,"path",8),In()(),Ip(),yn(10,"button",9),qs("click",function(){return r.nextPage()}),Gu(),yn(11,"svg",7),ti(12,"path",10),In()(),Fs(13,pQ,3,5,"button",11),In()()()),2&n&&(Un(2),Yn("ngIf",!r.hidePageSize),Un(3),pd(" ",r._intl.getRangeLabel(r.pageIndex,r.pageSize,r.length)," "),Un(1),Yn("ngIf",r.showFirstLastButtons),Un(1),Yn("matTooltip",r._intl.previousPageLabel)("matTooltipDisabled",r._previousButtonsDisabled())("matTooltipPosition","above")("disabled",r._previousButtonsDisabled()),si("aria-label",r._intl.previousPageLabel),Un(3),Yn("matTooltip",r._intl.nextPageLabel)("matTooltipDisabled",r._nextButtonsDisabled())("matTooltipPosition","above")("disabled",r._nextButtonsDisabled()),si("aria-label",r._intl.nextPageLabel),Un(3),Yn("ngIf",r.showFirstLastButtons))},dependencies:[Rw,$d,lR,eV,jZ,K3,rQ],styles:[".mat-mdc-paginator{display:block;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-paginator-container-text-color);background-color:var(--mat-paginator-container-background-color);font-family:var(--mat-paginator-container-text-font);line-height:var(--mat-paginator-container-text-line-height);font-size:var(--mat-paginator-container-text-size);font-weight:var(--mat-paginator-container-text-weight);letter-spacing:var(--mat-paginator-container-text-tracking)}.mat-mdc-paginator .mat-mdc-select-value{font-size:var(--mat-paginator-select-trigger-text-size)}.mat-mdc-paginator .mat-mdc-form-field-subscript-wrapper{display:none}.mat-mdc-paginator .mat-mdc-select{line-height:1.5}.mat-mdc-paginator-outer-container{display:flex}.mat-mdc-paginator-container{display:flex;align-items:center;justify-content:flex-end;padding:0 8px;flex-wrap:wrap-reverse;width:100%;min-height:var(--mat-paginator-container-size)}.mat-mdc-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-mdc-paginator-page-size{margin-right:0;margin-left:8px}.mat-mdc-paginator-page-size-label{margin:0 4px}.mat-mdc-paginator-page-size-select{margin:0 4px;width:84px}.mat-mdc-paginator-range-label{margin:0 32px 0 24px}.mat-mdc-paginator-range-actions{display:flex;align-items:center}.mat-mdc-paginator-icon{display:inline-block;width:28px;fill:var(--mat-paginator-enabled-icon-color)}.mat-mdc-icon-button[disabled] .mat-mdc-paginator-icon{fill:var(--mat-paginator-disabled-icon-color)}[dir=rtl] .mat-mdc-paginator-icon{transform:rotate(180deg)}.cdk-high-contrast-active .mat-mdc-icon-button[disabled] .mat-mdc-paginator-icon,.cdk-high-contrast-active .mat-mdc-paginator-icon{fill:currentColor;fill:CanvasText}.cdk-high-contrast-active .mat-mdc-paginator-range-actions .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),e})(),xQ=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[mQ],imports:[Ah,_B,sV,aQ]}),e})();const wQ=["mat-sort-header",""];function CQ(t,e){if(1&t){const s=iu();yn(0,"div",3),qs("@arrowPosition.start",function(){return hr(s),gs(bs()._disableViewStateAnimation=!0)})("@arrowPosition.done",function(){return hr(s),gs(bs()._disableViewStateAnimation=!1)}),ti(1,"div",4),yn(2,"div",5),ti(3,"div",6)(4,"div",7)(5,"div",8),In()()}if(2&t){const s=bs();Yn("@arrowOpacity",s._getArrowViewState())("@arrowPosition",s._getArrowViewState())("@allowChildren",s._getArrowDirectionState()),Un(2),Yn("@indicator",s._getArrowDirectionState()),Un(1),Yn("@leftPointer",s._getArrowDirectionState()),Un(1),Yn("@rightPointer",s._getArrowDirectionState())}}const EQ=["*"],lV=new Zn("MAT_SORT_DEFAULT_OPTIONS"),DQ=$3(Sb(class{}));let ER=(()=>{var t;class e extends DQ{get direction(){return this._direction}set direction(n){this._direction=n}get disableClear(){return this._disableClear}set disableClear(n){this._disableClear=Yr(n)}constructor(n){super(),this._defaultOptions=n,this.sortables=new Map,this._stateChanges=new Bt,this.start="asc",this._direction="",this.sortChange=new Rr}register(n){this.sortables.set(n.id,n)}deregister(n){this.sortables.delete(n.id)}sort(n){this.active!=n.id?(this.active=n.id,this.direction=n.start?n.start:this.start):this.direction=this.getNextSortDirection(n),this.sortChange.emit({active:this.active,direction:this.direction})}getNextSortDirection(n){if(!n)return"";let i=function SQ(t,e){let s=["asc","desc"];return"desc"==t&&s.reverse(),e||s.push(""),s}(n.start||this.start,n?.disableClear??this.disableClear??!!this._defaultOptions?.disableClear),a=i.indexOf(this.direction)+1;return a>=i.length&&(a=0),i[a]}ngOnInit(){this._markInitialized()}ngOnChanges(){this._stateChanges.next()}ngOnDestroy(){this._stateChanges.complete()}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(lV,8))},t.\u0275dir=Gn({type:t,selectors:[["","matSort",""]],hostAttrs:[1,"mat-sort"],inputs:{disabled:["matSortDisabled","disabled"],active:["matSortActive","active"],start:["matSortStart","start"],direction:["matSortDirection","direction"],disableClear:["matSortDisableClear","disableClear"]},outputs:{sortChange:"matSortChange"},exportAs:["matSort"],features:[Ps,Ia]}),e})();const m_=g9.ENTERING+" "+m9.STANDARD_CURVE,kb={indicator:nd("indicator",[Vl("active-asc, asc",Mi({transform:"translateY(0px)"})),Vl("active-desc, desc",Mi({transform:"translateY(10px)"})),sc("active-asc <=> active-desc",nc(m_))]),leftPointer:nd("leftPointer",[Vl("active-asc, asc",Mi({transform:"rotate(-45deg)"})),Vl("active-desc, desc",Mi({transform:"rotate(45deg)"})),sc("active-asc <=> active-desc",nc(m_))]),rightPointer:nd("rightPointer",[Vl("active-asc, asc",Mi({transform:"rotate(45deg)"})),Vl("active-desc, desc",Mi({transform:"rotate(-45deg)"})),sc("active-asc <=> active-desc",nc(m_))]),arrowOpacity:nd("arrowOpacity",[Vl("desc-to-active, asc-to-active, active",Mi({opacity:1})),Vl("desc-to-hint, asc-to-hint, hint",Mi({opacity:.54})),Vl("hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void",Mi({opacity:0})),sc("* => asc, * => desc, * => active, * => hint, * => void",nc("0ms")),sc("* <=> *",nc(m_))]),arrowPosition:nd("arrowPosition",[sc("* => desc-to-hint, * => desc-to-active",nc(m_,ZS([Mi({transform:"translateY(-25%)"}),Mi({transform:"translateY(0)"})]))),sc("* => hint-to-desc, * => active-to-desc",nc(m_,ZS([Mi({transform:"translateY(0)"}),Mi({transform:"translateY(25%)"})]))),sc("* => asc-to-hint, * => asc-to-active",nc(m_,ZS([Mi({transform:"translateY(25%)"}),Mi({transform:"translateY(0)"})]))),sc("* => hint-to-asc, * => active-to-asc",nc(m_,ZS([Mi({transform:"translateY(0)"}),Mi({transform:"translateY(-25%)"})]))),Vl("desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active",Mi({transform:"translateY(0)"})),Vl("hint-to-desc, active-to-desc, desc",Mi({transform:"translateY(-25%)"})),Vl("hint-to-asc, active-to-asc, asc",Mi({transform:"translateY(25%)"}))]),allowChildren:nd("allowChildren",[sc("* <=> *",[JS("@*",QS(),{optional:!0})])])};let hI=(()=>{var t;class e{constructor(){this.changes=new Bt}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const TQ={provide:hI,deps:[[new wh,new Gh,hI]],useFactory:function IQ(t){return t||new hI}},AQ=Sb(class{});let kQ=(()=>{var t;class e extends AQ{get sortActionDescription(){return this._sortActionDescription}set sortActionDescription(n){this._updateSortActionDescription(n)}get disableClear(){return this._disableClear}set disableClear(n){this._disableClear=Yr(n)}constructor(n,r,i,a,c,f,g,E){super(),this._intl=n,this._changeDetectorRef=r,this._sort=i,this._columnDef=a,this._focusMonitor=c,this._elementRef=f,this._ariaDescriber=g,this._showIndicatorHint=!1,this._viewState={},this._arrowDirection="",this._disableViewStateAnimation=!1,this.arrowPosition="after",this._sortActionDescription="Sort",E?.arrowPosition&&(this.arrowPosition=E?.arrowPosition),this._handleStateChanges()}ngOnInit(){!this.id&&this._columnDef&&(this.id=this._columnDef.name),this._updateArrowDirection(),this._setAnimationTransitionState({toState:this._isSorted()?"active":this._arrowDirection}),this._sort.register(this),this._sortButton=this._elementRef.nativeElement.querySelector(".mat-sort-header-container"),this._updateSortActionDescription(this._sortActionDescription)}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0).subscribe(n=>{const r=!!n;r!==this._showIndicatorHint&&(this._setIndicatorHintVisible(r),this._changeDetectorRef.markForCheck())})}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef),this._sort.deregister(this),this._rerenderSubscription.unsubscribe()}_setIndicatorHintVisible(n){this._isDisabled()&&n||(this._showIndicatorHint=n,this._isSorted()||(this._updateArrowDirection(),this._setAnimationTransitionState(this._showIndicatorHint?{fromState:this._arrowDirection,toState:"hint"}:{fromState:"hint",toState:this._arrowDirection})))}_setAnimationTransitionState(n){this._viewState=n||{},this._disableViewStateAnimation&&(this._viewState={toState:n.toState})}_toggleOnInteraction(){this._sort.sort(this),("hint"===this._viewState.toState||"active"===this._viewState.toState)&&(this._disableViewStateAnimation=!0)}_handleClick(){this._isDisabled()||this._sort.sort(this)}_handleKeydown(n){!this._isDisabled()&&(32===n.keyCode||13===n.keyCode)&&(n.preventDefault(),this._toggleOnInteraction())}_isSorted(){return this._sort.active==this.id&&("asc"===this._sort.direction||"desc"===this._sort.direction)}_getArrowDirectionState(){return`${this._isSorted()?"active-":""}${this._arrowDirection}`}_getArrowViewState(){const n=this._viewState.fromState;return(n?`${n}-to-`:"")+this._viewState.toState}_updateArrowDirection(){this._arrowDirection=this._isSorted()?this._sort.direction:this.start||this._sort.start}_isDisabled(){return this._sort.disabled||this.disabled}_getAriaSortAttribute(){return this._isSorted()?"asc"==this._sort.direction?"ascending":"descending":"none"}_renderArrow(){return!this._isDisabled()||this._isSorted()}_updateSortActionDescription(n){this._sortButton&&(this._ariaDescriber?.removeDescription(this._sortButton,this._sortActionDescription),this._ariaDescriber?.describe(this._sortButton,n)),this._sortActionDescription=n}_handleStateChanges(){this._rerenderSubscription=ji(this._sort.sortChange,this._sort._stateChanges,this._intl.changes).subscribe(()=>{this._isSorted()&&(this._updateArrowDirection(),("hint"===this._viewState.toState||"active"===this._viewState.toState)&&(this._disableViewStateAnimation=!0),this._setAnimationTransitionState({fromState:this._arrowDirection,toState:"active"}),this._showIndicatorHint=!1),!this._isSorted()&&this._viewState&&"active"===this._viewState.toState&&(this._disableViewStateAnimation=!1,this._setAnimationTransitionState({fromState:"active",toState:this._arrowDirection})),this._changeDetectorRef.markForCheck()})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(hI),lt(Ll),lt(ER,8),lt("MAT_SORT_HEADER_COLUMN_DEF",8),lt($m),lt(yr),lt(E3,8),lt(lV,8))},t.\u0275cmp=sr({type:t,selectors:[["","mat-sort-header",""]],hostAttrs:[1,"mat-sort-header"],hostVars:3,hostBindings:function(n,r){1&n&&qs("click",function(){return r._handleClick()})("keydown",function(a){return r._handleKeydown(a)})("mouseenter",function(){return r._setIndicatorHintVisible(!0)})("mouseleave",function(){return r._setIndicatorHintVisible(!1)}),2&n&&(si("aria-sort",r._getAriaSortAttribute()),Ei("mat-sort-header-disabled",r._isDisabled()))},inputs:{disabled:"disabled",id:["mat-sort-header","id"],arrowPosition:"arrowPosition",start:"start",sortActionDescription:"sortActionDescription",disableClear:"disableClear"},exportAs:["matSortHeader"],features:[Ps],attrs:wQ,ngContentSelectors:EQ,decls:4,vars:7,consts:[[1,"mat-sort-header-container","mat-focus-indicator"],[1,"mat-sort-header-content"],["class","mat-sort-header-arrow",4,"ngIf"],[1,"mat-sort-header-arrow"],[1,"mat-sort-header-stem"],[1,"mat-sort-header-indicator"],[1,"mat-sort-header-pointer-left"],[1,"mat-sort-header-pointer-right"],[1,"mat-sort-header-pointer-middle"]],template:function(n,r){1&n&&(Pl(),yn(0,"div",0)(1,"div",1),ri(2),In(),Fs(3,CQ,6,6,"div",2),In()),2&n&&(Ei("mat-sort-header-sorted",r._isSorted())("mat-sort-header-position-before","before"===r.arrowPosition),si("tabindex",r._isDisabled()?null:0)("role",r._isDisabled()?null:"button"),Un(3),Yn("ngIf",r._renderArrow()))},dependencies:[$d],styles:[".mat-sort-header-container{display:flex;cursor:pointer;align-items:center;letter-spacing:normal;outline:0}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-container,[mat-sort-header].cdk-program-focused .mat-sort-header-container{border-bottom:solid 1px currentColor}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-container::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-sort-header-content{text-align:center;display:flex;align-items:center}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.cdk-high-contrast-active .mat-sort-header-stem{width:0;border-left:solid 2px}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.cdk-high-contrast-active .mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.cdk-high-contrast-active .mat-sort-header-pointer-left,.cdk-high-contrast-active .mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}"],encapsulation:2,data:{animation:[kb.indicator,kb.leftPointer,kb.rightPointer,kb.arrowOpacity,kb.arrowPosition,kb.allowChildren]},changeDetection:0}),e})(),OQ=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[TQ],imports:[Ah,nl]}),e})();const RQ=[[["caption"]],[["colgroup"],["col"]]],NQ=["caption","colgroup, col"];function DR(t){return class extends t{get sticky(){return this._sticky}set sticky(e){const s=this._sticky;this._sticky=Yr(e),this._hasStickyChanged=s!==this._sticky}hasStickyChanged(){const e=this._hasStickyChanged;return this._hasStickyChanged=!1,e}resetStickyChanged(){this._hasStickyChanged=!1}constructor(...e){super(...e),this._sticky=!1,this._hasStickyChanged=!1}}}const Ob=new Zn("CDK_TABLE");let Rb=(()=>{var t;class e{constructor(n){this.template=n}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc))},t.\u0275dir=Gn({type:t,selectors:[["","cdkCellDef",""]]}),e})(),Nb=(()=>{var t;class e{constructor(n){this.template=n}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc))},t.\u0275dir=Gn({type:t,selectors:[["","cdkHeaderCellDef",""]]}),e})(),pI=(()=>{var t;class e{constructor(n){this.template=n}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc))},t.\u0275dir=Gn({type:t,selectors:[["","cdkFooterCellDef",""]]}),e})();class LQ{}const $Q=DR(LQ);let Vm=(()=>{var t;class e extends $Q{get name(){return this._name}set name(n){this._setNameInput(n)}get stickyEnd(){return this._stickyEnd}set stickyEnd(n){const r=this._stickyEnd;this._stickyEnd=Yr(n),this._hasStickyChanged=r!==this._stickyEnd}constructor(n){super(),this._table=n,this._stickyEnd=!1}_updateColumnCssClassName(){this._columnCssClassName=[`cdk-column-${this.cssClassFriendlyName}`]}_setNameInput(n){n&&(this._name=n,this.cssClassFriendlyName=n.replace(/[^a-z0-9_-]/gi,"-"),this._updateColumnCssClassName())}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Ob,8))},t.\u0275dir=Gn({type:t,selectors:[["","cdkColumnDef",""]],contentQueries:function(n,r,i){if(1&n&&(ea(i,Rb,5),ea(i,Nb,5),ea(i,pI,5)),2&n){let a;Ar(a=kr())&&(r.cell=a.first),Ar(a=kr())&&(r.headerCell=a.first),Ar(a=kr())&&(r.footerCell=a.first)}},inputs:{sticky:"sticky",name:["cdkColumnDef","name"],stickyEnd:"stickyEnd"},features:[vr([{provide:"MAT_SORT_HEADER_COLUMN_DEF",useExisting:t}]),Ps]}),e})();class SR{constructor(e,s){s.nativeElement.classList.add(...e._columnCssClassName)}}let IR=(()=>{var t;class e extends SR{constructor(n,r){super(n,r)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Vm),lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["cdk-header-cell"],["th","cdk-header-cell",""]],hostAttrs:["role","columnheader",1,"cdk-header-cell"],features:[Ps]}),e})(),TR=(()=>{var t;class e extends SR{constructor(n,r){if(super(n,r),1===n._table?._elementRef.nativeElement.nodeType){const i=n._table._elementRef.nativeElement.getAttribute("role");r.nativeElement.setAttribute("role","grid"===i||"treegrid"===i?"gridcell":"cell")}}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Vm),lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["cdk-cell"],["td","cdk-cell",""]],hostAttrs:[1,"cdk-cell"],features:[Ps]}),e})();class uV{constructor(){this.tasks=[],this.endTasks=[]}}const AR=new Zn("_COALESCED_STYLE_SCHEDULER");let dV=(()=>{var t;class e{constructor(n){this._ngZone=n,this._currentSchedule=null,this._destroyed=new Bt}schedule(n){this._createScheduleIfNeeded(),this._currentSchedule.tasks.push(n)}scheduleEnd(n){this._createScheduleIfNeeded(),this._currentSchedule.endTasks.push(n)}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete()}_createScheduleIfNeeded(){this._currentSchedule||(this._currentSchedule=new uV,this._getScheduleObservable().pipe(fo(this._destroyed)).subscribe(()=>{for(;this._currentSchedule.tasks.length||this._currentSchedule.endTasks.length;){const n=this._currentSchedule;this._currentSchedule=new uV;for(const r of n.tasks)r();for(const r of n.endTasks)r()}this._currentSchedule=null}))}_getScheduleObservable(){return this._ngZone.isStable?Hi(Promise.resolve(void 0)):this._ngZone.onStable.pipe($l(1))}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Gs))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})(),kR=(()=>{var t;class e{constructor(n,r){this.template=n,this._differs=r}ngOnChanges(n){if(!this._columnsDiffer){const r=n.columns&&n.columns.currentValue||[];this._columnsDiffer=this._differs.find(r).create(),this._columnsDiffer.diff(r)}}getColumnsDiff(){return this._columnsDiffer.diff(this.columns)}extractCellTemplate(n){return this instanceof IC?n.headerCell.template:this instanceof TC?n.footerCell.template:n.cell.template}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc),lt(Om))},t.\u0275dir=Gn({type:t,features:[Ia]}),e})();class BQ extends kR{}const VQ=DR(BQ);let IC=(()=>{var t;class e extends VQ{constructor(n,r,i){super(n,r),this._table=i}ngOnChanges(n){super.ngOnChanges(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc),lt(Om),lt(Ob,8))},t.\u0275dir=Gn({type:t,selectors:[["","cdkHeaderRowDef",""]],inputs:{columns:["cdkHeaderRowDef","columns"],sticky:["cdkHeaderRowDefSticky","sticky"]},features:[Ps,Ia]}),e})();class UQ extends kR{}const zQ=DR(UQ);let TC=(()=>{var t;class e extends zQ{constructor(n,r,i){super(n,r),this._table=i}ngOnChanges(n){super.ngOnChanges(n)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc),lt(Om),lt(Ob,8))},t.\u0275dir=Gn({type:t,selectors:[["","cdkFooterRowDef",""]],inputs:{columns:["cdkFooterRowDef","columns"],sticky:["cdkFooterRowDefSticky","sticky"]},features:[Ps,Ia]}),e})(),fI=(()=>{var t;class e extends kR{constructor(n,r,i){super(n,r),this._table=i}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc),lt(Om),lt(Ob,8))},t.\u0275dir=Gn({type:t,selectors:[["","cdkRowDef",""]],inputs:{columns:["cdkRowDefColumns","columns"],when:["cdkRowDefWhen","when"]},features:[Ps]}),e})(),Um=(()=>{var t;class e{constructor(n){this._viewContainer=n,e.mostRecentCellOutlet=this}ngOnDestroy(){e.mostRecentCellOutlet===this&&(e.mostRecentCellOutlet=null)}}return(t=e).mostRecentCellOutlet=null,t.\u0275fac=function(n){return new(n||t)(lt(jc))},t.\u0275dir=Gn({type:t,selectors:[["","cdkCellOutlet",""]]}),e})(),OR=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275cmp=sr({type:t,selectors:[["cdk-header-row"],["tr","cdk-header-row",""]],hostAttrs:["role","row",1,"cdk-header-row"],decls:1,vars:0,consts:[["cdkCellOutlet",""]],template:function(n,r){1&n&&Nd(0,0)},dependencies:[Um],encapsulation:2}),e})(),NR=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275cmp=sr({type:t,selectors:[["cdk-row"],["tr","cdk-row",""]],hostAttrs:["role","row",1,"cdk-row"],decls:1,vars:0,consts:[["cdkCellOutlet",""]],template:function(n,r){1&n&&Nd(0,0)},dependencies:[Um],encapsulation:2}),e})(),mI=(()=>{var t;class e{constructor(n){this.templateRef=n,this._contentClassName="cdk-no-data-row"}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Hc))},t.\u0275dir=Gn({type:t,selectors:[["ng-template","cdkNoDataRow",""]]}),e})();const hV=["top","bottom","left","right"];class WQ{constructor(e,s,n,r,i=!0,a=!0,c){this._isNativeHtmlTable=e,this._stickCellCss=s,this.direction=n,this._coalescedStyleScheduler=r,this._isBrowser=i,this._needsPositionStickyOnElement=a,this._positionListener=c,this._cachedCellWidths=[],this._borderCellCss={top:`${s}-border-elem-top`,bottom:`${s}-border-elem-bottom`,left:`${s}-border-elem-left`,right:`${s}-border-elem-right`}}clearStickyPositioning(e,s){const n=[];for(const r of e)if(r.nodeType===r.ELEMENT_NODE){n.push(r);for(let i=0;i<r.children.length;i++)n.push(r.children[i])}this._coalescedStyleScheduler.schedule(()=>{for(const r of n)this._removeStickyStyle(r,s)})}updateStickyColumns(e,s,n,r=!0){if(!e.length||!this._isBrowser||!s.some(Y=>Y)&&!n.some(Y=>Y))return void(this._positionListener&&(this._positionListener.stickyColumnsUpdated({sizes:[]}),this._positionListener.stickyEndColumnsUpdated({sizes:[]})));const i=e[0],a=i.children.length,c=this._getCellWidths(i,r),f=this._getStickyStartColumnPositions(c,s),g=this._getStickyEndColumnPositions(c,n),E=s.lastIndexOf(!0),A=n.indexOf(!0);this._coalescedStyleScheduler.schedule(()=>{const Y="rtl"===this.direction,ne=Y?"right":"left",Ee=Y?"left":"right";for(const Ge of e)for(let tt=0;tt<a;tt++){const Nt=Ge.children[tt];s[tt]&&this._addStickyStyle(Nt,ne,f[tt],tt===E),n[tt]&&this._addStickyStyle(Nt,Ee,g[tt],tt===A)}this._positionListener&&(this._positionListener.stickyColumnsUpdated({sizes:-1===E?[]:c.slice(0,E+1).map((Ge,tt)=>s[tt]?Ge:null)}),this._positionListener.stickyEndColumnsUpdated({sizes:-1===A?[]:c.slice(A).map((Ge,tt)=>n[tt+A]?Ge:null).reverse()}))})}stickRows(e,s,n){if(!this._isBrowser)return;const r="bottom"===n?e.slice().reverse():e,i="bottom"===n?s.slice().reverse():s,a=[],c=[],f=[];for(let E=0,A=0;E<r.length;E++){if(!i[E])continue;a[E]=A;const Y=r[E];f[E]=this._isNativeHtmlTable?Array.from(Y.children):[Y];const ne=Y.getBoundingClientRect().height;A+=ne,c[E]=ne}const g=i.lastIndexOf(!0);this._coalescedStyleScheduler.schedule(()=>{for(let E=0;E<r.length;E++){if(!i[E])continue;const A=a[E],Y=E===g;for(const ne of f[E])this._addStickyStyle(ne,n,A,Y)}"top"===n?this._positionListener?.stickyHeaderRowsUpdated({sizes:c,offsets:a,elements:f}):this._positionListener?.stickyFooterRowsUpdated({sizes:c,offsets:a,elements:f})})}updateStickyFooterContainer(e,s){if(!this._isNativeHtmlTable)return;const n=e.querySelector("tfoot");this._coalescedStyleScheduler.schedule(()=>{s.some(r=>!r)?this._removeStickyStyle(n,["bottom"]):this._addStickyStyle(n,"bottom",0,!1)})}_removeStickyStyle(e,s){for(const r of s)e.style[r]="",e.classList.remove(this._borderCellCss[r]);hV.some(r=>-1===s.indexOf(r)&&e.style[r])?e.style.zIndex=this._getCalculatedZIndex(e):(e.style.zIndex="",this._needsPositionStickyOnElement&&(e.style.position=""),e.classList.remove(this._stickCellCss))}_addStickyStyle(e,s,n,r){e.classList.add(this._stickCellCss),r&&e.classList.add(this._borderCellCss[s]),e.style[s]=`${n}px`,e.style.zIndex=this._getCalculatedZIndex(e),this._needsPositionStickyOnElement&&(e.style.cssText+="position: -webkit-sticky; position: sticky; ")}_getCalculatedZIndex(e){const s={top:100,bottom:10,left:1,right:1};let n=0;for(const r of hV)e.style[r]&&(n+=s[r]);return n?`${n}`:""}_getCellWidths(e,s=!0){if(!s&&this._cachedCellWidths.length)return this._cachedCellWidths;const n=[],r=e.children;for(let i=0;i<r.length;i++)n.push(r[i].getBoundingClientRect().width);return this._cachedCellWidths=n,n}_getStickyStartColumnPositions(e,s){const n=[];let r=0;for(let i=0;i<e.length;i++)s[i]&&(n[i]=r,r+=e[i]);return n}_getStickyEndColumnPositions(e,s){const n=[];let r=0;for(let i=e.length;i>0;i--)s[i]&&(n[i]=r,r+=e[i]);return n}}const MR=new Zn("CDK_SPL");let gI=(()=>{var t;class e{constructor(n,r){this.viewContainer=n,this.elementRef=r}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["","rowOutlet",""]]}),e})(),_I=(()=>{var t;class e{constructor(n,r){this.viewContainer=n,this.elementRef=r}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["","headerRowOutlet",""]]}),e})(),yI=(()=>{var t;class e{constructor(n,r){this.viewContainer=n,this.elementRef=r}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["","footerRowOutlet",""]]}),e})(),vI=(()=>{var t;class e{constructor(n,r){this.viewContainer=n,this.elementRef=r}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(jc),lt(yr))},t.\u0275dir=Gn({type:t,selectors:[["","noDataRowOutlet",""]]}),e})(),bI=(()=>{var t;class e{get trackBy(){return this._trackByFn}set trackBy(n){this._trackByFn=n}get dataSource(){return this._dataSource}set dataSource(n){this._dataSource!==n&&this._switchDataSource(n)}get multiTemplateDataRows(){return this._multiTemplateDataRows}set multiTemplateDataRows(n){this._multiTemplateDataRows=Yr(n),this._rowOutlet&&this._rowOutlet.viewContainer.length&&(this._forceRenderDataRows(),this.updateStickyColumnStyles())}get fixedLayout(){return this._fixedLayout}set fixedLayout(n){this._fixedLayout=Yr(n),this._forceRecalculateCellWidths=!0,this._stickyColumnStylesNeedReset=!0}constructor(n,r,i,a,c,f,g,E,A,Y,ne,Ee){this._differs=n,this._changeDetectorRef=r,this._elementRef=i,this._dir=c,this._platform=g,this._viewRepeater=E,this._coalescedStyleScheduler=A,this._viewportRuler=Y,this._stickyPositioningListener=ne,this._ngZone=Ee,this._onDestroy=new Bt,this._columnDefsByName=new Map,this._customColumnDefs=new Set,this._customRowDefs=new Set,this._customHeaderRowDefs=new Set,this._customFooterRowDefs=new Set,this._headerRowDefChanged=!0,this._footerRowDefChanged=!0,this._stickyColumnStylesNeedReset=!0,this._forceRecalculateCellWidths=!0,this._cachedRenderRowsMap=new Map,this.stickyCssClass="cdk-table-sticky",this.needsPositionStickyOnElement=!0,this._isShowingNoDataRow=!1,this._multiTemplateDataRows=!1,this._fixedLayout=!1,this.contentChanged=new Rr,this.viewChange=new Di({start:0,end:Number.MAX_VALUE}),a||this._elementRef.nativeElement.setAttribute("role","table"),this._document=f,this._isNativeHtmlTable="TABLE"===this._elementRef.nativeElement.nodeName}ngOnInit(){this._setupStickyStyler(),this._isNativeHtmlTable&&this._applyNativeTableSections(),this._dataDiffer=this._differs.find([]).create((n,r)=>this.trackBy?this.trackBy(r.dataIndex,r.data):r),this._viewportRuler.change().pipe(fo(this._onDestroy)).subscribe(()=>{this._forceRecalculateCellWidths=!0})}ngAfterContentChecked(){this._cacheRowDefs(),this._cacheColumnDefs();const r=this._renderUpdatedColumns()||this._headerRowDefChanged||this._footerRowDefChanged;this._stickyColumnStylesNeedReset=this._stickyColumnStylesNeedReset||r,this._forceRecalculateCellWidths=r,this._headerRowDefChanged&&(this._forceRenderHeaderRows(),this._headerRowDefChanged=!1),this._footerRowDefChanged&&(this._forceRenderFooterRows(),this._footerRowDefChanged=!1),this.dataSource&&this._rowDefs.length>0&&!this._renderChangeSubscription?this._observeRenderChanges():this._stickyColumnStylesNeedReset&&this.updateStickyColumnStyles(),this._checkStickyStates()}ngOnDestroy(){[this._rowOutlet.viewContainer,this._headerRowOutlet.viewContainer,this._footerRowOutlet.viewContainer,this._cachedRenderRowsMap,this._customColumnDefs,this._customRowDefs,this._customHeaderRowDefs,this._customFooterRowDefs,this._columnDefsByName].forEach(n=>{n.clear()}),this._headerRowDefs=[],this._footerRowDefs=[],this._defaultRowDef=null,this._onDestroy.next(),this._onDestroy.complete(),cR(this.dataSource)&&this.dataSource.disconnect(this)}renderRows(){this._renderRows=this._getAllRenderRows();const n=this._dataDiffer.diff(this._renderRows);if(!n)return this._updateNoDataRow(),void this.contentChanged.next();const r=this._rowOutlet.viewContainer;this._viewRepeater.applyChanges(n,r,(i,a,c)=>this._getEmbeddedViewArgs(i.item,c),i=>i.item.data,i=>{1===i.operation&&i.context&&this._renderCellTemplateForItem(i.record.item.rowDef,i.context)}),this._updateRowIndexContext(),n.forEachIdentityChange(i=>{r.get(i.currentIndex).context.$implicit=i.item.data}),this._updateNoDataRow(),this._ngZone&&Gs.isInAngularZone()?this._ngZone.onStable.pipe($l(1),fo(this._onDestroy)).subscribe(()=>{this.updateStickyColumnStyles()}):this.updateStickyColumnStyles(),this.contentChanged.next()}addColumnDef(n){this._customColumnDefs.add(n)}removeColumnDef(n){this._customColumnDefs.delete(n)}addRowDef(n){this._customRowDefs.add(n)}removeRowDef(n){this._customRowDefs.delete(n)}addHeaderRowDef(n){this._customHeaderRowDefs.add(n),this._headerRowDefChanged=!0}removeHeaderRowDef(n){this._customHeaderRowDefs.delete(n),this._headerRowDefChanged=!0}addFooterRowDef(n){this._customFooterRowDefs.add(n),this._footerRowDefChanged=!0}removeFooterRowDef(n){this._customFooterRowDefs.delete(n),this._footerRowDefChanged=!0}setNoDataRow(n){this._customNoDataRow=n}updateStickyHeaderRowStyles(){const n=this._getRenderedRows(this._headerRowOutlet),i=this._elementRef.nativeElement.querySelector("thead");i&&(i.style.display=n.length?"":"none");const a=this._headerRowDefs.map(c=>c.sticky);this._stickyStyler.clearStickyPositioning(n,["top"]),this._stickyStyler.stickRows(n,a,"top"),this._headerRowDefs.forEach(c=>c.resetStickyChanged())}updateStickyFooterRowStyles(){const n=this._getRenderedRows(this._footerRowOutlet),i=this._elementRef.nativeElement.querySelector("tfoot");i&&(i.style.display=n.length?"":"none");const a=this._footerRowDefs.map(c=>c.sticky);this._stickyStyler.clearStickyPositioning(n,["bottom"]),this._stickyStyler.stickRows(n,a,"bottom"),this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement,a),this._footerRowDefs.forEach(c=>c.resetStickyChanged())}updateStickyColumnStyles(){const n=this._getRenderedRows(this._headerRowOutlet),r=this._getRenderedRows(this._rowOutlet),i=this._getRenderedRows(this._footerRowOutlet);(this._isNativeHtmlTable&&!this._fixedLayout||this._stickyColumnStylesNeedReset)&&(this._stickyStyler.clearStickyPositioning([...n,...r,...i],["left","right"]),this._stickyColumnStylesNeedReset=!1),n.forEach((a,c)=>{this._addStickyColumnStyles([a],this._headerRowDefs[c])}),this._rowDefs.forEach(a=>{const c=[];for(let f=0;f<r.length;f++)this._renderRows[f].rowDef===a&&c.push(r[f]);this._addStickyColumnStyles(c,a)}),i.forEach((a,c)=>{this._addStickyColumnStyles([a],this._footerRowDefs[c])}),Array.from(this._columnDefsByName.values()).forEach(a=>a.resetStickyChanged())}_getAllRenderRows(){const n=[],r=this._cachedRenderRowsMap;this._cachedRenderRowsMap=new Map;for(let i=0;i<this._data.length;i++){let a=this._data[i];const c=this._getRenderRowsForData(a,i,r.get(a));this._cachedRenderRowsMap.has(a)||this._cachedRenderRowsMap.set(a,new WeakMap);for(let f=0;f<c.length;f++){let g=c[f];const E=this._cachedRenderRowsMap.get(g.data);E.has(g.rowDef)?E.get(g.rowDef).push(g):E.set(g.rowDef,[g]),n.push(g)}}return n}_getRenderRowsForData(n,r,i){return this._getRowDefs(n,r).map(c=>{const f=i&&i.has(c)?i.get(c):[];if(f.length){const g=f.shift();return g.dataIndex=r,g}return{data:n,rowDef:c,dataIndex:r}})}_cacheColumnDefs(){this._columnDefsByName.clear(),xI(this._getOwnDefs(this._contentColumnDefs),this._customColumnDefs).forEach(r=>{this._columnDefsByName.has(r.name),this._columnDefsByName.set(r.name,r)})}_cacheRowDefs(){this._headerRowDefs=xI(this._getOwnDefs(this._contentHeaderRowDefs),this._customHeaderRowDefs),this._footerRowDefs=xI(this._getOwnDefs(this._contentFooterRowDefs),this._customFooterRowDefs),this._rowDefs=xI(this._getOwnDefs(this._contentRowDefs),this._customRowDefs);const n=this._rowDefs.filter(r=>!r.when);this._defaultRowDef=n[0]}_renderUpdatedColumns(){const n=(c,f)=>c||!!f.getColumnsDiff(),r=this._rowDefs.reduce(n,!1);r&&this._forceRenderDataRows();const i=this._headerRowDefs.reduce(n,!1);i&&this._forceRenderHeaderRows();const a=this._footerRowDefs.reduce(n,!1);return a&&this._forceRenderFooterRows(),r||i||a}_switchDataSource(n){this._data=[],cR(this.dataSource)&&this.dataSource.disconnect(this),this._renderChangeSubscription&&(this._renderChangeSubscription.unsubscribe(),this._renderChangeSubscription=null),n||(this._dataDiffer&&this._dataDiffer.diff([]),this._rowOutlet.viewContainer.clear()),this._dataSource=n}_observeRenderChanges(){if(!this.dataSource)return;let n;cR(this.dataSource)?n=this.dataSource.connect(this):r$(this.dataSource)?n=this.dataSource:Array.isArray(this.dataSource)&&(n=Xs(this.dataSource)),this._renderChangeSubscription=n.pipe(fo(this._onDestroy)).subscribe(r=>{this._data=r||[],this.renderRows()})}_forceRenderHeaderRows(){this._headerRowOutlet.viewContainer.length>0&&this._headerRowOutlet.viewContainer.clear(),this._headerRowDefs.forEach((n,r)=>this._renderRow(this._headerRowOutlet,n,r)),this.updateStickyHeaderRowStyles()}_forceRenderFooterRows(){this._footerRowOutlet.viewContainer.length>0&&this._footerRowOutlet.viewContainer.clear(),this._footerRowDefs.forEach((n,r)=>this._renderRow(this._footerRowOutlet,n,r)),this.updateStickyFooterRowStyles()}_addStickyColumnStyles(n,r){const i=Array.from(r.columns||[]).map(f=>this._columnDefsByName.get(f)),a=i.map(f=>f.sticky),c=i.map(f=>f.stickyEnd);this._stickyStyler.updateStickyColumns(n,a,c,!this._fixedLayout||this._forceRecalculateCellWidths)}_getRenderedRows(n){const r=[];for(let i=0;i<n.viewContainer.length;i++){const a=n.viewContainer.get(i);r.push(a.rootNodes[0])}return r}_getRowDefs(n,r){if(1==this._rowDefs.length)return[this._rowDefs[0]];let i=[];if(this.multiTemplateDataRows)i=this._rowDefs.filter(a=>!a.when||a.when(r,n));else{let a=this._rowDefs.find(c=>c.when&&c.when(r,n))||this._defaultRowDef;a&&i.push(a)}return i}_getEmbeddedViewArgs(n,r){return{templateRef:n.rowDef.template,context:{$implicit:n.data},index:r}}_renderRow(n,r,i,a={}){const c=n.viewContainer.createEmbeddedView(r.template,a,i);return this._renderCellTemplateForItem(r,a),c}_renderCellTemplateForItem(n,r){for(let i of this._getCellTemplates(n))Um.mostRecentCellOutlet&&Um.mostRecentCellOutlet._viewContainer.createEmbeddedView(i,r);this._changeDetectorRef.markForCheck()}_updateRowIndexContext(){const n=this._rowOutlet.viewContainer;for(let r=0,i=n.length;r<i;r++){const c=n.get(r).context;c.count=i,c.first=0===r,c.last=r===i-1,c.even=r%2==0,c.odd=!c.even,this.multiTemplateDataRows?(c.dataIndex=this._renderRows[r].dataIndex,c.renderIndex=r):c.index=this._renderRows[r].dataIndex}}_getCellTemplates(n){return n&&n.columns?Array.from(n.columns,r=>{const i=this._columnDefsByName.get(r);return n.extractCellTemplate(i)}):[]}_applyNativeTableSections(){const n=this._document.createDocumentFragment(),r=[{tag:"thead",outlets:[this._headerRowOutlet]},{tag:"tbody",outlets:[this._rowOutlet,this._noDataRowOutlet]},{tag:"tfoot",outlets:[this._footerRowOutlet]}];for(const i of r){const a=this._document.createElement(i.tag);a.setAttribute("role","rowgroup");for(const c of i.outlets)a.appendChild(c.elementRef.nativeElement);n.appendChild(a)}this._elementRef.nativeElement.appendChild(n)}_forceRenderDataRows(){this._dataDiffer.diff([]),this._rowOutlet.viewContainer.clear(),this.renderRows()}_checkStickyStates(){const n=(r,i)=>r||i.hasStickyChanged();this._headerRowDefs.reduce(n,!1)&&this.updateStickyHeaderRowStyles(),this._footerRowDefs.reduce(n,!1)&&this.updateStickyFooterRowStyles(),Array.from(this._columnDefsByName.values()).reduce(n,!1)&&(this._stickyColumnStylesNeedReset=!0,this.updateStickyColumnStyles())}_setupStickyStyler(){this._stickyStyler=new WQ(this._isNativeHtmlTable,this.stickyCssClass,this._dir?this._dir.value:"ltr",this._coalescedStyleScheduler,this._platform.isBrowser,this.needsPositionStickyOnElement,this._stickyPositioningListener),(this._dir?this._dir.change:Xs()).pipe(fo(this._onDestroy)).subscribe(r=>{this._stickyStyler.direction=r,this.updateStickyColumnStyles()})}_getOwnDefs(n){return n.filter(r=>!r._table||r._table===this)}_updateNoDataRow(){const n=this._customNoDataRow||this._noDataRow;if(!n)return;const r=0===this._rowOutlet.viewContainer.length;if(r===this._isShowingNoDataRow)return;const i=this._noDataRowOutlet.viewContainer;if(r){const a=i.createEmbeddedView(n.templateRef),c=a.rootNodes[0];1===a.rootNodes.length&&c?.nodeType===this._document.ELEMENT_NODE&&(c.setAttribute("role","row"),c.classList.add(n._contentClassName))}else i.clear();this._isShowingNoDataRow=r,this._changeDetectorRef.markForCheck()}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Om),lt(Ll),lt(yr),na("role"),lt(td,8),lt(yi),lt(wc),lt(bC),lt(AR),lt(c0),lt(MR,12),lt(Gs,8))},t.\u0275cmp=sr({type:t,selectors:[["cdk-table"],["table","cdk-table",""]],contentQueries:function(n,r,i){if(1&n&&(ea(i,mI,5),ea(i,Vm,5),ea(i,fI,5),ea(i,IC,5),ea(i,TC,5)),2&n){let a;Ar(a=kr())&&(r._noDataRow=a.first),Ar(a=kr())&&(r._contentColumnDefs=a),Ar(a=kr())&&(r._contentRowDefs=a),Ar(a=kr())&&(r._contentHeaderRowDefs=a),Ar(a=kr())&&(r._contentFooterRowDefs=a)}},viewQuery:function(n,r){if(1&n&&(qo(gI,7),qo(_I,7),qo(yI,7),qo(vI,7)),2&n){let i;Ar(i=kr())&&(r._rowOutlet=i.first),Ar(i=kr())&&(r._headerRowOutlet=i.first),Ar(i=kr())&&(r._footerRowOutlet=i.first),Ar(i=kr())&&(r._noDataRowOutlet=i.first)}},hostAttrs:["ngSkipHydration","",1,"cdk-table"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("cdk-table-fixed-layout",r.fixedLayout)},inputs:{trackBy:"trackBy",dataSource:"dataSource",multiTemplateDataRows:"multiTemplateDataRows",fixedLayout:"fixedLayout"},outputs:{contentChanged:"contentChanged"},exportAs:["cdkTable"],features:[vr([{provide:Ob,useExisting:t},{provide:bC,useClass:yB},{provide:AR,useClass:dV},{provide:MR,useValue:null}])],ngContentSelectors:NQ,decls:6,vars:0,consts:[["headerRowOutlet",""],["rowOutlet",""],["noDataRowOutlet",""],["footerRowOutlet",""]],template:function(n,r){1&n&&(Pl(RQ),ri(0),ri(1,1),Nd(2,0)(3,1)(4,2)(5,3))},dependencies:[gI,_I,yI,vI],styles:[".cdk-table-fixed-layout{table-layout:fixed}"],encapsulation:2}),e})();function xI(t,e){return t.concat(Array.from(e))}let jQ=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[bR]}),e})();const GQ=[[["caption"]],[["colgroup"],["col"]]],KQ=["caption","colgroup, col"];let fV=(()=>{var t;class e extends bI{constructor(){super(...arguments),this.stickyCssClass="mat-mdc-table-sticky",this.needsPositionStickyOnElement=!1}ngOnInit(){super.ngOnInit(),this._isNativeHtmlTable&&this._elementRef.nativeElement.querySelector("tbody").classList.add("mdc-data-table__content")}}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275cmp=sr({type:t,selectors:[["mat-table"],["table","mat-table",""]],hostAttrs:["ngSkipHydration","",1,"mat-mdc-table","mdc-data-table__table"],hostVars:2,hostBindings:function(n,r){2&n&&Ei("mdc-table-fixed-layout",r.fixedLayout)},exportAs:["matTable"],features:[vr([{provide:bI,useExisting:t},{provide:Ob,useExisting:t},{provide:AR,useClass:dV},{provide:bC,useClass:yB},{provide:MR,useValue:null}]),Ps],ngContentSelectors:KQ,decls:6,vars:0,consts:[["headerRowOutlet",""],["rowOutlet",""],["noDataRowOutlet",""],["footerRowOutlet",""]],template:function(n,r){1&n&&(Pl(GQ),ri(0),ri(1,1),Nd(2,0)(3,1)(4,2)(5,3))},dependencies:[gI,_I,yI,vI],styles:[".mat-mdc-table-sticky{position:sticky !important}.mdc-data-table{-webkit-overflow-scrolling:touch;display:inline-flex;flex-direction:column;box-sizing:border-box;position:relative}.mdc-data-table__table-container{-webkit-overflow-scrolling:touch;overflow-x:auto;width:100%}.mdc-data-table__table{min-width:100%;border:0;white-space:nowrap;border-spacing:0;table-layout:fixed}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell,.mdc-data-table__cell[dir=rtl]{text-align:right}.mdc-data-table__cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__cell--numeric,.mdc-data-table__cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__header-cell{box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mdc-data-table__header-cell,.mdc-data-table__header-cell[dir=rtl]{text-align:right}.mdc-data-table__header-cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__header-cell--numeric,.mdc-data-table__header-cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__header-cell-wrapper{align-items:center;display:inline-flex;vertical-align:middle}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px 0 16px}.mdc-data-table__header-cell--checkbox,.mdc-data-table__cell--checkbox{padding-left:4px;padding-right:0}[dir=rtl] .mdc-data-table__header-cell--checkbox,[dir=rtl] .mdc-data-table__cell--checkbox,.mdc-data-table__header-cell--checkbox[dir=rtl],.mdc-data-table__cell--checkbox[dir=rtl]{padding-left:0;padding-right:4px}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table{--mat-table-row-item-outline-width:1px;table-layout:auto;white-space:normal;background-color:var(--mat-table-background-color)}.mat-mdc-header-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-header-container-height, 56px);color:var(--mat-table-header-headline-color, rgba(0, 0, 0, 0.87));font-family:var(--mat-table-header-headline-font, Roboto, sans-serif);line-height:var(--mat-table-header-headline-line-height);font-size:var(--mat-table-header-headline-size, 14px);font-weight:var(--mat-table-header-headline-weight, 500)}.mat-mdc-row{height:var(--mat-table-row-item-container-height, 52px);color:var(--mat-table-row-item-label-text-color, rgba(0, 0, 0, 0.87))}.mat-mdc-row,.mdc-data-table__content{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-table-row-item-label-text-font, Roboto, sans-serif);line-height:var(--mat-table-row-item-label-text-line-height);font-size:var(--mat-table-row-item-label-text-size, 14px);font-weight:var(--mat-table-row-item-label-text-weight)}.mat-mdc-footer-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-footer-container-height, 52px);color:var(--mat-table-row-item-label-text-color, rgba(0, 0, 0, 0.87));font-family:var(--mat-table-footer-supporting-text-font, Roboto, sans-serif);line-height:var(--mat-table-footer-supporting-text-line-height);font-size:var(--mat-table-footer-supporting-text-size, 14px);font-weight:var(--mat-table-footer-supporting-text-weight);letter-spacing:var(--mat-table-footer-supporting-text-tracking)}.mat-mdc-header-cell{border-bottom-color:var(--mat-table-row-item-outline-color, rgba(0, 0, 0, 0.12));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-header-headline-tracking);font-weight:inherit;line-height:inherit}.mat-mdc-cell{border-bottom-color:var(--mat-table-row-item-outline-color, rgba(0, 0, 0, 0.12));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-row-item-label-text-tracking);line-height:inherit}.mdc-data-table__row:last-child .mat-mdc-cell{border-bottom:none}.mat-mdc-footer-cell{letter-spacing:var(--mat-table-row-item-label-text-tracking)}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}"],encapsulation:2}),e})(),PR=(()=>{var t;class e extends Rb{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["","matCellDef",""]],features:[vr([{provide:Rb,useExisting:t}]),Ps]}),e})(),FR=(()=>{var t;class e extends Nb{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["","matHeaderCellDef",""]],features:[vr([{provide:Nb,useExisting:t}]),Ps]}),e})(),LR=(()=>{var t;class e extends Vm{get name(){return this._name}set name(n){this._setNameInput(n)}_updateColumnCssClassName(){super._updateColumnCssClassName(),this._columnCssClassName.push(`mat-column-${this.cssClassFriendlyName}`)}}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["","matColumnDef",""]],inputs:{sticky:"sticky",name:["matColumnDef","name"]},features:[vr([{provide:Vm,useExisting:t},{provide:"MAT_SORT_HEADER_COLUMN_DEF",useExisting:t}]),Ps]}),e})(),$R=(()=>{var t;class e extends IR{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["mat-header-cell"],["th","mat-header-cell",""]],hostAttrs:["role","columnheader",1,"mat-mdc-header-cell","mdc-data-table__header-cell"],features:[Ps]}),e})(),BR=(()=>{var t;class e extends TR{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["mat-cell"],["td","mat-cell",""]],hostAttrs:[1,"mat-mdc-cell","mdc-data-table__cell"],features:[Ps]}),e})(),mV=(()=>{var t;class e extends IC{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["","matHeaderRowDef",""]],inputs:{columns:["matHeaderRowDef","columns"],sticky:["matHeaderRowDefSticky","sticky"]},features:[vr([{provide:IC,useExisting:t}]),Ps]}),e})(),gV=(()=>{var t;class e extends fI{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["","matRowDef",""]],inputs:{columns:["matRowDefColumns","columns"],when:["matRowDefWhen","when"]},features:[vr([{provide:fI,useExisting:t}]),Ps]}),e})(),_V=(()=>{var t;class e extends OR{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275cmp=sr({type:t,selectors:[["mat-header-row"],["tr","mat-header-row",""]],hostAttrs:["role","row",1,"mat-mdc-header-row","mdc-data-table__header-row"],exportAs:["matHeaderRow"],features:[vr([{provide:OR,useExisting:t}]),Ps],decls:1,vars:0,consts:[["cdkCellOutlet",""]],template:function(n,r){1&n&&Nd(0,0)},dependencies:[Um],encapsulation:2}),e})(),yV=(()=>{var t;class e extends NR{}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275cmp=sr({type:t,selectors:[["mat-row"],["tr","mat-row",""]],hostAttrs:["role","row",1,"mat-mdc-row","mdc-data-table__row"],exportAs:["matRow"],features:[vr([{provide:NR,useExisting:t}]),Ps],decls:1,vars:0,consts:[["cdkCellOutlet",""]],template:function(n,r){1&n&&Nd(0,0)},dependencies:[Um],encapsulation:2}),e})(),vV=(()=>{var t;class e extends mI{constructor(){super(...arguments),this._contentClassName="mat-mdc-no-data-row"}}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["ng-template","matNoDataRow",""]],features:[vr([{provide:mI,useExisting:t}]),Ps]}),e})(),tJ=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,jQ,nl]}),e})();class sJ extends pX{get data(){return this._data.value}set data(e){e=Array.isArray(e)?e:[],this._data.next(e),this._renderChangesSubscription||this._filterData(e)}get filter(){return this._filter.value}set filter(e){this._filter.next(e),this._renderChangesSubscription||this._filterData(this.data)}get sort(){return this._sort}set sort(e){this._sort=e,this._updateChangeSubscription()}get paginator(){return this._paginator}set paginator(e){this._paginator=e,this._updateChangeSubscription()}constructor(e=[]){super(),this._renderData=new Di([]),this._filter=new Di(""),this._internalPageChanges=new Bt,this._renderChangesSubscription=null,this.sortingDataAccessor=(s,n)=>{const r=s[n];if(y3(r)){const i=Number(r);return i<9007199254740991?i:r}return r},this.sortData=(s,n)=>{const r=n.active,i=n.direction;return r&&""!=i?s.sort((a,c)=>{let f=this.sortingDataAccessor(a,r),g=this.sortingDataAccessor(c,r);const E=typeof f,A=typeof g;E!==A&&("number"===E&&(f+=""),"number"===A&&(g+=""));let Y=0;return null!=f&&null!=g?f>g?Y=1:f<g&&(Y=-1):null!=f?Y=1:null!=g&&(Y=-1),Y*("asc"==i?1:-1)}):s},this.filterPredicate=(s,n)=>{const r=Object.keys(s).reduce((a,c)=>a+s[c]+"\u25ec","").toLowerCase(),i=n.trim().toLowerCase();return-1!=r.indexOf(i)},this._data=new Di(e),this._updateChangeSubscription()}_updateChangeSubscription(){const e=this._sort?ji(this._sort.sortChange,this._sort.initialized):Xs(null),s=this._paginator?ji(this._paginator.page,this._internalPageChanges,this._paginator.initialized):Xs(null),r=qy([this._data,this._filter]).pipe(Xn(([c])=>this._filterData(c))),i=qy([r,e]).pipe(Xn(([c])=>this._orderData(c))),a=qy([i,s]).pipe(Xn(([c])=>this._pageData(c)));this._renderChangesSubscription?.unsubscribe(),this._renderChangesSubscription=a.subscribe(c=>this._renderData.next(c))}_filterData(e){return this.filteredData=null==this.filter||""===this.filter?e:e.filter(s=>this.filterPredicate(s,this.filter)),this.paginator&&this._updatePaginator(this.filteredData.length),this.filteredData}_orderData(e){return this.sort?this.sortData(e.slice(),this.sort):e}_pageData(e){if(!this.paginator)return e;const s=this.paginator.pageIndex*this.paginator.pageSize;return e.slice(s,s+this.paginator.pageSize)}_updatePaginator(e){Promise.resolve().then(()=>{const s=this.paginator;if(s&&(s.length=e,s.pageIndex>0)){const n=Math.ceil(s.length/s.pageSize)-1||0,r=Math.min(s.pageIndex,n);r!==s.pageIndex&&(s.pageIndex=r,this._internalPageChanges.next())}})}connect(){return this._renderChangesSubscription||this._updateChangeSubscription(),this._renderData}disconnect(){this._renderChangesSubscription?.unsubscribe(),this._renderChangesSubscription=null}}class rJ extends sJ{}let VR=(()=>{var t;class e{constructor(){this.selectedTrackSubject=new Di(null),this.trackRequestSubject=new Di(!1)}getTrackRequest(){return this.trackRequestSubject.asObservable()}requestRandomTrack(){this.trackRequestSubject.next(!0)}setSelectedTrack(n){this.selectedTrackSubject.next(n)}getSelectedTrack(){return this.selectedTrackSubject.asObservable()}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const bV=Lm({passive:!0});let iJ=(()=>{var t;class e{constructor(n,r){this._platform=n,this._ngZone=r,this._monitoredElements=new Map}monitor(n){if(!this._platform.isBrowser)return so;const r=cu(n),i=this._monitoredElements.get(r);if(i)return i.subject;const a=new Bt,c="cdk-text-field-autofilled",f=g=>{"cdk-text-field-autofill-start"!==g.animationName||r.classList.contains(c)?"cdk-text-field-autofill-end"===g.animationName&&r.classList.contains(c)&&(r.classList.remove(c),this._ngZone.run(()=>a.next({target:g.target,isAutofilled:!1}))):(r.classList.add(c),this._ngZone.run(()=>a.next({target:g.target,isAutofilled:!0})))};return this._ngZone.runOutsideAngular(()=>{r.addEventListener("animationstart",f,bV),r.classList.add("cdk-text-field-autofill-monitored")}),this._monitoredElements.set(r,{subject:a,unlisten:()=>{r.removeEventListener("animationstart",f,bV)}}),a}stopMonitoring(n){const r=cu(n),i=this._monitoredElements.get(r);i&&(i.unlisten(),i.subject.complete(),r.classList.remove("cdk-text-field-autofill-monitored"),r.classList.remove("cdk-text-field-autofilled"),this._monitoredElements.delete(r))}ngOnDestroy(){this._monitoredElements.forEach((n,r)=>this.stopMonitoring(r))}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(wc),cn(Gs))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})(),oJ=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({}),e})();const aJ=new Zn("MAT_INPUT_VALUE_ACCESSOR"),lJ=["button","checkbox","file","hidden","image","radio","range","reset","submit"];let cJ=0;const uJ=QO(class{constructor(t,e,s,n){this._defaultErrorStateMatcher=t,this._parentForm=e,this._parentFormGroup=s,this.ngControl=n,this.stateChanges=new Bt}});let dJ=(()=>{var t;class e extends uJ{get disabled(){return this._disabled}set disabled(n){this._disabled=Yr(n),this.focused&&(this.focused=!1,this.stateChanges.next())}get id(){return this._id}set id(n){this._id=n||this._uid}get required(){return this._required??this.ngControl?.control?.hasValidator(z2.required)??!1}set required(n){this._required=Yr(n)}get type(){return this._type}set type(n){this._type=n||"text",this._validateType(),!this._isTextarea&&d3().has(this._type)&&(this._elementRef.nativeElement.type=this._type)}get value(){return this._inputValueAccessor.value}set value(n){n!==this.value&&(this._inputValueAccessor.value=n,this.stateChanges.next())}get readonly(){return this._readonly}set readonly(n){this._readonly=Yr(n)}constructor(n,r,i,a,c,f,g,E,A,Y){super(f,a,c,i),this._elementRef=n,this._platform=r,this._autofillMonitor=E,this._formField=Y,this._uid="mat-input-"+cJ++,this.focused=!1,this.stateChanges=new Bt,this.controlType="mat-input",this.autofilled=!1,this._disabled=!1,this._type="text",this._readonly=!1,this._neverEmptyInputTypes=["date","datetime","datetime-local","month","time","week"].filter(Ge=>d3().has(Ge)),this._iOSKeyupListener=Ge=>{const tt=Ge.target;!tt.value&&0===tt.selectionStart&&0===tt.selectionEnd&&(tt.setSelectionRange(1,1),tt.setSelectionRange(0,0))};const ne=this._elementRef.nativeElement,Ee=ne.nodeName.toLowerCase();this._inputValueAccessor=g||ne,this._previousNativeValue=this.value,this.id=this.id,r.IOS&&A.runOutsideAngular(()=>{n.nativeElement.addEventListener("keyup",this._iOSKeyupListener)}),this._isServer=!this._platform.isBrowser,this._isNativeSelect="select"===Ee,this._isTextarea="textarea"===Ee,this._isInFormField=!!Y,this._isNativeSelect&&(this.controlType=ne.multiple?"mat-native-select-multiple":"mat-native-select")}ngAfterViewInit(){this._platform.isBrowser&&this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(n=>{this.autofilled=n.isAutofilled,this.stateChanges.next()})}ngOnChanges(){this.stateChanges.next()}ngOnDestroy(){this.stateChanges.complete(),this._platform.isBrowser&&this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement),this._platform.IOS&&this._elementRef.nativeElement.removeEventListener("keyup",this._iOSKeyupListener)}ngDoCheck(){this.ngControl&&(this.updateErrorState(),null!==this.ngControl.disabled&&this.ngControl.disabled!==this.disabled&&(this.disabled=this.ngControl.disabled,this.stateChanges.next())),this._dirtyCheckNativeValue(),this._dirtyCheckPlaceholder()}focus(n){this._elementRef.nativeElement.focus(n)}_focusChanged(n){n!==this.focused&&(this.focused=n,this.stateChanges.next())}_onInput(){}_dirtyCheckNativeValue(){const n=this._elementRef.nativeElement.value;this._previousNativeValue!==n&&(this._previousNativeValue=n,this.stateChanges.next())}_dirtyCheckPlaceholder(){const n=this._getPlaceholder();if(n!==this._previousPlaceholder){const r=this._elementRef.nativeElement;this._previousPlaceholder=n,n?r.setAttribute("placeholder",n):r.removeAttribute("placeholder")}}_getPlaceholder(){return this.placeholder||null}_validateType(){lJ.indexOf(this._type)}_isNeverEmpty(){return this._neverEmptyInputTypes.indexOf(this._type)>-1}_isBadInput(){let n=this._elementRef.nativeElement.validity;return n&&n.badInput}get empty(){return!(this._isNeverEmpty()||this._elementRef.nativeElement.value||this._isBadInput()||this.autofilled)}get shouldLabelFloat(){if(this._isNativeSelect){const n=this._elementRef.nativeElement,r=n.options[0];return this.focused||n.multiple||!this.empty||!!(n.selectedIndex>-1&&r&&r.label)}return this.focused||!this.empty}setDescribedByIds(n){n.length?this._elementRef.nativeElement.setAttribute("aria-describedby",n.join(" ")):this._elementRef.nativeElement.removeAttribute("aria-describedby")}onContainerClick(){this.focused||this.focus()}_isInlineSelect(){const n=this._elementRef.nativeElement;return this._isNativeSelect&&(n.multiple||n.size>1)}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(wc),lt(Kp,10),lt(ob,8),lt(ab,8),lt(VS),lt(aJ,10),lt(iJ),lt(Gs),lt(SC,8))},t.\u0275dir=Gn({type:t,selectors:[["input","matInput",""],["textarea","matInput",""],["select","matNativeControl",""],["input","matNativeControl",""],["textarea","matNativeControl",""]],hostAttrs:[1,"mat-mdc-input-element"],hostVars:18,hostBindings:function(n,r){1&n&&qs("focus",function(){return r._focusChanged(!0)})("blur",function(){return r._focusChanged(!1)})("input",function(){return r._onInput()}),2&n&&(ih("id",r.id)("disabled",r.disabled)("required",r.required),si("name",r.name||null)("readonly",r.readonly&&!r._isNativeSelect||null)("aria-invalid",r.empty&&r.required?null:r.errorState)("aria-required",r.required)("id",r.id),Ei("mat-input-server",r._isServer)("mat-mdc-form-field-textarea-control",r._isInFormField&&r._isTextarea)("mat-mdc-form-field-input-control",r._isInFormField)("mdc-text-field__input",r._isInFormField)("mat-mdc-native-select-inline",r._isInlineSelect()))},inputs:{disabled:"disabled",id:"id",placeholder:"placeholder",name:"name",required:"required",type:"type",errorStateMatcher:"errorStateMatcher",userAriaDescribedBy:["aria-describedby","userAriaDescribedBy"],value:"value",readonly:"readonly"},exportAs:["matInput"],features:[vr([{provide:cI,useExisting:t}]),Ps,Ia]}),e})(),hJ=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[nl,uI,uI,oJ,nl]}),e})(),pJ=(()=>{var t;class e{transform(n){return n.split(/(?=[A-Z])/).map(a=>a.charAt(0).toUpperCase()+a.slice(1)).join(" ")}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275pipe=bl({name:"camelCaseToTitle",type:t,pure:!0}),e})(),xV=(()=>{var t;class e{transform(n){if(!n||isNaN(n))return"00:00.000";const r=Math.floor(n/60),i=Math.floor(n%60),a=Math.floor(n%1*1e3);return`${r.toString().padStart(2,"0")}:${i.toString().padStart(2,"0")}.${a.toString().padStart(3,"0")}`}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275pipe=bl({name:"formatTime",type:t,pure:!0}),e})();function fJ(t,e){if(1&t&&(yn(0,"th",19),Ys(1),Cw(2,"camelCaseToTitle"),In()),2&t){const s=bs().$implicit;Un(1),pd(" ",Ew(2,1,s)," ")}}function mJ(t,e){if(1&t&&(dd(0),yn(1,"span"),Ys(2),In(),hd()),2&t){const s=bs().$implicit,n=bs().$implicit,r=bs();Un(2),zu(r.formatArray(s[n]))}}function gJ(t,e){if(1&t&&(yn(0,"span"),Ys(1),Cw(2,"formatTime"),In()),2&t){const s=bs(2).$implicit,n=bs().$implicit;Un(1),zu(Ew(2,1,s[n]))}}function _J(t,e){if(1&t&&(yn(0,"a",25),Ys(1),In()),2&t){const s=bs(3).$implicit,n=bs().$implicit;Yn("href",s.sourceLink,uy),Un(1),zu(s[n])}}function yJ(t,e){if(1&t&&(yn(0,"span"),Ys(1),In()),2&t){const s=bs(3).$implicit,n=bs().$implicit;Un(1),zu(s[n])}}function vJ(t,e){if(1&t&&(yn(0,"span"),Fs(1,_J,2,2,"a",24),Fs(2,yJ,2,1,"span",23),In()),2&t){const s=bs(2).$implicit;Un(1),Yn("ngIf",s.sourceLink),Un(1),Yn("ngIf",!s.sourceLink)}}function bJ(t,e){if(1&t&&(yn(0,"span"),Ys(1),In()),2&t){const s=bs(2).$implicit,n=bs().$implicit;Un(1),zu(s[n])}}function xJ(t,e){if(1&t&&(Fs(0,gJ,3,3,"span",23),Fs(1,vJ,3,2,"span",23),Fs(2,bJ,2,1,"span",23)),2&t){const s=bs(2).$implicit;Yn("ngIf","duration"===s),Un(1),Yn("ngIf","author"===s),Un(1),Yn("ngIf","duration"!==s&&"author"!==s)}}function wJ(t,e){if(1&t&&(yn(0,"td",20),Fs(1,mJ,3,1,"ng-container",21),Fs(2,xJ,3,3,"ng-template",null,22,Jv),In()),2&t){const s=e.$implicit,n=zp(3),r=bs().$implicit,i=bs();Un(1),Yn("ngIf",i.isArray(s[r]))("ngIfElse",n)}}function CJ(t,e){1&t&&(dd(0,17),Fs(1,fJ,3,3,"th",18),Fs(2,wJ,4,2,"td",10),hd()),2&t&&Hv("matColumnDef",e.$implicit)}function EJ(t,e){1&t&&(yn(0,"th",26),Ys(1,"\xa0"),In())}function DJ(t,e){1&t&&(yn(0,"mat-icon"),Ys(1,"keyboard_arrow_down"),In())}function SJ(t,e){1&t&&(yn(0,"mat-icon"),Ys(1,"keyboard_arrow_up"),In())}function IJ(t,e){if(1&t){const s=iu();yn(0,"td",20)(1,"button",27),qs("click",function(r){const a=hr(s).$implicit,c=bs();return c.expandedBackTrackElement=c.expandedBackTrackElement===a?null:a,gs(r.stopPropagation())}),Fs(2,DJ,2,0,"mat-icon",23),Fs(3,SJ,2,0,"mat-icon",23),In()()}if(2&t){const s=e.$implicit,n=bs();Un(2),Yn("ngIf",n.expandedBackTrackElement!==s),Un(1),Yn("ngIf",n.expandedBackTrackElement===s)}}function TJ(t,e){if(1&t){const s=iu();yn(0,"td",20)(1,"div",28)(2,"div",29)(3,"button",30),qs("click",function(){const i=hr(s).$implicit;return gs(bs().selectTrack(i,!0))}),yn(4,"mat-icon"),Ys(5,"play_arrow"),In(),Ys(6," Play "),In(),yn(7,"button",31),qs("click",function(){const i=hr(s).$implicit;return gs(bs().selectTrack(i))}),yn(8,"mat-icon"),Ys(9,"playlist_add"),In(),Ys(10," Queue "),In(),yn(11,"button",32)(12,"mat-icon"),Ys(13,"edit"),In(),Ys(14," Edit "),In()()()()}if(2&t){const s=e.$implicit,n=bs();si("colspan",n.columnstoDisplayBackTrackWithExpand.length),Un(1),Yn("@detailExpand",s==n.expandedBackTrackElement?"expanded":"collapsed")}}function AJ(t,e){1&t&&ti(0,"tr",33)}function kJ(t,e){if(1&t){const s=iu();yn(0,"tr",34),qs("click",function(){const i=hr(s).$implicit,a=bs();return gs(a.expandedBackTrackElement=a.expandedBackTrackElement===i?null:i)}),In()}if(2&t){const s=e.$implicit;Ei("expanded-element-row",bs().expandedBackTrackElement===s)}}function OJ(t,e){1&t&&ti(0,"tr",35)}function RJ(t,e){if(1&t&&(yn(0,"tr",36)(1,"td",37),Ys(2),In()()),2&t){bs();const s=zp(16);Un(2),pd('No data matching the filter "',s.value,'"')}}const NJ=function(){return["expandedBackTrackDetail"]},MJ=function(){return[2,4,6,18]};let PJ=(()=>{var t;class e{constructor(n,r){this.trackService=n,this.databaseService=r,this.tracks=[],this.isPanelExpanded=!1,this.columnsToDisplayBackTrack=["title","genre","beatsPerMinute","duration","author"],this.columnstoDisplayBackTrackWithExpand=[...this.columnsToDisplayBackTrack,"expand"],this.expandedBackTrackElement=null,this.playOrJustLoadSelectedTrack=new Rr}ngOnInit(){this.trackRequestSubscription=this.trackService.getTrackRequest().subscribe(i=>{i&&(console.log("received request!"),this.selectRandomTrack())}),this.databaseService.openDatabase("trackLibrary",1).then(()=>{this.databaseService.getAllTracks().then(i=>{0===i.length?this.databaseService.addDefaultTracks().then(a=>{this.tracks=a,this.setTable()}):(this.tracks=i,this.setTable())}).catch(i=>{console.error("Error getting all tracks from database",i)})}).catch(i=>{console.error("Error opening the database:",i)})}ngOnDestroy(){this.trackRequestSubscription.unsubscribe()}setTable(){this.backTrackTableDataSource=new rJ(this.tracks),this.backTrackTableDataSource.paginator=this.backTrackPaginator,this.backTrackTableDataSource.sort=this.backTrackSort,this.backTrackTableDataSource.paginator&&this.backTrackTableDataSource.paginator.firstPage()}clearDatabase(){this.databaseService.clearDatabase().then(()=>{console.log("Database cleared successfully.")}).catch(n=>{console.error("Error clearing database:",n)})}applyFilterToBackTrackTable(n){this.backTrackTableDataSource.filter=n.target.value.trim().toLowerCase(),this.backTrackTableDataSource.paginator&&this.backTrackTableDataSource.paginator.firstPage()}isArray(n){return Array.isArray(n)}formatArray(n){return n.join(", ")}selectTrack(n,r=!1){this.trackService.setSelectedTrack(n),this.playOrJustLoadSelectedTrack.emit(r),this.expandedBackTrackElement=null,this.isPanelExpanded=!1}selectRandomTrack(){const n=Math.floor(Math.random()*this.tracks.length);this.trackService.setSelectedTrack(this.tracks[n])}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(VR),lt(pB))},t.\u0275cmp=sr({type:t,selectors:[["app-back-track-table"]],viewQuery:function(n,r){if(1&n&&(qo(aV,5),qo(ER,5)),2&n){let i;Ar(i=kr())&&(r.backTrackPaginator=i.first),Ar(i=kr())&&(r.backTrackSort=i.first)}},outputs:{playOrJustLoadSelectedTrack:"playOrJustLoadSelectedTrack"},decls:30,vars:9,consts:[[3,"expanded","expandedChange"],["mat-icon-button","","color","primary",1,"random-button",3,"click"],[1,"filter-table-field"],["matInput","","placeholder","Ex. Hip Hop",3,"keyup"],["input",""],["mat-table","","multiTemplateDataRows","","matSort","",1,"mat-elevation-z8",3,"dataSource"],["backTrackSort",""],[3,"matColumnDef",4,"ngFor","ngForOf"],["matColumnDef","expand"],["mat-header-cell","","aria-label","row actions",4,"matHeaderCellDef"],["mat-cell","",4,"matCellDef"],["matColumnDef","expandedBackTrackDetail"],["mat-header-row","",4,"matHeaderRowDef"],["mat-row","","class","element-row",3,"expanded-element-row","click",4,"matRowDef","matRowDefColumns"],["mat-row","","class","element-detail-row",4,"matRowDef","matRowDefColumns"],["class","mat-row",4,"matNoDataRow"],["aria-label","Select page of users",3,"pageSizeOptions"],[3,"matColumnDef"],["mat-header-cell","","mat-sort-header","",4,"matHeaderCellDef"],["mat-header-cell","","mat-sort-header",""],["mat-cell",""],[4,"ngIf","ngIfElse"],["notArray",""],[4,"ngIf"],["class","author-link","target","_blank",3,"href",4,"ngIf"],["target","_blank",1,"author-link",3,"href"],["mat-header-cell","","aria-label","row actions"],["mat-icon-button","","aria-label","expand row",3,"click"],[1,"element-detail"],[1,"back-track-button-row"],["mat-fab","","extended","","color","primary",3,"click"],["mat-fab","","extended","","color","accent",3,"click"],["mat-fab","","extended","","color","warn"],["mat-header-row",""],["mat-row","",1,"element-row",3,"click"],["mat-row","",1,"element-detail-row"],[1,"mat-row"],["colspan","4",1,"mat-cell"]],template:function(n,r){1&n&&(yn(0,"mat-expansion-panel",0),qs("expandedChange",function(a){return r.isPanelExpanded=a}),yn(1,"mat-expansion-panel-header")(2,"mat-panel-title")(3,"mat-icon"),Ys(4,"album"),In(),yn(5,"h2"),Ys(6,"Tracks"),In()(),yn(7,"mat-panel-description")(8,"button",1),qs("click",function(a){return r.selectRandomTrack(),a.stopPropagation()}),yn(9,"mat-icon"),Ys(10,"casino"),In()(),Ys(11," Find Samson's best tracks here "),In()(),yn(12,"mat-form-field",2)(13,"mat-label"),Ys(14,"Filter"),In(),yn(15,"input",3,4),qs("keyup",function(a){return r.applyFilterToBackTrackTable(a)}),In()(),yn(17,"table",5,6),Fs(19,CJ,3,1,"ng-container",7),dd(20,8),Fs(21,EJ,2,0,"th",9),Fs(22,IJ,4,2,"td",10),hd(),dd(23,11),Fs(24,TJ,15,2,"td",10),hd(),Fs(25,AJ,1,0,"tr",12),Fs(26,kJ,1,2,"tr",13),Fs(27,OJ,1,0,"tr",14),Fs(28,RJ,3,1,"tr",15),In(),ti(29,"mat-paginator",16),In()),2&n&&(Yn("expanded",r.isPanelExpanded),Un(17),Yn("dataSource",r.backTrackTableDataSource),Un(2),Yn("ngForOf",r.columnsToDisplayBackTrack),Un(6),Yn("matHeaderRowDef",r.columnstoDisplayBackTrackWithExpand),Un(1),Yn("matRowDefColumns",r.columnstoDisplayBackTrackWithExpand),Un(1),Yn("matRowDefColumns",Lk(7,NJ)),Un(2),Yn("pageSizeOptions",Lk(8,MJ)))},dependencies:[Rw,$d,lR,gB,fR,mR,DB,NX,eV,CR,yC,dJ,aV,ER,kQ,fV,FR,mV,LR,PR,gV,$R,BR,_V,yV,vV,pJ,xV],styles:[".filter-table-field[_ngcontent-%COMP%], table[_ngcontent-%COMP%]{width:100%}.element-row[_ngcontent-%COMP%]:hover{background:darkgrey}.element-row[_ngcontent-%COMP%]:active, .expanded-element-row[_ngcontent-%COMP%]{background:rgb(187,31,96)}.element-detail[_ngcontent-%COMP%]{overflow:hidden;display:flex}.element-detail-row[_ngcontent-%COMP%]{height:0}.button-and-paginator-container[_ngcontent-%COMP%]{margin-top:10px;display:flex;justify-content:space-between;align-items:center}.back-track-button-row[_ngcontent-%COMP%]{display:flex;justify-content:space-between;width:100%}.back-track-button-row[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{flex-grow:1;margin:1%}.author-link[_ngcontent-%COMP%]{color:#fff}"],data:{animation:[nd("detailExpand",[Vl("collapsed",Mi({height:"0px",minHeight:"0"})),Vl("expanded",Mi({height:"*"})),sc("expanded <=> collapsed",nc("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))])]}}),e})();function UR(t,e,s){for(let n in e)if(e.hasOwnProperty(n)){const r=e[n];r?t.setProperty(n,r,s?.has(n)?"important":""):t.removeProperty(n)}return t}function Mb(t,e){const s=e?"":"none";UR(t.style,{"touch-action":e?"":"none","-webkit-user-drag":e?"":"none","-webkit-tap-highlight-color":e?"":"transparent","user-select":s,"-ms-user-select":s,"-webkit-user-select":s,"-moz-user-select":s})}function wV(t,e,s){UR(t.style,{position:e?"":"fixed",top:e?"":"0",opacity:e?"":"0",left:e?"":"-999em"},s)}function wI(t,e){return e&&"none"!=e?t+" "+e:t}function CV(t){const e=t.toLowerCase().indexOf("ms")>-1?1:1e3;return parseFloat(t)*e}function zR(t,e){return t.getPropertyValue(e).split(",").map(n=>n.trim())}function WR(t){const e=t.getBoundingClientRect();return{top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:e.width,height:e.height,x:e.x,y:e.y}}function HR(t,e,s){const{top:n,bottom:r,left:i,right:a}=t;return s>=n&&s<=r&&e>=i&&e<=a}function AC(t,e,s){t.top+=e,t.bottom=t.top+t.height,t.left+=s,t.right=t.left+t.width}function EV(t,e,s,n){const{top:r,right:i,bottom:a,left:c,width:f,height:g}=t,E=f*e,A=g*e;return n>r-A&&n<a+A&&s>c-E&&s<i+E}class DV{constructor(e){this._document=e,this.positions=new Map}clear(){this.positions.clear()}cache(e){this.clear(),this.positions.set(this._document,{scrollPosition:this.getViewportScrollPosition()}),e.forEach(s=>{this.positions.set(s,{scrollPosition:{top:s.scrollTop,left:s.scrollLeft},clientRect:WR(s)})})}handleScroll(e){const s=kh(e),n=this.positions.get(s);if(!n)return null;const r=n.scrollPosition;let i,a;if(s===this._document){const g=this.getViewportScrollPosition();i=g.top,a=g.left}else i=s.scrollTop,a=s.scrollLeft;const c=r.top-i,f=r.left-a;return this.positions.forEach((g,E)=>{g.clientRect&&s!==E&&s.contains(E)&&AC(g.clientRect,c,f)}),r.top=i,r.left=a,{top:c,left:f}}getViewportScrollPosition(){return{top:window.scrollY,left:window.scrollX}}}function SV(t){const e=t.cloneNode(!0),s=e.querySelectorAll("[id]"),n=t.nodeName.toLowerCase();e.removeAttribute("id");for(let r=0;r<s.length;r++)s[r].removeAttribute("id");return"canvas"===n?AV(t,e):("input"===n||"select"===n||"textarea"===n)&&TV(t,e),IV("canvas",t,e,AV),IV("input, textarea, select",t,e,TV),e}function IV(t,e,s,n){const r=e.querySelectorAll(t);if(r.length){const i=s.querySelectorAll(t);for(let a=0;a<r.length;a++)n(r[a],i[a])}}let LJ=0;function TV(t,e){"file"!==e.type&&(e.value=t.value),"radio"===e.type&&e.name&&(e.name=`mat-clone-${e.name}-${LJ++}`)}function AV(t,e){const s=e.getContext("2d");if(s)try{s.drawImage(t,0,0)}catch{}}const kV=Lm({passive:!0}),CI=Lm({passive:!1}),jR=new Set(["position"]);class BJ{get disabled(){return this._disabled||!(!this._dropContainer||!this._dropContainer.disabled)}set disabled(e){const s=Yr(e);s!==this._disabled&&(this._disabled=s,this._toggleNativeDragInteractions(),this._handles.forEach(n=>Mb(n,s)))}constructor(e,s,n,r,i,a){this._config=s,this._document=n,this._ngZone=r,this._viewportRuler=i,this._dragDropRegistry=a,this._passiveTransform={x:0,y:0},this._activeTransform={x:0,y:0},this._hasStartedDragging=!1,this._moveEvents=new Bt,this._pointerMoveSubscription=I.EMPTY,this._pointerUpSubscription=I.EMPTY,this._scrollSubscription=I.EMPTY,this._resizeSubscription=I.EMPTY,this._boundaryElement=null,this._nativeInteractionsEnabled=!0,this._handles=[],this._disabledHandles=new Set,this._direction="ltr",this.dragStartDelay=0,this._disabled=!1,this.beforeStarted=new Bt,this.started=new Bt,this.released=new Bt,this.ended=new Bt,this.entered=new Bt,this.exited=new Bt,this.dropped=new Bt,this.moved=this._moveEvents,this._pointerDown=c=>{if(this.beforeStarted.next(),this._handles.length){const f=this._getTargetHandle(c);f&&!this._disabledHandles.has(f)&&!this.disabled&&this._initializeDragSequence(f,c)}else this.disabled||this._initializeDragSequence(this._rootElement,c)},this._pointerMove=c=>{const f=this._getPointerPositionOnPage(c);if(!this._hasStartedDragging){if(Math.abs(f.x-this._pickupPositionOnPage.x)+Math.abs(f.y-this._pickupPositionOnPage.y)>=this._config.dragStartThreshold){const ne=Date.now()>=this._dragStartTime+this._getDragStartDelay(c),Ee=this._dropContainer;if(!ne)return void this._endDragSequence(c);(!Ee||!Ee.isDragging()&&!Ee.isReceiving())&&(c.preventDefault(),this._hasStartedDragging=!0,this._ngZone.run(()=>this._startDragSequence(c)))}return}c.preventDefault();const g=this._getConstrainedPointerPosition(f);if(this._hasMoved=!0,this._lastKnownPointerPosition=f,this._updatePointerDirectionDelta(g),this._dropContainer)this._updateActiveDropContainer(g,f);else{const E=this.constrainPosition?this._initialClientRect:this._pickupPositionOnPage,A=this._activeTransform;A.x=g.x-E.x+this._passiveTransform.x,A.y=g.y-E.y+this._passiveTransform.y,this._applyRootElementTransform(A.x,A.y)}this._moveEvents.observers.length&&this._ngZone.run(()=>{this._moveEvents.next({source:this,pointerPosition:g,event:c,distance:this._getDragDistance(g),delta:this._pointerDirectionDelta})})},this._pointerUp=c=>{this._endDragSequence(c)},this._nativeDragStart=c=>{if(this._handles.length){const f=this._getTargetHandle(c);f&&!this._disabledHandles.has(f)&&!this.disabled&&c.preventDefault()}else this.disabled||c.preventDefault()},this.withRootElement(e).withParent(s.parentDragRef||null),this._parentPositions=new DV(n),a.registerDragItem(this)}getPlaceholderElement(){return this._placeholder}getRootElement(){return this._rootElement}getVisibleElement(){return this.isDragging()?this.getPlaceholderElement():this.getRootElement()}withHandles(e){this._handles=e.map(n=>cu(n)),this._handles.forEach(n=>Mb(n,this.disabled)),this._toggleNativeDragInteractions();const s=new Set;return this._disabledHandles.forEach(n=>{this._handles.indexOf(n)>-1&&s.add(n)}),this._disabledHandles=s,this}withPreviewTemplate(e){return this._previewTemplate=e,this}withPlaceholderTemplate(e){return this._placeholderTemplate=e,this}withRootElement(e){const s=cu(e);return s!==this._rootElement&&(this._rootElement&&this._removeRootElementListeners(this._rootElement),this._ngZone.runOutsideAngular(()=>{s.addEventListener("mousedown",this._pointerDown,CI),s.addEventListener("touchstart",this._pointerDown,kV),s.addEventListener("dragstart",this._nativeDragStart,CI)}),this._initialTransform=void 0,this._rootElement=s),typeof SVGElement<"u"&&this._rootElement instanceof SVGElement&&(this._ownerSVGElement=this._rootElement.ownerSVGElement),this}withBoundaryElement(e){return this._boundaryElement=e?cu(e):null,this._resizeSubscription.unsubscribe(),e&&(this._resizeSubscription=this._viewportRuler.change(10).subscribe(()=>this._containInsideBoundaryOnResize())),this}withParent(e){return this._parentDragRef=e,this}dispose(){this._removeRootElementListeners(this._rootElement),this.isDragging()&&this._rootElement?.remove(),this._anchor?.remove(),this._destroyPreview(),this._destroyPlaceholder(),this._dragDropRegistry.removeDragItem(this),this._removeSubscriptions(),this.beforeStarted.complete(),this.started.complete(),this.released.complete(),this.ended.complete(),this.entered.complete(),this.exited.complete(),this.dropped.complete(),this._moveEvents.complete(),this._handles=[],this._disabledHandles.clear(),this._dropContainer=void 0,this._resizeSubscription.unsubscribe(),this._parentPositions.clear(),this._boundaryElement=this._rootElement=this._ownerSVGElement=this._placeholderTemplate=this._previewTemplate=this._anchor=this._parentDragRef=null}isDragging(){return this._hasStartedDragging&&this._dragDropRegistry.isDragging(this)}reset(){this._rootElement.style.transform=this._initialTransform||"",this._activeTransform={x:0,y:0},this._passiveTransform={x:0,y:0}}disableHandle(e){!this._disabledHandles.has(e)&&this._handles.indexOf(e)>-1&&(this._disabledHandles.add(e),Mb(e,!0))}enableHandle(e){this._disabledHandles.has(e)&&(this._disabledHandles.delete(e),Mb(e,this.disabled))}withDirection(e){return this._direction=e,this}_withDropContainer(e){this._dropContainer=e}getFreeDragPosition(){const e=this.isDragging()?this._activeTransform:this._passiveTransform;return{x:e.x,y:e.y}}setFreeDragPosition(e){return this._activeTransform={x:0,y:0},this._passiveTransform.x=e.x,this._passiveTransform.y=e.y,this._dropContainer||this._applyRootElementTransform(e.x,e.y),this}withPreviewContainer(e){return this._previewContainer=e,this}_sortFromLastPointerPosition(){const e=this._lastKnownPointerPosition;e&&this._dropContainer&&this._updateActiveDropContainer(this._getConstrainedPointerPosition(e),e)}_removeSubscriptions(){this._pointerMoveSubscription.unsubscribe(),this._pointerUpSubscription.unsubscribe(),this._scrollSubscription.unsubscribe()}_destroyPreview(){this._preview?.remove(),this._previewRef?.destroy(),this._preview=this._previewRef=null}_destroyPlaceholder(){this._placeholder?.remove(),this._placeholderRef?.destroy(),this._placeholder=this._placeholderRef=null}_endDragSequence(e){if(this._dragDropRegistry.isDragging(this)&&(this._removeSubscriptions(),this._dragDropRegistry.stopDragging(this),this._toggleNativeDragInteractions(),this._handles&&(this._rootElement.style.webkitTapHighlightColor=this._rootElementTapHighlight),this._hasStartedDragging))if(this.released.next({source:this,event:e}),this._dropContainer)this._dropContainer._stopScrolling(),this._animatePreviewToPlaceholder().then(()=>{this._cleanupDragArtifacts(e),this._cleanupCachedDimensions(),this._dragDropRegistry.stopDragging(this)});else{this._passiveTransform.x=this._activeTransform.x;const s=this._getPointerPositionOnPage(e);this._passiveTransform.y=this._activeTransform.y,this._ngZone.run(()=>{this.ended.next({source:this,distance:this._getDragDistance(s),dropPoint:s,event:e})}),this._cleanupCachedDimensions(),this._dragDropRegistry.stopDragging(this)}}_startDragSequence(e){kC(e)&&(this._lastTouchEventTime=Date.now()),this._toggleNativeDragInteractions();const s=this._dropContainer;if(s){const n=this._rootElement,r=n.parentNode,i=this._placeholder=this._createPlaceholderElement(),a=this._anchor=this._anchor||this._document.createComment(""),c=this._getShadowRoot();r.insertBefore(a,n),this._initialTransform=n.style.transform||"",this._preview=this._createPreviewElement(),wV(n,!1,jR),this._document.body.appendChild(r.replaceChild(i,n)),this._getPreviewInsertionPoint(r,c).appendChild(this._preview),this.started.next({source:this,event:e}),s.start(),this._initialContainer=s,this._initialIndex=s.getItemIndex(this)}else this.started.next({source:this,event:e}),this._initialContainer=this._initialIndex=void 0;this._parentPositions.cache(s?s.getScrollableParents():[])}_initializeDragSequence(e,s){this._parentDragRef&&s.stopPropagation();const n=this.isDragging(),r=kC(s),i=!r&&0!==s.button,a=this._rootElement,c=kh(s),f=!r&&this._lastTouchEventTime&&this._lastTouchEventTime+800>Date.now(),g=r?YO(s):XO(s);if(c&&c.draggable&&"mousedown"===s.type&&s.preventDefault(),n||i||f||g)return;if(this._handles.length){const Y=a.style;this._rootElementTapHighlight=Y.webkitTapHighlightColor||"",Y.webkitTapHighlightColor="transparent"}this._hasStartedDragging=this._hasMoved=!1,this._removeSubscriptions(),this._initialClientRect=this._rootElement.getBoundingClientRect(),this._pointerMoveSubscription=this._dragDropRegistry.pointerMove.subscribe(this._pointerMove),this._pointerUpSubscription=this._dragDropRegistry.pointerUp.subscribe(this._pointerUp),this._scrollSubscription=this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(Y=>this._updateOnScroll(Y)),this._boundaryElement&&(this._boundaryRect=WR(this._boundaryElement));const E=this._previewTemplate;this._pickupPositionInElement=E&&E.template&&!E.matchSize?{x:0,y:0}:this._getPointerPositionInElement(this._initialClientRect,e,s);const A=this._pickupPositionOnPage=this._lastKnownPointerPosition=this._getPointerPositionOnPage(s);this._pointerDirectionDelta={x:0,y:0},this._pointerPositionAtLastDirectionChange={x:A.x,y:A.y},this._dragStartTime=Date.now(),this._dragDropRegistry.startDragging(this,s)}_cleanupDragArtifacts(e){wV(this._rootElement,!0,jR),this._anchor.parentNode.replaceChild(this._rootElement,this._anchor),this._destroyPreview(),this._destroyPlaceholder(),this._initialClientRect=this._boundaryRect=this._previewRect=this._initialTransform=void 0,this._ngZone.run(()=>{const s=this._dropContainer,n=s.getItemIndex(this),r=this._getPointerPositionOnPage(e),i=this._getDragDistance(r),a=s._isOverContainer(r.x,r.y);this.ended.next({source:this,distance:i,dropPoint:r,event:e}),this.dropped.next({item:this,currentIndex:n,previousIndex:this._initialIndex,container:s,previousContainer:this._initialContainer,isPointerOverContainer:a,distance:i,dropPoint:r,event:e}),s.drop(this,n,this._initialIndex,this._initialContainer,a,i,r,e),this._dropContainer=this._initialContainer})}_updateActiveDropContainer({x:e,y:s},{x:n,y:r}){let i=this._initialContainer._getSiblingContainerFromPosition(this,e,s);!i&&this._dropContainer!==this._initialContainer&&this._initialContainer._isOverContainer(e,s)&&(i=this._initialContainer),i&&i!==this._dropContainer&&this._ngZone.run(()=>{this.exited.next({item:this,container:this._dropContainer}),this._dropContainer.exit(this),this._dropContainer=i,this._dropContainer.enter(this,e,s,i===this._initialContainer&&i.sortingDisabled?this._initialIndex:void 0),this.entered.next({item:this,container:i,currentIndex:i.getItemIndex(this)})}),this.isDragging()&&(this._dropContainer._startScrollingIfNecessary(n,r),this._dropContainer._sortItem(this,e,s,this._pointerDirectionDelta),this.constrainPosition?this._applyPreviewTransform(e,s):this._applyPreviewTransform(e-this._pickupPositionInElement.x,s-this._pickupPositionInElement.y))}_createPreviewElement(){const e=this._previewTemplate,s=this.previewClass,n=e?e.template:null;let r;if(n&&e){const i=e.matchSize?this._initialClientRect:null,a=e.viewContainer.createEmbeddedView(n,e.context);a.detectChanges(),r=RV(a,this._document),this._previewRef=a,e.matchSize?NV(r,i):r.style.transform=EI(this._pickupPositionOnPage.x,this._pickupPositionOnPage.y)}else r=SV(this._rootElement),NV(r,this._initialClientRect),this._initialTransform&&(r.style.transform=this._initialTransform);return UR(r.style,{"pointer-events":"none",margin:"0",position:"fixed",top:"0",left:"0","z-index":`${this._config.zIndex||1e3}`},jR),Mb(r,!1),r.classList.add("cdk-drag-preview"),r.setAttribute("dir",this._direction),s&&(Array.isArray(s)?s.forEach(i=>r.classList.add(i)):r.classList.add(s)),r}_animatePreviewToPlaceholder(){if(!this._hasMoved)return Promise.resolve();const e=this._placeholder.getBoundingClientRect();this._preview.classList.add("cdk-drag-animating"),this._applyPreviewTransform(e.left,e.top);const s=function FJ(t){const e=getComputedStyle(t),s=zR(e,"transition-property"),n=s.find(c=>"transform"===c||"all"===c);if(!n)return 0;const r=s.indexOf(n),i=zR(e,"transition-duration"),a=zR(e,"transition-delay");return CV(i[r])+CV(a[r])}(this._preview);return 0===s?Promise.resolve():this._ngZone.runOutsideAngular(()=>new Promise(n=>{const r=a=>{(!a||kh(a)===this._preview&&"transform"===a.propertyName)&&(this._preview?.removeEventListener("transitionend",r),n(),clearTimeout(i))},i=setTimeout(r,1.5*s);this._preview.addEventListener("transitionend",r)}))}_createPlaceholderElement(){const e=this._placeholderTemplate,s=e?e.template:null;let n;return s?(this._placeholderRef=e.viewContainer.createEmbeddedView(s,e.context),this._placeholderRef.detectChanges(),n=RV(this._placeholderRef,this._document)):n=SV(this._rootElement),n.style.pointerEvents="none",n.classList.add("cdk-drag-placeholder"),n}_getPointerPositionInElement(e,s,n){const r=s===this._rootElement?null:s,i=r?r.getBoundingClientRect():e,a=kC(n)?n.targetTouches[0]:n,c=this._getViewportScrollPosition();return{x:i.left-e.left+(a.pageX-i.left-c.left),y:i.top-e.top+(a.pageY-i.top-c.top)}}_getPointerPositionOnPage(e){const s=this._getViewportScrollPosition(),n=kC(e)?e.touches[0]||e.changedTouches[0]||{pageX:0,pageY:0}:e,r=n.pageX-s.left,i=n.pageY-s.top;if(this._ownerSVGElement){const a=this._ownerSVGElement.getScreenCTM();if(a){const c=this._ownerSVGElement.createSVGPoint();return c.x=r,c.y=i,c.matrixTransform(a.inverse())}}return{x:r,y:i}}_getConstrainedPointerPosition(e){const s=this._dropContainer?this._dropContainer.lockAxis:null;let{x:n,y:r}=this.constrainPosition?this.constrainPosition(e,this,this._initialClientRect,this._pickupPositionInElement):e;if("x"===this.lockAxis||"x"===s?r=this._pickupPositionOnPage.y-(this.constrainPosition?this._pickupPositionInElement.y:0):("y"===this.lockAxis||"y"===s)&&(n=this._pickupPositionOnPage.x-(this.constrainPosition?this._pickupPositionInElement.x:0)),this._boundaryRect){const{x:i,y:a}=this.constrainPosition?{x:0,y:0}:this._pickupPositionInElement,c=this._boundaryRect,{width:f,height:g}=this._getPreviewRect(),E=c.top+a,A=c.bottom-(g-a);n=OV(n,c.left+i,c.right-(f-i)),r=OV(r,E,A)}return{x:n,y:r}}_updatePointerDirectionDelta(e){const{x:s,y:n}=e,r=this._pointerDirectionDelta,i=this._pointerPositionAtLastDirectionChange,a=Math.abs(s-i.x),c=Math.abs(n-i.y);return a>this._config.pointerDirectionChangeThreshold&&(r.x=s>i.x?1:-1,i.x=s),c>this._config.pointerDirectionChangeThreshold&&(r.y=n>i.y?1:-1,i.y=n),r}_toggleNativeDragInteractions(){if(!this._rootElement||!this._handles)return;const e=this._handles.length>0||!this.isDragging();e!==this._nativeInteractionsEnabled&&(this._nativeInteractionsEnabled=e,Mb(this._rootElement,e))}_removeRootElementListeners(e){e.removeEventListener("mousedown",this._pointerDown,CI),e.removeEventListener("touchstart",this._pointerDown,kV),e.removeEventListener("dragstart",this._nativeDragStart,CI)}_applyRootElementTransform(e,s){const n=EI(e,s),r=this._rootElement.style;null==this._initialTransform&&(this._initialTransform=r.transform&&"none"!=r.transform?r.transform:""),r.transform=wI(n,this._initialTransform)}_applyPreviewTransform(e,s){const n=this._previewTemplate?.template?void 0:this._initialTransform,r=EI(e,s);this._preview.style.transform=wI(r,n)}_getDragDistance(e){const s=this._pickupPositionOnPage;return s?{x:e.x-s.x,y:e.y-s.y}:{x:0,y:0}}_cleanupCachedDimensions(){this._boundaryRect=this._previewRect=void 0,this._parentPositions.clear()}_containInsideBoundaryOnResize(){let{x:e,y:s}=this._passiveTransform;if(0===e&&0===s||this.isDragging()||!this._boundaryElement)return;const n=this._rootElement.getBoundingClientRect(),r=this._boundaryElement.getBoundingClientRect();if(0===r.width&&0===r.height||0===n.width&&0===n.height)return;const i=r.left-n.left,a=n.right-r.right,c=r.top-n.top,f=n.bottom-r.bottom;r.width>n.width?(i>0&&(e+=i),a>0&&(e-=a)):e=0,r.height>n.height?(c>0&&(s+=c),f>0&&(s-=f)):s=0,(e!==this._passiveTransform.x||s!==this._passiveTransform.y)&&this.setFreeDragPosition({y:s,x:e})}_getDragStartDelay(e){const s=this.dragStartDelay;return"number"==typeof s?s:kC(e)?s.touch:s?s.mouse:0}_updateOnScroll(e){const s=this._parentPositions.handleScroll(e);if(s){const n=kh(e);this._boundaryRect&&n!==this._boundaryElement&&n.contains(this._boundaryElement)&&AC(this._boundaryRect,s.top,s.left),this._pickupPositionOnPage.x+=s.left,this._pickupPositionOnPage.y+=s.top,this._dropContainer||(this._activeTransform.x-=s.left,this._activeTransform.y-=s.top,this._applyRootElementTransform(this._activeTransform.x,this._activeTransform.y))}}_getViewportScrollPosition(){return this._parentPositions.positions.get(this._document)?.scrollPosition||this._parentPositions.getViewportScrollPosition()}_getShadowRoot(){return void 0===this._cachedShadowRoot&&(this._cachedShadowRoot=LO(this._rootElement)),this._cachedShadowRoot}_getPreviewInsertionPoint(e,s){const n=this._previewContainer||"global";if("parent"===n)return e;if("global"===n){const r=this._document;return s||r.fullscreenElement||r.webkitFullscreenElement||r.mozFullScreenElement||r.msFullscreenElement||r.body}return cu(n)}_getPreviewRect(){return(!this._previewRect||!this._previewRect.width&&!this._previewRect.height)&&(this._previewRect=this._preview?this._preview.getBoundingClientRect():this._initialClientRect),this._previewRect}_getTargetHandle(e){return this._handles.find(s=>e.target&&(e.target===s||s.contains(e.target)))}}function EI(t,e){return`translate3d(${Math.round(t)}px, ${Math.round(e)}px, 0)`}function OV(t,e,s){return Math.max(e,Math.min(s,t))}function kC(t){return"t"===t.type[0]}function RV(t,e){const s=t.rootNodes;if(1===s.length&&s[0].nodeType===e.ELEMENT_NODE)return s[0];const n=e.createElement("div");return s.forEach(r=>n.appendChild(r)),n}function NV(t,e){t.style.width=`${e.width}px`,t.style.height=`${e.height}px`,t.style.transform=EI(e.left,e.top)}function MV(t,e,s){const n=OC(e,t.length-1),r=OC(s,t.length-1);if(n===r)return;const i=t[n],a=r<n?-1:1;for(let c=n;c!==r;c+=a)t[c]=t[c+a];t[r]=i}function OC(t,e){return Math.max(0,Math.min(e,t))}class VJ{constructor(e,s){this._element=e,this._dragDropRegistry=s,this._itemPositions=[],this.orientation="vertical",this._previousSwap={drag:null,delta:0,overlaps:!1}}start(e){this.withItems(e)}sort(e,s,n,r){const i=this._itemPositions,a=this._getItemIndexFromPointerPosition(e,s,n,r);if(-1===a&&i.length>0)return null;const c="horizontal"===this.orientation,f=i.findIndex(tt=>tt.drag===e),g=i[a],A=g.clientRect,Y=f>a?1:-1,ne=this._getItemOffsetPx(i[f].clientRect,A,Y),Ee=this._getSiblingOffsetPx(f,i,Y),Ge=i.slice();return MV(i,f,a),i.forEach((tt,Nt)=>{if(Ge[Nt]===tt)return;const kt=tt.drag===e,on=kt?ne:Ee,fn=kt?e.getPlaceholderElement():tt.drag.getRootElement();tt.offset+=on,c?(fn.style.transform=wI(`translate3d(${Math.round(tt.offset)}px, 0, 0)`,tt.initialTransform),AC(tt.clientRect,0,on)):(fn.style.transform=wI(`translate3d(0, ${Math.round(tt.offset)}px, 0)`,tt.initialTransform),AC(tt.clientRect,on,0))}),this._previousSwap.overlaps=HR(A,s,n),this._previousSwap.drag=g.drag,this._previousSwap.delta=c?r.x:r.y,{previousIndex:f,currentIndex:a}}enter(e,s,n,r){const i=null==r||r<0?this._getItemIndexFromPointerPosition(e,s,n):r,a=this._activeDraggables,c=a.indexOf(e),f=e.getPlaceholderElement();let g=a[i];if(g===e&&(g=a[i+1]),!g&&(null==i||-1===i||i<a.length-1)&&this._shouldEnterAsFirstChild(s,n)&&(g=a[0]),c>-1&&a.splice(c,1),g&&!this._dragDropRegistry.isDragging(g)){const E=g.getRootElement();E.parentElement.insertBefore(f,E),a.splice(i,0,e)}else cu(this._element).appendChild(f),a.push(e);f.style.transform="",this._cacheItemPositions()}withItems(e){this._activeDraggables=e.slice(),this._cacheItemPositions()}withSortPredicate(e){this._sortPredicate=e}reset(){this._activeDraggables.forEach(e=>{const s=e.getRootElement();if(s){const n=this._itemPositions.find(r=>r.drag===e)?.initialTransform;s.style.transform=n||""}}),this._itemPositions=[],this._activeDraggables=[],this._previousSwap.drag=null,this._previousSwap.delta=0,this._previousSwap.overlaps=!1}getActiveItemsSnapshot(){return this._activeDraggables}getItemIndex(e){return("horizontal"===this.orientation&&"rtl"===this.direction?this._itemPositions.slice().reverse():this._itemPositions).findIndex(n=>n.drag===e)}updateOnScroll(e,s){this._itemPositions.forEach(({clientRect:n})=>{AC(n,e,s)}),this._itemPositions.forEach(({drag:n})=>{this._dragDropRegistry.isDragging(n)&&n._sortFromLastPointerPosition()})}_cacheItemPositions(){const e="horizontal"===this.orientation;this._itemPositions=this._activeDraggables.map(s=>{const n=s.getVisibleElement();return{drag:s,offset:0,initialTransform:n.style.transform||"",clientRect:WR(n)}}).sort((s,n)=>e?s.clientRect.left-n.clientRect.left:s.clientRect.top-n.clientRect.top)}_getItemOffsetPx(e,s,n){const r="horizontal"===this.orientation;let i=r?s.left-e.left:s.top-e.top;return-1===n&&(i+=r?s.width-e.width:s.height-e.height),i}_getSiblingOffsetPx(e,s,n){const r="horizontal"===this.orientation,i=s[e].clientRect,a=s[e+-1*n];let c=i[r?"width":"height"]*n;if(a){const f=r?"left":"top",g=r?"right":"bottom";-1===n?c-=a.clientRect[f]-i[g]:c+=i[f]-a.clientRect[g]}return c}_shouldEnterAsFirstChild(e,s){if(!this._activeDraggables.length)return!1;const n=this._itemPositions,r="horizontal"===this.orientation;if(n[0].drag!==this._activeDraggables[0]){const a=n[n.length-1].clientRect;return r?e>=a.right:s>=a.bottom}{const a=n[0].clientRect;return r?e<=a.left:s<=a.top}}_getItemIndexFromPointerPosition(e,s,n,r){const i="horizontal"===this.orientation,a=this._itemPositions.findIndex(({drag:c,clientRect:f})=>c!==e&&((!r||c!==this._previousSwap.drag||!this._previousSwap.overlaps||(i?r.x:r.y)!==this._previousSwap.delta)&&(i?s>=Math.floor(f.left)&&s<Math.floor(f.right):n>=Math.floor(f.top)&&n<Math.floor(f.bottom))));return-1!==a&&this._sortPredicate(a,e)?a:-1}}class UJ{constructor(e,s,n,r,i){this._dragDropRegistry=s,this._ngZone=r,this._viewportRuler=i,this.disabled=!1,this.sortingDisabled=!1,this.autoScrollDisabled=!1,this.autoScrollStep=2,this.enterPredicate=()=>!0,this.sortPredicate=()=>!0,this.beforeStarted=new Bt,this.entered=new Bt,this.exited=new Bt,this.dropped=new Bt,this.sorted=new Bt,this.receivingStarted=new Bt,this.receivingStopped=new Bt,this._isDragging=!1,this._draggables=[],this._siblings=[],this._activeSiblings=new Set,this._viewportScrollSubscription=I.EMPTY,this._verticalScrollDirection=0,this._horizontalScrollDirection=0,this._stopScrollTimers=new Bt,this._cachedShadowRoot=null,this._startScrollInterval=()=>{this._stopScrolling(),hB(0,OB).pipe(fo(this._stopScrollTimers)).subscribe(()=>{const a=this._scrollNode,c=this.autoScrollStep;1===this._verticalScrollDirection?a.scrollBy(0,-c):2===this._verticalScrollDirection&&a.scrollBy(0,c),1===this._horizontalScrollDirection?a.scrollBy(-c,0):2===this._horizontalScrollDirection&&a.scrollBy(c,0)})},this.element=cu(e),this._document=n,this.withScrollableParents([this.element]),s.registerDropContainer(this),this._parentPositions=new DV(n),this._sortStrategy=new VJ(this.element,s),this._sortStrategy.withSortPredicate((a,c)=>this.sortPredicate(a,c,this))}dispose(){this._stopScrolling(),this._stopScrollTimers.complete(),this._viewportScrollSubscription.unsubscribe(),this.beforeStarted.complete(),this.entered.complete(),this.exited.complete(),this.dropped.complete(),this.sorted.complete(),this.receivingStarted.complete(),this.receivingStopped.complete(),this._activeSiblings.clear(),this._scrollNode=null,this._parentPositions.clear(),this._dragDropRegistry.removeDropContainer(this)}isDragging(){return this._isDragging}start(){this._draggingStarted(),this._notifyReceivingSiblings()}enter(e,s,n,r){this._draggingStarted(),null==r&&this.sortingDisabled&&(r=this._draggables.indexOf(e)),this._sortStrategy.enter(e,s,n,r),this._cacheParentPositions(),this._notifyReceivingSiblings(),this.entered.next({item:e,container:this,currentIndex:this.getItemIndex(e)})}exit(e){this._reset(),this.exited.next({item:e,container:this})}drop(e,s,n,r,i,a,c,f={}){this._reset(),this.dropped.next({item:e,currentIndex:s,previousIndex:n,container:this,previousContainer:r,isPointerOverContainer:i,distance:a,dropPoint:c,event:f})}withItems(e){const s=this._draggables;return this._draggables=e,e.forEach(n=>n._withDropContainer(this)),this.isDragging()&&(s.filter(r=>r.isDragging()).every(r=>-1===e.indexOf(r))?this._reset():this._sortStrategy.withItems(this._draggables)),this}withDirection(e){return this._sortStrategy.direction=e,this}connectedTo(e){return this._siblings=e.slice(),this}withOrientation(e){return this._sortStrategy.orientation=e,this}withScrollableParents(e){const s=cu(this.element);return this._scrollableElements=-1===e.indexOf(s)?[s,...e]:e.slice(),this}getScrollableParents(){return this._scrollableElements}getItemIndex(e){return this._isDragging?this._sortStrategy.getItemIndex(e):this._draggables.indexOf(e)}isReceiving(){return this._activeSiblings.size>0}_sortItem(e,s,n,r){if(this.sortingDisabled||!this._clientRect||!EV(this._clientRect,.05,s,n))return;const i=this._sortStrategy.sort(e,s,n,r);i&&this.sorted.next({previousIndex:i.previousIndex,currentIndex:i.currentIndex,container:this,item:e})}_startScrollingIfNecessary(e,s){if(this.autoScrollDisabled)return;let n,r=0,i=0;if(this._parentPositions.positions.forEach((a,c)=>{c===this._document||!a.clientRect||n||EV(a.clientRect,.05,e,s)&&([r,i]=function zJ(t,e,s,n){const r=LV(e,n),i=$V(e,s);let a=0,c=0;if(r){const f=t.scrollTop;1===r?f>0&&(a=1):t.scrollHeight-f>t.clientHeight&&(a=2)}if(i){const f=t.scrollLeft;1===i?f>0&&(c=1):t.scrollWidth-f>t.clientWidth&&(c=2)}return[a,c]}(c,a.clientRect,e,s),(r||i)&&(n=c))}),!r&&!i){const{width:a,height:c}=this._viewportRuler.getViewportSize(),f={width:a,height:c,top:0,right:a,bottom:c,left:0};r=LV(f,s),i=$V(f,e),n=window}n&&(r!==this._verticalScrollDirection||i!==this._horizontalScrollDirection||n!==this._scrollNode)&&(this._verticalScrollDirection=r,this._horizontalScrollDirection=i,this._scrollNode=n,(r||i)&&n?this._ngZone.runOutsideAngular(this._startScrollInterval):this._stopScrolling())}_stopScrolling(){this._stopScrollTimers.next()}_draggingStarted(){const e=cu(this.element).style;this.beforeStarted.next(),this._isDragging=!0,this._initialScrollSnap=e.msScrollSnapType||e.scrollSnapType||"",e.scrollSnapType=e.msScrollSnapType="none",this._sortStrategy.start(this._draggables),this._cacheParentPositions(),this._viewportScrollSubscription.unsubscribe(),this._listenToScrollEvents()}_cacheParentPositions(){const e=cu(this.element);this._parentPositions.cache(this._scrollableElements),this._clientRect=this._parentPositions.positions.get(e).clientRect}_reset(){this._isDragging=!1;const e=cu(this.element).style;e.scrollSnapType=e.msScrollSnapType=this._initialScrollSnap,this._siblings.forEach(s=>s._stopReceiving(this)),this._sortStrategy.reset(),this._stopScrolling(),this._viewportScrollSubscription.unsubscribe(),this._parentPositions.clear()}_isOverContainer(e,s){return null!=this._clientRect&&HR(this._clientRect,e,s)}_getSiblingContainerFromPosition(e,s,n){return this._siblings.find(r=>r._canReceive(e,s,n))}_canReceive(e,s,n){if(!this._clientRect||!HR(this._clientRect,s,n)||!this.enterPredicate(e,this))return!1;const r=this._getShadowRoot().elementFromPoint(s,n);if(!r)return!1;const i=cu(this.element);return r===i||i.contains(r)}_startReceiving(e,s){const n=this._activeSiblings;!n.has(e)&&s.every(r=>this.enterPredicate(r,this)||this._draggables.indexOf(r)>-1)&&(n.add(e),this._cacheParentPositions(),this._listenToScrollEvents(),this.receivingStarted.next({initiator:e,receiver:this,items:s}))}_stopReceiving(e){this._activeSiblings.delete(e),this._viewportScrollSubscription.unsubscribe(),this.receivingStopped.next({initiator:e,receiver:this})}_listenToScrollEvents(){this._viewportScrollSubscription=this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(e=>{if(this.isDragging()){const s=this._parentPositions.handleScroll(e);s&&this._sortStrategy.updateOnScroll(s.top,s.left)}else this.isReceiving()&&this._cacheParentPositions()})}_getShadowRoot(){if(!this._cachedShadowRoot){const e=LO(cu(this.element));this._cachedShadowRoot=e||this._document}return this._cachedShadowRoot}_notifyReceivingSiblings(){const e=this._sortStrategy.getActiveItemsSnapshot().filter(s=>s.isDragging());this._siblings.forEach(s=>s._startReceiving(this,e))}}function LV(t,e){const{top:s,bottom:n,height:r}=t,i=.05*r;return e>=s-i&&e<=s+i?1:e>=n-i&&e<=n+i?2:0}function $V(t,e){const{left:s,right:n,width:r}=t,i=.05*r;return e>=s-i&&e<=s+i?1:e>=n-i&&e<=n+i?2:0}const DI=Lm({passive:!1,capture:!0});let WJ=(()=>{var t;class e{constructor(n,r){this._ngZone=n,this._dropInstances=new Set,this._dragInstances=new Set,this._activeDragInstances=[],this._globalListeners=new Map,this._draggingPredicate=i=>i.isDragging(),this.pointerMove=new Bt,this.pointerUp=new Bt,this.scroll=new Bt,this._preventDefaultWhileDragging=i=>{this._activeDragInstances.length>0&&i.preventDefault()},this._persistentTouchmoveListener=i=>{this._activeDragInstances.length>0&&(this._activeDragInstances.some(this._draggingPredicate)&&i.preventDefault(),this.pointerMove.next(i))},this._document=r}registerDropContainer(n){this._dropInstances.has(n)||this._dropInstances.add(n)}registerDragItem(n){this._dragInstances.add(n),1===this._dragInstances.size&&this._ngZone.runOutsideAngular(()=>{this._document.addEventListener("touchmove",this._persistentTouchmoveListener,DI)})}removeDropContainer(n){this._dropInstances.delete(n)}removeDragItem(n){this._dragInstances.delete(n),this.stopDragging(n),0===this._dragInstances.size&&this._document.removeEventListener("touchmove",this._persistentTouchmoveListener,DI)}startDragging(n,r){if(!(this._activeDragInstances.indexOf(n)>-1)&&(this._activeDragInstances.push(n),1===this._activeDragInstances.length)){const i=r.type.startsWith("touch");this._globalListeners.set(i?"touchend":"mouseup",{handler:a=>this.pointerUp.next(a),options:!0}).set("scroll",{handler:a=>this.scroll.next(a),options:!0}).set("selectstart",{handler:this._preventDefaultWhileDragging,options:DI}),i||this._globalListeners.set("mousemove",{handler:a=>this.pointerMove.next(a),options:DI}),this._ngZone.runOutsideAngular(()=>{this._globalListeners.forEach((a,c)=>{this._document.addEventListener(c,a.handler,a.options)})})}}stopDragging(n){const r=this._activeDragInstances.indexOf(n);r>-1&&(this._activeDragInstances.splice(r,1),0===this._activeDragInstances.length&&this._clearGlobalListeners())}isDragging(n){return this._activeDragInstances.indexOf(n)>-1}scrolled(n){const r=[this.scroll];return n&&n!==this._document&&r.push(new Ue(i=>this._ngZone.runOutsideAngular(()=>{const c=f=>{this._activeDragInstances.length&&i.next(f)};return n.addEventListener("scroll",c,!0),()=>{n.removeEventListener("scroll",c,!0)}}))),ji(...r)}ngOnDestroy(){this._dragInstances.forEach(n=>this.removeDragItem(n)),this._dropInstances.forEach(n=>this.removeDropContainer(n)),this._clearGlobalListeners(),this.pointerMove.complete(),this.pointerUp.complete()}_clearGlobalListeners(){this._globalListeners.forEach((n,r)=>{this._document.removeEventListener(r,n.handler,n.options)}),this._globalListeners.clear()}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(Gs),cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const HJ={dragStartThreshold:5,pointerDirectionChangeThreshold:5};let BV=(()=>{var t;class e{constructor(n,r,i,a){this._document=n,this._ngZone=r,this._viewportRuler=i,this._dragDropRegistry=a}createDrag(n,r=HJ){return new BJ(n,r,this._document,this._ngZone,this._viewportRuler,this._dragDropRegistry)}createDropList(n){return new UJ(n,this._dragDropRegistry,this._document,this._ngZone,this._viewportRuler)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(Gs),cn(c0),cn(WJ))},t.\u0275prov=wt({token:t,factory:t.\u0275fac,providedIn:"root"}),e})();const GR=new Zn("CDK_DRAG_PARENT"),KR=new Zn("CdkDragHandle"),VV=new Zn("CdkDragPlaceholder"),UV=new Zn("CdkDragPreview"),zV=new Zn("CDK_DRAG_CONFIG"),WV=new Zn("CdkDropList");let HV=(()=>{var t;class e{get disabled(){return this._disabled||this.dropContainer&&this.dropContainer.disabled}set disabled(n){this._disabled=Yr(n),this._dragRef.disabled=this._disabled}constructor(n,r,i,a,c,f,g,E,A,Y,ne){this.element=n,this.dropContainer=r,this._ngZone=a,this._viewContainerRef=c,this._dir=g,this._changeDetectorRef=A,this._selfHandle=Y,this._parentDrag=ne,this._destroyed=new Bt,this.started=new Rr,this.released=new Rr,this.ended=new Rr,this.entered=new Rr,this.exited=new Rr,this.dropped=new Rr,this.moved=new Ue(Ee=>{const Ge=this._dragRef.moved.pipe(Xn(tt=>({source:this,pointerPosition:tt.pointerPosition,event:tt.event,delta:tt.delta,distance:tt.distance}))).subscribe(Ee);return()=>{Ge.unsubscribe()}}),this._dragRef=E.createDrag(n,{dragStartThreshold:f&&null!=f.dragStartThreshold?f.dragStartThreshold:5,pointerDirectionChangeThreshold:f&&null!=f.pointerDirectionChangeThreshold?f.pointerDirectionChangeThreshold:5,zIndex:f?.zIndex}),this._dragRef.data=this,e._dragInstances.push(this),f&&this._assignDefaults(f),r&&(this._dragRef._withDropContainer(r._dropListRef),r.addItem(this)),this._syncInputs(this._dragRef),this._handleEvents(this._dragRef)}getPlaceholderElement(){return this._dragRef.getPlaceholderElement()}getRootElement(){return this._dragRef.getRootElement()}reset(){this._dragRef.reset()}getFreeDragPosition(){return this._dragRef.getFreeDragPosition()}setFreeDragPosition(n){this._dragRef.setFreeDragPosition(n)}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.pipe($l(1),fo(this._destroyed)).subscribe(()=>{this._updateRootElement(),this._setupHandlesListener(),this.freeDragPosition&&this._dragRef.setFreeDragPosition(this.freeDragPosition)})})}ngOnChanges(n){const r=n.rootElementSelector,i=n.freeDragPosition;r&&!r.firstChange&&this._updateRootElement(),i&&!i.firstChange&&this.freeDragPosition&&this._dragRef.setFreeDragPosition(this.freeDragPosition)}ngOnDestroy(){this.dropContainer&&this.dropContainer.removeItem(this);const n=e._dragInstances.indexOf(this);n>-1&&e._dragInstances.splice(n,1),this._ngZone.runOutsideAngular(()=>{this._destroyed.next(),this._destroyed.complete(),this._dragRef.dispose()})}_updateRootElement(){const n=this.element.nativeElement;let r=n;this.rootElementSelector&&(r=void 0!==n.closest?n.closest(this.rootElementSelector):n.parentElement?.closest(this.rootElementSelector)),this._dragRef.withRootElement(r||n)}_getBoundaryElement(){const n=this.boundaryElement;return n?"string"==typeof n?this.element.nativeElement.closest(n):cu(n):null}_syncInputs(n){n.beforeStarted.subscribe(()=>{if(!n.isDragging()){const r=this._dir,i=this.dragStartDelay,a=this._placeholderTemplate?{template:this._placeholderTemplate.templateRef,context:this._placeholderTemplate.data,viewContainer:this._viewContainerRef}:null,c=this._previewTemplate?{template:this._previewTemplate.templateRef,context:this._previewTemplate.data,matchSize:this._previewTemplate.matchSize,viewContainer:this._viewContainerRef}:null;n.disabled=this.disabled,n.lockAxis=this.lockAxis,n.dragStartDelay="object"==typeof i&&i?i:Bl(i),n.constrainPosition=this.constrainPosition,n.previewClass=this.previewClass,n.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(a).withPreviewTemplate(c).withPreviewContainer(this.previewContainer||"global"),r&&n.withDirection(r.value)}}),n.beforeStarted.pipe($l(1)).subscribe(()=>{if(this._parentDrag)return void n.withParent(this._parentDrag._dragRef);let r=this.element.nativeElement.parentElement;for(;r;){if(r.classList.contains("cdk-drag")){n.withParent(e._dragInstances.find(i=>i.element.nativeElement===r)?._dragRef||null);break}r=r.parentElement}})}_handleEvents(n){n.started.subscribe(r=>{this.started.emit({source:this,event:r.event}),this._changeDetectorRef.markForCheck()}),n.released.subscribe(r=>{this.released.emit({source:this,event:r.event})}),n.ended.subscribe(r=>{this.ended.emit({source:this,distance:r.distance,dropPoint:r.dropPoint,event:r.event}),this._changeDetectorRef.markForCheck()}),n.entered.subscribe(r=>{this.entered.emit({container:r.container.data,item:this,currentIndex:r.currentIndex})}),n.exited.subscribe(r=>{this.exited.emit({container:r.container.data,item:this})}),n.dropped.subscribe(r=>{this.dropped.emit({previousIndex:r.previousIndex,currentIndex:r.currentIndex,previousContainer:r.previousContainer.data,container:r.container.data,isPointerOverContainer:r.isPointerOverContainer,item:this,distance:r.distance,dropPoint:r.dropPoint,event:r.event})})}_assignDefaults(n){const{lockAxis:r,dragStartDelay:i,constrainPosition:a,previewClass:c,boundaryElement:f,draggingDisabled:g,rootElementSelector:E,previewContainer:A}=n;this.disabled=g??!1,this.dragStartDelay=i||0,r&&(this.lockAxis=r),a&&(this.constrainPosition=a),c&&(this.previewClass=c),f&&(this.boundaryElement=f),E&&(this.rootElementSelector=E),A&&(this.previewContainer=A)}_setupHandlesListener(){this._handles.changes.pipe(ed(this._handles),Kc(n=>{const r=n.filter(i=>i._parentDrag===this).map(i=>i.element);this._selfHandle&&this.rootElementSelector&&r.push(this.element),this._dragRef.withHandles(r)}),Qi(n=>ji(...n.map(r=>r._stateChanges.pipe(ed(r))))),fo(this._destroyed)).subscribe(n=>{const r=this._dragRef,i=n.element.nativeElement;n.disabled?r.disableHandle(i):r.enableHandle(i)})}}return(t=e)._dragInstances=[],t.\u0275fac=function(n){return new(n||t)(lt(yr),lt(WV,12),lt(yi),lt(Gs),lt(jc),lt(zV,8),lt(td,8),lt(BV),lt(Ll),lt(KR,10),lt(GR,12))},t.\u0275dir=Gn({type:t,selectors:[["","cdkDrag",""]],contentQueries:function(n,r,i){if(1&n&&(ea(i,UV,5),ea(i,VV,5),ea(i,KR,5)),2&n){let a;Ar(a=kr())&&(r._previewTemplate=a.first),Ar(a=kr())&&(r._placeholderTemplate=a.first),Ar(a=kr())&&(r._handles=a)}},hostAttrs:[1,"cdk-drag"],hostVars:4,hostBindings:function(n,r){2&n&&Ei("cdk-drag-disabled",r.disabled)("cdk-drag-dragging",r._dragRef.isDragging())},inputs:{data:["cdkDragData","data"],lockAxis:["cdkDragLockAxis","lockAxis"],rootElementSelector:["cdkDragRootElement","rootElementSelector"],boundaryElement:["cdkDragBoundary","boundaryElement"],dragStartDelay:["cdkDragStartDelay","dragStartDelay"],freeDragPosition:["cdkDragFreeDragPosition","freeDragPosition"],disabled:["cdkDragDisabled","disabled"],constrainPosition:["cdkDragConstrainPosition","constrainPosition"],previewClass:["cdkDragPreviewClass","previewClass"],previewContainer:["cdkDragPreviewContainer","previewContainer"]},outputs:{started:"cdkDragStarted",released:"cdkDragReleased",ended:"cdkDragEnded",entered:"cdkDragEntered",exited:"cdkDragExited",dropped:"cdkDragDropped",moved:"cdkDragMoved"},exportAs:["cdkDrag"],standalone:!0,features:[vr([{provide:GR,useExisting:t}]),Ia]}),e})();const XR=new Zn("CdkDropListGroup");let ZJ=0,jV=(()=>{var t;class e{get disabled(){return this._disabled||!!this._group&&this._group.disabled}set disabled(n){this._dropListRef.disabled=this._disabled=Yr(n)}constructor(n,r,i,a,c,f,g){this.element=n,this._changeDetectorRef=i,this._scrollDispatcher=a,this._dir=c,this._group=f,this._destroyed=new Bt,this.connectedTo=[],this.id="cdk-drop-list-"+ZJ++,this.enterPredicate=()=>!0,this.sortPredicate=()=>!0,this.dropped=new Rr,this.entered=new Rr,this.exited=new Rr,this.sorted=new Rr,this._unsortedItems=new Set,this._dropListRef=r.createDropList(n),this._dropListRef.data=this,g&&this._assignDefaults(g),this._dropListRef.enterPredicate=(E,A)=>this.enterPredicate(E.data,A.data),this._dropListRef.sortPredicate=(E,A,Y)=>this.sortPredicate(E,A.data,Y.data),this._setupInputSyncSubscription(this._dropListRef),this._handleEvents(this._dropListRef),e._dropLists.push(this),f&&f._items.add(this)}addItem(n){this._unsortedItems.add(n),this._dropListRef.isDragging()&&this._syncItemsWithRef()}removeItem(n){this._unsortedItems.delete(n),this._dropListRef.isDragging()&&this._syncItemsWithRef()}getSortedItems(){return Array.from(this._unsortedItems).sort((n,r)=>n._dragRef.getVisibleElement().compareDocumentPosition(r._dragRef.getVisibleElement())&Node.DOCUMENT_POSITION_FOLLOWING?-1:1)}ngOnDestroy(){const n=e._dropLists.indexOf(this);n>-1&&e._dropLists.splice(n,1),this._group&&this._group._items.delete(this),this._unsortedItems.clear(),this._dropListRef.dispose(),this._destroyed.next(),this._destroyed.complete()}_setupInputSyncSubscription(n){this._dir&&this._dir.change.pipe(ed(this._dir.value),fo(this._destroyed)).subscribe(r=>n.withDirection(r)),n.beforeStarted.subscribe(()=>{const r=cC(this.connectedTo).map(i=>"string"==typeof i?e._dropLists.find(c=>c.id===i):i);if(this._group&&this._group._items.forEach(i=>{-1===r.indexOf(i)&&r.push(i)}),!this._scrollableParentsResolved){const i=this._scrollDispatcher.getAncestorScrollContainers(this.element).map(a=>a.getElementRef().nativeElement);this._dropListRef.withScrollableParents(i),this._scrollableParentsResolved=!0}n.disabled=this.disabled,n.lockAxis=this.lockAxis,n.sortingDisabled=Yr(this.sortingDisabled),n.autoScrollDisabled=Yr(this.autoScrollDisabled),n.autoScrollStep=Bl(this.autoScrollStep,2),n.connectedTo(r.filter(i=>i&&i!==this).map(i=>i._dropListRef)).withOrientation(this.orientation)})}_handleEvents(n){n.beforeStarted.subscribe(()=>{this._syncItemsWithRef(),this._changeDetectorRef.markForCheck()}),n.entered.subscribe(r=>{this.entered.emit({container:this,item:r.item.data,currentIndex:r.currentIndex})}),n.exited.subscribe(r=>{this.exited.emit({container:this,item:r.item.data}),this._changeDetectorRef.markForCheck()}),n.sorted.subscribe(r=>{this.sorted.emit({previousIndex:r.previousIndex,currentIndex:r.currentIndex,container:this,item:r.item.data})}),n.dropped.subscribe(r=>{this.dropped.emit({previousIndex:r.previousIndex,currentIndex:r.currentIndex,previousContainer:r.previousContainer.data,container:r.container.data,item:r.item.data,isPointerOverContainer:r.isPointerOverContainer,distance:r.distance,dropPoint:r.dropPoint,event:r.event}),this._changeDetectorRef.markForCheck()}),ji(n.receivingStarted,n.receivingStopped).subscribe(()=>this._changeDetectorRef.markForCheck())}_assignDefaults(n){const{lockAxis:r,draggingDisabled:i,sortingDisabled:a,listAutoScrollDisabled:c,listOrientation:f}=n;this.disabled=i??!1,this.sortingDisabled=a??!1,this.autoScrollDisabled=c??!1,this.orientation=f||"vertical",r&&(this.lockAxis=r)}_syncItemsWithRef(){this._dropListRef.withItems(this.getSortedItems().map(n=>n._dragRef))}}return(t=e)._dropLists=[],t.\u0275fac=function(n){return new(n||t)(lt(yr),lt(BV),lt(Ll),lt(Tb),lt(td,8),lt(XR,12),lt(zV,8))},t.\u0275dir=Gn({type:t,selectors:[["","cdkDropList",""],["cdk-drop-list"]],hostAttrs:[1,"cdk-drop-list"],hostVars:7,hostBindings:function(n,r){2&n&&(si("id",r.id),Ei("cdk-drop-list-disabled",r.disabled)("cdk-drop-list-dragging",r._dropListRef.isDragging())("cdk-drop-list-receiving",r._dropListRef.isReceiving()))},inputs:{connectedTo:["cdkDropListConnectedTo","connectedTo"],data:["cdkDropListData","data"],orientation:["cdkDropListOrientation","orientation"],id:"id",lockAxis:["cdkDropListLockAxis","lockAxis"],disabled:["cdkDropListDisabled","disabled"],sortingDisabled:["cdkDropListSortingDisabled","sortingDisabled"],enterPredicate:["cdkDropListEnterPredicate","enterPredicate"],sortPredicate:["cdkDropListSortPredicate","sortPredicate"],autoScrollDisabled:["cdkDropListAutoScrollDisabled","autoScrollDisabled"],autoScrollStep:["cdkDropListAutoScrollStep","autoScrollStep"]},outputs:{dropped:"cdkDropListDropped",entered:"cdkDropListEntered",exited:"cdkDropListExited",sorted:"cdkDropListSorted"},exportAs:["cdkDropList"],standalone:!0,features:[vr([{provide:XR,useValue:void 0},{provide:WV,useExisting:t}])]}),e})();function QJ(t,e){1&t&&(yn(0,"span",7),ri(1,1),In())}function JJ(t,e){1&t&&(yn(0,"span",8),ri(1,2),In())}const GV=["*",[["mat-chip-avatar"],["","matChipAvatar",""]],[["mat-chip-trailing-icon"],["","matChipRemove",""],["","matChipTrailingIcon",""]]],KV=["*","mat-chip-avatar, [matChipAvatar]","mat-chip-trailing-icon,[matChipRemove],[matChipTrailingIcon]"];function qJ(t,e){1&t&&(yn(0,"span",8),ri(1,1),yn(2,"span",9),Gu(),yn(3,"svg",10),ti(4,"path",11),In()()())}function eq(t,e){1&t&&(yn(0,"span",12),ri(1,2),In())}const YR=["*"],SI=new Zn("mat-chips-default-options"),ZR=new Zn("MatChipAvatar"),QR=new Zn("MatChipTrailingIcon"),JR=new Zn("MatChipRemove"),II=new Zn("MatChip");class uq{}const dq=hC(uq,-1);let Pb=(()=>{var t;class e extends dq{get disabled(){return this._disabled||this._parentChip.disabled}set disabled(n){this._disabled=Yr(n)}_getDisabledAttribute(){return this.disabled&&!this._allowFocusWhenDisabled?"":null}_getTabindex(){return this.disabled&&!this._allowFocusWhenDisabled||!this.isInteractive?null:this.tabIndex.toString()}constructor(n,r){super(),this._elementRef=n,this._parentChip=r,this.isInteractive=!0,this._isPrimary=!0,this._disabled=!1,this._allowFocusWhenDisabled=!1,"BUTTON"===n.nativeElement.nodeName&&n.nativeElement.setAttribute("type","button")}focus(){this._elementRef.nativeElement.focus()}_handleClick(n){!this.disabled&&this.isInteractive&&this._isPrimary&&(n.preventDefault(),this._parentChip._handlePrimaryActionInteraction())}_handleKeydown(n){(13===n.keyCode||32===n.keyCode)&&!this.disabled&&this.isInteractive&&this._isPrimary&&!this._parentChip._isEditing&&(n.preventDefault(),this._parentChip._handlePrimaryActionInteraction())}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(II))},t.\u0275dir=Gn({type:t,selectors:[["","matChipAction",""]],hostAttrs:[1,"mdc-evolution-chip__action","mat-mdc-chip-action"],hostVars:9,hostBindings:function(n,r){1&n&&qs("click",function(a){return r._handleClick(a)})("keydown",function(a){return r._handleKeydown(a)}),2&n&&(si("tabindex",r._getTabindex())("disabled",r._getDisabledAttribute())("aria-disabled",r.disabled),Ei("mdc-evolution-chip__action--primary",r._isPrimary)("mdc-evolution-chip__action--presentational",!r.isInteractive)("mdc-evolution-chip__action--trailing",!r._isPrimary))},inputs:{disabled:"disabled",tabIndex:"tabIndex",isInteractive:"isInteractive",_allowFocusWhenDisabled:"_allowFocusWhenDisabled"},features:[Ps]}),e})(),ZV=(()=>{var t;class e extends Pb{constructor(){super(...arguments),this._isPrimary=!1}_handleClick(n){this.disabled||(n.stopPropagation(),n.preventDefault(),this._parentChip.remove())}_handleKeydown(n){(13===n.keyCode||32===n.keyCode)&&!this.disabled&&(n.stopPropagation(),n.preventDefault(),this._parentChip.remove())}}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275dir=Gn({type:t,selectors:[["","matChipRemove",""]],hostAttrs:["role","button",1,"mat-mdc-chip-remove","mat-mdc-chip-trailing-icon","mat-mdc-focus-indicator","mdc-evolution-chip__icon","mdc-evolution-chip__icon--trailing"],hostVars:1,hostBindings:function(n,r){2&n&&si("aria-hidden",null)},features:[vr([{provide:JR,useExisting:t}]),Ps]}),e})(),fq=0;const mq=hC(Ib(BS(Sb(class{constructor(t){this._elementRef=t}})),"primary"),-1);let d0=(()=>{var t;class e extends mq{_hasFocus(){return this._hasFocusInternal}get value(){return void 0!==this._value?this._value:this._textElement.textContent.trim()}set value(n){this._value=n}get removable(){return this._removable}set removable(n){this._removable=Yr(n)}get highlighted(){return this._highlighted}set highlighted(n){this._highlighted=Yr(n)}get ripple(){return this._rippleLoader?.getRipple(this._elementRef.nativeElement)}set ripple(n){this._rippleLoader?.attachRipple(this._elementRef.nativeElement,n)}constructor(n,r,i,a,c,f,g,E){super(r),this._changeDetectorRef=n,this._ngZone=i,this._focusMonitor=a,this._globalRippleOptions=g,this._onFocus=new Bt,this._onBlur=new Bt,this.role=null,this._hasFocusInternal=!1,this.id="mat-mdc-chip-"+fq++,this.ariaLabel=null,this.ariaDescription=null,this._ariaDescriptionId=`${this.id}-aria-description`,this._removable=!0,this._highlighted=!1,this.removed=new Rr,this.destroyed=new Rr,this.basicChipAttrName="mat-basic-chip",this._rippleLoader=jn(q3),this._document=c,this._animationsDisabled="NoopAnimations"===f,null!=E&&(this.tabIndex=parseInt(E)??this.defaultTabIndex),this._monitorFocus(),this._rippleLoader?.configureRipple(this._elementRef.nativeElement,{className:"mat-mdc-chip-ripple",disabled:this._isRippleDisabled()})}ngOnInit(){const n=this._elementRef.nativeElement;this._isBasicChip=n.hasAttribute(this.basicChipAttrName)||n.tagName.toLowerCase()===this.basicChipAttrName}ngAfterViewInit(){this._textElement=this._elementRef.nativeElement.querySelector(".mat-mdc-chip-action-label"),this._pendingFocus&&(this._pendingFocus=!1,this.focus())}ngAfterContentInit(){this._actionChanges=ji(this._allLeadingIcons.changes,this._allTrailingIcons.changes,this._allRemoveIcons.changes).subscribe(()=>this._changeDetectorRef.markForCheck())}ngDoCheck(){this._rippleLoader.setDisabled(this._elementRef.nativeElement,this._isRippleDisabled())}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef),this._actionChanges?.unsubscribe(),this.destroyed.emit({chip:this}),this.destroyed.complete()}remove(){this.removable&&this.removed.emit({chip:this})}_isRippleDisabled(){return this.disabled||this.disableRipple||this._animationsDisabled||this._isBasicChip||!!this._globalRippleOptions?.disabled}_hasTrailingIcon(){return!(!this.trailingIcon&&!this.removeIcon)}_handleKeydown(n){(8===n.keyCode||46===n.keyCode)&&(n.preventDefault(),this.remove())}focus(){this.disabled||(this.primaryAction?this.primaryAction.focus():this._pendingFocus=!0)}_getSourceAction(n){return this._getActions().find(r=>{const i=r._elementRef.nativeElement;return i===n||i.contains(n)})}_getActions(){const n=[];return this.primaryAction&&n.push(this.primaryAction),this.removeIcon&&n.push(this.removeIcon),this.trailingIcon&&n.push(this.trailingIcon),n}_handlePrimaryActionInteraction(){}_monitorFocus(){this._focusMonitor.monitor(this._elementRef,!0).subscribe(n=>{const r=null!==n;r!==this._hasFocusInternal&&(this._hasFocusInternal=r,r?this._onFocus.next({chip:this}):this._ngZone.onStable.pipe($l(1)).subscribe(()=>this._ngZone.run(()=>this._onBlur.next({chip:this}))))})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Ll),lt(yr),lt(Gs),lt($m),lt(yi),lt(ac,8),lt(mC,8),na("tabindex"))},t.\u0275cmp=sr({type:t,selectors:[["mat-basic-chip"],["","mat-basic-chip",""],["mat-chip"],["","mat-chip",""]],contentQueries:function(n,r,i){if(1&n&&(ea(i,ZR,5),ea(i,QR,5),ea(i,JR,5),ea(i,ZR,5),ea(i,QR,5),ea(i,JR,5)),2&n){let a;Ar(a=kr())&&(r.leadingIcon=a.first),Ar(a=kr())&&(r.trailingIcon=a.first),Ar(a=kr())&&(r.removeIcon=a.first),Ar(a=kr())&&(r._allLeadingIcons=a),Ar(a=kr())&&(r._allTrailingIcons=a),Ar(a=kr())&&(r._allRemoveIcons=a)}},viewQuery:function(n,r){if(1&n&&qo(Pb,5),2&n){let i;Ar(i=kr())&&(r.primaryAction=i.first)}},hostAttrs:[1,"mat-mdc-chip"],hostVars:30,hostBindings:function(n,r){1&n&&qs("keydown",function(a){return r._handleKeydown(a)}),2&n&&(ih("id",r.id),si("role",r.role)("tabindex",r.role?r.tabIndex:null)("aria-label",r.ariaLabel),Ei("mdc-evolution-chip",!r._isBasicChip)("mdc-evolution-chip--disabled",r.disabled)("mdc-evolution-chip--with-trailing-action",r._hasTrailingIcon())("mdc-evolution-chip--with-primary-graphic",r.leadingIcon)("mdc-evolution-chip--with-primary-icon",r.leadingIcon)("mdc-evolution-chip--with-avatar",r.leadingIcon)("mat-mdc-chip-with-avatar",r.leadingIcon)("mat-mdc-chip-highlighted",r.highlighted)("mat-mdc-chip-disabled",r.disabled)("mat-mdc-basic-chip",r._isBasicChip)("mat-mdc-standard-chip",!r._isBasicChip)("mat-mdc-chip-with-trailing-icon",r._hasTrailingIcon())("_mat-animation-noopable",r._animationsDisabled))},inputs:{color:"color",disabled:"disabled",disableRipple:"disableRipple",tabIndex:"tabIndex",role:"role",id:"id",ariaLabel:["aria-label","ariaLabel"],ariaDescription:["aria-description","ariaDescription"],value:"value",removable:"removable",highlighted:"highlighted"},outputs:{removed:"removed",destroyed:"destroyed"},exportAs:["matChip"],features:[vr([{provide:II,useExisting:t}]),Ps],ngContentSelectors:KV,decls:8,vars:3,consts:[[1,"mat-mdc-chip-focus-overlay"],[1,"mdc-evolution-chip__cell","mdc-evolution-chip__cell--primary"],["matChipAction","",3,"isInteractive"],["class","mdc-evolution-chip__graphic mat-mdc-chip-graphic",4,"ngIf"],[1,"mdc-evolution-chip__text-label","mat-mdc-chip-action-label"],[1,"mat-mdc-chip-primary-focus-indicator","mat-mdc-focus-indicator"],["class","mdc-evolution-chip__cell mdc-evolution-chip__cell--trailing",4,"ngIf"],[1,"mdc-evolution-chip__graphic","mat-mdc-chip-graphic"],[1,"mdc-evolution-chip__cell","mdc-evolution-chip__cell--trailing"]],template:function(n,r){1&n&&(Pl(GV),ti(0,"span",0),yn(1,"span",1)(2,"span",2),Fs(3,QJ,2,0,"span",3),yn(4,"span",4),ri(5),ti(6,"span",5),In()()(),Fs(7,JJ,2,0,"span",6)),2&n&&(Un(2),Yn("isInteractive",!1),Un(1),Yn("ngIf",r.leadingIcon),Un(4),Yn("ngIf",r._hasTrailingIcon()))},dependencies:[$d,Pb],styles:['.mdc-evolution-chip,.mdc-evolution-chip__cell,.mdc-evolution-chip__action{display:inline-flex;align-items:center}.mdc-evolution-chip{position:relative;max-width:100%}.mdc-evolution-chip .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-evolution-chip__cell,.mdc-evolution-chip__action{height:100%}.mdc-evolution-chip__cell--primary{overflow-x:hidden}.mdc-evolution-chip__cell--trailing{flex:1 0 auto}.mdc-evolution-chip__action{align-items:center;background:none;border:none;box-sizing:content-box;cursor:pointer;display:inline-flex;justify-content:center;outline:none;padding:0;text-decoration:none;color:inherit}.mdc-evolution-chip__action--presentational{cursor:auto}.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{pointer-events:none}.mdc-evolution-chip__action--primary{overflow-x:hidden}.mdc-evolution-chip__action--trailing{position:relative;overflow:visible}.mdc-evolution-chip__action--primary:before{box-sizing:border-box;content:"";height:100%;left:0;position:absolute;pointer-events:none;top:0;width:100%;z-index:1}.mdc-evolution-chip--touch{margin-top:8px;margin-bottom:8px}.mdc-evolution-chip__action-touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-evolution-chip__text-label{white-space:nowrap;user-select:none;text-overflow:ellipsis;overflow:hidden}.mdc-evolution-chip__graphic{align-items:center;display:inline-flex;justify-content:center;overflow:hidden;pointer-events:none;position:relative;flex:1 0 auto}.mdc-evolution-chip__checkmark{position:absolute;opacity:0;top:50%;left:50%}.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--selected):not(.mdc-evolution-chip--with-primary-icon) .mdc-evolution-chip__graphic{width:0}.mdc-evolution-chip__checkmark-background{opacity:0}.mdc-evolution-chip__checkmark-svg{display:block}.mdc-evolution-chip__checkmark-path{stroke-width:2px;stroke-dasharray:29.7833385;stroke-dashoffset:29.7833385;stroke:currentColor}.mdc-evolution-chip--selecting .mdc-evolution-chip__graphic{transition:width 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark{transition:transform 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting .mdc-evolution-chip__graphic{transition:width 100ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting .mdc-evolution-chip__checkmark{transition:opacity 50ms 0ms linear,transform 100ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--deselecting .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}.mdc-evolution-chip--selecting-with-primary-icon .mdc-evolution-chip__icon--primary{transition:opacity 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selecting-with-primary-icon .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 75ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting-with-primary-icon .mdc-evolution-chip__icon--primary{transition:opacity 150ms 75ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting-with-primary-icon .mdc-evolution-chip__checkmark{transition:opacity 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-50%, -50%)}.mdc-evolution-chip--deselecting-with-primary-icon .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}.mdc-evolution-chip--selected .mdc-evolution-chip__icon--primary{opacity:0}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{transform:translate(-50%, -50%);opacity:1}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}@keyframes mdc-evolution-chip-enter{from{transform:scale(0.8);opacity:.4}to{transform:scale(1);opacity:1}}.mdc-evolution-chip--enter{animation:mdc-evolution-chip-enter 100ms 0ms cubic-bezier(0, 0, 0.2, 1)}@keyframes mdc-evolution-chip-exit{from{opacity:1}to{opacity:0}}.mdc-evolution-chip--exit{animation:mdc-evolution-chip-exit 75ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-evolution-chip--hidden{opacity:0;pointer-events:none;transition:width 150ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mat-mdc-standard-chip{border-radius:var(--mdc-chip-container-shape-radius);height:var(--mdc-chip-container-height);--mdc-chip-container-shape-family:rounded;--mdc-chip-container-shape-radius:16px 16px 16px 16px;--mdc-chip-with-avatar-avatar-shape-family:rounded;--mdc-chip-with-avatar-avatar-shape-radius:14px 14px 14px 14px;--mdc-chip-with-avatar-avatar-size:28px;--mdc-chip-with-icon-icon-size:18px}.mat-mdc-standard-chip .mdc-evolution-chip__ripple{border-radius:var(--mdc-chip-container-shape-radius)}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary:before{border-radius:var(--mdc-chip-container-shape-radius)}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{border-radius:var(--mdc-chip-with-avatar-avatar-shape-radius)}.mat-mdc-standard-chip.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--with-primary-icon){--mdc-chip-graphic-selected-width:var(--mdc-chip-with-avatar-avatar-size)}.mat-mdc-standard-chip .mdc-evolution-chip__graphic{height:var(--mdc-chip-with-avatar-avatar-size);width:var(--mdc-chip-with-avatar-avatar-size);font-size:var(--mdc-chip-with-avatar-avatar-size)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip .mdc-evolution-chip__text-label{font-family:var(--mdc-chip-label-text-font);line-height:var(--mdc-chip-label-text-line-height);font-size:var(--mdc-chip-label-text-size);font-weight:var(--mdc-chip-label-text-weight);letter-spacing:var(--mdc-chip-label-text-tracking)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-label-text-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color)}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{height:var(--mdc-chip-with-icon-icon-size);width:var(--mdc-chip-with-icon-icon-size);font-size:var(--mdc-chip-with-icon-icon-size)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-icon-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-disabled-icon-color)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-disabled-icon-color)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--trailing{color:var(--mdc-chip-with-trailing-icon-trailing-icon-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{color:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-color)}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary.mdc-ripple-upgraded--background-focused .mdc-evolution-chip__ripple::before,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary:not(.mdc-ripple-upgraded):focus .mdc-evolution-chip__ripple::before{transition-duration:75ms;opacity:var(--mdc-chip-focus-state-layer-opacity)}.mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color);opacity:var(--mdc-chip-focus-state-layer-opacity)}.mat-mdc-standard-chip .mdc-evolution-chip__checkmark{height:20px;width:20px}.mat-mdc-standard-chip .mdc-evolution-chip__icon--trailing{height:18px;width:18px;font-size:18px}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:12px;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic[dir=rtl]{padding-left:6px;padding-right:6px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:12px;padding-right:0}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing[dir=rtl]{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing{left:8px;right:initial}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing[dir=rtl]{left:initial;right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:0;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic[dir=rtl]{padding-left:6px;padding-right:6px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing[dir=rtl]{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing{left:8px;right:initial}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing[dir=rtl]{left:initial;right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:0;padding-right:0}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color, currentColor)}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic[dir=rtl]{padding-left:8px;padding-right:4px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:12px;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic[dir=rtl]{padding-left:8px;padding-right:4px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing[dir=rtl]{padding-left:8px;padding-right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing{left:8px;right:initial}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing[dir=rtl]{left:initial;right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:0;padding-right:0}.mat-mdc-standard-chip{-webkit-tap-highlight-color:rgba(0,0,0,0)}.cdk-high-contrast-active .mat-mdc-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-mdc-standard-chip .mdc-evolution-chip__checkmark-path{stroke:CanvasText !important}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{opacity:.4}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mat-mdc-chip-action-label{overflow:visible}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary{flex-basis:100%}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{font:inherit;letter-spacing:inherit;white-space:inherit}.mat-mdc-standard-chip .mat-mdc-chip-graphic,.mat-mdc-standard-chip .mat-mdc-chip-trailing-icon{box-sizing:content-box}.mat-mdc-standard-chip._mat-animation-noopable,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__graphic,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark-path{transition-duration:1ms;animation-duration:1ms}.mat-mdc-basic-chip .mdc-evolution-chip__action--primary{font:inherit}.mat-mdc-chip-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;opacity:0;border-radius:inherit;transition:opacity 150ms linear}._mat-animation-noopable .mat-mdc-chip-focus-overlay{transition:none}.mat-mdc-basic-chip .mat-mdc-chip-focus-overlay{display:none}.mat-mdc-chip:hover .mat-mdc-chip-focus-overlay{opacity:.04}.mat-mdc-chip.cdk-focused .mat-mdc-chip-focus-overlay{opacity:.12}.mat-mdc-chip .mat-ripple.mat-mdc-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-chip-avatar{text-align:center;line-height:1;color:var(--mdc-chip-with-icon-icon-color, currentColor)}.mat-mdc-chip{position:relative;z-index:0}.mat-mdc-chip-action-label{text-align:left;z-index:1}[dir=rtl] .mat-mdc-chip-action-label{text-align:right}.mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{position:relative}.mat-mdc-chip-action-label .mat-mdc-chip-primary-focus-indicator{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.mat-mdc-chip-action-label .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-chip-remove{opacity:.54}.mat-mdc-chip-remove:focus{opacity:1}.mat-mdc-chip-remove::before{margin:calc(var(--mat-mdc-focus-indicator-border-width, 3px) * -1);left:8px;right:8px}.mat-mdc-chip-remove .mat-icon{width:inherit;height:inherit;font-size:inherit;box-sizing:content-box}.mat-chip-edit-input{cursor:text;display:inline-block;color:inherit;outline:0}.cdk-high-contrast-active .mat-mdc-chip-selected:not(.mat-mdc-chip-multiple){outline-width:3px}.mat-mdc-chip-action:focus .mat-mdc-focus-indicator::before{content:""}'],encapsulation:2,changeDetection:0}),e})(),qR=(()=>{var t;class e extends d0{constructor(){super(...arguments),this._defaultOptions=jn(SI,{optional:!0}),this.chipListSelectable=!0,this._chipListMultiple=!1,this._chipListHideSingleSelectionIndicator=this._defaultOptions?.hideSingleSelectionIndicator??!1,this._selectable=!0,this._selected=!1,this.basicChipAttrName="mat-basic-chip-option",this.selectionChange=new Rr}get selectable(){return this._selectable&&this.chipListSelectable}set selectable(n){this._selectable=Yr(n),this._changeDetectorRef.markForCheck()}get selected(){return this._selected}set selected(n){this._setSelectedState(Yr(n),!1,!0)}get ariaSelected(){return this.selectable?this.selected.toString():null}ngOnInit(){super.ngOnInit(),this.role="presentation"}select(){this._setSelectedState(!0,!1,!0)}deselect(){this._setSelectedState(!1,!1,!0)}selectViaInteraction(){this._setSelectedState(!0,!0,!0)}toggleSelected(n=!1){return this._setSelectedState(!this.selected,n,!0),this.selected}_handlePrimaryActionInteraction(){this.disabled||(this.focus(),this.selectable&&this.toggleSelected(!0))}_hasLeadingGraphic(){return!!this.leadingIcon||!this._chipListHideSingleSelectionIndicator||this._chipListMultiple}_setSelectedState(n,r,i){n!==this.selected&&(this._selected=n,i&&this.selectionChange.emit({source:this,isUserInput:r,selected:this.selected}),this._changeDetectorRef.markForCheck())}}return(t=e).\u0275fac=function(){let s;return function(r){return(s||(s=Gr(t)))(r||t)}}(),t.\u0275cmp=sr({type:t,selectors:[["mat-basic-chip-option"],["","mat-basic-chip-option",""],["mat-chip-option"],["","mat-chip-option",""]],hostAttrs:[1,"mat-mdc-chip","mat-mdc-chip-option"],hostVars:37,hostBindings:function(n,r){2&n&&(ih("id",r.id),si("tabindex",null)("aria-label",null)("aria-description",null)("role",r.role),Ei("mdc-evolution-chip",!r._isBasicChip)("mdc-evolution-chip--filter",!r._isBasicChip)("mdc-evolution-chip--selectable",!r._isBasicChip)("mat-mdc-chip-selected",r.selected)("mat-mdc-chip-multiple",r._chipListMultiple)("mat-mdc-chip-disabled",r.disabled)("mat-mdc-chip-with-avatar",r.leadingIcon)("mdc-evolution-chip--disabled",r.disabled)("mdc-evolution-chip--selected",r.selected)("mdc-evolution-chip--selecting",!r._animationsDisabled)("mdc-evolution-chip--with-trailing-action",r._hasTrailingIcon())("mdc-evolution-chip--with-primary-icon",r.leadingIcon)("mdc-evolution-chip--with-primary-graphic",r._hasLeadingGraphic())("mdc-evolution-chip--with-avatar",r.leadingIcon)("mat-mdc-chip-highlighted",r.highlighted)("mat-mdc-chip-with-trailing-icon",r._hasTrailingIcon()))},inputs:{color:"color",disabled:"disabled",disableRipple:"disableRipple",tabIndex:"tabIndex",selectable:"selectable",selected:"selected"},outputs:{selectionChange:"selectionChange"},features:[vr([{provide:d0,useExisting:t},{provide:II,useExisting:t}]),Ps],ngContentSelectors:KV,decls:10,vars:9,consts:[[1,"mat-mdc-chip-focus-overlay"],[1,"mdc-evolution-chip__cell","mdc-evolution-chip__cell--primary"],["matChipAction","","role","option",3,"tabIndex","_allowFocusWhenDisabled"],["class","mdc-evolution-chip__graphic mat-mdc-chip-graphic",4,"ngIf"],[1,"mdc-evolution-chip__text-label","mat-mdc-chip-action-label"],[1,"mat-mdc-chip-primary-focus-indicator","mat-mdc-focus-indicator"],["class","mdc-evolution-chip__cell mdc-evolution-chip__cell--trailing",4,"ngIf"],[1,"cdk-visually-hidden",3,"id"],[1,"mdc-evolution-chip__graphic","mat-mdc-chip-graphic"],[1,"mdc-evolution-chip__checkmark"],["viewBox","-2 -3 30 30","focusable","false","aria-hidden","true",1,"mdc-evolution-chip__checkmark-svg"],["fill","none","stroke","currentColor","d","M1.73,12.91 8.1,19.28 22.79,4.59",1,"mdc-evolution-chip__checkmark-path"],[1,"mdc-evolution-chip__cell","mdc-evolution-chip__cell--trailing"]],template:function(n,r){1&n&&(Pl(GV),ti(0,"span",0),yn(1,"span",1)(2,"button",2),Fs(3,qJ,5,0,"span",3),yn(4,"span",4),ri(5),ti(6,"span",5),In()()(),Fs(7,eq,2,0,"span",6),yn(8,"span",7),Ys(9),In()),2&n&&(Un(2),Yn("tabIndex",r.tabIndex)("_allowFocusWhenDisabled",!0),si("aria-selected",r.ariaSelected)("aria-label",r.ariaLabel)("aria-describedby",r._ariaDescriptionId),Un(1),Yn("ngIf",r._hasLeadingGraphic()),Un(4),Yn("ngIf",r._hasTrailingIcon()),Un(1),Yn("id",r._ariaDescriptionId),Un(1),zu(r.ariaDescription))},dependencies:[$d,Pb],styles:['.mdc-evolution-chip,.mdc-evolution-chip__cell,.mdc-evolution-chip__action{display:inline-flex;align-items:center}.mdc-evolution-chip{position:relative;max-width:100%}.mdc-evolution-chip .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-evolution-chip__cell,.mdc-evolution-chip__action{height:100%}.mdc-evolution-chip__cell--primary{overflow-x:hidden}.mdc-evolution-chip__cell--trailing{flex:1 0 auto}.mdc-evolution-chip__action{align-items:center;background:none;border:none;box-sizing:content-box;cursor:pointer;display:inline-flex;justify-content:center;outline:none;padding:0;text-decoration:none;color:inherit}.mdc-evolution-chip__action--presentational{cursor:auto}.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{pointer-events:none}.mdc-evolution-chip__action--primary{overflow-x:hidden}.mdc-evolution-chip__action--trailing{position:relative;overflow:visible}.mdc-evolution-chip__action--primary:before{box-sizing:border-box;content:"";height:100%;left:0;position:absolute;pointer-events:none;top:0;width:100%;z-index:1}.mdc-evolution-chip--touch{margin-top:8px;margin-bottom:8px}.mdc-evolution-chip__action-touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-evolution-chip__text-label{white-space:nowrap;user-select:none;text-overflow:ellipsis;overflow:hidden}.mdc-evolution-chip__graphic{align-items:center;display:inline-flex;justify-content:center;overflow:hidden;pointer-events:none;position:relative;flex:1 0 auto}.mdc-evolution-chip__checkmark{position:absolute;opacity:0;top:50%;left:50%}.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--selected):not(.mdc-evolution-chip--with-primary-icon) .mdc-evolution-chip__graphic{width:0}.mdc-evolution-chip__checkmark-background{opacity:0}.mdc-evolution-chip__checkmark-svg{display:block}.mdc-evolution-chip__checkmark-path{stroke-width:2px;stroke-dasharray:29.7833385;stroke-dashoffset:29.7833385;stroke:currentColor}.mdc-evolution-chip--selecting .mdc-evolution-chip__graphic{transition:width 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark{transition:transform 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting .mdc-evolution-chip__graphic{transition:width 100ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting .mdc-evolution-chip__checkmark{transition:opacity 50ms 0ms linear,transform 100ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--deselecting .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}.mdc-evolution-chip--selecting-with-primary-icon .mdc-evolution-chip__icon--primary{transition:opacity 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selecting-with-primary-icon .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 75ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting-with-primary-icon .mdc-evolution-chip__icon--primary{transition:opacity 150ms 75ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--deselecting-with-primary-icon .mdc-evolution-chip__checkmark{transition:opacity 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-50%, -50%)}.mdc-evolution-chip--deselecting-with-primary-icon .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}.mdc-evolution-chip--selected .mdc-evolution-chip__icon--primary{opacity:0}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{transform:translate(-50%, -50%);opacity:1}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}@keyframes mdc-evolution-chip-enter{from{transform:scale(0.8);opacity:.4}to{transform:scale(1);opacity:1}}.mdc-evolution-chip--enter{animation:mdc-evolution-chip-enter 100ms 0ms cubic-bezier(0, 0, 0.2, 1)}@keyframes mdc-evolution-chip-exit{from{opacity:1}to{opacity:0}}.mdc-evolution-chip--exit{animation:mdc-evolution-chip-exit 75ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-evolution-chip--hidden{opacity:0;pointer-events:none;transition:width 150ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mat-mdc-standard-chip{border-radius:var(--mdc-chip-container-shape-radius);height:var(--mdc-chip-container-height);--mdc-chip-container-shape-family:rounded;--mdc-chip-container-shape-radius:16px 16px 16px 16px;--mdc-chip-with-avatar-avatar-shape-family:rounded;--mdc-chip-with-avatar-avatar-shape-radius:14px 14px 14px 14px;--mdc-chip-with-avatar-avatar-size:28px;--mdc-chip-with-icon-icon-size:18px}.mat-mdc-standard-chip .mdc-evolution-chip__ripple{border-radius:var(--mdc-chip-container-shape-radius)}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary:before{border-radius:var(--mdc-chip-container-shape-radius)}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{border-radius:var(--mdc-chip-with-avatar-avatar-shape-radius)}.mat-mdc-standard-chip.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--with-primary-icon){--mdc-chip-graphic-selected-width:var(--mdc-chip-with-avatar-avatar-size)}.mat-mdc-standard-chip .mdc-evolution-chip__graphic{height:var(--mdc-chip-with-avatar-avatar-size);width:var(--mdc-chip-with-avatar-avatar-size);font-size:var(--mdc-chip-with-avatar-avatar-size)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip .mdc-evolution-chip__text-label{font-family:var(--mdc-chip-label-text-font);line-height:var(--mdc-chip-label-text-line-height);font-size:var(--mdc-chip-label-text-size);font-weight:var(--mdc-chip-label-text-weight);letter-spacing:var(--mdc-chip-label-text-tracking)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-label-text-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color)}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{height:var(--mdc-chip-with-icon-icon-size);width:var(--mdc-chip-with-icon-icon-size);font-size:var(--mdc-chip-with-icon-icon-size)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-icon-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-disabled-icon-color)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-disabled-icon-color)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--trailing{color:var(--mdc-chip-with-trailing-icon-trailing-icon-color)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{color:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-color)}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary.mdc-ripple-upgraded--background-focused .mdc-evolution-chip__ripple::before,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary:not(.mdc-ripple-upgraded):focus .mdc-evolution-chip__ripple::before{transition-duration:75ms;opacity:var(--mdc-chip-focus-state-layer-opacity)}.mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color);opacity:var(--mdc-chip-focus-state-layer-opacity)}.mat-mdc-standard-chip .mdc-evolution-chip__checkmark{height:20px;width:20px}.mat-mdc-standard-chip .mdc-evolution-chip__icon--trailing{height:18px;width:18px;font-size:18px}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:12px;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic[dir=rtl]{padding-left:6px;padding-right:6px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:12px;padding-right:0}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing[dir=rtl]{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing{left:8px;right:initial}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing[dir=rtl]{left:initial;right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:0;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic[dir=rtl]{padding-left:6px;padding-right:6px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing[dir=rtl]{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing{left:8px;right:initial}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing[dir=rtl]{left:initial;right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:0;padding-right:0}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color, currentColor)}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic[dir=rtl]{padding-left:8px;padding-right:4px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:12px;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic[dir=rtl]{padding-left:8px;padding-right:4px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing[dir=rtl]{padding-left:8px;padding-right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing{left:8px;right:initial}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__ripple--trailing[dir=rtl]{left:initial;right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary,.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary[dir=rtl]{padding-left:0;padding-right:0}.mat-mdc-standard-chip{-webkit-tap-highlight-color:rgba(0,0,0,0)}.cdk-high-contrast-active .mat-mdc-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-mdc-standard-chip .mdc-evolution-chip__checkmark-path{stroke:CanvasText !important}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{opacity:.4}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mat-mdc-chip-action-label{overflow:visible}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary{flex-basis:100%}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{font:inherit;letter-spacing:inherit;white-space:inherit}.mat-mdc-standard-chip .mat-mdc-chip-graphic,.mat-mdc-standard-chip .mat-mdc-chip-trailing-icon{box-sizing:content-box}.mat-mdc-standard-chip._mat-animation-noopable,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__graphic,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark-path{transition-duration:1ms;animation-duration:1ms}.mat-mdc-basic-chip .mdc-evolution-chip__action--primary{font:inherit}.mat-mdc-chip-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;opacity:0;border-radius:inherit;transition:opacity 150ms linear}._mat-animation-noopable .mat-mdc-chip-focus-overlay{transition:none}.mat-mdc-basic-chip .mat-mdc-chip-focus-overlay{display:none}.mat-mdc-chip:hover .mat-mdc-chip-focus-overlay{opacity:.04}.mat-mdc-chip.cdk-focused .mat-mdc-chip-focus-overlay{opacity:.12}.mat-mdc-chip .mat-ripple.mat-mdc-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-chip-avatar{text-align:center;line-height:1;color:var(--mdc-chip-with-icon-icon-color, currentColor)}.mat-mdc-chip{position:relative;z-index:0}.mat-mdc-chip-action-label{text-align:left;z-index:1}[dir=rtl] .mat-mdc-chip-action-label{text-align:right}.mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{position:relative}.mat-mdc-chip-action-label .mat-mdc-chip-primary-focus-indicator{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.mat-mdc-chip-action-label .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-chip-remove{opacity:.54}.mat-mdc-chip-remove:focus{opacity:1}.mat-mdc-chip-remove::before{margin:calc(var(--mat-mdc-focus-indicator-border-width, 3px) * -1);left:8px;right:8px}.mat-mdc-chip-remove .mat-icon{width:inherit;height:inherit;font-size:inherit;box-sizing:content-box}.mat-chip-edit-input{cursor:text;display:inline-block;color:inherit;outline:0}.cdk-high-contrast-active .mat-mdc-chip-selected:not(.mat-mdc-chip-multiple){outline-width:3px}.mat-mdc-chip-action:focus .mat-mdc-focus-indicator::before{content:""}'],encapsulation:2,changeDetection:0}),e})();class gq{constructor(e){}}const _q=hC(gq);let AI=(()=>{var t;class e extends _q{get chipFocusChanges(){return this._getChipStream(n=>n._onFocus)}get chipDestroyedChanges(){return this._getChipStream(n=>n.destroyed)}get disabled(){return this._disabled}set disabled(n){this._disabled=Yr(n),this._syncChipsState()}get empty(){return!this._chips||0===this._chips.length}get role(){return this._explicitRole?this._explicitRole:this.empty?null:this._defaultRole}set role(n){this._explicitRole=n}get focused(){return this._hasFocusedChip()}constructor(n,r,i){super(n),this._elementRef=n,this._changeDetectorRef=r,this._dir=i,this._lastDestroyedFocusedChipIndex=null,this._destroyed=new Bt,this._defaultRole="presentation",this._disabled=!1,this._explicitRole=null,this._chipActions=new Ky}ngAfterViewInit(){this._setUpFocusManagement(),this._trackChipSetChanges(),this._trackDestroyedFocusedChip()}ngOnDestroy(){this._keyManager?.destroy(),this._chipActions.destroy(),this._destroyed.next(),this._destroyed.complete()}_hasFocusedChip(){return this._chips&&this._chips.some(n=>n._hasFocus())}_syncChipsState(){this._chips&&this._chips.forEach(n=>{n.disabled=this._disabled,n._changeDetectorRef.markForCheck()})}focus(){}_handleKeydown(n){this._originatesFromChip(n)&&this._keyManager.onKeydown(n)}_isValidIndex(n){return n>=0&&n<this._chips.length}_allowFocusEscape(){if(-1!==this.tabIndex){const n=this.tabIndex;this.tabIndex=-1,setTimeout(()=>this.tabIndex=n)}}_getChipStream(n){return this._chips.changes.pipe(ed(null),Qi(()=>ji(...this._chips.map(n))))}_originatesFromChip(n){let r=n.target;for(;r&&r!==this._elementRef.nativeElement;){if(r.classList.contains("mat-mdc-chip"))return!0;r=r.parentElement}return!1}_setUpFocusManagement(){this._chips.changes.pipe(ed(this._chips)).subscribe(n=>{const r=[];n.forEach(i=>i._getActions().forEach(a=>r.push(a))),this._chipActions.reset(r),this._chipActions.notifyOnChanges()}),this._keyManager=new I3(this._chipActions).withVerticalOrientation().withHorizontalOrientation(this._dir?this._dir.value:"ltr").withHomeAndEnd().skipPredicate(n=>this._skipPredicate(n)),this.chipFocusChanges.pipe(fo(this._destroyed)).subscribe(({chip:n})=>{const r=n._getSourceAction(document.activeElement);r&&this._keyManager.updateActiveItem(r)}),this._dir?.change.pipe(fo(this._destroyed)).subscribe(n=>this._keyManager.withHorizontalOrientation(n))}_skipPredicate(n){return!n.isInteractive||n.disabled}_trackChipSetChanges(){this._chips.changes.pipe(ed(null),fo(this._destroyed)).subscribe(()=>{this.disabled&&Promise.resolve().then(()=>this._syncChipsState()),this._redirectDestroyedChipFocus()})}_trackDestroyedFocusedChip(){this.chipDestroyedChanges.pipe(fo(this._destroyed)).subscribe(n=>{const i=this._chips.toArray().indexOf(n.chip);this._isValidIndex(i)&&n.chip._hasFocus()&&(this._lastDestroyedFocusedChipIndex=i)})}_redirectDestroyedChipFocus(){if(null!=this._lastDestroyedFocusedChipIndex){if(this._chips.length){const n=Math.min(this._lastDestroyedFocusedChipIndex,this._chips.length-1),r=this._chips.toArray()[n];r.disabled?1===this._chips.length?this.focus():this._keyManager.setPreviousItemActive():r.focus()}else this.focus();this._lastDestroyedFocusedChipIndex=null}}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(Ll),lt(td,8))},t.\u0275cmp=sr({type:t,selectors:[["mat-chip-set"]],contentQueries:function(n,r,i){if(1&n&&ea(i,d0,5),2&n){let a;Ar(a=kr())&&(r._chips=a)}},hostAttrs:[1,"mat-mdc-chip-set","mdc-evolution-chip-set"],hostVars:1,hostBindings:function(n,r){1&n&&qs("keydown",function(a){return r._handleKeydown(a)}),2&n&&si("role",r.role)},inputs:{disabled:"disabled",role:"role"},features:[Ps],ngContentSelectors:YR,decls:2,vars:0,consts:[["role","presentation",1,"mdc-evolution-chip-set__chips"]],template:function(n,r){1&n&&(Pl(),yn(0,"div",0),ri(1),In())},styles:[".mdc-evolution-chip-set{display:flex}.mdc-evolution-chip-set:focus{outline:none}.mdc-evolution-chip-set__chips{display:flex;flex-flow:wrap;min-width:0}.mdc-evolution-chip-set--overflow .mdc-evolution-chip-set__chips{flex-flow:nowrap}.mdc-evolution-chip-set .mdc-evolution-chip-set__chips{margin-left:-8px;margin-right:0}[dir=rtl] .mdc-evolution-chip-set .mdc-evolution-chip-set__chips,.mdc-evolution-chip-set .mdc-evolution-chip-set__chips[dir=rtl]{margin-left:0;margin-right:-8px}.mdc-evolution-chip-set .mdc-evolution-chip{margin-left:8px;margin-right:0}[dir=rtl] .mdc-evolution-chip-set .mdc-evolution-chip,.mdc-evolution-chip-set .mdc-evolution-chip[dir=rtl]{margin-left:0;margin-right:8px}.mdc-evolution-chip-set .mdc-evolution-chip{margin-top:4px;margin-bottom:4px}.mat-mdc-chip-set .mdc-evolution-chip-set__chips{min-width:100%}.mat-mdc-chip-set-stacked{flex-direction:column;align-items:flex-start}.mat-mdc-chip-set-stacked .mat-mdc-chip{width:100%}.mat-mdc-chip-set-stacked .mdc-evolution-chip__graphic{flex-grow:0}.mat-mdc-chip-set-stacked .mdc-evolution-chip__action--primary{flex-basis:100%;justify-content:start}input.mat-mdc-chip-input{flex:1 0 150px;margin-left:8px}[dir=rtl] input.mat-mdc-chip-input{margin-left:0;margin-right:8px}"],encapsulation:2,changeDetection:0}),e})(),Dq=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[VS,{provide:SI,useValue:{separatorKeyCodes:[13]}}],imports:[nl,Ah,zS,nl]}),e})();function Sq(t,e){if(1&t){const s=iu();yn(0,"div",5)(1,"mat-chip-option",6),Ys(2),yn(3,"mat-icon",7),qs("click",function(){const i=hr(s).$implicit;return gs(bs(2).removeTrack(i))}),Ys(4,"cancel"),In()()()}if(2&t){const s=e.$implicit,n=e.index,r=bs(2);Un(1),Ei("shake",0===n&&r.isPlaying),Yn("selected",n<2)("color",0===n?"primary":1===n?"warn":"accent"),Un(1),Kv(" ",s.title," ",s.beatsPerMinute,"bpm ")}}function Iq(t,e){if(1&t){const s=iu();dd(0),yn(1,"mat-chip-set",3),qs("cdkDropListDropped",function(r){return hr(s),gs(bs().drop(r))}),Fs(2,Sq,5,6,"div",4),In(),hd()}if(2&t){const s=bs();Un(2),Yn("ngForOf",s.tracklist)}}function Tq(t,e){1&t&&(yn(0,"mat-chip",8),Ys(1,"Add a track!"),In()),2&t&&Yn("disabled",!0)}let Aq=(()=>{var t;class e{constructor(n,r,i){this.trackService=n,this.backTrackAudioService=r,this.tracklistService=i,this.isPlaying=!1,this.tracklist=[],this.dropSelecting=!1}ngOnInit(){this.playbackSubscription=this.backTrackAudioService.getPlaybackState().subscribe(n=>{this.isPlaying=n}),this.tracklistService.removeTrack$.subscribe(n=>{n>=0&&n<this.tracklist.length&&(this.tracklist.splice(n,1),this.tracklistService.updateTracklist(this.tracklist))}),this.selectedTrackSubscription=this.trackService.getSelectedTrack().subscribe(n=>{null!=n&&(this.tracklist.includes(n)||(this.isPlaying?this.tracklist.push(n):this.tracklist.unshift(n)),this.tracklistService.updateTracklist(this.tracklist))})}ngOnDestroy(){this.selectedTrackSubscription.unsubscribe(),this.playbackSubscription.unsubscribe()}removeTrack(n){const r=this.tracklist.indexOf(n);-1!==r&&this.tracklistService.removeTrack(r)}drop(n){this.isPlaying||(MV(this.tracklist,n.previousIndex,n.currentIndex),this.tracklistService.updateTracklist(this.tracklist))}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(VR),lt(rR),lt(iR))},t.\u0275cmp=sr({type:t,selectors:[["app-tracklist"]],decls:5,vars:2,consts:[[1,"tracklist-card"],[4,"ngIf","ngIfElse"],["noTracks",""],["cdkDropList","","cdkDropListOrientation","horizontal",3,"cdkDropListDropped"],["cdkDrag","",4,"ngFor","ngForOf"],["cdkDrag",""],[3,"selected","color"],["matChipRemove","",3,"click"],[3,"disabled"]],template:function(n,r){if(1&n&&(yn(0,"mat-card",0)(1,"mat-card-content"),Fs(2,Iq,3,1,"ng-container",1),Fs(3,Tq,2,1,"ng-template",null,2,Jv),In()()),2&n){const i=zp(4);Un(2),Yn("ngIf",r.tracklist.length>0)("ngIfElse",i)}},dependencies:[Rw,$d,gC,jS,d0,qR,ZV,AI,yC,HV,jV],styles:[".tracklist-card[_ngcontent-%COMP%]{text-align:left}@keyframes _ngcontent-%COMP%_shake{0%{transform:rotate(-4deg)}50%{transform:rotate(4deg)}to{transform:rotate(-4deg)}}.shake[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_shake .5s ease infinite}"]}),e})();var zm=h(5861),qV=h(2535);const kq=["determinateSpinner"];function Oq(t,e){if(1&t&&(Gu(),yn(0,"svg",11),ti(1,"circle",12),In()),2&t){const s=bs();si("viewBox",s._viewBox()),Un(1),Ju("stroke-dasharray",s._strokeCircumference(),"px")("stroke-dashoffset",s._strokeCircumference()/2,"px")("stroke-width",s._circleStrokeWidth(),"%"),si("r",s._circleRadius())}}const Rq=Ib(class{constructor(t){this._elementRef=t}},"primary"),Nq=new Zn("mat-progress-spinner-default-options",{providedIn:"root",factory:function Mq(){return{diameter:eU}}}),eU=100;let Fq=(()=>{var t;class e extends Rq{constructor(n,r,i){super(n),this.mode="mat-spinner"===this._elementRef.nativeElement.nodeName.toLowerCase()?"indeterminate":"determinate",this._value=0,this._diameter=eU,this._noopAnimations="NoopAnimations"===r&&!!i&&!i._forceAnimations,i&&(i.color&&(this.color=this.defaultColor=i.color),i.diameter&&(this.diameter=i.diameter),i.strokeWidth&&(this.strokeWidth=i.strokeWidth))}get value(){return"determinate"===this.mode?this._value:0}set value(n){this._value=Math.max(0,Math.min(100,Bl(n)))}get diameter(){return this._diameter}set diameter(n){this._diameter=Bl(n)}get strokeWidth(){return this._strokeWidth??this.diameter/10}set strokeWidth(n){this._strokeWidth=Bl(n)}_circleRadius(){return(this.diameter-10)/2}_viewBox(){const n=2*this._circleRadius()+this.strokeWidth;return`0 0 ${n} ${n}`}_strokeCircumference(){return 2*Math.PI*this._circleRadius()}_strokeDashOffset(){return"determinate"===this.mode?this._strokeCircumference()*(100-this._value)/100:null}_circleStrokeWidth(){return this.strokeWidth/this.diameter*100}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(ac,8),lt(Nq))},t.\u0275cmp=sr({type:t,selectors:[["mat-progress-spinner"],["mat-spinner"]],viewQuery:function(n,r){if(1&n&&qo(kq,5),2&n){let i;Ar(i=kr())&&(r._determinateCircle=i.first)}},hostAttrs:["role","progressbar","tabindex","-1",1,"mat-mdc-progress-spinner","mdc-circular-progress"],hostVars:16,hostBindings:function(n,r){2&n&&(si("aria-valuemin",0)("aria-valuemax",100)("aria-valuenow","determinate"===r.mode?r.value:null)("mode",r.mode),Ju("width",r.diameter,"px")("height",r.diameter,"px")("--mdc-circular-progress-size",r.diameter+"px")("--mdc-circular-progress-active-indicator-width",r.diameter+"px"),Ei("_mat-animation-noopable",r._noopAnimations)("mdc-circular-progress--indeterminate","indeterminate"===r.mode))},inputs:{color:"color",mode:"mode",value:"value",diameter:"diameter",strokeWidth:"strokeWidth"},exportAs:["matProgressSpinner"],features:[Ps],decls:14,vars:11,consts:[["circle",""],["aria-hidden","true",1,"mdc-circular-progress__determinate-container"],["determinateSpinner",""],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__determinate-circle-graphic"],["cx","50%","cy","50%",1,"mdc-circular-progress__determinate-circle"],["aria-hidden","true",1,"mdc-circular-progress__indeterminate-container"],[1,"mdc-circular-progress__spinner-layer"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-left"],[3,"ngTemplateOutlet"],[1,"mdc-circular-progress__gap-patch"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-right"],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__indeterminate-circle-graphic"],["cx","50%","cy","50%"]],template:function(n,r){if(1&n&&(Fs(0,Oq,2,8,"ng-template",null,0,Jv),yn(2,"div",1,2),Gu(),yn(4,"svg",3),ti(5,"circle",4),In()(),Ip(),yn(6,"div",5)(7,"div",6)(8,"div",7),Nd(9,8),In(),yn(10,"div",9),Nd(11,8),In(),yn(12,"div",10),Nd(13,8),In()()()),2&n){const i=zp(1);Un(4),si("viewBox",r._viewBox()),Un(1),Ju("stroke-dasharray",r._strokeCircumference(),"px")("stroke-dashoffset",r._strokeDashOffset(),"px")("stroke-width",r._circleStrokeWidth(),"%"),si("r",r._circleRadius()),Un(4),Yn("ngTemplateOutlet",i),Un(2),Yn("ngTemplateOutlet",i),Un(2),Yn("ngTemplateOutlet",i)}},dependencies:[S2],styles:["@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-color-1-fade-in-out{from{opacity:.99}25%{opacity:.99}26%{opacity:0}89%{opacity:0}90%{opacity:.99}to{opacity:.99}}@keyframes mdc-circular-progress-color-2-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:.99}50%{opacity:.99}51%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-3-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:.99}75%{opacity:.99}76%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-4-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:.99}90%{opacity:.99}to{opacity:0}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}.mdc-circular-progress{display:inline-flex;position:relative;direction:ltr;line-height:0;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-1{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-1-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-2{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-2-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-3{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-3-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-4{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-4-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--closed{opacity:0}.mat-mdc-progress-spinner{--mdc-circular-progress-active-indicator-width:4px;--mdc-circular-progress-size:48px}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mat-mdc-progress-spinner circle{stroke-width:var(--mdc-circular-progress-active-indicator-width)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-1 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-2 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-3 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-4 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mat-mdc-progress-spinner .mdc-circular-progress{width:var(--mdc-circular-progress-size) !important;height:var(--mdc-circular-progress-size) !important}.mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}"],encapsulation:2,changeDetection:0}),e})(),Lq=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[Ah,nl]}),e})();const $q=["webcam"];function Bq(t,e){if(1&t&&(yn(0,"div",8)(1,"mat-icon",9),Ys(2,"accessibility_new"),In(),yn(3,"mat-card-subtitle"),Ys(4),In()()),2&t){const s=bs();Un(4),zu(s.coolingOff?"Cool off?":"Idle"!==s.gesture||s.hasTrack?s.gesture:"Tilt your head!")}}function Vq(t,e){1&t&&(yn(0,"div",10),ti(1,"img",11)(2,"mat-spinner"),In())}function Uq(t,e){1&t&&(yn(0,"div",12),ti(1,"mat-progress-bar",9,13),In())}function zq(t,e){if(1&t){const s=iu();yn(0,"button",14),qs("click",function(){return hr(s),gs(bs().close())}),yn(1,"mat-icon"),Ys(2,"close"),In()()}}let Wq=(()=>{var t;class e{constructor(n,r,i){this.trackService=n,this.audioService=r,this.tracklistService=i,this.webcamLoaded=!1,this.loopId=null,this.maxPredictions=0,this.gesture="",this.closeComponent=new Rr,this.fadeIn=new Rr,this.hasFadedIn=!1,this.fadeOut=new Rr,this.canFadeOut=!1,this.isPlaying=!1,this.hasTrack=!1,this.countdown=0,this.coolingOff=!1,this.loop=()=>{this.webcam.update(),this.predict(),this.loopId=requestAnimationFrame(this.loop)}}ngAfterViewInit(){this.init(),this.playbackSubscription=this.audioService.getPlaybackState().subscribe(n=>{this.isPlaying=n}),this.tracklistSubscription=this.tracklistService.tracklist$.subscribe(n=>{this.hasTrack=null!=n&&n.length>0})}ngOnDestroy(){this.playbackSubscription.unsubscribe(),this.tracklistSubscription.unsubscribe(),console.log("stopping loop and webcam!"),this.stopLoopAndWebcam()}close(){this.closeComponent.emit()}init(){var n=this;return(0,zm.Z)(function*(){const r="./assets/gestures/",i=r+"model.json",a=r+"metadata.json";n.model=yield qV.zD(i,a),n.maxPredictions=n.model.getTotalClasses(),n.webcam=new qV.bb(200,200,!0),yield n.webcam.setup(),yield n.webcam.play(),n.webcamContainer.nativeElement.appendChild(n.webcam.canvas),n.loop(),n.webcamLoaded=!0})()}predict(){var n=this;return(0,zm.Z)(function*(){if(n.coolingOff)return void n.progressToIndeterminate();const{pose:r,posenetOutput:i}=yield n.model.estimatePose(n.webcam.canvas);n.pose=r;const a=yield n.model.predict(i);for(let c=0;c<n.maxPredictions;c++){const f=a[c],g=f.probability.toFixed(2),E=f.className;let Y="Idle";g>.8&&(n.hasTrack?n.hasTrack&&!n.isPlaying?Y="Idle"!=E?n.hasFadedIn?"Idle":"Fade In":"Idle":n.isPlaying&&(Y="Idle"!=E&&n.canFadeOut?"Fade Out":"Idle"):Y="Idle"!=E?"Add Track":"Idle"),n.gesture=Y}n.processPrediction()})()}processPrediction(){if("Idle"===this.gesture){if(this.countdown=0,this.hasFadedIn&&this.isPlaying&&!this.canFadeOut)return this.canFadeOut=!0,void console.log("can fade out!");this.canFadeOut&&this.hasFadedIn&&!this.isPlaying&&(console.log("reset faded in!"),this.hasFadedIn=!1,this.canFadeOut=!1),this.progressToBuffer()}else if(this.countdown+=10/this.maxPredictions,this.progressToDeterminate(this.countdown),this.countdown>120){if(this.countdown=120,"Add Track"===this.gesture)return void(this.hasTrack||(console.log("sent request!"),this.trackService.requestRandomTrack()));if(!this.hasFadedIn&&"Fade In"===this.gesture)return void(this.isPlaying||(this.hasFadedIn=!0,this.fadeIn.emit(),console.log("emitted event to fade in!"),this.startCoolingOff()));this.canFadeOut&&"Fade Out"===this.gesture&&(this.isPlaying&&(console.log("emitted event to fade out!"),this.fadeOut.emit()),this.startCoolingOff())}}startCoolingOff(){this.coolingOff=!0,this.progressToIndeterminate(),setTimeout(()=>{this.coolingOff=!1},2e3)}stopLoopAndWebcam(){null!==this.loopId&&cancelAnimationFrame(this.loopId),this.webcam&&(this.webcamLoaded=!1,this.webcam.stop())}progressToIndeterminate(){this.progressBar.mode="indeterminate",console.log("progress to indeterminate!"),this.progressBar.value=0}progressToDeterminate(n){this.progressBar.mode="determinate",this.progressBar.value=n}progressToBuffer(){this.progressBar.mode="buffer",this.progressBar.value=0}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(VR),lt(rR),lt(iR))},t.\u0275cmp=sr({type:t,selectors:[["app-gesture-control"]],viewQuery:function(n,r){if(1&n&&(qo($q,5),qo(gR,5)),2&n){let i;Ar(i=kr())&&(r.webcamContainer=i.first),Ar(i=kr())&&(r.progressBar=i.first)}},outputs:{closeComponent:"closeComponent",fadeIn:"fadeIn",fadeOut:"fadeOut"},decls:10,vars:4,consts:[[1,"gestures-container"],[1,"webcam-card"],["class","label-container",4,"ngIf"],[1,"content-container"],["class","spinner-container",4,"ngIf"],["class","progress-container",4,"ngIf"],["webcam",""],["color","warn","class","close-button","mat-mini-fab","",3,"click",4,"ngIf"],[1,"label-container"],["color","warn"],[1,"spinner-container"],["src","samson.png",1,"samson"],[1,"progress-container"],["progressBar",""],["color","warn","mat-mini-fab","",1,"close-button",3,"click"]],template:function(n,r){1&n&&(yn(0,"div",0)(1,"mat-card",1)(2,"mat-card-header"),Fs(3,Bq,5,1,"div",2),In(),yn(4,"mat-card-content",3),Fs(5,Vq,3,0,"div",4),Fs(6,Uq,3,0,"div",5),ti(7,"div",null,6),In(),Fs(9,zq,3,0,"button",7),In()()),2&n&&(Un(3),Yn("ngIf",r.webcamLoaded),Un(2),Yn("ngIf",!r.webcamLoaded),Un(1),Yn("ngIf",r.webcamLoaded),Un(3),Yn("ngIf",r.webcamLoaded))},dependencies:[$d,hX,gC,jS,nB,GS,yC,gR,Fq],styles:[".gestures-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:center;align-items:center;margin-bottom:2%}.samson[_ngcontent-%COMP%]{width:60px;height:50px;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.progress-container[_ngcontent-%COMP%]{margin:2%;padding:2%}.label-container[_ngcontent-%COMP%]{display:flex;justify-content:left}.label-container[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]:not(:last-child){margin-right:10px}.close-button[_ngcontent-%COMP%]{align-self:center}.content-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:10px}"]}),e})();function Hq(t,e){if(1&t){const s=iu();yn(0,"app-gesture-control",22),qs("fadeOut",function(){return hr(s),gs(bs().handleFadeOutGestureControl())})("fadeIn",function(){return hr(s),gs(bs().handleFadeInGestureControl())})("closeComponent",function(){return hr(s),gs(bs().handleCloseGestureControl())}),In()}}function jq(t,e){if(1&t){const s=iu();yn(0,"div",6)(1,"button",10),qs("click",function(){return hr(s),gs(bs().playNext())}),yn(2,"mat-icon",15),Ys(3,"skip_next"),In()()()}}function Gq(t,e){if(1&t){const s=iu();yn(0,"div",6)(1,"button",10),qs("click",function(){return hr(s),gs(bs().playNext())}),yn(2,"mat-icon",15),Ys(3,"repeat_one"),In()()()}}function Kq(t,e){1&t&&(yn(0,"div",6)(1,"button",23)(2,"mat-icon",15),Ys(3,"favorite"),In()()())}function Xq(t,e){if(1&t){const s=iu();yn(0,"div",6)(1,"button",42),qs("click",function(){return hr(s),gs(bs(2).fadeIn())}),Ys(2," FADE IN "),In()()}}function Yq(t,e){if(1&t){const s=iu();yn(0,"div",6)(1,"button",42),qs("click",function(){return hr(s),gs(bs(2).fadeOut())}),Ys(2," FADE OUT "),In()()}}function Zq(t,e){if(1&t){const s=iu();yn(0,"div",24)(1,"mat-expansion-panel",25)(2,"mat-expansion-panel-header")(3,"mat-panel-title")(4,"mat-icon"),Ys(5,"cable"),In(),yn(6,"h3"),Ys(7,"Track Pan & Fade"),In()()(),yn(8,"div",26)(9,"mat-card")(10,"mat-card-actions"),Fs(11,Xq,3,0,"div",16),Fs(12,Yq,3,0,"div",16),In()(),yn(13,"mat-card")(14,"div",27)(15,"button",28),qs("click",function(){return hr(s),gs(bs().setDefaultPan())}),yn(16,"mat-icon",15),Ys(17,"hearing"),In()(),yn(18,"mat-slider",12)(19,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().panValue=r)})("input",function(r){return hr(s),gs(bs().onPanChange(r))}),In()(),yn(20,"button",29),qs("click",function(){return hr(s),gs(bs().setDefaultPan())}),yn(21,"mat-icon",15),Ys(22,"hearing"),In()()()()()(),yn(23,"mat-expansion-panel",30)(24,"mat-expansion-panel-header")(25,"mat-panel-title")(26,"mat-icon"),Ys(27,"equalizer"),In(),yn(28,"h3"),Ys(29,"Track Three-Band Equalizer"),In()()(),yn(30,"div",31)(31,"mat-card")(32,"div",32)(33,"mat-slider",33)(34,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().equalizerLowValue=r)})("input",function(r){return hr(s),gs(bs().onEqualizerLowSliderChange(r))}),In()()(),yn(35,"button",34),qs("click",function(){return hr(s),gs(bs().setEqualizerDefaultLow())}),Ys(36," LOW "),In()(),yn(37,"mat-card")(38,"div",32)(39,"mat-slider",33)(40,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().equalizerMidValue=r)})("input",function(r){return hr(s),gs(bs().onEqualizerMidSliderChange(r))}),In()()(),yn(41,"button",34),qs("click",function(){return hr(s),gs(bs().setEqualizerDefaultMid())}),Ys(42," MID "),In()(),yn(43,"mat-card")(44,"div",32)(45,"mat-slider",33)(46,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().equalizerHighValue=r)})("input",function(r){return hr(s),gs(bs().onEqualizerHighSliderChange(r))}),In()()(),yn(47,"button",34),qs("click",function(){return hr(s),gs(bs().setEqualizerDefaultHigh())}),Ys(48," HIGH "),In()()()(),yn(49,"mat-expansion-panel",35)(50,"mat-expansion-panel-header")(51,"mat-panel-title")(52,"mat-icon"),Ys(53,"compress"),In(),yn(54,"h3"),Ys(55,"Track Compression"),In()()(),yn(56,"div",36)(57,"mat-card")(58,"mat-slider",37)(59,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().compressionThresholdValue=r)})("input",function(r){return hr(s),gs(bs().onCompressionThresholdChange(r))}),In()(),yn(60,"button",34),qs("click",function(){return hr(s),gs(bs().setDefaultCompressionThreshold())}),Ys(61," Threshold "),In()(),yn(62,"mat-card")(63,"mat-slider",38)(64,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().compressionKneeValue=r)})("input",function(r){return hr(s),gs(bs().onCompressionKneeChange(r))}),In()(),yn(65,"button",39),qs("click",function(){return hr(s),gs(bs().setDefaultCompressionKnee())}),Ys(66," Knee "),In()(),yn(67,"mat-card")(68,"mat-slider",40)(69,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().compressionRatioValue=r)})("input",function(r){return hr(s),gs(bs().onCompressionRatioChange(r))}),In()(),yn(70,"button",39),qs("click",function(){return hr(s),gs(bs().setDefaultCompressionRatio())}),Ys(71," Ratio "),In()(),yn(72,"mat-card")(73,"mat-slider",41)(74,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().compressionAttackValue=r)})("input",function(r){return hr(s),gs(bs().onCompressionAttackChange(r))}),In()(),yn(75,"button",39),qs("click",function(){return hr(s),gs(bs().setDefaultCompressionAttack())}),Ys(76," Attack "),In()(),yn(77,"mat-card")(78,"mat-slider",41)(79,"input",13),qs("ngModelChange",function(r){return hr(s),gs(bs().compressionReleaseValue=r)})("input",function(r){return hr(s),gs(bs().onCompressionReleaseChange(r))}),In()(),yn(80,"button",39),qs("click",function(){return hr(s),gs(bs().setDefaultCompressionRelease())}),Ys(81," Release "),In()()()()()}if(2&t){const s=bs();Un(11),Yn("ngIf",s.hasFadeOut||s.tracklist.length>=1&&!s.isPlaying),Un(1),Yn("ngIf",!s.hasFadeOut&&s.isPlaying),Un(6),Yn("displayWith",s.formatPanSliderLabel),Un(1),Yn("ngModel",s.panValue),Un(15),Yn("ngModel",s.equalizerLowValue),Un(6),Yn("ngModel",s.equalizerMidValue),Un(6),Yn("ngModel",s.equalizerHighValue),Un(12),Yn("displayWith",s.formatCompressionThresholdSliderLabel),Un(1),Yn("ngModel",s.compressionThresholdValue),Un(4),Yn("displayWith",s.formatCompressionKneeSliderLabel),Un(1),Yn("ngModel",s.compressionKneeValue),Un(4),Yn("displayWith",s.formatCompressionRatioSliderLabel),Un(1),Yn("ngModel",s.compressionRatioValue),Un(4),Yn("displayWith",s.formatCompressionAttackSliderLabel),Un(1),Yn("ngModel",s.compressionAttackValue),Un(4),Yn("displayWith",s.formatCompressionReleaseSliderLabel),Un(1),Yn("ngModel",s.compressionReleaseValue)}}let Qq=(()=>{var t;class e{constructor(n,r,i){this.databaseService=n,this.audioService=r,this.tracklistService=i,this.isPlaying=!1,this.isPaused=!1,this.hasFadeOut=!1,this.hasGestureControl=!1,this.volumeValue=e.DEFAULT_VOLUME,this.panValue=e.DEFAULT_PAN,this.fadeInValue=e.DEFAULT_FADE_IN,this.fadeOutValue=e.DEFAULT_FADE_OUT,this.compressionThresholdValue=e.DEFAULT_COMPRESSION_THRESHOLD,this.compressionKneeValue=e.DEFAULT_COMPRESSION_KNEE,this.compressionRatioValue=e.DEFAULT_COMPRESSION_RATIO,this.compressionAttackValue=e.DEFAULT_COMPRESSION_ATTACK,this.compressionReleaseValue=e.DEFAULT_COMPRESSION_RELEASE,this.equalizerLowValue=0,this.equalizerMidValue=0,this.equalizerHighValue=0,this.track=null,this.tracklist=[],this.trackProgress=0,this.trackDuration=0,this.nextPlay=!1,this.hasUpdatedTrack=!1}ngOnInit(){this.playbackSubscription=this.audioService.getPlaybackState().subscribe(n=>{this.isPlaying=n,this.audioService.backTrackEnded&&this.playNext()}),this.tracklistSubscription=this.tracklistService.tracklist$.subscribe(n=>{null!=n&&(this.tracklist=n,this.tracklist.length&&(this.track=this.tracklist[0],this.trackDuration=this.track.duration,this.audioService.loadAudioBuffer(this.track.sourcePath),this.nextPlay&&(this.nextPlay=!1,this.audioService.playBackTrackAudio(this.track.sourcePath))))}),this.timeUpdateSubscription=hB(1e3).subscribe(()=>{this.isPlaying&&this.track&&this.audioService.getCurrentTime().subscribe(n=>{this.trackProgress=n})}),this.bufferSubscription=this.audioService.getAudioBuffer().subscribe(n=>{n&&(console.log("got a buffer track is",this.track?.title),this.trackDuration=n.duration,this.track&&0===this.track.duration&&(console.log("we are going to update the duration in the database"),console.log("the duration in the buffer is",n.duration),this.track.duration=n.duration,this.databaseService.updateTrackDurationIfZero(this.track)))}),this.volumeSubscription=this.audioService.getVolumeLevel().subscribe(n=>{n<=.02&&this.isPlaying&&(this.audioService.stopBackTrackAudio(),this.tracklistService.removeTrack(0),this.track=null,this.trackDuration=0,this.trackProgress=0)})}ngOnDestroy(){this.playbackSubscription.unsubscribe(),this.timeUpdateSubscription.unsubscribe(),this.tracklistSubscription.unsubscribe(),this.bufferSubscription.unsubscribe(),this.volumeSubscription.unsubscribe()}handleCloseGestureControl(){this.hasGestureControl=!1}handleFadeInGestureControl(){this.fadeIn()}handleFadeOutGestureControl(){this.fadeOut()}setGestureControl(){this.hasGestureControl=!this.hasGestureControl}playNext(){if(this.tracklist.length<2)return;this.nextPlay=!0;const n=this.tracklist.shift();this.tracklist.push(n),this.tracklistService.updateTracklist(this.tracklist)}fadeOut(){this.audioService.fadeOut(e.DEFAULT_FADE_OUT),this.hasFadeOut=!0}fadeIn(){null!==this.track&&(this.hasFadeOut=!1,this.isPlaying||this.audioService.playBackTrackAudio(this.track.sourcePath),this.audioService.fadeIn(e.DEFAULT_FADE_IN))}selectedTrackPlayOrJustLoad(n){null!=this.track&&(this.audioService.loadAudioBuffer(this.track.sourcePath),n&&this.audioService.playBackTrackAudio(this.track.sourcePath))}calculateProgress(){return 0===this.audioService.backTrackDuration?0:Math.round(this.trackProgress/this.audioService.backTrackDuration*100*100)/100}pauseSelectedTrack(){this.isPaused=!0,this.audioService.pauseBackTrackAudio()}togglePlayback(){if(null!==this.track){if(this.isPlaying)return void this.audioService.stopBackTrackAudio();this.audioService.playBackTrackAudio(this.track.sourcePath),this.isPaused=!1}}onVolumeChange(n){this.audioService.setBackTrackVolume(+n.target.value)}formatVolumeSliderLabel(n){return`${Math.min(100,Math.max(0,n))}%`}setDefaultVolume(){this.volumeValue=e.DEFAULT_VOLUME,this.audioService.setBackTrackVolume(this.volumeValue)}onPanChange(n){this.audioService.setBackTrackPan(+n.target.value)}formatPanSliderLabel(n){return n<50?100-n+"%L":n>50?`${n}%R`:"Mid"}setDefaultPan(){this.panValue=e.DEFAULT_PAN,this.audioService.setBackTrackPan(this.panValue)}onCompressionThresholdChange(n){this.audioService.setBackTrackCompressionThreshold(+n.target.value)}formatCompressionThresholdSliderLabel(n){return`${Math.max(-60,Math.min(0,n))}dB`}setDefaultCompressionThreshold(){this.compressionThresholdValue=e.DEFAULT_COMPRESSION_THRESHOLD,this.audioService.setBackTrackCompressionThreshold(this.compressionThresholdValue)}onCompressionKneeChange(n){this.audioService.setBackTrackCompressionKnee(+n.target.value)}formatCompressionKneeSliderLabel(n){return`${Math.max(0,Math.min(40,n))}`}setDefaultCompressionKnee(){this.compressionKneeValue=e.DEFAULT_COMPRESSION_KNEE,this.audioService.setBackTrackCompressionKnee(this.compressionKneeValue)}onCompressionRatioChange(n){this.compressionRatioValue=+n.target.value,this.audioService.setBackTrackCompressionRatio(this.compressionRatioValue)}formatCompressionRatioSliderLabel(n){return`${Math.max(1,Math.min(20,n))}`}setDefaultCompressionRatio(){this.compressionRatioValue=e.DEFAULT_COMPRESSION_RATIO,this.audioService.setBackTrackCompressionRatio(this.compressionRatioValue)}onCompressionAttackChange(n){this.audioService.setBackTrackCompressionAttack(+n.target.value)}formatCompressionAttackSliderLabel(n){return`${Math.max(0,Math.min(1,n))}`}setDefaultCompressionAttack(){this.compressionAttackValue=e.DEFAULT_COMPRESSION_ATTACK,this.audioService.setBackTrackCompressionAttack(this.compressionAttackValue)}onCompressionReleaseChange(n){this.audioService.setBackTrackCompressionRelease(+n.target.value)}formatCompressionReleaseSliderLabel(n){return`${Math.max(0,Math.min(1,n))}`}setDefaultCompressionRelease(){this.compressionReleaseValue=e.DEFAULT_COMPRESSION_RELEASE,this.audioService.setBackTrackCompressionRelease(this.compressionReleaseValue)}onEqualizerLowSliderChange(n){this.audioService.setLowBandGain(+n.target.value)}setEqualizerDefaultLow(){this.equalizerLowValue=0,this.audioService.setLowBandGain(0)}onEqualizerMidSliderChange(n){this.audioService.setLowBandGain(+n.target.value)}setEqualizerDefaultMid(){this.equalizerMidValue=0,this.audioService.setMidBandGain(0)}onEqualizerHighSliderChange(n){this.audioService.setHighBandGain(+n.target.value)}setEqualizerDefaultHigh(){this.equalizerHighValue=0,this.audioService.setHighBandGain(0)}}return(t=e).DEFAULT_VOLUME=60,t.DEFAULT_PAN=50,t.DEFAULT_COMPRESSION_THRESHOLD=0,t.DEFAULT_COMPRESSION_KNEE=5,t.DEFAULT_COMPRESSION_RATIO=12,t.DEFAULT_COMPRESSION_ATTACK=.001,t.DEFAULT_COMPRESSION_RELEASE=.003,t.DEFAULT_FADE_IN=4,t.DEFAULT_FADE_OUT=4,t.\u0275fac=function(n){return new(n||t)(lt(pB),lt(rR),lt(iR))},t.\u0275cmp=sr({type:t,selectors:[["app-player"]],decls:42,vars:18,consts:[[3,"fadeOut","fadeIn","closeComponent",4,"ngIf"],[1,"player"],[1,"player-header-card"],[1,"duration-display",2,"text-align","right"],["mode","determinate",3,"value"],[1,"player-header-controls"],[1,"button-container"],["mat-fab","","color","primary",1,"play-button",3,"disabled","click"],[1,"play-icon"],[1,"volume-control"],["mat-icon-button","","color","accent",3,"click"],[1,"volume-slider"],["min","0","max","100","step","1","showTickMarks","","discrete","",3,"displayWith"],["matSliderThumb","",3,"ngModel","ngModelChange","input"],["mat-icon-button","","color","accent",3,"disabled","click"],["mat-list-icon",""],["class","button-container",4,"ngIf"],["mat-icon-button","","color","warn",3,"click"],["mat-icon-button","","color","accent","routerLink","/trainer"],[1,"player-body"],[3,"playOrJustLoadSelectedTrack"],["class","track-controls",4,"ngIf"],[3,"fadeOut","fadeIn","closeComponent"],["mat-icon-button","","color","accent"],[1,"track-controls"],["expanded","true",1,"player-track-pan-and-fade"],[1,"pan-and-fade-controls"],[1,"pan-control"],["mat-button","",3,"click"],["mat-button","",1,"mirror-icon",3,"click"],[1,"player-track-equalizer"],[1,"equalizer-controls"],[1,"vertical-slider"],["min","-12","max","12","step","1","showTickMarks",""],["mat-raised-button","","color","primary",1,"center-button",3,"click"],[1,"player-track-compressor"],[1,"compressor-controls"],["min","-60","max","0","step","1","showTickMarks","","discrete","",3,"displayWith"],["min","0","max","40","step","1","showTickMarks","","discrete","",3,"displayWith"],["mat-raised-button","",3,"click"],["min","1","max","20","step","1","showTickMarks","","discrete","",3,"displayWith"],["min","0.001","max","1","step",".001","showTickMarks","","discrete","",3,"displayWith"],["mat-stroked-button","","color","primary",3,"click"]],template:function(n,r){1&n&&(Fs(0,Hq,1,0,"app-gesture-control",0),yn(1,"div",1)(2,"mat-card",2)(3,"mat-card-subtitle")(4,"div",3),Ys(5),Cw(6,"formatTime"),Cw(7,"formatTime"),In()(),yn(8,"mat-card-title"),ti(9,"mat-progress-bar",4),In(),yn(10,"mat-card-actions",5)(11,"div",6)(12,"button",7),qs("click",function(){return r.togglePlayback()}),yn(13,"mat-icon",8),Ys(14),In()()(),yn(15,"div",9)(16,"button",10),qs("click",function(){return r.setDefaultVolume()}),yn(17,"mat-icon"),Ys(18,"volume_down"),In()(),yn(19,"div",11)(20,"mat-slider",12)(21,"input",13),qs("ngModelChange",function(a){return r.volumeValue=a})("input",function(a){return r.onVolumeChange(a)}),In()()()(),yn(22,"div",6)(23,"button",14),qs("click",function(){return r.pauseSelectedTrack()}),yn(24,"mat-icon",15),Ys(25,"pause"),In()()(),Fs(26,jq,4,0,"div",16),Fs(27,Gq,4,0,"div",16),Fs(28,Kq,4,0,"div",16),yn(29,"div",6)(30,"button",17),qs("click",function(){return r.setGestureControl()}),yn(31,"mat-icon",15),Ys(32,"accessibility_new"),In()()(),yn(33,"div",6)(34,"button",18)(35,"mat-icon",15),Ys(36,"settings_accessibility"),In()()()()(),yn(37,"div",19),ti(38,"app-tracklist"),yn(39,"mat-accordion")(40,"app-back-track-table",20),qs("playOrJustLoadSelectedTrack",function(a){return r.selectedTrackPlayOrJustLoad(a)}),In()(),Fs(41,Zq,82,17,"div",21),In()()),2&n&&(Yn("ngIf",r.hasGestureControl),Un(5),Kv(" ",Ew(6,14,r.trackProgress)," / ",Ew(7,16,r.trackDuration)," "),Un(4),Yn("value",r.calculateProgress()),Un(3),Yn("disabled",null===r.track)("@fabRotate",r.isPlaying?"closed":"open"),Un(2),pd(" ",r.isPlaying?"stop":"play_arrow"," "),Un(6),Yn("displayWith",r.formatVolumeSliderLabel),Un(1),Yn("ngModel",r.volumeValue),Un(2),Yn("disabled",!r.isPlaying),Un(3),Yn("ngIf",r.tracklist.length>=2),Un(1),Yn("ngIf",r.tracklist.length>=1),Un(1),Yn("ngIf",r.tracklist.length>=1),Un(13),Yn("ngIf",r.tracklist.length>0))},dependencies:[$d,kS,QD,cL,tO,dX,lR,gB,gC,tB,GS,eR,MX,fR,mR,DB,yC,gR,QX,_R,PJ,Aq,Wq,xV],styles:[".player[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-between;gap:16px;overflow-y:auto}.player-header-card[_ngcontent-%COMP%]{padding:2%;margin-bottom:1%}.volume-control[_ngcontent-%COMP%]{margin-left:2%;display:flex}.pan-and-fade-controls[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;gap:16px}.mirror-icon[_ngcontent-%COMP%]   .mat-icon[_ngcontent-%COMP%]{transform:scaleX(-1)}.fade-slider[_ngcontent-%COMP%]{margin-left:5%;width:100%}.vertical-slider[_ngcontent-%COMP%]{transform:rotate(270deg) translateY(50px);height:150px;align-self:center}.equalizer-controls[_ngcontent-%COMP%], .compressor-controls[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:space-evenly;width:100%;gap:16px}"],data:{animation:[nd("fabRotate",[Vl("open",Mi({transform:"rotate(-360deg)"})),Vl("closed",Mi({transform:"rotate(0deg)"})),sc("open => closed",[nc("0.5s")]),sc("closed => open",[nc("0.2s")])]),nd("fadeInOut",[Vl("in",Mi({opacity:1})),sc(":enter",[Mi({opacity:0}),nc(300),nc("300ms ease-in",Mi({opacity:1}))]),sc(":leave",[nc("300ms ease-out",Mi({opacity:0}))])])]}}),e})(),Jq=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275cmp=sr({type:t,selectors:[["app-home"]],decls:27,vars:0,consts:[[1,"home-container"],[1,"home-card"],[1,"header"],[1,"subtitle"],["mat-card-xl-image","","src","samson.png",1,"flipped-image"],[1,"paragraph"],["color","primary"],[1,"icon-text"],["color","warn"],["color","accent"]],template:function(n,r){1&n&&(yn(0,"div",0),ti(1,"app-player"),In(),yn(2,"mat-card",1)(3,"mat-card-title-group")(4,"mat-card-title")(5,"h1",2),Ys(6,"SAMSON"),In()(),yn(7,"mat-card-subtitle")(8,"p",3),Ys(9,"simple drums backing track player."),In()(),ti(10,"img",4),In(),yn(11,"mat-card-content")(12,"p",5)(13,"mat-icon",6),Ys(14,"casino"),In(),yn(15,"span",7),Ys(16,"Add random track or choose one from the table!"),In()(),yn(17,"p",5)(18,"mat-icon",8),Ys(19,"accessibility_new"),In(),yn(20,"span",7),Ys(21,"Pose to control the player hands-free!"),In()(),yn(22,"p",5)(23,"mat-icon",9),Ys(24,"favorite"),In(),yn(25,"span",7),Ys(26,"Favourite the tracks you love!"),In()()()())},dependencies:[gC,jS,GS,eR,eB,sB,yC,Qq],styles:["@keyframes _ngcontent-%COMP%_gradientAnimation{0%{background-position:0% 50%}50%{background-position:100% 50%}to{background-position:0% 50%}}.home-container[_ngcontent-%COMP%]{display:flex;justify-content:center;height:-moz-fit-content;height:fit-content;width:100%;padding-top:4%;padding-bottom:4%;background:linear-gradient(45deg,#FF1493,#FF69B4,#FF1493,#FF69B4);animation:_ngcontent-%COMP%_gradientAnimation 20s ease infinite}.header[_ngcontent-%COMP%]{font-family:RubikBubbles,sans-serif;font-size:96px;color:#fff;text-align:left;text-shadow:0 0 10px deeppink,0 0 20px deeppink,0 0 30px deeppink}.subtitle[_ngcontent-%COMP%]{font-family:Noto,sans-serif;font-size:36px}.paragraph[_ngcontent-%COMP%]{font-family:Noto,serif;font-size:18px}.flipped-image[_ngcontent-%COMP%]{transform:scaleX(-1.2);margin-right:2%}.icon-text[_ngcontent-%COMP%]{margin-left:2%}"]}),e})();var qq=h(6546),Ce=h(9075),Fb=h(7926);const Oh=(0,Ce.OBj)();Oh.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),Oh.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),Oh.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),Oh.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0),Oh.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),Oh.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),Oh.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),Oh.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0),Oh.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1),Oh.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1),Oh.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1),Oh.registerFlag("WEBGPU_PRINT_SHADER",()=>""),Oh.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);class eee{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class tee{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,s,n=!1,r=!0){let i;const a=tU(e,s);return r?(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).length>0?(i=this.freeBuffers.get(a).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:s,mappedAtCreation:n}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:s,mappedAtCreation:n}),this.numBytesAllocated+=e),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.usedBuffers.get(a).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,s=!0){if(0===this.freeBuffers.size)return;const n=e.size,i=tU(n,e.usage),a=this.usedBuffers.get(i),c=a.indexOf(e);if(c<0)throw new Error("Cannot find the buffer in buffer manager");a[c]=a[a.length-1],a.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,s?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,s)=>{e.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((e,s)=>{e.forEach(n=>{n.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function tU(t,e){return`${t}_${e}`}class nee{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,s,n,r){const a=e*s*sU(n),c=nU(e,s,n,r);if(this.freeTextures.has(c)||this.freeTextures.set(c,[]),this.usedTextures.has(c)||this.usedTextures.set(c,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(c).length>0){this.numFreeTextures--;const g=this.freeTextures.get(c).shift();return this.usedTextures.get(c).push(g),g}this.numBytesAllocated+=a;const f=this.device.createTexture({size:[e,s],format:n,usage:r});return this.usedTextures.get(c).push(f),f}releaseTexture(e){if(0===this.freeTextures.size)return;const s=e.width,n=e.height,r=e.format,a=nU(s,n,r,e.usage);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;const c=this.usedTextures.get(a),f=c.indexOf(e);if(f<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(f,1);const g=sU(r);this.numBytesUsed-=s*n*g}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,s)=>{e.forEach(n=>{n.destroy()})}),this.usedTextures.forEach((e,s)=>{e.forEach(n=>{n.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function nU(t,e,s,n){return`${t}_${e}_${s}_${n}`}function sU(t){if("rgba8unorm"===t)return 16;throw new Error(`${t} is not supported!`)}function see(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const s=t.length,r=t.map(a=>`${e}.${"xyzwuv"[a]}`),i=new Array(s-1);i[s-2]=r[s-1];for(let a=s-3;a>=0;--a)i[a]=`(${i[a+1]} * ${r[a+1]})`;return i}const g_=(t,e,s)=>"int32"===s?`atomicAdd(${t}, bitcast<i32>(${e}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${e});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;var RC=function(t){return t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW",t}(RC||{});const xo=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function Xc(t){if(t<=1)return"i32";if(2===t)return"vec2<i32>";if(3===t)return"vec3<i32>";if(4===t)return"vec4<i32>";if(5===t)return"vec5";if(6===t)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function Wm(t){if(0===t)return"x";if(1===t)return"y";if(2===t)return"z";if(3===t)return"w";if(4===t)return"u";if(5===t)return"v";throw Error(`Index ${t} is not yet supported`)}function er(...t){let e;switch(t.length){case 0:e="\n        fn main()\n      ";break;case 1:e=`\n        fn main(${t[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return e}function rU(t,e){let s;return s=`\n     ${function iee(t){return`\n  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})\n`}(e)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${t?"main(getGlobalIndex());":"main();"};\n      }\n    `,s}const iU="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",lee="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function kI(t,e=""){const s=t.length,n=""!==e?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=""!==e?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(s<=1)return`fn ${n}(index : i32) -> i32 { return index; }`;const i=Ce.D5U.computeStrides(t),a=Xc(s),c=[];for(let g=0;g<s;g++)c.push(`d${g}`);if(1===i.length)return`    fn ${n}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};\n      return vec2<i32>(d0, d1);\n    }`;let f;return f="var index2 = index;"+i.map((g,E)=>`let ${c[E]} = index2 / uniforms.${r}.${Wm(E)}; ${E===i.length-1?`let ${c[E+1]} = index2 - ${c[E]} * uniforms.${r}.${Wm(E)}`:`index2 = index2 - ${c[E]} * uniforms.${r}.${Wm(E)}`};`).join(""),`\n    fn ${n}(index : i32) -> ${a} {\n      ${f}\n      return ${a}(${c.join(",")});\n    }\n  `}function pee(t){let e="";switch(t){case 0:case 1:e+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:e+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:e+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:e+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:e+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:e+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:Ce.D5U.assert(!1,()=>`Unsupported ${t}D shape`)}return e}function oU(t){return 1===t.dispatch[1]&&1===t.dispatch[2]}function h0(t,e=1){if("float32"===t)return xo(e,"f32");if("int32"===t||"bool"===t)return xo(e,"i32");throw new Error(`type ${t} is not supported.`)}function aU(t){return!(t.dispatchLayout.hasOwnProperty("y")&&0!==t.dispatchLayout.y.length||t.dispatchLayout.hasOwnProperty("z")&&0!==t.dispatchLayout.z.length)}const p0=t=>{let e=1;for(let s=0;s<t.length;s++)e*=t[s];return e};function tr(t,e,s=[1,1,1],n=[1,1,1]){const[r,i,a]=[Math.ceil(p0(t.x.map(c=>e[c]))/(s[0]*n[0])),t.y?Math.ceil(p0(t.y.map(c=>e[c]))/(s[1]*n[1])):1,t.z?Math.ceil(p0(t.z.map(c=>e[c]))/(s[2]*n[2])):1];return[r,i,a]}function lU(t,e,s=!1){if(s)return[8,8,1];const n=p0(t.x.map(i=>e[i])),r=p0(t.y.map(i=>e[i]));return n<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function cU(t,e,s=!1){if(s)return[4,4,1];const n=p0(t.x.map(i=>e[i])),r=p0(t.y.map(i=>e[i]));return n<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function br(t){return{x:t.map((e,s)=>s)}}function uU(t){if("float32"===t||"int32"===t||"bool"===t||"string"===t)return 4;if("complex64"===t)return 8;throw new Error(`Unknown dtype ${t}`)}function dU(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}function hU(t,e){Array.isArray(t)||(t=[t]),t.forEach(s=>{null!=s&&Ce.D5U.assert("complex64"!==s.dtype,()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var Hm=function(t){return t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax",t}(Hm||{});const _ee=(0,Ce.OBj)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");let eN=(()=>{class t extends Ce.Zuw{nextDataId(){return t.nextDataId++}constructor(s,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!dU())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=s,this.queue=s.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new eee(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new tee(this.device),this.textureManager=new nee(this.device),this.tensorMap=new Ce.JLz(this,(0,Ce.SRH)()),(0,Ce.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:s,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(s,n=!1){if(!this.tensorMap.has(s))return!0;const r=this.tensorMap.get(s);return n?r.refCount=0:r.refCount--,!(r.refCount>0||(null!=r.complexTensorInfos&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(s)?(this.tensorDataPendingDisposal.push(s),0):(this.releaseResource(s),this.tensorMap.delete(s),0)))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(s){const n=this.tensorMap.get(s);if(n&&n.resource){if(n.external)return void(n.resource=null);n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(s){return this.tensorMap.has(s)?this.tensorMap.get(s).refCount:0}incRef(s){this.tensorMap.get(s).refCount++}decRef(s){this.tensorMap.has(s)&&this.tensorMap.get(s).refCount--}write(s,n,r){if("complex64"===r&&null!=s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:r,shape:n,values:s,refCount:1}),i}move(s,n,r,i,a){if("complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(s,{dtype:i,shape:r,values:n,refCount:a})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(s=>{this.releaseResource(s),this.tensorMap.delete(s)}),this.uniformPendingDisposal.forEach(s=>this.bufferManager.releaseBuffer(s)),this.stagingPendingDisposal.forEach(s=>this.bufferManager.releaseBuffer(s,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}checkCompileCompletionAsync(){var s=this;return(0,zm.Z)(function*(){let n;try{n=yield Promise.all(Object.values(s.pipelineCache))}catch(r){throw new Error(r.message)}Object.keys(s.pipelineCache).map((r,i)=>{s.pipelineCache[r]=n[i]})})()}getBufferData(s){var n=this;return(0,zm.Z)(function*(){if((0,Ce.OBj)().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const r=s.size,i=n.bufferManager.acquireBuffer(r,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);n.ensureCommandEncoderReady(),n.endComputePassEncoder(),n.commandEncoder.copyBufferToBuffer(s,0,i,0,r),n.submitQueue(),yield i.mapAsync(GPUMapMode.READ);const a=i.getMappedRange().slice(0);return i.unmap(),null!=i&&n.bufferManager.releaseBuffer(i),(0,Ce.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(Ce.D5U.assert(void 0!==n.dummyContext,()=>"Fail to get context for profiling tool"),n.dummyContext.getCurrentTexture()),a})()}convertAndCacheOnCPU(s,n){const r=this.tensorMap.get(s);return r.values=n,r.values}readSync(s){const n=this.tensorMap.get(s),{values:r,complexTensorInfos:i}=n;if(null!=r||"string"===n.dtype)return r;if("complex64"===n.dtype){const tt=this.readSync(i.real.dataId),Nt=this.readSync(i.imag.dataId),kt=Ce.D5U.convertBackendValuesAndArrayBuffer(Ce.backend_util.mergeRealAndImagArrays(tt,Nt).buffer,"float32");return this.convertAndCacheOnCPU(s,kt),kt}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const a=["opaque","premultiplied"],c=n.resource,f=c.size;Ce.D5U.assert(f%4==0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const g=f/4,E=new ArrayBuffer(f),A=256,Y=256,ne=a.map(tt=>new OffscreenCanvas(A,Y)),Ee=new OffscreenCanvas(A,Y);this.endComputePassEncoder(),ne.map((tt,Nt)=>{const kt=tt.getContext("webgpu");return kt.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:a[Nt]}),kt.getCurrentTexture()}).map((tt,Nt)=>{const on=(fs,Ks,Hr)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:c,bytesPerRow:1024,offset:Hr},{texture:tt},{width:fs,height:Ks}),this.submitQueue();const xi=Ee.getContext("2d",{willReadFrequently:!0});xi.clearRect(0,0,fs,Ks),xi.drawImage(ne[Nt],0,0);const jr=xi.getImageData(0,0,fs,Ks).data,Co=a[Nt],ba=new Uint8ClampedArray(E,Hr,fs*Ks*4);for(let ws=0;ws<ba.length;ws+=4)if("premultiplied"===Co)ba[ws+3]=jr[ws+3];else{const Mr=jr[ws];ba[ws]=jr[ws+2],ba[ws+1]=jr[ws+1],ba[ws+2]=Mr}},fn=Math.floor(g/(A*Y));let Tn=A,Hn=Y,Wn=0;for(let fs=0;fs<fn;fs++)on(Tn,Hn,Wn),Wn+=A*Y*4;const xs=g%(A*Y);Hn=Math.floor(xs/A),Hn>0&&(on(Tn,Hn,Wn),Wn+=Hn*(4*A)),Tn=xs%A,Tn>0&&on(Tn,1,Wn)});const Ge=Ce.D5U.convertBackendValuesAndArrayBuffer(E,n.dtype);return this.convertAndCacheOnCPU(s,Ge),Ge}read(s){var n=this;return(0,zm.Z)(function*(){if(!n.tensorMap.has(s))throw new Error(`Tensor ${s} was not registered!`);const r=n.tensorMap.get(s),{values:i}=r;if(null!=i)return i;let a;if("complex64"===r.dtype){const c=yield Promise.all([n.read(r.complexTensorInfos.real.dataId),n.read(r.complexTensorInfos.imag.dataId)]);a=Ce.backend_util.mergeRealAndImagArrays(c[0],c[1])}else{const c=yield n.getBufferData(r.resource);a=Ce.D5U.convertBackendValuesAndArrayBuffer(c,r.dtype)}return n.convertAndCacheOnCPU(s,a),a})()}copyBuffer(s){const n=s.size,i=this.bufferManager.acquireBuffer(n,s.usage);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(s,0,i,0,n),this.submitQueue(),i}createTensorFromGPUData(s,n,r){let i=s.buffer;if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. ");const a={id:this.nextDataId()};this.tensorMap.set(a,{dtype:r,shape:n,values:null,refCount:1,external:s.zeroCopy});const c=this.tensorMap.get(a),f=uU(c.dtype)*Ce.D5U.sizeFromShape(c.shape);if(s.buffer.size<f)throw new Error(`GPUBuffer size(${s.buffer.size}) is smaller than tensor size(${f})!`);if((s.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==s.zeroCopy&&(i=this.copyBuffer(i)),c.resource=i,(0,Ce.SRH)().makeTensorFromDataId(a,n,r,this)}readToGPU(s){const n=this.tensorMap.get(s),{values:r,dtype:i,shape:a,resource:c}=n;if("complex64"===i)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==c)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const g=c.size,A=this.bufferManager.acquireBuffer(g,c.usage);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(c,0,A,0,g),this.submitQueue();const Y=this.makeTensorInfo(a,i),ne=(0,Ce.SRH)().makeTensorFromTensorInfo(Y);return this.tensorMap.get(Y.dataId).resource=A,{tensorRef:ne,buffer:A}}bufferSync(s){const n=this.readSync(s.dataId);if("string"===s.dtype)try{const r=n.map(i=>Ce.D5U.decodeString(i));return(0,Ce.f3b)(s.shape,s.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,Ce.f3b)(s.shape,s.dtype,n)}time(s){var n=this;return(0,zm.Z)(function*(){!n.supportTimestampQuery&&!n.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),n.hasTimestampQueryWarned=!0);const r=n.activeTimers,i=[];let a=!1;null==n.programTimersStack?(n.programTimersStack=i,a=!0):n.activeTimers.push(i),n.activeTimers=i,s();const c=Ce.D5U.flatten(n.activeTimers.map(A=>A.query)).filter(A=>null!=A),f=Ce.D5U.flatten(n.activeTimers.map(A=>A.name)).filter(A=>null!=A);n.activeTimers=r,a&&(n.programTimersStack=null);const g={uploadWaitMs:n.uploadWaitMs,downloadWaitMs:n.downloadWaitMs,kernelMs:null,wallMs:null},E=yield Promise.all(c);return g.kernelMs=Ce.D5U.sum(E),g.getExtraProfileInfo=()=>E.map((A,Y)=>({name:f[Y],ms:A})).map(A=>`${A.name}: ${A.ms}`).join(", "),n.uploadWaitMs=0,n.downloadWaitMs=0,g})()}makeTensorInfo(s,n,r){return"string"===n&&null!=r&&r.length>0&&Ce.D5U.isString(r[0])&&(r=r.map(a=>Ce.D5U.encodeString(a))),{dataId:this.write(r,s,n),shape:s,dtype:n}}tensorToBinding(s){if(!s)return null;const r=this.tensorMap.get(s.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(s){const n=this.tensorMap.get(s);if(null!=n.resource)return;const r=uU(n.dtype)*Ce.D5U.sizeFromShape(n.shape);let i;const a=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(i=this.bufferManager.acquireBuffer(r,a,!0),"unmapped"===i.mapState){const c=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),f=c.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(f).set(n.values):new Float32Array(f).set(n.values),c.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(c,0,i,0,r),this.stagingPendingDisposal.push(c)}else{const c=i.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(c).set(n.values):new Float32Array(c).set(n.values),i.unmap()}n.values=null}else i=this.bufferManager.acquireBuffer(r,a);n.resource=i}makeUniforms(s){let n=0,r=0;const i=[];let a=1;s.forEach(g=>{let E;switch(0===g.data.length&&(g.data=[1]),g.data.length){case 1:E=4;break;case 2:E=8;break;case 3:case 4:case 5:case 6:E=16;break;default:Ce.D5U.assert(!1,()=>`Unsupported ${g.data.length}D shape`)}(5===r||6===r)&&(E=16),E>a&&(a=E),n=Math.ceil(n/E)*E,r=g.data.length,i.push(n),n+=4*g.data.length}),n=Math.ceil(n/a)*a;const c=new ArrayBuffer(n);s.forEach((g,E)=>{const A=i[E];"int32"===g.type?new Int32Array(c,A,g.data.length).set(g.data):"uint32"===g.type?new Uint32Array(c,A,g.data.length).set(g.data):new Float32Array(c,A,g.data.length).set(g.data)});const f=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(f,0,c,0,n),this.uniformPendingDisposal.push(f),{offset:0,size:n,buffer:f}}runWebGPUProgram(s,n,r,i,a){if(a||(a=this.makeTensorInfo(s.outputShape,r)),0===Ce.D5U.sizeFromShape(a.shape))return this.tensorMap.get(a.dataId).values=Ce.D5U.getTypedArrayFromDType(a.dtype,0),a;this.uploadToGPU(a.dataId),s.dispatch=((t,e)=>{const s=this.device.limits.maxComputeWorkgroupsPerDimension,n=e.dispatchLayout,r=e.dispatch;if(r.every(a=>a<=s))return r;Ce.D5U.assert(r[0]>s&&void 0===n.y&&void 0===n.z,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(r[0]));return i>s?(i=Math.ceil(Math.cbrt(r[0])),Ce.D5U.assert(i<=s,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]})(0,s);const c=n.map((g,E)=>{if("complex64"===g.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(g.dataId),{dtype:this.tensorMap.get(g.dataId).dtype,shape:g.shape,name:s.variableNames[E]}});s.shaderKey=function aee(t,e,s){let n=t.shaderKey;if(null!=t.pixelsOpType)return n;const r=[],i=[];e.forEach(E=>{r.push(E.shape),i.push(E.dtype)}),r.push(s.shape),i.push(s.dtype);const a=e.map(E=>Ce.backend_util.getBroadcastDims(E.shape,s.shape)),c=e.map(E=>Ce.D5U.arraysEqual(E.shape,s.shape)).join("_"),f=a.map(E=>E.join("_")).join(";"),g=oU(t)?"flatDispatch":"";return n+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+r.map(E=>E.length).join(",")+i.join(",")+t.variableNames.join(",")+f+c+g,n}(s,c,a);const f=(0,Ce.OBj)().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return s.shaderKey in this.pipelineCache||(this.pipelineCache[s.shaderKey]=((t,e,s,n,r)=>{const a=function oee(t,e,s){const n=[],r=s.workgroupSize[0]*s.workgroupSize[1]*s.workgroupSize[2];if(s.outputComponent=s.outputComponent?s.outputComponent:1,n.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${oU(s)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +\n                localIndex);\n        `}\n      }\n    `),null!=s.pixelsOpType){const Ee=s.pixelsOpType===RC.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${h0(e.dtype,s.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${h0(t[0].dtype,s.outputComponent)}>;`;n.push(`\n        struct Uniform {\n          outShapeStrides : ${3===e.shape.length?"vec2<i32>":"i32"},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${Ee}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const tt=aU(s);return[iU,n.join("\n"),kI(e.shape),s.getUserCode(),rU(tt,s)].join("\n")}let i,a,c="struct Uniforms { NAN : f32, INFINITY : f32, ";s.variableNames.forEach((Ee,Ge)=>{const tt=Xc(t[Ge].shape.length);c+=`${Ee.charAt(0).toLowerCase()+Ee.slice(1)}Shape : ${tt}, `,i=t[Ge].shape.length-1,a=Xc(i),c+=`${Ee.charAt(0).toLowerCase()+Ee.slice(1)}ShapeStrides: ${a}, `});const f=Xc(e.shape.length);c+=`outShape : ${f}, `,i=e.shape.length-1,a=Xc(i),c+=`\n         outShapeStrides: ${a}, `,s.size&&(c+="size : i32, "),s.uniforms&&(c+=s.uniforms),c+="};",c=function mee(t){return t=t.replace(/(\w+)\s*:\s*vec(5|6)/g,n=>"@align(16) "+n),t=t.replace(/vec(5|6)\s*,\s*(\w+)/g,(n,r,i)=>`vec${r}, @align(16) ${i}`),t}(c),n.push(c),n.push(s.atomic?"\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    ":`\n      @group(0) @binding(0) var<storage, read_write> result: array<${h0(e.dtype,s.outputComponent)}>;\n    `),s.variableNames.forEach((Ee,Ge)=>{n.push(`\n      @group(0) @binding(${1+Ge}) var<storage, read> ${Ee}: array<${h0(t[Ge].dtype,s.variableComponents?s.variableComponents[Ge]:s.outputComponent)}>;\n        `)}),""!==c&&n.push(`\n      @group(0) @binding(${1+s.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const g=function hee(t,e){const{x:s,y:n=[],z:r=[]}=e,i=t.length,a=s.length+n.length+r.length;if(a!==i)return"";if(s.length===i)return`fn getOutputCoords() -> ${Xc(i)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `;let c="";const f=[s,n,r];for(let Y=0;Y<f.length;Y++){const ne=f[Y];if(0!==ne.length)if(1===ne.length)c+=`let d${ne[0]} = i32(globalId[${Y}]);`;else{const Ee=see(ne,"uniforms.outShape");c+=`var index${Y} = i32(globalId[${Y}]);`;for(let Ge=0;Ge<Ee.length;Ge++)c+=`let d${ne[Ge]} = index${Y} / ${Ee[Ge]};`,c+=Ge===Ee.length-1?`let d${ne[Ge+1]} = index${Y} - d${ne[Ge]} * ${Ee[Ge]};`:`index${Y} = index${Y} - d${ne[Ge]} * ${Ee[Ge]};`}}const g=[];for(let Y=0;Y<a;Y++)g.push(`d${Y}`);const E=Xc(a);let A=`fn getOutputCoords() -> ${E} {\n  ${c}\n`;return A+=0===g.length?`return ${E}(0); }`:`return ${E}(${g.join(",")}); }`,A}(e.shape,s.dispatchLayout),E=[iU,n.join("\n")+lee,kI(e.shape),g,pee(e.shape.length)];s.atomic||E.push(function fee(t,e,s){const n=t.length,r=h0(e,s);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${xo(s)}) {\n      result[flatIndex] = ${r}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${xo(s,"i32")}) {\n      result[flatIndex] = ${r}(value);\n    }\n    `;if(n>=2){const a=["d0","d1","d2","d3","d4","d5"].slice(0,n),c=Xc(n);i+=`\n      fn setOutputAtCoords(${a.map(f=>`${f} : i32`).join(", ")}, value : ${xo(s)}) {\n        let flatIndex = getOutputIndexFromCoords(${c}(${a.join(", ")}));\n        setOutputAtIndex(flatIndex${1===s?"":` / ${s}`}, value);\n      }\n      fn setOutputAtCoordsI32(${a.map(f=>`${f} : i32`).join(", ")}, value : ${xo(s,"i32")}) {\n        let flatIndex = getOutputIndexFromCoords(${c}(${a.join(", ")}));\n        setOutputAtIndexI32(flatIndex${1===s?"":` / ${s}`}, value);\n      }\n    `}return i}(e.shape,e.dtype,s.outputComponent)),s.variableNames.forEach((Ee,Ge)=>{E.push(`${kI(t[Ge].shape,Ee)}`)});const A=t.map((Ee,Ge)=>function dee(t,e,s,n){let r=function cee(t,e){const s=t.name,n=t.shape.length,r=Xc(n),i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,n),c=a.map(E=>`${E} : i32`).join(", ");if(n<1)return`\n      fn ${i}() -> ${xo(e)} {\n        return ${xo(e)}(${s}[0]);\n      }\n    `;const f=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`;let g=`${n}D`;return 0===n&&(g="1D"),`\n    fn ${i}(${c}) -> ${xo(e)} {\n      return ${xo(e)}(${s}[getIndexFromCoords${g}(${r}(${a.join(",")}),\n        ${f})${1===e?"":` / ${e}`}]);\n    }\n   `}(t,s);return t.shape.length<=e.length&&(r+=function uee(t,e,s,n){const r=t.name,i=r.charAt(0).toUpperCase()+r.slice(1),a="get"+i+"ByOutput",c=t.shape.length,f=e.length,g=Xc(f);if(Ce.D5U.arraysEqual(t.shape,e)&&n)return`\n    fn ${a}Index(globalIndex : i32) -> ${xo(s)} {\n      return ${xo(s)}(${r}[globalIndex]);\n    }\n\n    fn ${a}Coords(coords : ${g}) -> ${xo(s)} {\n      return ${xo(s)}(${r}[${f>1?"getOutputIndexFromCoords(coords)":"coords"}${1===s?"":` / ${s}`}]);\n    }\n    `;const E=Ce.backend_util.getBroadcastDims(t.shape,e),A=f-c;let Y="";if(0===c)return`\n    fn ${a}Index(globalIndex : i32) -> ${xo(s)}{\n      return get${i}();\n    }\n\n    fn ${a}Coords(coords : ${g}) -> ${xo(s)}{\n      return get${i}();\n    }\n  `;Y=f<2&&E.length>=1?"coords = 0;":E.map(tt=>`coords.${Wm(tt+A)} = 0;`).join("\n");let ne="";ne=f<2&&c>0?"coords":f>1?`${Xc(c)}(${t.shape.map((kt,on)=>`coords.${Wm(on+A)}`).join(", ")})`:"coords";const Ee=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,Ge=`${c}D`;return`\n  fn ${a}Index(globalIndex : i32) -> ${xo(s)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${Y}\n    return ${xo(s)}(${r}[getIndexFromCoords${Ge}(${ne}, ${Ee})${1===s?"":` / ${s}`}]);\n  }\n\n  fn ${a}Coords(coordsIn : ${g}) -> ${xo(s)} {\n    var coords = coordsIn;\n    ${Y}\n    return ${xo(s)}(${r}[getIndexFromCoords${Ge}(${ne}, ${Ee})${1===s?"":` / ${s}`}]);\n  }\n`}(t,e,s,n)),r}(Ee,e.shape,s.variableComponents?s.variableComponents[Ge]:s.outputComponent,s.dispatchLayout.x.length===e.shape.length)).join("\n");E.push(A),E.push(s.getUserCode());const Y=aU(s);return E.push(rU(Y,s)),E.join("\n")}(s,{dtype:n.dtype,shape:n.shape},e),c=t.createShaderModule({code:a,label:e.constructor.name});let f=(0,Ce.OBj)().get("WEBGPU_PRINT_SHADER");if(""!==f){f=f.toLowerCase();const g=f.split(",");("all"===f||g.some(E=>e.shaderKey.toLowerCase().includes(E)))&&(console.group(e.shaderKey),console.debug(a),console.groupEnd())}return r?t.createComputePipelineAsync({compute:{module:c,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:c,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})})(this.device,s,c,a,f)),s.pipeline=this.pipelineCache[s.shaderKey],f||this.recordAndSubmit(s,a,n,i),a}recordAndSubmit(s,n,r,i){if(s.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let a=[],c=[];const f="int32";if(null==s.pixelsOpType){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),c=r.concat(n).map(Ee=>Ee.shape);const ne="int32";c.map(Ee=>{a.push({type:ne,data:Ee});const Ge=Ce.D5U.computeStrides(Ee);a.push({type:ne,data:Ge})})}else{const ne=Ce.D5U.computeStrides(n.shape);a.push({type:f,data:ne})}if(s.size){const ne=Ce.D5U.sizeFromShape(s.outputShape);a.push({type:f,data:[s.outputComponent?ne/s.outputComponent:ne]})}i&&(a=[...a,...i]);const g=[this.tensorToBinding(n),...r.map(ne=>this.tensorToBinding(ne)),this.makeUniforms(a)];r.forEach(ne=>{this.commandQueueOwnedIds.add(ne.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const E=this.device.createBindGroup({layout:s.pipeline.getBindGroupLayout(0),entries:g.map((ne,Ee)=>({binding:Ee,resource:ne}))}),A=null!=this.activeTimers;this.ensureCommandEncoderReady();const Y={};A&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),Y.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(Y)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(Y)),this.computePassEncoder.setPipeline(s.pipeline),this.computePassEncoder.setBindGroup(0,E),this.computePassEncoder.dispatchWorkgroups(s.dispatch[0],s.dispatch[1],s.dispatch[2]),this.dispatchCountInPass++,(A||(0,Ce.OBj)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||s.pixelsOpType===RC.DRAW)&&(this.endComputePassEncoder(),A?this.activeTimers.push({name:s.constructor.name,query:this.getQueryTime()}):this.submitQueue())}getQueryTime(){var s=this;return(0,zm.Z)(function*(){if(!s.supportTimestampQuery)return 0;null==s.queryResolveBuffer&&(s.queryResolveBuffer=s.bufferManager.acquireBuffer(8*s.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),s.commandEncoder.resolveQuerySet(s.querySet,0,s.querySetCount,s.queryResolveBuffer,0);const n=s.bufferManager.acquireBuffer(8*s.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);s.commandEncoder.copyBufferToBuffer(s.queryResolveBuffer,0,n,0,8*s.querySetCount),s.submitQueue(),yield n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),i=Number(r[1]-r[0])/1e6;return n.unmap(),s.bufferManager.releaseBuffer(n),i})()}shouldExecuteOnCPU(s,n=_ee){return(0,Ce.OBj)().getBool("WEBGPU_CPU_FORWARD")&&s.every(r=>null==this.tensorMap.get(r.dataId).resource&&Ce.D5U.sizeFromShape(r.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}return t.nextDataId=0,t})();dU()&&(0,Ce.jqO)("webgpu",(0,zm.Z)(function*(){const t={powerPreference:(0,Ce.OBj)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=yield navigator.gpu.requestAdapter(t),s={},n=[];e.features.has("timestamp-query")&&n.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&n.push(["bgra8unorm-storage"]),s.requiredFeatures=n;const r=e.limits;s.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const i=yield e.requestDevice(s),a=yield e.requestAdapterInfo();return new eN(i,a)}),3);var Pi=function(t){return t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB",t}(Pi||{});const vee="let resultTemp = a + b;",bee="let resultTemp = atan2(a, b);",xee="let resultTemp = areal * breal - aimag * bimag;",wee="let resultTemp = areal * bimag + aimag * breal;",Cee="let resultTemp = a / b;",Eee="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Dee="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n",See="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n",Iee="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n",Tee="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n",Aee="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n",kee="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n",Oee="return f32(a >= 1.0 && b >= 1.0);",Ree="return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));",Nee="return f32(a >= 1.0 || b >= 1.0);",Mee="return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));",Pee="let resultTemp = max(a, b);",Fee="let resultTemp = min(a, b);",Lee="\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n",$ee="\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n",Bee="let resultTemp = a * b;",Vee="\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n",Uee="\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n",zee="\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n",Wee="\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n",Hee="if (a < 0.0) { return b * a; }  return a;",jee="\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n",Gee="let resultTemp = (a - b) * (a - b);",Kee="let resultTemp = a - b;";function tN(t,e){let s;do{switch(t){case Pi.ATAN2:s=bee;break;case Pi.MAX:s=Pee;break;case Pi.MIN:s=Fee;break;case Pi.MOD:s=e?$ee:Lee;break;case Pi.NOT_EQUAL:s=e?Uee:Vee;break;case Pi.POW:s=e?Wee:zee;break;default:continue}let n,r,i;return e?(n="isnanVec4",r="vec4<f32>",i="vec4<bool>"):(n="isnan",r="f32",i="bool"),`\n      let aIsNaN = ${n}(a);\n      let aPostLegalization = select(a, ${r}(42), aIsNaN);\n      let bIsNaN = ${n}(b);\n      let bPostLegalization = select(b, ${r}(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ${s}\n        return select(\n            resultTemp, ${r}(valueForNaN),\n            ${i}(isNaN) | aIsNaN | bIsNaN);\n      }\n    `}while(0);switch(t){case Pi.ADD:s=vee;break;case Pi.COMPLEX_MULTIPLY_IMAG:s=wee;break;case Pi.COMPLEX_MULTIPLY_REAL:s=xee;break;case Pi.DIV:s=Cee;break;case Pi.ELU_DER:s=Eee;break;case Pi.EQUAL:s=Dee;break;case Pi.FLOOR_DIV:s=See;break;case Pi.GREATER:s=Iee;break;case Pi.GREATER_EQUAL:s=Tee;break;case Pi.LESS:s=Aee;break;case Pi.LESS_EQUAL:s=kee;break;case Pi.LOGICAL_AND:return e?Ree:Oee;case Pi.LOGICAL_OR:return e?Mee:Nee;case Pi.MUL:s=Bee;break;case Pi.PRELU:return e?jee:Hee;case Pi.SQUARED_DIFFERENCE:s=Gee;break;case Pi.SUB:s=Kee}return`\n    ${s}\n    return resultTemp;\n  `}var Zs=function(t){return t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT",t}(Zs||{});const Xee="return abs(a);",Yee="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n",Zee="\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n",Qee="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n",Jee="return asinh(a);",qee="\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n",ete="\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n",tte="return ceil(a);",nte="return cos(a);",ste="\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n",rte="return exp(a) - 1.0;",ite="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",ote="\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n",ate=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${Ce.backend_util.ERF_P};\n  let a1 = ${Ce.backend_util.ERF_A1};\n  let a2 = ${Ce.backend_util.ERF_A2};\n  let a3 = ${Ce.backend_util.ERF_A3};\n  let a4 = ${Ce.backend_util.ERF_A4};\n  let a5 = ${Ce.backend_util.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,lte="return exp(a);",cte="return floor(a);",ute="return f32(!isnan(a) && !isinf(a));",dte="return f32(isinf(a));",hte="return f32(isnan(a));",pte="return a;",fte="if (a < 0.0) { return uniforms.NAN; }\n  return log(a);",mte="\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n",gte="return f32(!(a >= 1.0));",_te="return -a;",yte="if (a < 0.0) { return uniforms.alpha * a; } return a;",vte="\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n",bte="return 1.0 / a;",xte="return select(a, 0.0, a < 0.0);",wte="return clamp(a, 0.0, 6.0);",Cte="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",Ete="\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n",Dte="return round(a);",Ste="return inverseSqrt(a);",Ite=`\n  if (a >= 0.0) {\n    return ${Ce.backend_util.SELU_SCALE} * a;\n  } else {\n    return ${Ce.backend_util.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`,Tte="return 1.0 / (1.0 + exp(-1.0 * a));",Ate="return sign(a);",kte="return sin(a);",Ote="\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n",Rte="\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n",Nte="return sqrt(a);",Mte="return a * a;",Pte="\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n",Fte="return tan(a);",Lte="\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n",$te="return f32(i32((a)));";function f0(t,e){switch(t){case Zs.ABS:return Xee;case Zs.ACOS:return Yee;case Zs.ACOSH:return Zee;case Zs.ASIN:return Qee;case Zs.ASINH:return Jee;case Zs.ATAN:return qee;case Zs.ATANH:return ete;case Zs.COS:return nte;case Zs.COSH:return ste;case Zs.CEIL:return tte;case Zs.ELU:return e?ote:ite;case Zs.ERF:return ate;case Zs.EXP:return lte;case Zs.EXPM1:return rte;case Zs.FLOOR:return cte;case Zs.IS_FINITE:return ute;case Zs.IS_INF:return dte;case Zs.IS_NAN:return hte;case Zs.LINEAR:return pte;case Zs.LOG:return fte;case Zs.LOG1P:return mte;case Zs.LOGICAL_NOT:return gte;case Zs.NEG:return _te;case Zs.LEAKYRELU:return e?vte:yte;case Zs.RECIPROCAL:return bte;case Zs.RELU:return e?Ete:xte;case Zs.RELU6:return e?Cte:wte;case Zs.ROUND:return Dte;case Zs.RSQRT:return Ste;case Zs.SELU:return Ite;case Zs.SIGMOID:return Tte;case Zs.SIGN:return Ate;case Zs.SIN:return kte;case Zs.SINH:return Ote;case Zs.SOFTPLUS:return Rte;case Zs.SQRT:return Nte;case Zs.SQUARE:return Mte;case Zs.STEP:return Pte;case Zs.TAN:return Fte;case Zs.TANH:return Lte;case Zs.TO_INT:return $te;default:throw new Error(`BinaryType ${t} is not implemented!`)}}function jm(t,e=!1,s=!1,n=3){if(null===t)return"";let r="";if("linear"===t)r=f0(Zs.LINEAR);else if("relu"===t)r=f0(Zs.RELU,s);else if("elu"===t)r=f0(Zs.ELU,s);else if("relu6"===t)r=f0(Zs.RELU6,s);else if("prelu"===t)r=tN(Pi.PRELU,s);else if("sigmoid"===t)r=f0(Zs.SIGMOID,s);else{if("leakyrelu"!==t)throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);r=f0(Zs.LEAKYRELU,s)}const a=xo(s?4:1);let c="";return c=e?`\n      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${r}\n      }`:`\n      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {\n        ${r}\n      }`,c}function m0(t,e){return`\n      ${t?"value = value + getBiasByOutputCoords(coords);":""}\n      ${e?"value = activation(value, coords);":""}\n      `}function pU(t,e,s=!1,n=!1,r=!1,i=1){Ce.D5U.assert(t&&1===i||!t,()=>`transposeA ${t} is not compatible with component size ${i}`);const a=`\n      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,c=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ${xo(i)} {\n    var value = ${xo(i)}(0.0);\n    ${s&&r?a:`\n    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${a}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ${xo(i)} {\n    var value = ${xo(i)}(0.0);\n    ${c}\n    return value;\n  }\n  `}function nN(t,e,s,n,r=!1,i=!1,a=!1,c=1){return`\n  ${pU(s,n,r,i,a,c)}\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${xo(c)}) {\n    ${r&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${m0(t,e)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function OI(t,e,s=!1,n=32,r=!1,i=32,a=!1){const c=e[1]*t[1],f=e[0]*t[0],g=s?c:n,E=s?n:c,A=g/e[0],Y=n/e[1],ne=t[1],Ee=t[0];return Ce.D5U.assert((s&&4===A&&4===t[1]||!s&&(3===A||4===A))&&g%e[0]==0&&n%e[1]==0&&4===t[0],()=>`If transposeA ${s} is true, innerElementSize ${A} and workPerThread[1] ${t[1]} must be 4.\n          Otherwise, innerElementSize ${A} must be 3 or 4.\n      tileAWidth ${g} must be divisible by workgroupSize[0]${e[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`\n  var<workgroup> mm_Asub : array<array<vec${A}<f32>, ${g/A}>, ${E}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${f/t[0]}>, ${n}>;\n\n  ${er()} {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ${ne};\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ${ne};\n    let globalCol = i32(globalId.x) * ${Ee};\n    let batch = ${r?"0":"i32(globalId.z)"};\n    let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${c};\n\n    let numTiles = ${r?`${Math.ceil(i/n)}`:`(uniforms.dimInner - 1) / ${n} + 1`};\n    var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};\n\n    var acc: array<vec4<f32>, ${ne}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${Y};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${ne}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((t,e)=>t?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ${e});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ${e});\n        `)(s,A)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${Y}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${n};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ${((t,e,s,n)=>{if(t)return`\n      for (var k = 0; k < ${n}; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ${s}; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }`;{let r="",i="";for(let a=0;a<e;a++)r+=`let BCached${a} = mm_Bsub[k * ${e} + ${a}][tileCol];`,i+=`acc[i] = fma(BCached${a}, vec4<f32>(ACached[${a}]), acc[i]);`;return`\n      for (var k = 0; k < ${n/e}; k++) {\n        ${r}\n        for (var i = 0; i < ${s}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ${i}\n        }\n      }`}})(s,A,ne,n)}\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${ne}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const fU=t=>t?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function RI(t,e,s=!1,n=32,r=!1,i=32,a=!1,c=!1){const f=t[1]*e[1],g=t[0]*e[0],E=s?f:n,A=s?n:f;Ce.D5U.assert(A%e[1]==0&&E%e[0]==0&&n%e[1]==0,()=>`tileAHight ${A} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${E} must be divisible by workgroupSize[0]${e[0]}, tileInner ${n} must be divisible by workgroupSize[1]${e[1]}`);const Y=A/e[1],ne=E/e[0],Ee=n/e[1],Ge=t[1],tt=t[0],Nt=a?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${f};\n      let globalColStart = i32(workgroupId.x) * ${g};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${A}; inputRow = inputRow + ${e[1]}) {\n          for (var inputCol = localCol; inputCol < ${E}; inputCol = inputCol + ${e[0]}) {\n            ${fU(s)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${e[1]}) {\n              for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${e[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${n};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${tt}>;\n        for (var k = 0; k < ${n}; k++) {\n          for (var inner = 0; inner < ${tt}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${Ge}; innerRow++) {\n            let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${tt}; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${Ge}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${e[1]};\n        for (var innerCol = 0; innerCol < ${tt}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${e[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${Ge};\n  let tileCol = i32(localId.x) * ${tt};\n\n  let globalRow = i32(globalId.y) * ${Ge};\n  let globalCol = i32(globalId.x) * ${tt};\n  let globalRowStart = i32(workgroupId.y) * ${f};\n\n  let tileRowA = i32(localId.y) * ${Y};\n  let tileColA = i32(localId.x) * ${ne};\n  let tileRowB = i32(localId.y) * ${Ee};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${Y}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${ne}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${fU(s)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${Ee}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${tt}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${n};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${tt}>;\n    for (var k = 0; k < ${n}; k++) {\n      for (var inner = 0; inner < ${tt}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${Ge}; innerRow++) {\n        ${(t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(s)}\n        for (var innerCol = 0; innerCol < ${tt}; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${Ge}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${tt}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${E}>, ${A}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${g}>, ${n}>;\n\n    ${er()} {\n      let batch = ${r?"0":"i32(globalId.z)"};\n      let batchA = ${r||!c?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${r||!c?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${r?`${Math.ceil(i/n)}`:`(uniforms.dimInner - 1) / ${n} + 1`};\n      var kStart = ${r?`i32(globalId.z) * ${i}`:"0"};\n\n      var acc : array<array<f32, ${tt}>, ${Ge}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${Ge}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${tt}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${Nt}\n    }\n  `}class Hte{constructor(e,s,n=!1,r=!1,i=null,a=null,c=null,f=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]};const g=n?e[1]:e[2];if(this.isVec4=(g%4==0&&!n||s[1]%4==0&&n)&&s[2]%4==0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===s[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const Y=function gee(t,e,s,n=!1){const r=[8,8,1],i=[4,4,1];return n||(t<=8&&(i[1]=1),e<=16&&s<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:i}}(s[1],g,s[2],n);this.workgroupSize=Y.workgroupSize,this.elementsPerThread=Y.elementsPerThread}this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const E=null!=i,A=null!=c;E&&this.variableNames.push("bias"),A&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=f,this.transposeA=n,this.transposeB=r,this.addBias=E,this.activation=a,this.hasPreluActivationWeights=A,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(s[1],s[2],g),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,s,n){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];return this.tileInner=!this.isVec4&&this.isVectorA?4*this.workgroupSize[0]:i,[e%r==0,s%i==0,n%this.tileInner==0]}getUserCode(){return`\n      ${jm(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${nN(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?OI(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function Wte(t,e=!1){Ce.D5U.assert(1===t[1]&&1===t[2],()=>`A linear work group size is required. But got ${t}.`);const s=4*t[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;\n\n    ${er()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${s} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${s} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(t=>t?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(e)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${s/4}; k++) {\n          let rowB = t * ${s} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):RI(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `}}class Gte{constructor(e,s=!1,n=!1,r=null,i=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize);const c=null!=r,f=null!=a;c&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=n,this.addBias=c,this.activation=i,this.hasPreluActivationWeights=f,this.shaderKey=`matMulReduce_${this.activation}_${s}_${n}`}getUserCode(){return`\n      ${jm(this.activation,this.hasPreluActivationWeights)}\n      ${nN(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function jte(t){return`\n    var<workgroup> sumValues : array<f32, ${t}>;\n    ${er()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${t}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${t/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}(this.workgroupSize[0])}\n    `}}class Xte{constructor(e,s,n,r=!1,i=!1,a=null,c=null,f=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const g=null!=a;g&&this.variableNames.push("bias");const E=null!=f;E&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=g,this.activation=c,this.hasPreluActivationWeights=E,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`\n      ${jm(this.activation,this.hasPreluActivationWeights)}\n      ${nN(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function Kte(t){const e=t[1],s=t[0],n=e>s?e:s;return`\n  var<workgroup> mm_Asub : array<array<f32, ${n}>, ${e}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${s}>, ${n}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${er()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${n};\n    globalRowB = globalRowB + ${n};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${n};\n      globalRowB = globalRowB + ${n};\n\n      for (var k = 0; k < ${n}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class Yte{constructor(e,s,n=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,Ce.D5U.assert(1===e[0],()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(n&&this.outputShape[1]%4==0||!n&&s%4==0)&&this.outputShape[2]%4==0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=tr(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],s],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=r,this.shaderKey=`matMulSplitK_${n}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`\n      ${pU(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${xo(e)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${g_("&result[flatIndex + i]",e>1?"value[i]":"value","float32")}\n          }\n        }\n      }\n      ${4===e?OI(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):RI(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class Zte{constructor(e,s=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=s,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${jm(this.activation,this.hasPreluActivationWeights)}\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${m0(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class Qte{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function Vd(t){const{backend:e,attrs:s}=t,{shape:n,value:r}=s;let{dtype:i}=s;if(i=i||Ce.D5U.inferDtype(r),"string"===i){const a=Ce.D5U.getArrayFromDType(i,Ce.D5U.sizeFromShape(n));return a.fill(r),e.makeTensorInfo(n,i,a)}{const a=new Qte(n);return e.runWebGPUProgram(a,[],i,[{type:"float32",data:[r]}])}}const Jte={kernelName:Ce.deh,backendName:"webgpu",kernelFunc:Vd};function Kr(t){const{inputs:e,attrs:s}=t,{x:n}=e,{shape:r}=s,i=Ce.D5U.sizeFromShape(n.shape),a=Ce.D5U.inferFromImplicitShape(r,i),c=Ce.D5U.sizeFromShape(a);return Ce.D5U.assert(i===c,()=>`The new shape (${a}) has ${c} elements and the old shape (${n.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}const qte={kernelName:Ce.HZH,backendName:"webgpu",kernelFunc:Kr};function NI({a:t,b:e,transposeA:s,transposeB:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:c=0,activation:f=null}){const g=t.shape.length,E=e.shape.length,A=s?t.shape[g-2]:t.shape[g-1],Y=n?e.shape[E-1]:e.shape[E-2],ne=s?t.shape[g-1]:t.shape[g-2],Ee=n?e.shape[E-2]:e.shape[E-1],Ge=t.shape.slice(0,-2),tt=e.shape.slice(0,-2),Nt=Ce.D5U.sizeFromShape(Ge),kt=Ce.D5U.sizeFromShape(tt),fn=Ce.Jyw.assertAndGetBroadcastShape(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([ne,Ee]);Ce.D5U.assert(A===Y,()=>`Error in matMul: inner shapes (${A}) and (${Y}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${s} and transposeB=${n} must match.`);const Tn=s?[Nt,A,ne]:[Nt,ne,A],Hn=n?[kt,Ee,Y]:[kt,Y,Ee],Wn=Kr({inputs:{x:t},backend:r,attrs:{shape:Tn}}),xs=Kr({inputs:{x:e},backend:r,attrs:{shape:Hn}}),fs=[Wn,xs],Ks=Math.max(Nt,kt),Hr=[Wn,xs],xi=[{type:"int32",data:[ne]},{type:"int32",data:[Ee]},{type:"int32",data:[A]}];let jr,Co;const ba=[Ks,ne,Ee];let ws=(0,Ce.OBj)().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(ws<0){const Qr=(0,Ce.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),Wi=Qr>0?Qr:r.thresholdToIncreaseWorkgroups,rc=Ks*Math.ceil(ne/32)*Math.ceil(Ee/32);ws=rc<=Wi||ne<=8&&rc<=2*Wi?Ks*ne*Ee<=128?Hm.MatMulReduceProgram:1===Ks&&Y>=2e3?Hm.MatMulSplitKProgram:Hm.MatMulSmallOutputSizeProgram:Hm.MatMulPackedProgram}switch(ws){case Hm.MatMulReduceProgram:jr=new Gte(ba,s,n,i,f,a);break;case Hm.MatMulSplitKProgram:if(Co=Vd({backend:r,attrs:{shape:ba,value:0,dtype:t.dtype}}),jr=new Yte(ba,Y,s,n),i||f){Co=r.runWebGPUProgram(jr,Hr,t.dtype,xi,Co);const Wi=new Zte(Co.shape,i,f,a);let rc=null;const vu=[Co];i&&vu.push(i),a&&vu.push(a),"leakyrelu"===f&&(rc=[{type:"float32",data:[c]}],Wi.uniforms+=" alpha : f32,");const vd=r.runWebGPUProgram(Wi,vu,Co.dtype,rc);fs.push(Co);const Bf=Kr({inputs:{x:vd},backend:r,attrs:{shape:fn}});fs.push(vd);for(const Cc of fs)r.disposeData(Cc.dataId);return Bf}break;case Hm.MatMulSmallOutputSizeProgram:jr=new Xte(Tn,Hn,ba,s,n,i,f,a);break;case Hm.MatMulPackedProgram:const Qr=r.adapterInfo.isIntel();jr=new Hte(Tn,ba,s,n,i,f,a,Qr);break;default:throw new Error(`Unsupported MatMulProgramType ${ws}.`)}i&&Hr.push(i),a&&Hr.push(a),"leakyrelu"===f&&(xi.push({type:"float32",data:[c]}),jr.uniforms+=" alpha : f32,"),Co=r.runWebGPUProgram(jr,Hr,t.dtype,xi,Co);const Mr=Kr({inputs:{x:Co},backend:r,attrs:{shape:fn}});fs.push(Co);for(const Qr of fs)r.disposeData(Qr.dataId);return Mr}const tne={kernelName:Ce.usg,backendName:"webgpu",kernelFunc:function ene(t){const{inputs:e,backend:s,attrs:n}=t,{a:r,b:i,bias:a,preluActivationWeights:c}=e,{transposeA:f,transposeB:g,activation:E,leakyreluAlpha:A}=n;return NI({a:r,b:i,transposeA:f,transposeB:g,backend:s,bias:a,preluActivationWeights:c,leakyreluAlpha:A,activation:E})}};class mU{constructor(e,s,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ce.backend_util.assertAndGetBroadcastShape(s,n),this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${tN(this.op,!1)}\n      }\n\n      ${er("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class MI{constructor(e,s,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ce.backend_util.assertAndGetBroadcastShape(s,n),this.dispatchLayout=br(this.outputShape),this.op=e,this.useSharedMemoryWithA=s.length<=1&&n.length>1&&s[0]<128,this.useSharedMemoryWithB=n.length<=1&&s.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:s[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=s.length>0&&s[s.length-1]%4==0,i=n.length>0&&n[n.length-1]%4==0;r&&i?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(Ce.D5U.isScalarShape(n)||1===n[n.length-1])||i&&(Ce.D5U.isScalarShape(s)||1===s[s.length-1])?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const s=4===this.outputComponent?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${s}, b : ${s}) -> ${s} {\n      ${tN(this.op,4===this.outputComponent)}\n    };\n    `;if("shared"===this.type){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${er("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${i}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${er("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ${this.outputComponent});\n           let a = ${s}(getAByOutputCoords(coords));\n           let b = ${s}(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function uh(t){const{inputs:e}=t,{x:s}=e;return t.backend.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const nne={kernelName:Ce.iJz,backendName:"webgpu",kernelFunc:uh};function g0(t){const{inputs:e,backend:s}=t,{real:n,imag:r}=e,i=s.makeTensorInfo(n.shape,"complex64"),a=s.tensorMap.get(i.dataId),c=uh({inputs:{x:n},backend:s}),f=uh({inputs:{x:r},backend:s});return a.complexTensorInfos={real:c,imag:f},i}const sne={kernelName:Ce.Zz9,backendName:"webgpu",kernelFunc:g0};class Lb{constructor(e,s,n=""){this.variableNames=["A"],this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=s,""!==n&&(this.uniforms=n),this.shaderKey=`unary_${s}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${f0(this.op,!1)}\n      }\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function ha({opType:t,cpuKernelImpl:e,dtype:s}){return({inputs:n,backend:r})=>{const{x:i}=n,a=r,c=s||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const g=a.tensorMap.get(i.dataId),E=e(g.values,c);return a.makeTensorInfo(i.shape,c,E)}const f=new Lb(i.shape,t);return a.runWebGPUProgram(f,[i],c)}}function Su({opType:t,cpuKernelImpl:e,supportsComplex:s=!1,dtype:n}){return({inputs:r,backend:i})=>{const{a,b:c}=r,f=i;if(s&&"complex64"===a.dtype){const A=f.tensorMap.get(a.dataId),Y=f.tensorMap.get(c.dataId);let ne,Ee;if(t!==Pi.MUL)[ne,Ee]=[[A.complexTensorInfos.real,Y.complexTensorInfos.real],[A.complexTensorInfos.imag,Y.complexTensorInfos.imag]].map(tt=>{const[Nt,kt]=tt,on={dataId:Nt.dataId,dtype:Nt.dtype,shape:a.shape},fn={dataId:kt.dataId,dtype:kt.dtype,shape:c.shape},Tn=new MI(t,a.shape,c.shape);return f.runWebGPUProgram(Tn,[on,fn],(0,Ce.x8V)(Nt.dtype,kt.dtype))});else{const tt=new mU(Pi.COMPLEX_MULTIPLY_REAL,a.shape,c.shape),Nt=new mU(Pi.COMPLEX_MULTIPLY_IMAG,a.shape,c.shape),kt=[{dataId:A.complexTensorInfos.real.dataId,dtype:A.complexTensorInfos.real.dtype,shape:a.shape},{dataId:A.complexTensorInfos.imag.dataId,dtype:A.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:Y.complexTensorInfos.real.dataId,dtype:Y.complexTensorInfos.real.dtype,shape:c.shape},{dataId:Y.complexTensorInfos.imag.dataId,dtype:Y.complexTensorInfos.imag.dtype,shape:c.shape}];ne=f.runWebGPUProgram(tt,kt,"float32"),Ee=f.runWebGPUProgram(Nt,kt,"float32")}const Ge=g0({inputs:{real:ne,imag:Ee},backend:f});return f.disposeData(ne.dataId),f.disposeData(Ee.dataId),Ge}const g=n||(0,Ce.x8V)(a.dtype,c.dtype);if(("string"===a.dtype||"string"===c.dtype||f.shouldExecuteOnCPU([a,c]))&&null!=e){const A=f.tensorMap.get(a.dataId).values,Y=f.tensorMap.get(c.dataId).values,ne="string"===a.dtype?Ce.backend_util.fromUint8ToStringArray(A):A,Ee="string"===a.dtype?Ce.backend_util.fromUint8ToStringArray(Y):Y,[Ge,tt]=e(a.shape,c.shape,ne,Ee,g);return f.makeTensorInfo(tt,g,Ge)}const E=new MI(t,a.shape,c.shape);return f.runWebGPUProgram(E,[a,c],g)}}var rne=h(8669);const{addImpl:ine,castImpl:one,ceilImpl:ane,concatImpl:lne,equalImpl:cne,expImpl:une,expm1Impl:dne,floorImpl:hne,floorDivImpl:pne,gatherNdImpl:fne,gatherV2Impl:mne,greaterEqualImpl:gne,greaterImpl:_ne,lessEqualImpl:yne,lessImpl:vne,logImpl:bne,maxImpl:xne,maximumImpl:wne,minimumImpl:Cne,multiplyImpl:Ene,negImpl:Dne,notEqualImpl:Sne,prodImpl:Ine,rangeImpl:Tne,rsqrtImpl:Ane,scatterImpl:kne,simpleAbsImpl:One,sliceImpl:Rne,stridedSliceImpl:Nne,stringNGramsImpl:Mne,subImpl:Pne,tileImpl:Fne,topKImpl:Lne,transposeImpl:$ne}=rne,Bne=ha({opType:Zs.ABS,cpuKernelImpl:One}),Vne={kernelName:Ce.SYM,backendName:"webgpu",kernelFunc:Bne},Une=ha({opType:Zs.ACOS}),zne={kernelName:Ce.VGw,backendName:"webgpu",kernelFunc:Une},Wne=ha({opType:Zs.ACOSH}),Hne={kernelName:Ce.SpW,backendName:"webgpu",kernelFunc:Wne},jne=Su({opType:Pi.ADD,cpuKernelImpl:ine,supportsComplex:!0}),Gne={kernelName:Ce.mm_,backendName:"webgpu",kernelFunc:jne};class Kne{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((s,n)=>`T${n}`),this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const s=this.variableNames.map(r=>`v${r}`).join(" + ");return`\n      ${er("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${s});\n          }\n        }\n      }\n    `}}const Yne={kernelName:Ce.Xze,backendName:"webgpu",kernelFunc:function Xne(t){const{inputs:e,backend:s}=t,n=e;if(1===n.length)return uh({inputs:{x:n[0]},backend:s});const r=n.map(c=>c.dtype).reduce((c,f)=>(0,Ce.x8V)(c,f)),i=n.map(c=>c.shape),a=new Kne(i);return s.runWebGPUProgram(a,n,r)}};class Zne{constructor(e,s){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[s[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){Ce.D5U.assert(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${er()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class Qne{constructor(e,s){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[s[r]];this.outputShape=n,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=s,this.shaderKey=`transpose_${s}`}getUserCode(){const e=Xc(this.outputShape.length),s=gU(this.newDim);return`\n      ${er("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${s}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function gU(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const s=new Array(e);for(let n=0;n<t.length;n++)s[t[n]]=`coords.${Wm(n)}`;return s.join()}function Ff(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{perm:i}=n,a=s,f=new Array(r.shape.length);for(let E=0;E<f.length;E++)f[E]=r.shape[i[E]];if(s.shouldExecuteOnCPU([r])){const A=a.tensorMap.get(r.dataId).values,Y=$ne(A,r.shape,r.dtype,i,f);return s.makeTensorInfo(f,r.dtype,Y)}if(2===r.shape.length&&Ce.D5U.arraysEqual(i,[1,0])){const E=new Zne(r.shape,i);return a.runWebGPUProgram(E,[r],r.dtype)}const g=new Qne(r.shape,i);return a.runWebGPUProgram(g,[r],r.dtype)}const Jne={kernelName:Ce.G3Y,backendName:"webgpu",kernelFunc:Ff};class qne{constructor(e,s,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=Ce.backend_util.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===r.length?[1]:r,this.workgroupSize=e.inSize>=32768&&n>=512?[512,1,1]:e.inSize>=4096?[256,1,1]:[64,1,1],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=s,this.shaderKey=`reduce_${s}`}getUserCode(){let e="",s="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,s="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",s="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",s="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",s="0.0");const r="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       \n         var<workgroup> xBestValues : array<f32, ${n}>;\n       \n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${er("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${s};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${r}\n        }\n       }\n     `}}const ese={mean:"float32",all:"bool",any:"bool"};function _0(t,e,s,n,r){const i=t.shape.length,a=[],c=Ce.D5U.parseAxisParam(e,t.shape);let f=c;const g=Ce.backend_util.getAxesPermutation(f,i);let E=t;null!=g&&(E=Ff({inputs:{x:t},attrs:{perm:g},backend:r}),f=Ce.backend_util.getInnerMostAxes(f.length,i),a.push(E)),Ce.backend_util.assertAxesAreInnerMostDims(n,f,i);const[A,Y]=Ce.backend_util.computeOutAndReduceShapes(E.shape,f);let Ee,ne=A;if(s&&(ne=Ce.backend_util.expandShapeToKeepDim(A,c)),"max"!==n&&"prod"!==n||!r.shouldExecuteOnCPU([E])){const Ge=Ce.D5U.sizeFromShape(Y),kt={windowSize:Ge,inSize:Ge,batchSize:Ce.D5U.sizeFromShape(E.shape)/Ge,outSize:1},on=ese[n]||(0,Ce.z4k)(t.dtype),fn=[{type:"int32",data:[Ge]}],Tn=new qne(kt,n,r.device.limits.maxComputeWorkgroupSizeX),Hn=r.runWebGPUProgram(Tn,[E],on,fn);a.push(Hn),Ee=Kr({inputs:{x:Hn},attrs:{shape:ne},backend:r})}else{const Ge=r.tensorMap.get(E.dataId).values;switch(n){case"max":const tt=xne(Ge,Ce.D5U.sizeFromShape(Y),ne,t.dtype);Ee=r.makeTensorInfo(ne,t.dtype,tt);break;case"prod":const{outVals:Nt,outShape:kt,outDtype:on}=Ine(E.shape,E.dtype,Ge,f);Ee=r.makeTensorInfo(kt,on,Nt);break;default:throw new Error(`${n} CPU implementation is not yet supported.`)}}return a.forEach(Ge=>r.disposeData(Ge.dataId)),Ee}const nse={kernelName:Ce.oT6,backendName:"webgpu",kernelFunc:function tse(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{keepDims:i,axis:a}=n;return _0(r,a,i,"all",s)}},rse={kernelName:Ce.IKK,backendName:"webgpu",kernelFunc:function sse(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{keepDims:i,axis:a}=n;return _0(r,a,i,"any",s)}};class _U{constructor(e,s,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[s];this.op="min"===n?"<":">";const[i,a]=Ce.backend_util.computeOutAndReduceShapes(e,r);this.outputShape=0===i.length?[1]:i,this.dispatchLayout=br(this.outputShape),Ce.D5U.sizeFromShape(a)<32?(this.type="plain",this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=tr(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],s=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${Wm(this.inputShape.length-1)}`,n=()=>{let r="";if(1===this.outputShape.length)1!==this.inputShape.length&&(r+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)r+=`outputCoords.${Wm(i)},`;return r};return"shared"===this.type?`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      \n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    \n\n      ${er("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${s()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `:`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${s()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const ose={kernelName:Ce.sJF,backendName:"webgpu",kernelFunc:function ise(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{axis:i}=n;let a=Ce.D5U.parseAxisParam(i,r.shape);const c=Ce.backend_util.getAxesPermutation(a,r.shape.length);let f=r;const g=[];null!=c&&(f=Ff({inputs:{x:r},backend:s,attrs:{perm:c}}),g.push(f),a=Ce.backend_util.getInnerMostAxes(a.length,f.shape.length)),Ce.backend_util.assertAxesAreInnerMostDims("argMax",[a[0]],f.shape.length);const E=new _U(f.shape,a[0],"max"),Y=s.runWebGPUProgram(E,[f],"int32",[{type:"float32",data:[Number.NEGATIVE_INFINITY]}]);return g.forEach(ne=>s.disposeData(ne.dataId)),Y}},lse={kernelName:Ce.aJk,backendName:"webgpu",kernelFunc:function ase(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{axis:i}=n;let a=Ce.D5U.parseAxisParam(i,r.shape);const c=Ce.backend_util.getAxesPermutation(a,r.shape.length);let f=r;const g=[];null!=c&&(f=Ff({inputs:{x:r},backend:s,attrs:{perm:c}}),g.push(f),a=Ce.backend_util.getInnerMostAxes(a.length,f.shape.length)),Ce.backend_util.assertAxesAreInnerMostDims("argMin",[a[0]],f.shape.length);const E=new _U(f.shape,a[0],"min"),Y=s.runWebGPUProgram(E,[f],"int32",[{type:"float32",data:[Number.POSITIVE_INFINITY]}]);return g.forEach(ne=>s.disposeData(ne.dataId)),Y}},cse=ha({opType:Zs.ASIN}),use={kernelName:Ce.M2y,backendName:"webgpu",kernelFunc:cse},dse=ha({opType:Zs.ASINH}),hse={kernelName:Ce.qw7,backendName:"webgpu",kernelFunc:dse},pse=ha({opType:Zs.ATAN}),fse={kernelName:Ce.jMg,backendName:"webgpu",kernelFunc:pse},mse=Su({opType:Pi.ATAN2}),gse={kernelName:Ce.QCc,backendName:"webgpu",kernelFunc:mse},_se=ha({opType:Zs.ATANH}),yse={kernelName:Ce.Oyi,backendName:"webgpu",kernelFunc:_se};class vse{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}class NC{constructor(e,s,n=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===s&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=s,this.computePositions=n,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool2D_${s}_${n}_${r}_${i}`}getUserCode(){let e;e="avg"===this.poolType?"resultValue = resultValue + value; count = count + 1.0;":this.computePositions?`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};\n      }`:"resultValue = max(value, resultValue);";let s="resultValue";return"avg"===this.poolType&&(s="resultValue / max(count, 1.0)"),`\n      ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${e}\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${s});`}\n        }\n      }\n    `}}class sN{constructor(e,s,n=!1,r=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===s&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=s,this.computePositions=n,this.flattenPositions=r,this.includeBatchIndex=i,this.shaderKey=`pool3D_${s}_${n}_${r}_${i}`}getUserCode(){let e;e="avg"===this.poolType?"resultValue += value; count += 1.0;":this.computePositions?`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};\n      }`:"resultValue = max(value, resultValue);";let s="resultValue";return"avg"===this.poolType&&(s="resultValue / max(count, 1.0)"),`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${e}\n              }\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${s});`}\n        }\n      }\n    `}}function yU(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{reductionIndices:i,keepDims:a}=n;return _0(r,i,a,"max",s)}const bse={kernelName:Ce.YoZ,backendName:"webgpu",kernelFunc:yU};function vU(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{keepDims:i,axis:a}=n;return _0(r,a,i,"mean",s)}const xse={kernelName:Ce.q2K,backendName:"webgpu",kernelFunc:vU};function bU(t,e,s,n){if(1===e.filterWidth&&1===e.filterHeight&&Ce.D5U.arraysEqual(e.inShape,e.outShape))return uh({inputs:{x:t},backend:n});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&1===e.batchSize&&"VALID"===e.padInfo.type){const a=t.shape.length,c=Kr({inputs:{x:t},backend:n,attrs:{shape:[t.shape[a-3]*t.shape[a-2],t.shape[a-1]]}});let f;"avg"===s?f=vU({inputs:{x:c},backend:n,attrs:{axis:0,keepDims:!1}}):(Ce.D5U.assert("max"===s,()=>`Invalid pool type ${s}`),f=yU({inputs:{x:c},backend:n,attrs:{reductionIndices:0,keepDims:!1}}));const g=Kr({inputs:{x:f},backend:n,attrs:{shape:e.outShape}});return n.disposeData(c.dataId),n.disposeData(f.dataId),g}let r;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return 1===e.filterHeight&&1===e.filterWidth?r=new vse(e):("avg"===s?r=new NC(e,"avg"):(Ce.D5U.assert("max"===s,()=>`Invalid pool type ${s}`),r=new NC(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),n.runWebGPUProgram(r,[t],t.dtype,i)}const Cse={kernelName:Ce.JhU,backendName:"webgpu",kernelFunc:function wse(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{filterSize:i,strides:a,pad:c,dimRoundingMode:f}=n;return bU(r,Ce.backend_util.computePool2DInfo(r.shape,i,a,1,c,f),"avg",s)}},Dse={kernelName:Ce._k9,backendName:"webgpu",kernelFunc:function Ese(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{filterSize:i,strides:a,pad:c,dataFormat:f,dimRoundingMode:g}=n,A=Ce.backend_util.computePool3DInfo(r.shape,i,a,[1,1,1],c,g,f),Y=new sN(A,"avg");return s.runWebGPUProgram(Y,[r],r.dtype,[{type:"int32",data:[A.strideDepth,A.strideHeight,A.strideWidth]},{type:"int32",data:[A.padInfo.front,A.padInfo.top,A.padInfo.left]},{type:"int32",data:[A.inDepth,A.inHeight,A.inWidth]},{type:"int32",data:[A.effectiveFilterDepth,A.effectiveFilterHeight,A.effectiveFilterWidth]}])}};class Sse{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`\n      ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Ise{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`\n      ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Ase={kernelName:Ce.IMb,backendName:"webgpu",kernelFunc:function Tse(t){const{inputs:e,backend:s,attrs:n}=t,{dy:r,input:i}=e,a=i,{filterSize:c,strides:f,pad:g,dimRoundingMode:E}=n,A=Ce.backend_util.computePool3DInfo(a.shape,c,f,1,g,E),Y=new Ise(A);return s.runWebGPUProgram(Y,[r],a.dtype,[{type:"int32",data:[A.strideDepth,A.strideHeight,A.strideWidth]},{type:"int32",data:[A.effectiveFilterDepth-1-A.padInfo.front,A.effectiveFilterHeight-1-A.padInfo.top,A.effectiveFilterWidth-1-A.padInfo.left]},{type:"int32",data:[A.effectiveFilterDepth,A.effectiveFilterHeight,A.effectiveFilterWidth]},{type:"int32",data:[A.outDepth]},{type:"int32",data:[A.outHeight]},{type:"int32",data:[A.outWidth]},{type:"float32",data:[1/(A.filterDepth*A.filterHeight*A.filterWidth)]}])}},Ose={kernelName:Ce.ROF,backendName:"webgpu",kernelFunc:function kse(t){const{inputs:e,backend:s,attrs:n}=t,{dy:r,input:i}=e,a=i;hU([r,i],"avgPoolGrad");const{filterSize:c,strides:f,pad:g}=n,E=Ce.backend_util.computePool2DInfo(a.shape,c,f,1,g),A=new Sse(E);return s.runWebGPUProgram(A,[r],a.dtype,[{type:"int32",data:[E.strideHeight,E.strideWidth]},{type:"int32",data:[E.effectiveFilterHeight-1-E.padInfo.top,E.effectiveFilterWidth-1-E.padInfo.left]},{type:"int32",data:[E.dilationHeight,E.dilationWidth]},{type:"int32",data:[E.effectiveFilterHeight,E.effectiveFilterWidth]},{type:"int32",data:[E.outHeight]},{type:"int32",data:[E.outWidth]},{type:"float32",data:[1/(E.filterHeight*E.filterWidth)]}])}},Nse={kernelName:Ce.XLW,backendName:"webgpu",kernelFunc:function Rse(t){const{inputs:e,backend:s,attrs:n}=t,{a:r,b:i}=e,{transposeA:a,transposeB:c}=n;return NI({a:r,b:i,transposeA:a,transposeB:c,backend:s})}};class Mse{constructor(e,s){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=s,this.rank=s.length,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Xc(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Xc(this.rank),s=function Pse(t){if(1===t)return"sourceLoc";if(t<=6)return rN.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let n;return n=this.outputShape.map(1===this.start.length?(i,a)=>"sourceLoc = uniforms.start + coords;":(i,a)=>`sourceLoc.${rN[a]} = uniforms.start.${Wm(a)} + coords.${rN[a]};`),`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${s}));\n        }\n      }\n    `}}const rN=["x","y","z","w","u","v"];function $b(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{begin:i,size:a}=n,[c,f]=Ce.kuN.parseSliceParams(r,i,a);if(Ce.kuN.assertParamsValid(r,c,f),s.shouldExecuteOnCPU([r])||"string"===r.dtype){const A=s.tensorMap.get(r.dataId),Y=Rne(A.values,c,f,r.shape,r.dtype);return s.makeTensorInfo(f,r.dtype,Y)}if(0===Ce.D5U.sizeFromShape(f))return s.makeTensorInfo(f,r.dtype,[]);const g=new Mse(c,f);return s.runWebGPUProgram(g,[r],r.dtype,[{type:"int32",data:c}])}const Fse={kernelName:Ce.p2w,backendName:"webgpu",kernelFunc:$b},$se={kernelName:Ce.zws,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{blockShape:i,crops:a}=n;Ce.D5U.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const c=i.reduce((kt,on)=>kt*on),f=Ce.backend_util.getReshaped(r.shape,i,c),g=Ce.backend_util.getPermuted(f.length,i.length),E=Ce.backend_util.getReshapedPermuted(r.shape,i,c),A=Ce.backend_util.getSliceBeginCoords(a,i.length),Y=Ce.backend_util.getSliceSize(E,a,i.length),ne=[],Ee=Kr({inputs:{x:r},backend:s,attrs:{shape:f}}),Ge=Ff({inputs:{x:Ee},backend:s,attrs:{perm:g}}),tt=Kr({inputs:{x:Ge},backend:s,attrs:{shape:E}}),Nt=$b({inputs:{x:tt},backend:s,attrs:{begin:A,size:Y}});return ne.push(Ee),ne.push(Ge),ne.push(tt),ne.forEach(kt=>s.disposeData(kt.dataId)),Nt}},Bse=`\n  fn bincount_write(index: i32, value: f32) {\n    ${g_("&result[index]","value","float32")}\n  }\n`;class xU{constructor(e,s,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=s,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":Bse}\n  ${er("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const zse={kernelName:Ce.zvY,backendName:"webgpu",kernelFunc:function Use(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,weights:i}=e,{size:a}=n,c=Ce.D5U.sizeFromShape(r.shape),g=Ce.D5U.sizeFromShape(i.shape)>0,A=i.dtype,Y=Vd({backend:s,attrs:{shape:[a],value:0,dtype:A}}),ne=new xU([c],g);return s.runWebGPUProgram(ne,g?[r,i]:[r],A,[{type:"int32",data:[a]}],Y)}};class Wse{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`\n  ${er("index")} {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  `}}const jse={kernelName:Ce.eEB,backendName:"webgpu",kernelFunc:function Hse(t){const{inputs:e,backend:s}=t,{s0:n,s1:r}=e;if(s.shouldExecuteOnCPU([n,r])){const E=s.tensorMap.get(n.dataId),ne=s.tensorMap.get(r.dataId).values,Ee=Ce.backend_util.assertAndGetBroadcastShape(Array.from(E.values),Array.from(ne));return s.makeTensorInfo([Ee.length],"int32",Int32Array.from(Ee))}const i=Ce.D5U.sizeFromShape(n.shape),a=Ce.D5U.sizeFromShape(r.shape),c=Math.max(i,a),f=new Wse(c);return s.runWebGPUProgram(f,[n,r],"int32",[{type:"int32",data:[i]},{type:"int32",data:[a]}])}},wU=Su({opType:Pi.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Sne}),Gse={kernelName:Ce.yQU,backendName:"webgpu",kernelFunc:wU};function MC(t){const{inputs:e,backend:s}=t,{input:n}=e;return uh({inputs:{x:s.tensorMap.get(n.dataId).complexTensorInfos.real},backend:s})}const Kse={kernelName:Ce.xJR,backendName:"webgpu",kernelFunc:MC},Yse={kernelName:Ce.RFZ,backendName:"webgpu",kernelFunc:function iN(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{dtype:i}=n;if("complex64"===i){if("complex64"===r.dtype)return uh({inputs:{x:r},backend:s});const a=Ce.lls(r.shape),c=iN({inputs:{x:r},backend:s,attrs:{dtype:"float32"}}),f=g0({inputs:{real:c,imag:a},backend:s});return a.dispose(),s.disposeData(c.dataId),f}if("complex64"===r.dtype){const a=MC({inputs:{input:r},backend:s}),c=iN({inputs:{x:a},backend:s,attrs:{dtype:i}});return s.disposeData(a.dataId),c}if(!Ce.D5U.hasEncodingLoss(r.dtype,i)){const a=uh({inputs:{x:r},backend:s});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(s.shouldExecuteOnCPU([r])){const a=s.tensorMap.get(r.dataId).values,[c,f,g]=one(a,r.shape,r.dtype,i);return s.makeTensorInfo(c,f,g)}if("int32"===i)return function Xse(t,e){const s=new Lb(t.shape,Zs.TO_INT),n=e.runWebGPUProgram(s,[t],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}(r,s);if("bool"===i){const a=s.makeTensorInfo([],"bool",Ce.D5U.getTypedArrayFromDType("bool",1)),f=wU({inputs:{a:r,b:a},backend:s});return s.disposeData(a.dataId),f}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}},Zse=ha({opType:Zs.CEIL,cpuKernelImpl:ane}),Qse={kernelName:Ce.gJX,backendName:"webgpu",kernelFunc:Zse};class Jse{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${er("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class qse{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${er("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const tre={kernelName:Ce.xnO,backendName:"webgpu",kernelFunc:function ere(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{clipValueMin:i,clipValueMax:a}=n;let c;const f=[{type:"float32",data:[i]},{type:"float32",data:[a]}];return c=Ce.D5U.sizeFromShape(r.shape)%4==0?new Jse(r.shape):new qse(r.shape),s.runWebGPUProgram(c,[r],r.dtype,f)}};class nre{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  `}}function CU(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const rre={kernelName:Ce.yj2,backendName:"webgpu",kernelFunc:function sre(t){const{inputs:e,backend:s}=t,{x:n}=e,r=s.tensorMap.get(n.dataId),i=new nre(n.shape),a=[CU(n,r.complexTensorInfos.real),CU(n,r.complexTensorInfos.imag)];return s.runWebGPUProgram(i,a,a[0].dtype)}};class ire{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Ce.backend_util.computeOutShape(e,1),this.variableNames=e.map((s,n)=>`T${n}`),this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let s=0;s<this.offsetLength;s++)this.uniforms+=`offset${s} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${this.offsetLength}(yR, yC - uniforms.offset${this.offsetLength-1})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${er("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function PI(t){const{inputs:e,backend:s}=t,{input:n}=e;return uh({inputs:{x:s.tensorMap.get(n.dataId).complexTensorInfos.imag},backend:s})}const ore={kernelName:Ce.J_u,backendName:"webgpu",kernelFunc:PI};function PC(t,e,s){const n=t[0].dtype;if("complex64"===n){const Ee=t.map(on=>MC({inputs:{input:on},backend:s})),Ge=t.map(on=>PI({inputs:{input:on},backend:s})),tt=PC(Ee,e,s),Nt=PC(Ge,e,s),kt=g0({inputs:{real:tt,imag:Nt},backend:s});return Ee.forEach(on=>s.disposeData(on.dataId)),Ge.forEach(on=>s.disposeData(on.dataId)),s.disposeData(tt.dataId),s.disposeData(Nt.dataId),kt}let r=s.shouldExecuteOnCPU(t);if("string"===n&&(r=!0),r){const Ee=t.map(Tn=>{const Wn=[-1,Ce.D5U.sizeFromShape(Tn.shape.slice(e))];return Kr({inputs:{x:Tn},backend:s,attrs:{shape:Wn}})}),Ge=Ee.map(Tn=>({vals:s.readSync(Tn.dataId),shape:Tn.shape})),tt=Ce.backend_util.computeOutShape(Ee.map(Tn=>Tn.shape),1),kt=lne(Ge,tt,n,1===Ee[0].shape[0]),on=Ce.backend_util.computeOutShape(t.map(Tn=>Tn.shape),e),fn=s.makeTensorInfo(on,n,kt);return Ee.forEach(Tn=>s.disposeData(Tn.dataId)),fn}const i=s.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>i){const Ee=[];for(let tt=0;tt<t.length;tt+=i){const Nt=t.slice(tt,tt+i);Ee.push(PC(Nt,e,s))}const Ge=PC(Ee,e,s);for(const tt of Ee)s.disposeData(tt.dataId);return Ge}const{tensors2D:a,outShape:c}=function are(t,e,s){const n=Ce.backend_util.computeOutShape(t.map(i=>i.shape),e);return{tensors2D:t.map(i=>Kr({inputs:{x:i},backend:s,attrs:{shape:[Ce.D5U.sizeFromShape(i.shape.slice(0,e)),Ce.D5U.sizeFromShape(i.shape.slice(e))]}})),outShape:n}}(t,e,s),f=a.map(Ee=>Ee.shape),g=new ire(f),E=[],A=new Array(f.length-1);if(A.length>0){A[0]=f[0][1],E.push({type:"int32",data:[A[0]]});for(let Ee=1;Ee<A.length;Ee++)A[Ee]=A[Ee-1]+f[Ee][1],E.push({type:"int32",data:[A[Ee]]})}const Y=s.runWebGPUProgram(g,a,a[0].dtype,E);a.forEach(Ee=>s.disposeData(Ee.dataId));const ne=Kr({inputs:{x:Y},backend:s,attrs:{shape:c}});return s.disposeData(Y.dataId),ne}function EU(t){const{inputs:e,backend:s,attrs:n}=t,{axis:r}=n,i=Ce.D5U.parseAxisParam(r,e[0].shape)[0],a=e.map(g=>g.shape);Ce.backend_util.assertParamsConsistent(a,i);const c=Ce.backend_util.computeOutShape(e.map(g=>g.shape),i);if(0===Ce.D5U.sizeFromShape(c))return s.makeTensorInfo(c,e[0].dtype,[]);const f=e.filter(g=>Ce.D5U.sizeFromShape(g.shape)>0);return 1===f.length?uh({inputs:{x:f[0]},backend:s}):PC(f,i,s)}const lre={kernelName:Ce.Eh3,backendName:"webgpu",kernelFunc:EU};class ure{constructor(e,s,n,r,i=!1,a=null,c=!1,f=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=lU(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=cU(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),c&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=f,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=c,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=s%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?OI(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):RI(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),s=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function cre(t,e,s,n,r=!1,i=null,a=!1,c=4,f=4,g=4){const Y=t?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",ne=t?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",Ee=t?"uniforms.xShape[1]":"uniforms.xShape[2]",Ge=t?"uniforms.xShape[2]":"uniforms.xShape[3]",tt=t?"row":"col",Nt=t?"col":"row",kt=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${tt} / outWidth;\n      let outCol = ${tt} % outWidth;\n\n      let WRow = ${Nt} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${Nt} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${Nt} % inChannels;\n      var resData = ${xo(c)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${Ee} && xCol >= 0 && xCol < ${Ge}) {\n        ${Y}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(fs=>{switch(fs){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${fs} is not supported.`)}})(c)}\n      }\n      return resData;`,on=t?e&&n?`\n      ${kt}`:`\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${kt}\n      }\n      return ${xo(c)}(0.0);`:n&&s?`\n      ${kt}`:`\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${kt}\n      }\n      return ${xo(c)}(0.0);`,fn=`${(fs=>{switch(fs){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${fs} is not supported.`)}})(f)}`,Tn=xo(g),Hn=xo(t?c:f),Wn=xo(t?f:c);return`\n      ${jm(i,a,4===g,4)}\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ${Hn} {\n        ${t?on:fn}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ${Wn} {\n        ${t?fn:on}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${Tn}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${ne}\n        ${m0(r,i)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,s[0],s[1],s[2])}\n    ${e}\n  `}}class dre{constructor(e,s=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=s,this.activation=n,this.hasPreluActivationWeights=r,s&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${jm(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${m0(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${er("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class hre{constructor(e,s){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=s,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,s=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${er("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${r};\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${s}] && xCol >= 0) {\n            value = ${i};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function FI(t,e){const s=t.length;return s>=3?e?[...t.slice(0,-3),t[s-3]*t[s-2],t[s-1]]:[...t.slice(0,-3),t[s-3],t[s-2]*t[s-1]]:!e&&1===s&&t[0]>1?[t[0],1]:null}function DU({x:t,filter:e,convInfo:s,backend:n,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:c=null}){const f=null!=r,g=null!=i,E="channelsLast"===s.dataFormat,A=E&&s.filterHeight===s.inHeight&&s.filterWidth===s.inWidth&&"VALID"===s.padInfo.type,Y=(0,Ce.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!Y&&(A||1===s.filterHeight&&1===s.filterWidth&&1===s.dilationHeight&&1===s.dilationWidth&&1===s.strideHeight&&1===s.strideWidth&&("SAME"===s.padInfo.type||"VALID"===s.padInfo.type)))return function pre({x:t,filter:e,convInfo:s,backend:n,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:c=null}){const f="channelsLast"===s.dataFormat,g=!f,Y=[];let ne,Ee;if(f&&s.filterHeight===s.inHeight&&s.filterWidth===s.inWidth&&"VALID"===s.padInfo.type){const Nt=s.inHeight*s.inWidth*s.inChannels;ne=Kr({inputs:{x:t},backend:n,attrs:{shape:[1,s.batchSize,Nt]}}),Ee=Kr({inputs:{x:e},backend:n,attrs:{shape:[1,Nt,s.outChannels]}})}else ne=Kr({inputs:{x:t},backend:n,attrs:{shape:f?[s.batchSize,s.inHeight*s.inWidth,s.inChannels]:[s.batchSize,s.inChannels,s.inHeight*s.inWidth]}}),Ee=Kr({inputs:{x:e},backend:n,attrs:{shape:[1,s.inChannels,s.outChannels]}});if(Y.push(ne),Y.push(Ee),null!=i){const Nt=FI(i.shape,f);null!=Nt&&(i=Kr({inputs:{x:i},backend:n,attrs:{shape:Nt}}),Y.push(i))}if(null!=r){const Nt=FI(r.shape,f);null!=Nt&&(r=Kr({inputs:{x:r},backend:n,attrs:{shape:Nt}}),Y.push(r))}const Ge=NI({a:f?ne:Ee,b:f?Ee:ne,transposeA:g,transposeB:!1,backend:n,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:a}),tt=Kr({inputs:{x:Ge},backend:n,attrs:{shape:s.outShape}});Y.push(Ge);for(const Nt of Y)n.disposeData(Nt.dataId);return tt}({x:t,filter:e,convInfo:s,backend:n,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:a});const ne=(0,Ce.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),Ee=ne>-1?ne:n.thresholdToIncreaseWorkgroups,Ge=s.batchSize*Math.ceil(s.outHeight*s.outWidth/32)*Math.ceil(s.outChannels/32);if((0,Ce.OBj)().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||Ge<=Ee)return function fre({x:t,filter:e,convInfo:s,backend:n,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:c=null}){const{filterWidth:f,filterHeight:g,inChannels:E,strideWidth:A,strideHeight:Y,padInfo:ne,outWidth:Ee,outHeight:Ge,dilationWidth:tt,dilationHeight:Nt,dataFormat:kt}=s,on="channelsLast"===kt,fn=f*g*E,Tn=Ge*Ee,Wn=new hre(on?[s.batchSize,Tn,fn]:[s.batchSize,fn,Tn],on),fs=n.runWebGPUProgram(Wn,[t],t.dtype,[{type:"int32",data:[ne.top,ne.left]},{type:"int32",data:[Y,A]},{type:"int32",data:[Nt,tt]},{type:"int32",data:[Ee]},{type:"int32",data:[E*f]},{type:"int32",data:[E]}]),Ks=[];Ks.push(fs);const Hr=Kr({inputs:{x:e},backend:n,attrs:{shape:[1,fn,-1]}});if(Ks.push(Hr),null!=i){const ws=FI(i.shape,on);null!=ws&&(i=Kr({inputs:{x:i},backend:n,attrs:{shape:ws}}),Ks.push(i))}if(null!=r){const ws=FI(r.shape,on);null!=ws&&(r=Kr({inputs:{x:r},backend:n,attrs:{shape:ws}}),Ks.push(r))}const Co=NI({a:on?fs:Hr,b:on?Hr:fs,transposeA:!on,transposeB:!1,backend:n,bias:r,activation:c,preluActivationWeights:i,leakyreluAlpha:a}),ba=Kr({inputs:{x:Co},backend:n,attrs:{shape:s.outShape}});Ks.push(Co);for(const ws of Ks)n.disposeData(ws.dataId);return ba}({x:t,filter:e,convInfo:s,backend:n,bias:r,preluActivationWeights:i,leakyreluAlpha:a,activation:c});let tt;const kt=[{type:"int32",data:[s.filterHeight,s.filterWidth]},{type:"int32",data:[s.padInfo.top,s.padInfo.left]},{type:"int32",data:[s.strideHeight,s.strideWidth]},{type:"int32",data:[s.dilationHeight,s.dilationWidth]}];if(Y)tt=new dre(s,f,c,g);else{const Hn=E?s.outHeight*s.outWidth:s.outChannels,Wn=E?s.outChannels:s.outHeight*s.outWidth,xs=s.filterHeight*s.filterWidth*s.inChannels;kt.push({type:"int32",data:[Hn]},{type:"int32",data:[Wn]},{type:"int32",data:[xs]});const fs=n.adapterInfo.isIntel();tt=new ure(s,Hn,Wn,xs,f,c,g,fs)}const on=[],fn=[t,e];f&&(!E&&1===r.shape.length&&(r=Kr({inputs:{x:r},backend:n,attrs:{shape:[r.shape[0],1,1]}}),on.push(r)),fn.push(r)),g&&(!E&&1===i.shape.length&&(i=Kr({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}}),on.push(i)),fn.push(i)),"leakyrelu"===c&&(kt.push({type:"float32",data:[a]}),tt.uniforms+=" alpha : f32,");const Tn=n.runWebGPUProgram(tt,fn,t.dtype,kt);for(const Hn of on)n.disposeData(Hn.dataId);return Tn}const gre={kernelName:Ce.mhS,backendName:"webgpu",kernelFunc:function mre(t){const{inputs:e,attrs:s,backend:n}=t,{x:r,filter:i}=e,{strides:a,pad:c,dataFormat:f,dilations:g,dimRoundingMode:E}=s,A=Ce.backend_util.convertConv2DDataFormat(f);return DU({x:r,filter:i,convInfo:Ce.backend_util.computeConv2DInfo(r.shape,i.shape,a,g,c,E,!1,A),backend:n})}};class _re{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4==0&&e.inChannels%4==0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,s=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,r=`\n    ${er()} {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ${this.workPerThread};\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ${this.workPerThread}>;\n      for (var i = 0; i < ${this.workPerThread}; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    `;return this.isVec4?`\n    ${r}\n    `:`\n    ${er("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${s}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class yre{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`\n    ${er("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class vre{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`\n    ${er("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class bre{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`\n    ${er("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const wre={kernelName:Ce.wUP,backendName:"webgpu",kernelFunc:function xre(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,dy:i}=e,{strides:a,pad:c,dataFormat:f,dimRoundingMode:g,filterShape:E}=n,A=Ce.backend_util.convertConv2DDataFormat(f),Y=Ce.backend_util.computeConv2DInfo(r.shape,E,a,1,c,g,!1,A),ne=new yre(Y);return s.runWebGPUProgram(ne,[r,i],r.dtype,[{type:"int32",data:[Y.padInfo.top,Y.padInfo.left]},{type:"int32",data:[Y.strideHeight,Y.strideWidth]},{type:"int32",data:[Y.batchSize]},{type:"int32",data:[Y.outHeight]},{type:"int32",data:[Y.outWidth]},{type:"int32",data:[Y.inHeight]},{type:"int32",data:[Y.inWidth]}])}};class Ere{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,Ce.D5U.assert("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=lU(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=cU(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?OI(this.elementsPerThread,this.workgroupSize):RI(this.elementsPerThread,this.workgroupSize);return`\n    ${function Cre(t=4){const n=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${xo(t)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${xo(t)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];\n      }\n      return ${xo(t)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${xo(t)} {\n    ${n}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${xo(t)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${i} is not supported.`)}})(t)}\n    }\n    return ${xo(t)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${xo(t)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const Sre={kernelName:Ce.wm,backendName:"webgpu",kernelFunc:function Dre(t){const{inputs:e,backend:s,attrs:n}=t,{dy:r,filter:i}=e,{inputShape:a,strides:c,pad:f,dataFormat:g,dimRoundingMode:E}=n,A=Ce.backend_util.convertConv2DDataFormat(g),Y=Ce.backend_util.computeConv2DInfo(a,i.shape,c,1,f,E,!1,A),ne=[{type:"int32",data:[Y.filterHeight,Y.filterWidth]},{type:"int32",data:[Y.filterHeight-1-Y.padInfo.top,Y.filterWidth-1-Y.padInfo.left]},{type:"int32",data:[Y.strideHeight,Y.strideWidth]},{type:"int32",data:[Y.batchSize,Y.outHeight,Y.outWidth,Y.outChannels]}];let Ee;return(0,Ce.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==Y.dataFormat?Ee=new _re(Y):(Ee=new Ere(Y),ne.push({type:"uint32",data:[Y.inHeight*Y.inWidth]},{type:"uint32",data:[Y.inChannels]},{type:"uint32",data:[Y.filterHeight*Y.filterWidth*Y.outChannels]})),s.runWebGPUProgram(Ee,[r,i],"float32",ne)}};class Ire{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }`}}const Are={kernelName:Ce.x12,backendName:"webgpu",kernelFunc:function Tre(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,filter:i}=e,{strides:a,pad:c,dilations:f}=n,g=Ce.backend_util.computeConv3DInfo(r.shape,i.shape,a,f,c),A=[{type:"int32",data:[g.filterDepth,g.filterHeight,g.filterWidth]},{type:"int32",data:[g.padInfo.front,g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.strideDepth,g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationDepth,g.dilationHeight,g.dilationWidth]}],Y=new Ire(g),ne=(0,Ce.x8V)(r.dtype,i.dtype);return s.runWebGPUProgram(Y,[r,i],ne,A)}},Ore={kernelName:Ce.o2y,backendName:"webgpu",kernelFunc:function kre(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,dy:i}=e,{strides:a,pad:c,filterShape:f}=n,g=Ce.backend_util.computeConv3DInfo(r.shape,f,a,1,c),E=new vre(g);return s.runWebGPUProgram(E,[r,i],i.dtype,[{type:"int32",data:[g.padInfo.front,g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.strideDepth,g.strideHeight,g.strideWidth]},{type:"int32",data:[g.batchSize]},{type:"int32",data:[g.outDepth]},{type:"int32",data:[g.outHeight]},{type:"int32",data:[g.outWidth]},{type:"int32",data:[g.inDepth]},{type:"int32",data:[g.inHeight]},{type:"int32",data:[g.inWidth]}])}},Nre={kernelName:Ce.ik2,backendName:"webgpu",kernelFunc:function Rre(t){const{inputs:e,backend:s,attrs:n}=t,{dy:r,filter:i}=e,{strides:a,pad:c,inputShape:f}=n,g=Ce.backend_util.computeConv3DInfo(f,i.shape,a,1,c),E=new bre(g);return s.runWebGPUProgram(E,[r,i],r.dtype,[{type:"int32",data:[g.filterDepth,g.filterHeight,g.filterWidth]},{type:"int32",data:[g.filterDepth-1-g.padInfo.front,g.filterHeight-1-g.padInfo.top,g.filterWidth-1-g.padInfo.left]},{type:"int32",data:[g.strideDepth,g.strideHeight,g.strideWidth]},{type:"int32",data:[g.outDepth]},{type:"int32",data:[g.outHeight]},{type:"int32",data:[g.outWidth]},{type:"int32",data:[g.outChannels]}])}},Mre=ha({opType:Zs.COS}),Pre={kernelName:Ce.mc4,backendName:"webgpu",kernelFunc:Mre},Fre=ha({opType:Zs.COSH}),Lre={kernelName:Ce.TR1,backendName:"webgpu",kernelFunc:Fre};class $re{constructor(e,s,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=s;this.outputShape=[i,n[0],n[1],e],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,s]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,c,f]=this.cropWidthBiggerThan1?[`(${s} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${s} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${s}`];return`\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${a});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${c};\n        let in_y = ${i};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${f};\n        if( in_x < 0.0 || in_x > ${s} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Vre={kernelName:Ce.VcC,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:s,attrs:n}=t,{image:r,boxes:i,boxInd:a}=e,{cropSize:c,method:f,extrapolationValue:g}=n,E=new $re(r.shape[3],i.shape,c,f);return s.runWebGPUProgram(E,[r,i,a],"float32",[{type:"float32",data:[g]}])}};var LI=function(t){return t.Prod="*",t.Sum="+",t}(LI||{});class SU{constructor(e,s,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=s,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.exclusive?this.op===LI.Prod?"1.0":"0.0":`getX(${IU(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",a="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`\n      ${er("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${TU(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${i}) {\n           let idx = ${a};\n           ${TU(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${IU(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function IU(t,e,s){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${s} for rank ${t} is not yet supported`)}function TU(t,e,s){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative ${s} for rank ${t} is not yet supported`)}function AU(t,e,s,n,r,i){const a=e.shape.length,c=Ce.backend_util.getAxesPermutation([n],a);let f=e;null!=c&&(f=Ff({inputs:{x:e},backend:s,attrs:{perm:c}}));const g=Ce.backend_util.getInnerMostAxes(1,a)[0];if(g!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${n}`);const E=f.shape[g];let A=uh({inputs:{x:f},backend:s});for(let Y=0;Y<=Math.ceil(Math.log2(E))-1;Y++){const ne=new SU(t,f.shape,!1,i),Ee=A;A=s.runWebGPUProgram(ne,[A],A.dtype,[{type:"float32",data:[Y]}]),s.disposeData(Ee.dataId)}if(r){const Y=new SU(t,f.shape,r,i),ne=A;A=s.runWebGPUProgram(Y,[A],A.dtype,[{type:"float32",data:[0]}]),s.disposeData(ne.dataId)}if(null!=c){const ne=Ff({inputs:{x:A},backend:s,attrs:{perm:Ce.backend_util.getUndoAxesPermutation(c)}});return s.disposeData(A.dataId),s.disposeData(f.dataId),ne}return A}const zre={kernelName:Ce.Byc,backendName:"webgpu",kernelFunc:function Ure(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{axis:i,exclusive:a,reverse:c}=n;return AU(LI.Prod,r,s,i,a,c)}},Hre={kernelName:Ce.iHb,backendName:"webgpu",kernelFunc:function Wre(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{axis:i,exclusive:a,reverse:c}=n;return AU(LI.Sum,r,s,i,a,c)}},Gre={kernelName:Ce.QRR,backendName:"webgpu",kernelFunc:function jre(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,weights:i}=e,{size:a,binaryOutput:c}=n,f=1===r.shape.length,E=Ce.D5U.sizeFromShape(i.shape)>0,A=i.dtype,Y=f?[r.shape[0]]:[r.shape[0],r.shape[1]],Ee=Vd({backend:s,attrs:{shape:f?[a]:[r.shape[0],a],value:0,dtype:A}}),Ge=new xU(Y,E,c);return s.runWebGPUProgram(Ge,E?[r,i]:[r],A,[{type:"int32",data:[a]}],Ee)}};class Kre{constructor(e,s){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${s}`,this.dataFormat=s}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Yre={kernelName:Ce.T0n,backendName:"webgpu",kernelFunc:function Xre(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{blockSize:i,dataFormat:a}=n,c=r.shape[0],A=("NHWC"===a?r.shape[1]:r.shape[2])*i,Y=("NHWC"===a?r.shape[2]:r.shape[3])*i,ne=("NHWC"===a?r.shape[3]:r.shape[1])/(i*i),Ge=[{type:"int32",data:[i]}],tt=new Kre("NHWC"===a?[c,A,Y,ne]:[c,ne,A,Y],a);return s.runWebGPUProgram(tt,[r],r.dtype,Ge)}};class Zre{constructor(e,s,n,r=!1,i=null,a=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=a,this.filterHeight=s,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,s=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${jm(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${er()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<s?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${s})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${m0(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class kU{constructor(e,s=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=br(i),this.dispatch=tr(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),Ce.D5U.assert("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),s&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=s,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,s=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${jm(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${er("index")} {\n        let width0 = uniforms.outShape[3] / ${this.outputComponent};\n        let d1 = (index % width0) * ${this.outputComponent};\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ${this.workPerThread};\n        let c = (index1 % width1) * ${this.workPerThread};\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${s}, ${n}) - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${m0(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class OU{constructor(e,s=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,s&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=s,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${jm(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${m0(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const Jre={kernelName:Ce.cie,backendName:"webgpu",kernelFunc:function Qre(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,filter:i}=e,{strides:a,pad:c,dataFormat:f,dilations:g,dimRoundingMode:E}=n,A=Ce.backend_util.convertConv2DDataFormat(f);let Y=g;null==Y&&(Y=[1,1]);const ne=Ce.backend_util.computeConv2DInfo(r.shape,i.shape,a,Y,c,E,!0,A),Ee=[{type:"int32",data:[ne.padInfo.top,ne.padInfo.left]},{type:"int32",data:[ne.inHeight,ne.inWidth]}],Ge="channelsLast"===ne.dataFormat;let tt;return!Ge&&ne.inHeight>16&&ne.inWidth>16&&1===ne.strideHeight&&1===ne.strideWidth&&1===ne.dilationWidth&&1===ne.dilationHeight&&ne.inChannels===ne.outChannels?tt=new Zre(ne.outShape,ne.filterHeight,ne.filterWidth):Ge&&ne.outHeight>4&&ne.outWidth>4&&ne.strideWidth<=2&&ne.inChannels===ne.outChannels&&1===ne.dilationHeight&&1===ne.dilationWidth&&ne.inChannels%4==0?(tt=new kU(ne),Ee.push({type:"int32",data:[tt.virtualWidth]})):(tt=new OU(ne),Ee.push({type:"int32",data:[ne.filterHeight]},{type:"int32",data:[ne.filterWidth]},{type:"int32",data:[ne.strideHeight,ne.strideWidth]},{type:"int32",data:[ne.dilationHeight,ne.dilationWidth]})),s.runWebGPUProgram(tt,[r,i],r.dtype,Ee)}};class qre{constructor(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`\n      ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class eie{constructor(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`\n      ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const nie={kernelName:Ce.sL$,backendName:"webgpu",kernelFunc:function tie(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,dy:i}=e,{strides:a,dilations:c,pad:f,dimRoundingMode:g,filterShape:E}=n,A=Ce.backend_util.computeConv2DInfo(r.shape,E,a,c,f,g,!0),Y=new qre(A);return s.runWebGPUProgram(Y,[r,i],"float32",[{type:"int32",data:[A.strideHeight,A.strideWidth]},{type:"int32",data:[A.padInfo.top,A.padInfo.left]},{type:"int32",data:[A.filterHeight,A.filterWidth]},{type:"int32",data:[A.outHeight]},{type:"int32",data:[A.outWidth]},{type:"int32",data:[A.inHeight]},{type:"int32",data:[A.inWidth]},{type:"int32",data:[A.batchSize]},{type:"int32",data:[A.outChannels/A.inChannels]}])}},rie={kernelName:Ce.y7R,backendName:"webgpu",kernelFunc:function sie(t){const{inputs:e,backend:s,attrs:n}=t,{dy:r,filter:i}=e,{strides:a,dilations:c,pad:f,dimRoundingMode:g,inputShape:E}=n,A=Ce.backend_util.computeConv2DInfo(E,i.shape,a,c,f,g,!0),Y=new eie(A);return s.runWebGPUProgram(Y,[r,i],r.dtype,[{type:"int32",data:[A.strideHeight,A.strideWidth]},{type:"int32",data:[A.filterHeight-1-A.padInfo.top,A.filterWidth-1-A.padInfo.left]},{type:"int32",data:[A.filterHeight,A.filterWidth]},{type:"int32",data:[A.outHeight]},{type:"int32",data:[A.outWidth]},{type:"int32",data:[A.outChannels/A.inChannels]}])}};class iie{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const aie={kernelName:Ce.$w,backendName:"webgpu",kernelFunc:function oie(t){const{inputs:e,backend:s}=t,{x:n}=e,r=[...n.shape,...n.shape],i=Ce.D5U.sizeFromShape(n.shape),a=Kr({inputs:{x:n},backend:s,attrs:{shape:[i]}}),c=new iie(i),f=s.runWebGPUProgram(c,[a],a.dtype),g=Kr({inputs:{x:f},backend:s,attrs:{shape:r}});return s.disposeData(a.dataId),s.disposeData(f.dataId),g}};class lie{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${er("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const uie={kernelName:Ce.p4S,backendName:"webgpu",kernelFunc:function cie(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,filter:i}=e,{strides:a,pad:c,dilations:f}=n,g=Ce.backend_util.computeDilation2DInfo(r.shape,i.shape,a,c,"NHWC",f),A=[{type:"int32",data:[g.filterHeight,g.filterWidth]},{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]}],Y=new lie(g);return s.runWebGPUProgram(Y,[r,i],r.dtype,A)}};class die{constructor(e,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=br(e.outShape),this.dispatch=tr(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==s&&"int32"!==s)throw new Error(`Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`\n       ${er("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ${g_("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}class hie{constructor(e,s,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=br(e.outShape),this.dispatch=tr(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`\n       ${er("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ${g_("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}const fie={kernelName:Ce.Vn9,backendName:"webgpu",kernelFunc:function pie(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,filter:i,dy:a}=e,{strides:c,pad:f,dilations:g}=n,E=Ce.backend_util.computeDilation2DInfo(r.shape,i.shape,c,f,"NHWC",g),A=i.dtype,Y=new hie(E,i.shape,A),ne=[{type:"int32",data:[E.filterHeight,E.filterWidth]},{type:"int32",data:[E.padInfo.top,E.padInfo.left]},{type:"int32",data:[E.strideHeight,E.strideWidth]},{type:"int32",data:[E.dilationHeight,E.dilationWidth]},{type:"int32",data:[Ce.D5U.sizeFromShape(E.outShape)]}],Ee=Vd({backend:s,attrs:{shape:i.shape,value:0,dtype:A}});return s.runWebGPUProgram(Y,[r,i,a],A,ne,Ee)}},gie={kernelName:Ce.ekb,backendName:"webgpu",kernelFunc:function mie(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,filter:i,dy:a}=e,{strides:c,pad:f,dilations:g}=n,E=Ce.backend_util.computeDilation2DInfo(r.shape,i.shape,c,f,"NHWC",g),A=r.dtype,Y=new die(E,A),ne=[{type:"int32",data:[E.filterHeight,E.filterWidth]},{type:"int32",data:[E.padInfo.top,E.padInfo.left]},{type:"int32",data:[E.strideHeight,E.strideWidth]},{type:"int32",data:[E.dilationHeight,E.dilationWidth]},{type:"int32",data:[Ce.D5U.sizeFromShape(E.outShape)]}],Ee=Vd({backend:s,attrs:{shape:E.inShape,value:0,dtype:A}});return s.runWebGPUProgram(Y,[r,i,a],A,ne,Ee)}};class _ie{constructor(e,s,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=RC.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=s,this.textureFormat=n,this.shaderKey=`draw_${s}_${n}`}getUserCode(){let e;const s="float32"===this.type?"value":"value / 255.0";return e=`\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ${s};\n        rgba[1] = ${s};\n        rgba[2] = ${s};\n      } else {\n        rgba[d] = ${s};\n      }`,`\n       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;\n       ${er("index")} {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ${e}\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      `}}const vie={kernelName:Ce.hGc,backendName:"webgpu",kernelFunc:function yie(t){const{inputs:e,backend:s,attrs:n}=t,{image:r}=e,{canvas:i,options:a}=n,[c,f]=r.shape.slice(0,2),{imageOptions:g}=a||{},E=g?.alpha||1,A=s.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",Y=[c,f],ne=new _ie(Y,r.dtype,A);i.width=f,i.height=c;let tt,Ge=i.getContext("webgpu");Ge||(tt=new OffscreenCanvas(f,c),Ge=tt.getContext("webgpu"));const Nt=3===r.shape.length?r.shape[2]:1;Ge.configure({device:s.device,format:A,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const on=s.makeTensorInfo(Y,"int32"),fn=s.tensorMap.get(on.dataId);if(fn.resource=Ge.getCurrentTexture(),fn.external=!0,s.runWebGPUProgram(ne,[r],"int32",[{type:"uint32",data:[Nt]},{type:"float32",data:[E]}],on),tt){const Hn=i.getContext("2d");if(!Hn)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");Hn.drawImage(tt,0,0)}return s.disposeData(on.dataId),r}},RU=Su({opType:Pi.MUL,cpuKernelImpl:Ene,supportsComplex:!0}),bie={kernelName:Ce.wYn,backendName:"webgpu",kernelFunc:RU};function NU(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{axis:i,keepDims:a}=n;return _0(r,i,a,"sum",s)}const xie={kernelName:Ce.GBy,backendName:"webgpu",kernelFunc:NU},Cie={kernelName:Ce.$g6,backendName:"webgpu",kernelFunc:function wie(t){const{inputs:e,backend:s,attrs:n}=t,{equation:r}=n,i=e,{allDims:a,summedDims:c,idDims:f}=Ce.backend_util.decodeEinsumEquation(r,i.length);Ce.backend_util.checkEinsumDimSizes(a.length,f,i);const{path:g,steps:E}=Ce.backend_util.getEinsumComputePath(c,f),A=E.length;let Y=null,ne=a.length;const Ee=[];for(let Ge=0;Ge<A;++Ge){for(const tt of E[Ge]){const{permutationIndices:Nt,expandDims:kt}=Ce.backend_util.getEinsumPermutation(ne,f[tt]);let on;Ce.backend_util.isIdentityPermutation(Nt)?on=i[tt]:(on=Ff({inputs:{x:i[tt]},backend:s,attrs:{perm:Nt}}),Ee.push(on));const fn=on.shape.slice();for(let Tn=0;Tn<kt.length;++Tn)fn.splice(kt[Tn],0,1);Ce.D5U.arraysEqual(on.shape,fn)||(on=Kr({inputs:{x:on},backend:s,attrs:{shape:fn}}),Ee.push(on)),null===Y?Y=on:(Y=RU({inputs:{a:on,b:Y},backend:s}),Ee.push(Y))}Ge<A-1&&(g[Ge]>=0&&(Y=NU({inputs:{x:Y},backend:s,attrs:{axis:g[Ge]-(a.length-ne),keepDims:!1}}),Ee.push(Y)),ne--)}for(const Ge of Ee)Ge!==Y&&s.disposeData(Ge.dataId);return Y}},Eie=ha({opType:Zs.ELU}),Die={kernelName:Ce.SX0,backendName:"webgpu",kernelFunc:Eie},Iie={kernelName:Ce.HEU,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:s}=t,{dy:n,y:r}=e,i=new MI(Pi.ELU_DER,n.shape,r.shape);return s.runWebGPUProgram(i,[n,r],n.dtype)}},Tie=Su({opType:Pi.EQUAL,dtype:"bool",cpuKernelImpl:cne}),Aie={kernelName:Ce.hdR,backendName:"webgpu",kernelFunc:Tie},kie=ha({opType:Zs.ERF}),Oie={kernelName:Ce.Omj,backendName:"webgpu",kernelFunc:kie},Rie=ha({opType:Zs.EXP,cpuKernelImpl:une,dtype:"float32"}),Nie={kernelName:Ce.NEP,backendName:"webgpu",kernelFunc:Rie};function oN(t){const{inputs:e,attrs:s,backend:n}=t,{dim:r}=s,{input:i}=e,a=i.shape.length,c=i.shape.slice();let f=r;return r<0&&(Ce.D5U.assert(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),f=a+r+1),c.splice(f,0,1),Kr({inputs:{x:i},backend:n,attrs:{shape:c}})}const Mie={kernelName:Ce.YFo,backendName:"webgpu",kernelFunc:oN},Pie=ha({opType:Zs.EXPM1,cpuKernelImpl:dne}),Fie={kernelName:Ce.Y0y,backendName:"webgpu",kernelFunc:Pie};class MU{constructor(e,s){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=s,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function PU(t,e,s){const n=s.tensorMap.get(t.dataId),r=Ce.D5U.sizeFromShape(t.shape),i=t.shape[t.shape.length-1],c=[],f=Kr({inputs:{x:t},backend:s,attrs:{shape:[r/i,i]}});c.push(f);const g=f.shape,E=new MU("real",g),A=new MU("imag",g),Y=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:g},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:g}],Ge=[{type:"float32",data:[e?2*Math.PI:-2*Math.PI]},{type:"float32",data:[e?g[1]:1]}],tt=s.runWebGPUProgram(E,Y,"float32",Ge);c.push(tt);const Nt=s.runWebGPUProgram(A,Y,"float32",Ge);c.push(Nt);const kt=g0({inputs:{real:tt,imag:Nt},backend:s});c.push(kt);const on=Kr({inputs:{x:kt},backend:s,attrs:{shape:t.shape}});return c.forEach(fn=>s.disposeData(fn.dataId)),on}const $ie={kernelName:Ce.vwp,backendName:"webgpu",kernelFunc:function Lie(t){const{inputs:e,backend:s}=t,{input:n}=e;return PU(n,!1,s)}};class Bie{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const Vie={kernelName:Ce.Uyb,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:s}=t,n=e,r=new Bie(s.shape);return n.runWebGPUProgram(r,[s],s.dtype)}},Uie=ha({opType:Zs.FLOOR,cpuKernelImpl:hne}),zie={kernelName:Ce.OR,backendName:"webgpu",kernelFunc:Uie},Wie=Su({opType:Pi.FLOOR_DIV,cpuKernelImpl:pne,dtype:"int32"}),Hie={kernelName:Ce.jeX,backendName:"webgpu",kernelFunc:Wie};class jie{constructor(e,s,n=!1){this.pixelsOpType=RC.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[s,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${er("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const Gie={kernelName:Ce.eBW,backendName:"webgpu",kernelFunc:function Kie(t){const{inputs:e,backend:s,attrs:n}=t;let{pixels:r}=e;const{numChannels:i}=n;if(null==r)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,c=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,f=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,g=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[E,A]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],Y=[A,E,i],Ee=a||c;if(g||f||Ee){let kt;{if(Ee){const jr=(0,Ce.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Bb||jr!==aN)&&(aN=jr,Bb=document.createElement("canvas").getContext("2d",{willReadFrequently:aN})),Bb.canvas.width=E,Bb.canvas.height=A,Bb.drawImage(r,0,0,E,A),r=Bb.canvas}const Ks=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,xi=s.textureManager.acquireTexture(Y[1],Y[0],"rgba8unorm",Ks);s.queue.copyExternalImageToTexture({source:r},{texture:xi},[Y[1],Y[0]]),kt=xi}const on=Ce.D5U.sizeFromShape(Y),fn=Ce.D5U.computeStrides(Y),Tn=new jie(Y,i,!1),Hn=[{type:"uint32",data:[on]},{type:"uint32",data:[i]},{type:"uint32",data:[...fn]}],Wn=s.makeTensorInfo([A,E],"int32");s.tensorMap.get(Wn.dataId).resource=kt;const fs=s.runWebGPUProgram(Tn,[Wn],"int32",Hn);return s.disposeData(Wn.dataId),fs}const Ge=r.data;let tt=Ge;if(null!=i&&4!==i){tt=new Uint8Array(r.width*r.height*i);const kt=Ge.length;let on=0;for(let fn=0;fn<kt;fn++)fn%4<i&&(tt[on++]=Ge[fn])}const Nt=s.makeTensorInfo(Y,"int32",new Int32Array(tt));return s.uploadToGPU(Nt.dataId),Nt}};let Bb,aN=(0,Ce.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class Xie{constructor(e,s,n,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ce.backend_util.assertAndGetBroadcastShape(e,s),Ce.backend_util.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=r&&(Ce.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),null!=i&&(Ce.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let s="1.0";return null!=this.scaleShape&&(s="getScaleByOutputIndex(index)"),`\n      ${er("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${s};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const Yie={kernelName:Ce.sHE,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:s})=>{const{x:n,scale:r,offset:i,mean:a,variance:c}=t,{varianceEpsilon:f}=e,g=s,E=[n,a,c];let A=null;null!=i&&(A=i.shape,E.push(i));let Y=null;null!=r&&(Y=r.shape,E.push(r));const ne=new Xie(n.shape,a.shape,c.shape,A,Y);return g.runWebGPUProgram(ne,E,n.dtype,[{type:"float32",data:[f]}])}},Qie={kernelName:Ce._V0,backendName:"webgpu",kernelFunc:function Zie(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,filter:i,bias:a,preluActivationWeights:c}=e,{strides:f,pad:g,dataFormat:E,dilations:A,dimRoundingMode:Y,activation:ne,leakyreluAlpha:Ee}=n,Ge=Ce.backend_util.convertConv2DDataFormat(E);return DU({x:r,filter:i,convInfo:Ce.backend_util.computeConv2DInfo(r.shape,i.shape,f,A,g,Y,!1,Ge),backend:s,bias:a,preluActivationWeights:c,leakyreluAlpha:Ee,activation:ne})}},qie={kernelName:Ce.luS,backendName:"webgpu",kernelFunc:function Jie(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,filter:i,bias:a,preluActivationWeights:c}=e,{strides:f,pad:g,dilations:E,dimRoundingMode:A,activation:Y,leakyreluAlpha:ne}=n;let Ee=E;null==Ee&&(Ee=[1,1]),Ce.D5U.assert(Ce.backend_util.eitherStridesOrDilationsAreOne(f,Ee),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${f} and dilations '${Ee}'`);const Ge=Ce.backend_util.computeConv2DInfo(r.shape,i.shape,f,Ee,g,A,!0),tt=[r,i],Nt=null!=a,kt=null!=c;Nt&&tt.push(a),kt&&tt.push(c);const on=[{type:"int32",data:[Ge.padInfo.top,Ge.padInfo.left]},{type:"int32",data:[Ge.inHeight,Ge.inWidth]}];let fn;return Ge.outHeight>4&&Ge.outWidth>4&&Ge.strideWidth<=2&&Ge.inChannels===Ge.outChannels&&1===Ge.dilationHeight&&1===Ge.dilationWidth&&Ge.inChannels%4==0?(fn=new kU(Ge,Nt,Y,kt),on.push({type:"int32",data:[fn.virtualWidth]})):(fn=new OU(Ge,Nt,Y,kt),on.push({type:"int32",data:[Ge.filterHeight]},{type:"int32",data:[Ge.filterWidth]},{type:"int32",data:[Ge.strideHeight,Ge.strideWidth]},{type:"int32",data:[Ge.dilationHeight,Ge.dilationWidth]})),"leakyrelu"===Y&&(on.push({type:"float32",data:[ne]}),fn.uniforms+=" alpha : f32,"),s.runWebGPUProgram(fn,tt,"float32",on)}};class eoe{constructor(e,s){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=s,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Xc(e)},`}getUserCode(){let e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const noe={kernelName:Ce.q1x,backendName:"webgpu",kernelFunc:function toe(t){const{inputs:e,backend:s}=t,{params:n,indices:r}=e,i=r.shape,a=i[i.length-1],c=Ce.D5U.sizeFromShape(n.shape),[f,g,E,A]=Ce.backend_util.prepareAndValidate(n,r),Y=Kr({inputs:{x:r},backend:s,attrs:{shape:[g,a]}}),ne=Kr({inputs:{x:n},backend:s,attrs:{shape:[Ce.D5U.sizeFromShape(n.shape)/E,E]}});if(s.shouldExecuteOnCPU([n,r])||"string"===n.dtype){const kt=s.readSync(r.dataId),on=s.bufferSync(n),fn=fne(kt,on,n.dtype,g,a,E,A,n.shape,c);return s.makeTensorInfo(f,n.dtype,fn.values)}const Ee=new eoe(a,[g,E]),tt=s.runWebGPUProgram(Ee,[ne,Y],ne.dtype,[{type:"int32",data:[a]},{type:"int32",data:A}]),Nt=Kr({inputs:{x:tt},backend:s,attrs:{shape:f}});return s.disposeData(Y.dataId),s.disposeData(ne.dataId),s.disposeData(tt.dataId),Nt}};class soe{constructor(e,s){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=s,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function roe(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let n=0;n<t.length;n++)s.push(2===n?"indexZ":`${e[n]}`);return s.join()}(this.aShape);return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function FU(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,indices:i}=e,{axis:a,batchDims:c}=n,f=Ce.D5U.parseAxisParam(a,r.shape)[0],g=Ce.backend_util.segment_util.collectGatherOpShapeInfo(r,i,f,c),E=Ce.D5U.sizeFromShape(i.shape),A=[],Y=Kr({inputs:{x:r},backend:s,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),ne=Kr({inputs:{x:i},backend:s,attrs:{shape:[g.batchSize,E/g.batchSize]}});A.push(Y),A.push(ne);const Ee=[g.batchSize,g.outerSize,E/g.batchSize,g.sliceSize];if(s.shouldExecuteOnCPU([r,i])){const on=s.tensorMap.get(ne.dataId).values,fn=(0,Ce.f3b)(ne.shape,ne.dtype,on),Hn=s.tensorMap.get(Y.dataId).values,Wn=(0,Ce.f3b)(Y.shape,Y.dtype,Hn),xs=mne(Wn,fn,Ee);return A.forEach(fs=>s.disposeData(fs.dataId)),s.makeTensorInfo(g.outputShape,xs.dtype,xs.values)}const Ge=new soe(Y.shape,Ee),tt=s.runWebGPUProgram(Ge,[Y,ne],Y.dtype);A.push(tt);const Nt=Kr({inputs:{x:tt},backend:s,attrs:{shape:g.outputShape}});return A.forEach(kt=>s.disposeData(kt.dataId)),Nt}const ioe={kernelName:Ce.qi_,backendName:"webgpu",kernelFunc:FU},ooe=Su({opType:Pi.GREATER,cpuKernelImpl:_ne,dtype:"bool"}),aoe={kernelName:Ce.iZT,backendName:"webgpu",kernelFunc:ooe},loe=Su({opType:Pi.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:gne}),coe={kernelName:Ce.Acj,backendName:"webgpu",kernelFunc:loe},doe={kernelName:Ce.Qg5,backendName:"webgpu",kernelFunc:function uoe(t){const{inputs:e,backend:s}=t,{input:n}=e;return PU(n,!0,s)}},hoe=ha({opType:Zs.IS_FINITE,dtype:"bool"}),poe={kernelName:Ce.avt,backendName:"webgpu",kernelFunc:hoe},foe=ha({opType:Zs.IS_INF,dtype:"bool"}),moe={kernelName:Ce.iWB,backendName:"webgpu",kernelFunc:foe},goe=ha({opType:Zs.IS_NAN,dtype:"bool"}),_oe={kernelName:Ce.r7n,backendName:"webgpu",kernelFunc:goe},voe={kernelName:Ce.J$2,backendName:"webgpu",kernelFunc:function yoe(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{alpha:i}=n,a=[{type:"float32",data:[i]}],c=new Lb(r.shape,Zs.LEAKYRELU,"alpha : f32,");return s.runWebGPUProgram(c,[r],"float32",a)}},boe=Su({opType:Pi.LESS,dtype:"bool",cpuKernelImpl:vne}),xoe={kernelName:Ce.vtC,backendName:"webgpu",kernelFunc:boe},woe=Su({opType:Pi.LESS_EQUAL,dtype:"bool",cpuKernelImpl:yne}),Coe={kernelName:Ce.CAk,backendName:"webgpu",kernelFunc:woe};class Eoe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const Soe={kernelName:Ce.e7N,backendName:"webgpu",kernelFunc:function Doe(t){const{backend:e,attrs:s}=t,{start:n,stop:r,num:i}=s,a=(r-n)/(i-1),c=new Eoe(i);return e.runWebGPUProgram(c,[],"float32",[{type:"float32",data:[n]},{type:"float32",data:[a]}])}},Ioe=ha({opType:Zs.LOG,cpuKernelImpl:bne}),Toe={kernelName:Ce.ZbH,backendName:"webgpu",kernelFunc:Ioe},Aoe=ha({opType:Zs.LOG1P}),koe={kernelName:Ce.kU,backendName:"webgpu",kernelFunc:Aoe},Ooe=Su({opType:Pi.LOGICAL_AND,dtype:"bool"}),Roe={kernelName:Ce.PYm,backendName:"webgpu",kernelFunc:Ooe},Noe=ha({opType:Zs.LOGICAL_NOT}),Moe={kernelName:Ce.VfG,backendName:"webgpu",kernelFunc:Noe},Poe=Su({opType:Pi.LOGICAL_OR}),Foe={kernelName:Ce.MZg,backendName:"webgpu",kernelFunc:Poe},LU="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class Loe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${LU}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class $oe{constructor(e,s){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,Ce.D5U.assert(s<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${s}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=tr(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${er()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${LU}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const Voe={kernelName:Ce.eZ0,backendName:"webgpu",kernelFunc:function Boe(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{depthRadius:i,bias:a,alpha:c,beta:f}=n;let g;return g=i>16?new Loe(r.shape):new $oe(r.shape,i),s.runWebGPUProgram(g,[r],r.dtype,[{type:"int32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[c]},{type:"float32",data:[f]}])}};class Uoe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  `}}const Woe={kernelName:Ce.Hhh,backendName:"webgpu",kernelFunc:function zoe(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,y:i,dy:a}=e,{depthRadius:c,bias:f,alpha:g,beta:E}=n,A=new Uoe(r.shape);return s.runWebGPUProgram(A,[r,i,a],r.dtype,[{type:"int32",data:[c]},{type:"float32",data:[f]},{type:"float32",data:[g]},{type:"float32",data:[E]}])}},Hoe=Su({opType:Pi.MAX,cpuKernelImpl:wne}),joe={kernelName:Ce.BMI,backendName:"webgpu",kernelFunc:Hoe},Koe={kernelName:Ce.mTV,backendName:"webgpu",kernelFunc:function Goe(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{filterSize:i,strides:a,pad:c,dimRoundingMode:f}=n;return bU(r,Ce.backend_util.computePool2DInfo(r.shape,i,a,1,c,f),"max",s)}},Yoe={kernelName:Ce.OAf,backendName:"webgpu",kernelFunc:function Xoe(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{filterSize:i,strides:a,pad:c,dataFormat:f,dimRoundingMode:g}=n,A=Ce.backend_util.computePool3DInfo(r.shape,i,a,[1,1,1],c,g,f),Y=new sN(A,"max");return s.runWebGPUProgram(Y,[r],r.dtype,[{type:"int32",data:[A.strideDepth,A.strideHeight,A.strideWidth]},{type:"int32",data:[A.padInfo.front,A.padInfo.top,A.padInfo.left]},{type:"int32",data:[A.inDepth,A.inHeight,A.inWidth]},{type:"int32",data:[A.effectiveFilterDepth,A.effectiveFilterHeight,A.effectiveFilterWidth]}])}};class Zoe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`\n      ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Qoe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`\n      ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const qoe={kernelName:Ce.OU7,backendName:"webgpu",kernelFunc:function Joe(t){const{inputs:e,backend:s,attrs:n}=t,{dy:r,input:i}=e,a=i,{filterSize:c,strides:f,pad:g,dimRoundingMode:E}=n,Y=Ce.backend_util.computePool3DInfo(a.shape,c,f,[1,1,1],g,E),ne=new sN(Y,"max",!0);let Ee=[{type:"int32",data:[Y.strideDepth,Y.strideHeight,Y.strideWidth]},{type:"int32",data:[Y.padInfo.front,Y.padInfo.top,Y.padInfo.left]},{type:"int32",data:[Y.inDepth,Y.inHeight,Y.inWidth]},{type:"int32",data:[Y.effectiveFilterDepth,Y.effectiveFilterHeight,Y.effectiveFilterWidth]}];const Ge=s.runWebGPUProgram(ne,[a],"int32",Ee),tt=new Qoe(Y);Ee=[{type:"int32",data:[Y.strideDepth,Y.strideHeight,Y.strideWidth]},{type:"int32",data:[Y.effectiveFilterDepth-1-Y.padInfo.front,Y.effectiveFilterHeight-1-Y.padInfo.top,Y.effectiveFilterWidth-1-Y.padInfo.left]},{type:"int32",data:[Y.effectiveFilterDepth,Y.effectiveFilterHeight,Y.effectiveFilterWidth]},{type:"int32",data:[Y.outDepth]},{type:"int32",data:[Y.outHeight]},{type:"int32",data:[Y.outWidth]}];const Nt=s.runWebGPUProgram(tt,[r,Ge],a.dtype,Ee);return s.disposeData(Ge.dataId),Nt}},tae={kernelName:Ce.OV7,backendName:"webgpu",kernelFunc:function eae(t){const{inputs:e,backend:s,attrs:n}=t,{dy:r,input:i,output:a}=e,c=i;hU([i,a],"maxPoolGrad");const{filterSize:f,strides:g,pad:E,dimRoundingMode:A}=n,Y=Ce.backend_util.computePool2DInfo(c.shape,f,g,1,E,A),ne=new NC(Y,"max",!0);let Ee=[{type:"int32",data:[Y.strideHeight,Y.strideWidth]},{type:"int32",data:[Y.padInfo.top,Y.padInfo.left]},{type:"int32",data:[Y.dilationHeight,Y.dilationWidth]},{type:"int32",data:[Y.inHeight,Y.inWidth]},{type:"int32",data:[Y.effectiveFilterHeight,Y.effectiveFilterWidth]}];const Ge=s.runWebGPUProgram(ne,[c],"int32",Ee),tt=new Zoe(Y);Ee=[{type:"int32",data:[Y.strideHeight,Y.strideWidth]},{type:"int32",data:[Y.effectiveFilterHeight-1-Y.padInfo.top,Y.effectiveFilterWidth-1-Y.padInfo.left]},{type:"int32",data:[Y.dilationHeight,Y.dilationWidth]},{type:"int32",data:[Y.effectiveFilterHeight,Y.effectiveFilterWidth]},{type:"int32",data:[Y.outHeight]},{type:"int32",data:[Y.outWidth]}];const Nt=s.runWebGPUProgram(tt,[r,Ge],c.dtype,Ee);return s.disposeData(Ge.dataId),Nt}},sae={kernelName:Ce.vFR,backendName:"webgpu",kernelFunc:function nae(t){const{inputs:e,backend:s,attrs:n}=t,{filterSize:r,strides:i,pad:a,includeBatchInIndex:c}=n,{x:f}=e;Ce.D5U.assert(4===f.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${f.shape.length}.`);const g=[1,1];Ce.D5U.assert(Ce.backend_util.eitherStridesOrDilationsAreOne(i,g),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${g}'`);const E=Ce.backend_util.computePool2DInfo(f.shape,r,i,g,a),A=[{type:"int32",data:[E.strideHeight,E.strideWidth]},{type:"int32",data:[E.padInfo.top,E.padInfo.left]},{type:"int32",data:[E.dilationHeight,E.dilationWidth]},{type:"int32",data:[E.inHeight,E.inWidth]},{type:"int32",data:[E.effectiveFilterHeight,E.effectiveFilterWidth]}];let Y=new NC(E,"max",!1);const ne=s.runWebGPUProgram(Y,[f],f.dtype,A);return Y=new NC(E,"max",!0,!0,c),[ne,s.runWebGPUProgram(Y,[f],"int32",A)]}},iae={kernelName:Ce.c17,backendName:"webgpu",kernelFunc:function rae(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{axis:i,keepDims:a}=n;return _0(r,i,a,"min",s)}},oae=Su({opType:Pi.MIN,cpuKernelImpl:Cne}),aae={kernelName:Ce.q8u,backendName:"webgpu",kernelFunc:oae};class lae{constructor(e,s,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=s.map((r,i)=>r[0]+e[i]+r[1]),this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,s.map((r,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,s=this.xShape.map((g,E)=>`uniforms.pad${E}[0]`).join(","),n=this.xShape.map((g,E)=>`uniforms.pad${E}[0] + uniforms.xShape${e>1?`[${E}]`:""}`).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",a=1===e?"outC":"outC[i]",c=Xc(e),f=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let start = ${c}(${s});\n          let end = ${c}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${a} < ${r}) {\n              ${a} = ${r} * 2 - ${a} - ${this.offset};\n            } else if(${a} >= ${i}) {\n              ${a} = (${i} - 1) * 2 - ${a} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${f}));\n        }\n      }\n    `}}const cae={kernelName:Ce.jQs,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:s})=>{const{x:n}=t,{paddings:r,mode:i}=e,a=s,c=r.map(E=>({type:"int32",data:[E[0],E[1]]})),f=new lae(n.shape,r,i);return a.runWebGPUProgram(f,[n],n.dtype,c)}},uae=Su({opType:Pi.MOD}),dae={kernelName:Ce.Vbg,backendName:"webgpu",kernelFunc:uae};class hae{constructor(e,s){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,s],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  `}}class pae{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.workgroupSize=this.outputShape[1]>=4096?[256,1,1]:[64,1,1],this.shaderKey="softmax"}getUserCode(){return`\n    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ${this.workgroupSize[0]};\n    ${er("index")} {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    `}}function $U(t){const{inputs:e,backend:s,attrs:n}=t,{logits:r}=e,{dim:i}=n,a=Kr({inputs:{x:r},backend:s,attrs:{shape:[Ce.D5U.sizeFromShape(r.shape)/r.shape[i],r.shape[i]]}}),c=new pae(a.shape),f=s.runWebGPUProgram(c,[a],r.dtype),g=Kr({inputs:{x:f},backend:s,attrs:{shape:r.shape}});return s.disposeData(a.dataId),s.disposeData(f.dataId),g}const fae={kernelName:Ce.Gcp,backendName:"webgpu",kernelFunc:$U},gae={kernelName:Ce.NZg,backendName:"webgpu",kernelFunc:function mae(t){const{inputs:e,backend:s,attrs:n}=t,{logits:r}=e,{numSamples:i,seed:a,normalized:c}=n,f=c?r:$U({inputs:{logits:r},backend:s,attrs:{dim:r.shape.length-1}}),E=f.shape[1],A=new hae(f.shape[0],i),ne=s.runWebGPUProgram(A,[f],"int32",[{type:"float32",data:[a]},{type:"int32",data:[E]}]);return c||s.disposeData(f.dataId),ne}},yae={kernelName:Ce.kuV,backendName:"webgpu",kernelFunc:function _ae(t){const{inputs:e,backend:s}=t,{x:n}=e;if(s.shouldExecuteOnCPU([n])){const i=s.tensorMap.get(n.dataId),[a,c]=Dne(i.values,n.shape,n.dtype);return s.makeTensorInfo(c,n.dtype,a)}const r=new Lb(n.shape,Zs.NEG);return s.runWebGPUProgram(r,[n],n.dtype)}},bae={kernelName:Ce.uv1,backendName:"webgpu",kernelFunc:function vae(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:s,attrs:n}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:c,scoreThreshold:f}=n,g=s.readSync(r.dataId),E=s.readSync(i.dataId),{selectedIndices:A}=Ce.GDt.nonMaxSuppressionV3Impl(g,E,a,c,f);return s.makeTensorInfo([A.length],"int32",new Int32Array(A))}},wae={kernelName:Ce.W0H,backendName:"webgpu",kernelFunc:function xae(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:s,attrs:n}=t,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:c,scoreThreshold:f,softNmsSigma:g}=n,E=s.readSync(r.dataId),A=s.readSync(i.dataId),Y=a,ne=c,Ee=f,Ge=g,{selectedIndices:tt,selectedScores:Nt}=Ce.GDt.nonMaxSuppressionV5Impl(E,A,Y,ne,Ee,Ge);return[s.makeTensorInfo([tt.length],"int32",new Int32Array(tt)),s.makeTensorInfo([Nt.length],"float32",new Float32Array(Nt))]}};class Cae{constructor(e,s){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,s],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${er("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const Dae={kernelName:Ce.we_,backendName:"webgpu",kernelFunc:function Eae(t){const{inputs:e,backend:s,attrs:n}=t,{indices:r}=e,{dtype:i,depth:a,onValue:c,offValue:f}=n,g=Ce.D5U.sizeFromShape(r.shape),E=new Cae(g,a),A=Kr({inputs:{x:r},backend:s,attrs:{shape:[g]}}),ne=s.runWebGPUProgram(E,[A],i,[{type:"float32",data:[c]},{type:"float32",data:[f]}]);s.disposeData(A.dataId);const Ge=Kr({inputs:{x:ne},backend:s,attrs:{shape:[...r.shape,a]}});return s.disposeData(ne.dataId),Ge}};function $I(t){const{inputs:e,backend:s}=t,{x:n}=e;if("complex64"===n.dtype){const r=MC({inputs:{input:n},backend:s}),i=$I({inputs:{x:r},backend:s}),a=PI({inputs:{input:n},backend:s}),c=$I({inputs:{x:a},backend:s}),f=g0({inputs:{real:i,imag:c},backend:s});return s.disposeData(r.dataId),s.disposeData(i.dataId),s.disposeData(a.dataId),s.disposeData(c.dataId),f}return Vd({attrs:{shape:n.shape,dtype:n.dtype,value:"string"===n.dtype?"":0},backend:s})}const Sae={kernelName:Ce.RuY,backendName:"webgpu",kernelFunc:$I},Iae={kernelName:Ce.qWM,backendName:"webgpu",kernelFunc:function BU(t){const{inputs:e,backend:s}=t,{x:n}=e;if("string"===n.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===n.dtype){const r=MC({inputs:{input:n},backend:s}),i=BU({inputs:{x:r},backend:s}),a=PI({inputs:{input:n},backend:s}),c=$I({inputs:{x:a},backend:s}),f=g0({inputs:{real:i,imag:c},backend:s});return s.disposeData(r.dataId),s.disposeData(i.dataId),s.disposeData(a.dataId),s.disposeData(c.dataId),f}return Vd({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:s})}},Aae={kernelName:Ce.QiL,backendName:"webgpu",kernelFunc:function Tae(t){const{inputs:e,backend:s,attrs:n}=t,{axis:r}=n;if(1===e.length)return oN({inputs:{input:e[0]},backend:s,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(E=>{Ce.D5U.assertShapesMatch(i,E.shape,"All tensors passed to stack must have matching shapes"),Ce.D5U.assert(a===E.dtype,()=>"All tensors passed to stack must have matching dtypes")});const c=[],g=EU({inputs:e.map(E=>{const A=oN({inputs:{input:E},backend:s,attrs:{dim:r}});return c.push(A),A}),backend:s,attrs:{axis:r}});return c.forEach(E=>s.disposeData(E.dataId)),g}};function VU(t,e=!1){const s=t.length,n=Xc(s),r=t.map((A,Y)=>`uniforms.pad${Y}[0]`).join(","),i=t.map((A,Y)=>`uniforms.pad${Y}[0] + uniforms.xShape${s>1?`[${Y}]`:""}`).join(",");return`\n        let start = ${s>1?`${n}(${r})`:`${r}`};\n        let end = ${s>1?`${n}(${i})`:`${i}`};\n        if (${s>1?"any(paddedCoords < start)":"paddedCoords < start"} || ${s>1?"any(paddedCoords >= end)":"paddedCoords >= end"}) {\n          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(${s>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s):"coords"}));\n        }\n  `}class kae{constructor(e,s){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=s.map((n,r)=>n[0]+e[r]+n[1]),this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),s.map((n,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ${VU(this.xShape)}\n        }\n      }\n    `}}const Rae={kernelName:Ce.lyA,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{paddings:i,constantValue:a}=n;if(i.every(g=>Ce.D5U.arraysEqual(g,[0,0])))return uh({inputs:{x:r},backend:s});if(0===Ce.D5U.sizeFromShape(r.shape))return Vd({backend:s,attrs:{shape:i.map((E,A)=>E[0]+r.shape[A]+E[1]),value:a,dtype:r.dtype}});const c=[{type:"float32",data:[a]}];i.map(g=>c.push({type:"int32",data:[g[0],g[1]]}));const f=new kae(r.shape,i);return s.runWebGPUProgram(f,[r],r.dtype,c)}},Nae=Su({opType:Pi.POW}),Mae={kernelName:Ce.pe_,backendName:"webgpu",kernelFunc:Nae},Fae={kernelName:Ce.o0g,backendName:"webgpu",kernelFunc:function Pae(t){const{inputs:e,backend:s}=t,{x:n,alpha:r}=e,i=new MI(Pi.PRELU,n.shape,r.shape);return s.runWebGPUProgram(i,[n,r],"float32")}},$ae={kernelName:Ce.DlI,backendName:"webgpu",kernelFunc:function Lae(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{axis:i,keepDims:a}=n;return _0(r,i,a,"prod",s)}},Vae={kernelName:Ce.e6w,backendName:"webgpu",kernelFunc:t=>{const{backend:e,attrs:s}=t,{start:n,stop:r,step:i,dtype:a}=s,c=Tne(n,r,i,a);return e.makeTensorInfo([c.length],a,c)}},Uae=Su({opType:Pi.DIV}),zae={kernelName:Ce.oHH,backendName:"webgpu",kernelFunc:Uae},Wae=ha({opType:Zs.RECIPROCAL}),Hae={kernelName:Ce.$HU,backendName:"webgpu",kernelFunc:Wae},jae=ha({opType:Zs.RELU}),Gae={kernelName:Ce.qkr,backendName:"webgpu",kernelFunc:jae},Kae=ha({opType:Zs.RELU6}),Xae={kernelName:Ce.SbG,backendName:"webgpu",kernelFunc:Kae};class Yae{constructor(e,s,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],s,n,e[3]],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Qae={kernelName:Ce._Yw,backendName:"webgpu",kernelFunc:function Zae(t){const{inputs:e,backend:s,attrs:n}=t,{images:r}=e,{alignCorners:i,size:a,halfPixelCenters:c}=n,[f,g]=a,ne=[{type:"float32",data:[i&&f>1?1:0,i&&g>1?1:0]},{type:"float32",data:[c?.5:0]}],Ee=new Yae(r.shape,f,g);return s.runWebGPUProgram(Ee,[r],"float32",ne)}};class Jae{constructor(e,s){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=s,this.shaderKey=`resizeBilinearBackprop_${s}`}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const ele={kernelName:Ce.zbQ,backendName:"webgpu",kernelFunc:function qae(t){const{inputs:e,backend:s,attrs:n}=t,{images:r,dy:i}=e,{alignCorners:a}=n,[,c,f]=r.shape,[,g,E]=i.shape,A=[a&&g>1?c-1:c,a&&E>1?f-1:f],Y=[a&&g>1?g-1:g,a&&E>1?E-1:E],ne=A[0]/Y[0],Ee=A[1]/Y[1],Ge=1/ne,tt=1/Ee,Nt=2*Math.ceil(Ge)+2,kt=2*Math.ceil(tt)+2,on=new Jae(r.shape,a);return s.runWebGPUProgram(on,[i],i.dtype,[{type:"int32",data:A},{type:"int32",data:Y},{type:"float32",data:[ne]},{type:"float32",data:[Ee]},{type:"float32",data:[Ge]},{type:"float32",data:[tt]},{type:"int32",data:[Nt]},{type:"int32",data:[kt]}])}};class tle{constructor(e,s,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],s,n,e[3]],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const sle={kernelName:Ce.dpD,backendName:"webgpu",kernelFunc:function nle(t){const{inputs:e,backend:s,attrs:n}=t,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:c}=n,[f,g]=c,ne=[{type:"float32",data:[i&&f>1?1:0,i&&g>1?1:0]},{type:"float32",data:[i?.5:0]}],Ee=new tle(r.shape,f,g,a);return s.runWebGPUProgram(Ee,[r],r.dtype,ne)}};class rle{constructor(e,s){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=s,this.shaderKey=`resizeNearestNeigborBackprop_${s}`}getUserCode(){return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const ole={kernelName:Ce.Hmb,backendName:"webgpu",kernelFunc:function ile(t){const{inputs:e,backend:s,attrs:n}=t,{images:r,dy:i}=e,{alignCorners:a}=n,[,c,f]=r.shape,[,g,E]=i.shape,A=[a&&g>1?c-1:c,a&&E>1?f-1:f],Y=[a&&g>1?g-1:g,a&&E>1?E-1:E],Ge=1/(A[0]/Y[0]),tt=1/(A[1]/Y[1]),Nt=2*Math.ceil(Ge)+2,kt=2*Math.ceil(tt)+2,on=new rle(r.shape,a);return s.runWebGPUProgram(on,[i],i.dtype,[{type:"int32",data:A},{type:"int32",data:Y},{type:"float32",data:[Ge]},{type:"float32",data:[tt]},{type:"int32",data:[Nt]},{type:"int32",data:[kt]}])}};class ale{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const cle={kernelName:Ce.mKl,backendName:"webgpu",kernelFunc:function lle(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{dims:i}=n,a=r.shape.length;if(0===a)return uh({inputs:{x:r},backend:s});const c=r.shape,f=[1,1,1,1];c.forEach((tt,Nt)=>{f[Nt+4-a]=tt});const g=Ce.D5U.parseAxisParam(i,r.shape),E=[0,0,0,0];g.forEach(tt=>{E[tt+4-a]=1});const A=[{type:"int32",data:E}],Y=Kr({inputs:{x:r},backend:s,attrs:{shape:f}}),ne=new ale(f),Ee=s.runWebGPUProgram(ne,[Y],Y.dtype,A);s.disposeData(Y.dataId);const Ge=Kr({inputs:{x:Ee},backend:s,attrs:{shape:c}});return s.disposeData(Ee.dataId),Ge}};class ule{constructor(e,s){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof s?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${er("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const dle={kernelName:Ce.b9H,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:s})=>{const{image:n}=t,{radians:r,fillValue:i,center:a}=e,c=s,f=new ule(n.shape,i),[g,E]=Ce.backend_util.getImageCenter(a,n.shape[1],n.shape[2]),A=[{type:"float32",data:[g]},{type:"float32",data:[E]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return A.push("number"==typeof i?{type:"float32",data:[Number.parseFloat(i.toFixed(2))]}:{type:"float32",data:i}),c.runWebGPUProgram(f,[n],n.dtype,A)}},hle=ha({opType:Zs.ROUND}),ple={kernelName:Ce.e07,backendName:"webgpu",kernelFunc:hle},fle=ha({opType:Zs.RSQRT,cpuKernelImpl:Ane}),mle={kernelName:Ce.bV0,backendName:"webgpu",kernelFunc:fle};class FC{constructor(e,s,n,r,i,a,c,f=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=c,this.sumDupeIndices=f,this.dispatchLayout=br(e),this.dispatch=tr(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=s>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${c}_${f}`;const g=Xc(i.length);this.uniforms=`sliceDim : i32, strides: ${g}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const s=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";1===this.dispatchLayout.x.length?(r="flattenedIndex",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const c=`getUpdates(${Array.from({length:this.updatesRank},(g,E)=>`coords[${E}]`).join(", ")})`;return`\n    ${i}\n      ${er("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${s}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${h0(this.type)}(${c});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${this.sumDupeIndices?g_("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const _le={kernelName:Ce.xQA,backendName:"webgpu",kernelFunc:function gle(t){const{inputs:e,backend:s,attrs:n}=t,{indices:r,updates:i}=e,{shape:a}=n,{sliceRank:c,numUpdates:f,sliceSize:g,strides:E,outputSize:A}=Ce.backend_util.calculateShapes(i,r,a),Y=[A/g,g];if(0===A)return s.makeTensorInfo(a,r.dtype);const ne=Kr({inputs:{x:r},backend:s,attrs:{shape:[f,c]}}),Ee=Kr({inputs:{x:i},backend:s,attrs:{shape:[f,g]}}),Ge=Ee.dtype,tt=Vd({backend:s,attrs:{shape:Y,value:0,dtype:Ge}}),kt=[{type:"int32",data:[c]},{type:"int32",data:E},{type:"int32",data:[Ce.D5U.sizeFromShape(Ee.shape)]}],on=new FC(Ee.shape,c,ne.shape.length,Ee.shape.length,E,Y,Ge),fn=s.runWebGPUProgram(on,[Ee,ne],Ge,kt,tt),Tn=Kr({inputs:{x:fn},backend:s,attrs:{shape:a}});return s.disposeData(ne.dataId),s.disposeData(Ee.dataId),s.disposeData(fn.dataId),Tn}};class yle{constructor(e,s){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=s,this.shaderKey=`search_sorted_${s}`}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const ble={kernelName:Ce.nr8,backendName:"webgpu",kernelFunc:function vle(t){const{inputs:e,backend:s,attrs:n}=t,{sortedSequence:r,values:i}=e,{side:a}=n,c=new yle([i.shape[0],i.shape[1]],a);return s.runWebGPUProgram(c,[r,i],"int32",[{type:"int32",data:[r.shape[1]]}])}};class xle{constructor(e,s,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=s,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,s;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)s="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let c=0;c<this.outputShape.length;c++)a.push(`${r[c]}`),c<this.cRank&&i.push(`${r[c]}`);e=i.join(),s=a.join()}return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${s}));\n          } else {\n            setOutputAtIndex(index, getB(${s}));\n          }\n        }\n      }\n    `}}const Cle={kernelName:Ce.PhF,backendName:"webgpu",kernelFunc:function wle(t){const{inputs:e,backend:s}=t,{condition:n,t:r,e:i}=e,a=new xle(n.shape.length,r.shape,r.shape.length);return s.runWebGPUProgram(a,[n,r,i],(0,Ce.x8V)(r.dtype,i.dtype))}},Ele=ha({opType:Zs.SELU}),Dle={kernelName:Ce.oFR,backendName:"webgpu",kernelFunc:Ele},Sle=ha({opType:Zs.SIGMOID}),Ile={kernelName:Ce.a5O,backendName:"webgpu",kernelFunc:Sle},Tle=ha({opType:Zs.SIGN}),Ale={kernelName:Ce.i5y,backendName:"webgpu",kernelFunc:Tle},kle=ha({opType:Zs.SIN}),Ole={kernelName:Ce.RQH,backendName:"webgpu",kernelFunc:kle},Rle=ha({opType:Zs.SINH}),Nle={kernelName:Ce.wYB,backendName:"webgpu",kernelFunc:Rle},Mle=ha({opType:Zs.SOFTPLUS}),Ple={kernelName:Ce.MRv,backendName:"webgpu",kernelFunc:Mle};class Fle{constructor(e,s,n,r,i,a){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const c=new Array(r.length);for(let f=0;f<c.length;f++)c[f]=r[i[f]];this.outputShape=c,this.newDim=i,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=s,this.uniforms+=`reshapedPaddedXShape : ${Xc(r.length)}, paddedXShapeStrides : ${Xc(a)}, `,n.map((f,g)=>{this.uniforms+=` pad${g} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Xc(this.outputShape.length),s=gU(this.newDim);return`\n      ${kI(this.paddedXShape,"PaddedX")}\n      ${er("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${s}), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ${VU(this.xShape,!0)}\n        }\n      }\n    `}}const $le={kernelName:Ce.TQc,backendName:"webgpu",kernelFunc:t=>{const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{blockShape:i,paddings:a}=n;Ce.D5U.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const c=i.reduce((kt,on)=>kt*on),f=[[0,0]];f.push(...a);for(let kt=1+i.length;kt<r.shape.length;++kt)f.push([0,0]);const g=f.map((kt,on)=>kt[0]+r.shape[on]+kt[1]),E=Ce.backend_util.getReshaped(g,i,c,!1),A=Ce.backend_util.getPermuted(E.length,i.length,!1),Y=Ce.backend_util.getReshapedPermuted(g,i,c,!1),ne=Ce.D5U.computeStrides(g),Ee=new Fle(r.shape,g,f,E,A,ne.length),Ge=[{type:"int32",data:E},{type:"int32",data:ne}];f.map(kt=>Ge.push({type:"int32",data:[kt[0],kt[1]]}));const tt=s.runWebGPUProgram(Ee,[r],r.dtype,Ge),Nt=Kr({inputs:{x:tt},backend:s,attrs:{shape:Y}});return s.disposeData(tt.dataId),Nt}};class Ble{constructor(e,s,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=n,this.dispatchLayout=br([s]),this.dispatch=tr(this.dispatchLayout,[s],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ${g_("&result[outIndex]","value",this.type)}\n      }\n    }\n  `}}class Vle{constructor(e,s){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=br(s),this.dispatch=tr(this.dispatchLayout,s,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ${g_("&result[segmentId]","1","int32")}\n      }\n    }\n  `}}class Ule{constructor(e,s){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=s,this.dispatchLayout=br(e),this.dispatch=tr(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ${"float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}\n        }\n      }\n    }\n  `}}function UU(t,e,s,n=!1,r){const a=Ce.D5U.sizeFromShape(t.shape)/t.shape[0],c=t.dtype,f=Ce.D5U.sizeFromShape(e.shape),g=r.readSync(s.dataId),A=f>0?g[f-1]+1:0;let Y;const ne=t.shape.slice();ne[0]=A;const Ee=f*a,Ge=Vd({backend:r,attrs:{shape:ne,value:0,dtype:c}});Y=new Ble(ne,Ee,c);let tt=[{type:"int32",data:[a]},{type:"int32",data:[Ee]}];const Nt=r.runWebGPUProgram(Y,[t,e,s],c,tt,Ge);if(n)return Nt;const kt=Vd({backend:r,attrs:{shape:[A],value:0,dtype:"int32"}});Y=new Vle(A,s.shape);const on=r.runWebGPUProgram(Y,[s],"int32",null,kt),fn=Vd({backend:r,attrs:{shape:ne,value:0,dtype:c}});Y=new Ule(ne,c),tt=[{type:"int32",data:[a]}];const Tn=r.runWebGPUProgram(Y,[Nt,on],c,tt,fn);return r.disposeData(Nt.dataId),r.disposeData(on.dataId),Tn}const Wle={kernelName:Ce.w3H,backendName:"webgpu",kernelFunc:function zle(t){const{inputs:e,backend:s}=t,{data:n,indices:r,segmentIds:i}=e;return UU(n,r,i,!1,s)}},jle={kernelName:Ce.ZjV,backendName:"webgpu",kernelFunc:function Hle(t){const{inputs:e,backend:s}=t,{data:n,indices:r,segmentIds:i}=e;return UU(n,r,i,!0,s)}};class Gle{constructor(e,s){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*s[r];this.outputShape=n,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function Kle(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`(resRC % ${e}aShape)`;const s=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<t;r++)n.push(`(${s[r]} % ${e}aShape[${r}])`);return n.join()}(this.rank,"uniforms.");return`\n      ${er("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function lN(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{reps:i}=n;if(s.shouldExecuteOnCPU([r])||"string"===r.dtype||r.shape.length>=5){const f=s.readSync(r.dataId),g="string"===r.dtype?f.map(Y=>Ce.D5U.decodeString(Y)):f,E=(0,Ce.f3b)(r.shape,r.dtype,g),A=Fne(E,i);return s.makeTensorInfo(A.shape,A.dtype,A.values)}const a=new Gle(r.shape,i);return s.runWebGPUProgram(a,[r],r.dtype)}const Xle={kernelName:Ce.n9L,backendName:"webgpu",kernelFunc:lN},Zle={kernelName:Ce.D2d,backendName:"webgpu",kernelFunc:function Yle(t){const{inputs:e,backend:s,attrs:n}=t,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:c}=n,{sliceRank:f,numUpdates:g,sliceSize:E,strides:A,outputSize:Y}=Ce.backend_util.calculateShapes(i,r,c);if("string"===i.dtype){const xs=s.bufferSync(r),fs=s.bufferSync(i),Ks=Ce.D5U.decodeString(s.readSync(a.dataId)[0]),Hr=kne(xs,fs,c,Y,E,g,f,A,Ks,!1);return s.makeTensorInfo(c,Hr.dtype,Hr.values)}const Ee=[Y/E,E],Ge=Kr({inputs:{x:r},backend:s,attrs:{shape:[g,f]}}),tt=i.shape.length?Kr({inputs:{x:i},backend:s,attrs:{shape:[g,E]}}):uh({inputs:{x:i},backend:s}),Nt=tt.dtype,kt=s.makeTensorInfo([],Nt,Ce.D5U.makeZerosTypedArray(1,Nt)),on=Kr({inputs:{x:a},backend:s,attrs:{shape:Array(Ee.length).fill(1)}}),fn=lN({inputs:{x:on},backend:s,attrs:{reps:Ee}}),Hn=[{type:"int32",data:[f]},{type:"int32",data:A},{type:"int32",data:[Ce.D5U.sizeFromShape([g,E])]}];switch(g){case 0:break;case 1:{const xs=new FC([g,E],f,Ge.shape.length,tt.shape.length,A,Ee,Nt,!1);s.runWebGPUProgram(xs,[tt,Ge],Nt,Hn,fn)}break;default:{const xs=new FC([g,E],f,Ge.shape.length,kt.shape.length,A,Ee,Nt,!1);s.runWebGPUProgram(xs,[kt,Ge],Nt,Hn,fn)}{const xs=new FC([g,E],f,Ge.shape.length,tt.shape.length,A,Ee,Nt);s.runWebGPUProgram(xs,[tt,Ge],Nt,Hn,fn)}}const Wn=Kr({inputs:{x:fn},backend:s,attrs:{shape:c}});return s.disposeData(Ge.dataId),s.disposeData(tt.dataId),s.disposeData(on.dataId),s.disposeData(kt.dataId),s.disposeData(fn.dataId),Wn}},Jle={kernelName:Ce.L8s,backendName:"webgpu",kernelFunc:function Qle(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{numOrSizeSplits:i,axis:a}=n,c=Ce.D5U.parseAxisParam(a,r.shape)[0],f=Ce.backend_util.prepareSplitSize(r,i,c),E=new Array(r.shape.length).fill(0),A=r.shape.slice();return f.map(Y=>{const ne=[...A];ne[c]=Y;const Ee=$b({inputs:{x:r},backend:s,attrs:{begin:E,size:ne}});return E[c]+=Y,Ee})}},qle=ha({opType:Zs.SQRT}),ece={kernelName:Ce.FKq,backendName:"webgpu",kernelFunc:qle},tce={kernelName:Ce.bK0,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:s}=t,n=e,r=new Lb(s.shape,Zs.SQUARE);return n.runWebGPUProgram(r,[s],s.dtype)}},nce=Su({opType:Pi.SQUARED_DIFFERENCE}),sce={kernelName:Ce._tC,backendName:"webgpu",kernelFunc:nce},ice={kernelName:Ce.h8e,backendName:"webgpu",kernelFunc:function rce({inputs:t,attrs:e,backend:s}){const{x:n}=t,r=new Lb(n.shape,Zs.STEP,"stepAlpha : f32,");return s.runWebGPUProgram(r,[n],n.dtype,[{type:"float32",data:[e.alpha]}])}};class oce{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const s=Xc(this.outputShape.length);this.uniforms=`begin : ${s},  strides : ${s}, `,this.shaderKey="stridedSlice"}getUserCode(){let s="";if(1===this.outputShape.length)s="coords * uniforms.strides + uniforms.begin";else{let r=0;s=this.outputShape.map((i,a)=>(r++,1===this.outputShape.length?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${r-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`\n       ${er("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${s}));\n         }\n       }\n     `}}const lce={kernelName:Ce.jQk,backendName:"webgpu",kernelFunc:function ace(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{begin:i,end:a,strides:c,beginMask:f,endMask:g,ellipsisMask:E,newAxisMask:A,shrinkAxisMask:Y}=n,{finalShapeSparse:ne,finalShape:Ee,isIdentity:Ge,sliceDim0:tt,isSimpleSlice:Nt,begin:kt,end:on,strides:fn}=Ce.kuN.sliceInfo(r.shape,i,a,c,f,g,E,A,Y);let Tn;if(Ge)Tn=Kr({inputs:{x:r},backend:s,attrs:{shape:Ee}});else if(tt||Nt){Ce.D5U.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const Hn=Ce.kuN.computeOutShape(kt,on,fn),Wn=$b({inputs:{x:r},backend:s,attrs:{begin:kt,size:Hn}});Tn=Kr({inputs:{x:Wn},backend:s,attrs:{shape:Ee}}),s.disposeData(Wn.dataId)}else if(s.shouldExecuteOnCPU([r])){const Wn=s.readSync(r.dataId),xs=(0,Ce.f3b)(r.shape,r.dtype,Wn),fs=Nne(ne,xs,fn,kt);Tn=s.makeTensorInfo(Ee,r.dtype,fs.values)}else{const Wn=new oce(ne),fs=s.runWebGPUProgram(Wn,[r],r.dtype,[{type:"int32",data:kt},{type:"int32",data:fn}]);Tn=Kr({inputs:{x:fs},backend:s,attrs:{shape:Ee}}),s.disposeData(fs.dataId)}return Tn}},uce={kernelName:Ce._JP,backendName:"webgpu",kernelFunc:function cce(t){const{inputs:e,backend:s,attrs:n}=t,{separator:r,nGramWidths:i,leftPad:a,rightPad:c,padWidth:f,preserveShortSequences:g}=n,{data:E,dataSplits:A}=e,Y=s.readSync(E.dataId),ne=s.readSync(A.dataId),[Ee,Ge]=Mne(Y,ne,r,i,a,c,f,g);return[s.makeTensorInfo([Ee.length],"string",Ee),s.makeTensorInfo(A.shape,"int32",Ge)]}},dce=Su({opType:Pi.SUB,cpuKernelImpl:Pne,supportsComplex:!0}),hce={kernelName:Ce.Tr8,backendName:"webgpu",kernelFunc:dce},pce=ha({opType:Zs.TAN}),fce={kernelName:Ce.sEM,backendName:"webgpu",kernelFunc:pce},mce=ha({opType:Zs.TANH}),gce={kernelName:Ce.MIZ,backendName:"webgpu",kernelFunc:mce},yce={kernelName:Ce.SIB,backendName:"webgpu",kernelFunc:function _ce(t){const{inputs:e,backend:s}=t,{tensor:r,indices:i,updates:a}=e,{sliceRank:c,numUpdates:f,sliceSize:g,strides:E,outputSize:A}=Ce.backend_util.calculateShapes(a,i,r.shape),Y=[A/g,g];if(0===A)return s.makeTensorInfo(r.shape,i.dtype);const ne=[],Ee=Kr({inputs:{x:i},backend:s,attrs:{shape:[f,c]}});ne.push(Ee);const Ge=Kr({inputs:{x:a},backend:s,attrs:{shape:[f,g]}});ne.push(Ge);const tt=Kr({inputs:{x:r},backend:s,attrs:{shape:Y}});ne.push(tt);const Nt=lN({inputs:{x:tt},backend:s,attrs:{reps:Array(Y.length).fill(1)}}),kt=new FC([f,g],c,Ee.shape.length,Ge.shape.length,E,Y,r.dtype,!1),on=Ce.D5U.sizeFromShape([f,g]),Tn=s.runWebGPUProgram(kt,[Ge,Ee],tt.dtype,[{type:"int32",data:[c]},{type:"int32",data:E},{type:"int32",data:[on]}],Nt);ne.push(Tn);const Hn=Kr({inputs:{x:Tn},backend:s,attrs:{shape:r.shape}});return ne.forEach(Wn=>s.disposeData(Wn.dataId)),Hn}};class vce{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${er("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class bce{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${er("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function Vb(t,e){null!==e&&t.disposeData(e.dataId)}function zU(t){let e=1;for(;e<t;)e*=2;return e}const wce={kernelName:Ce.cWu,backendName:"webgpu",kernelFunc:function xce(t){const{inputs:e,backend:s,attrs:n}=t,{x:r}=e,{k:i,sorted:a}=n,c=r.shape,f=c[c.length-1];if(s.shouldExecuteOnCPU([r])){const Tn=s.readSync(r.dataId),[Hn,Wn]=Lne(Tn,c,r.dtype,i,a);return[s.makeTensorInfo(Hn.shape,Hn.dtype,Hn.values),s.makeTensorInfo(Wn.shape,Wn.dtype,Wn.values)]}if(0===i)return c[c.length-1]=0,[s.makeTensorInfo(c,r.dtype,[]),s.makeTensorInfo(c,"int32",[])];if(1===f)return[r,Vd({attrs:{shape:c,dtype:"int32",value:0},backend:s})];const E=Ce.D5U.sizeFromShape(c)/f,A=Kr({inputs:{x:r},attrs:{shape:[E,f]},backend:s}),Y=zU(i),ne=zU(f);let Ee=null;const Ge=()=>null===Ee?[A,A]:[A,Ee],tt=(Tn,Hn,Wn)=>{const xs=Ge(),fs=new vce(Wn),xi=Ee;Ee=s.runWebGPUProgram(fs,xs,"int32",[{type:"int32",data:[f]},{type:"int32",data:[null===Ee?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[Tn]},{type:"int32",data:[Hn]}]),Vb(s,xi)};for(let Tn=1;Tn<Y;Tn*=2){const Hn=2*Tn;for(let Wn=Tn;Wn>=1;Wn/=2)tt(Hn,Wn,[E,ne])}for(let Tn=ne;Tn>Y;Tn/=2){const Hn=Ge(),Wn=new bce([E,Tn/2]),Ks=Ee;Ee=s.runWebGPUProgram(Wn,Hn,"int32",[{type:"int32",data:[f]},{type:"int32",data:[null===Ee?1:0]},{type:"int32",data:[Y]}]),Vb(s,Ks);const Hr=Y/2,xi=2*Hr;for(let jr=Hr;jr>=1;jr/=2)tt(xi,jr,Ee.shape)}let Nt=Ee;Ee=$b({inputs:{x:Ee},backend:s,attrs:{begin:0,size:[E,i]}}),Vb(s,Nt);let kt=FU({inputs:{x:A,indices:Ee},backend:s,attrs:{axis:1,batchDims:1}});Vb(s,A);const on=c.slice(0,-1);on.push(i),Nt=Ee,Ee=Kr({inputs:{x:Ee},attrs:{shape:on},backend:s}),Vb(s,Nt);const fn=kt;return kt=Kr({inputs:{x:kt},attrs:{shape:on},backend:s}),Vb(s,fn),[kt,Ee]}};class Cce{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${er("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const Dce={kernelName:Ce.wx7,backendName:"webgpu",kernelFunc:function Ece(t){const{inputs:e,backend:s,attrs:n}=t,{image:r,transforms:i}=e,{interpolation:a,fillMode:c,fillValue:f,outputShape:g}=n,[E,A,Y,ne]=r.shape,[Ee,Ge]=g??[A,Y],Nt=new Cce([E,Ee,Ge,ne]),kt="nearest"===a?1:2;let on;switch(c){case"constant":default:on=1;break;case"reflect":on=2;break;case"wrap":on=3;break;case"nearest":on=4}return s.runWebGPUProgram(Nt,[r,i],"float32",[{type:"int32",data:[kt]},{type:"int32",data:[on]},{type:"float32",data:[f]}])}},Ice={kernelName:Ce.ToN,backendName:"webgpu",kernelFunc:function Sce(t){const{inputs:e,backend:s,attrs:n}=t,{value:r}=e;let{axis:i}=n;i<0&&(i+=r.shape.length);const a=r,c=a.shape.length,f=r.shape[i],g=new Array(c-1);let E=0;for(let Ge=0;Ge<c;Ge++)Ge!==i&&(g[E++]=a.shape[Ge]);const A=[],Y=new Array(c).fill(0),ne=a.shape.slice();ne[i]=1;const Ee=new Array(f);for(let Ge=0;Ge<Ee.length;Ge++){Y[i]=Ge;const tt=$b({inputs:{x:a},backend:s,attrs:{begin:Y,size:ne}}),Nt=Kr({inputs:{x:tt},backend:s,attrs:{shape:g}});Ee[Ge]=Nt,A.push(tt)}return A.forEach(Ge=>s.disposeData(Ge.dataId)),Ee}};class Tce{constructor(e,s,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=s,this.dispatchLayout=br(e),this.dispatch=tr(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`UnsortedSegmentSum only supports float32 and int32\n              types, does not support ${n} type.`);this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`\n    ${er("index")} {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ${g_("&result[flatIndex]","value",this.type)}\n        }\n      }\n    }\n  `}}const kce={kernelName:Ce.Qvg,backendName:"webgpu",kernelFunc:function Ace(t){const{inputs:e,backend:s,attrs:n}=t,{x:r,segmentIds:i}=e,{numSegments:a}=n,c=r.shape.length,f=[];let g=0;const E=Ce.backend_util.getAxesPermutation([g],c);let A=r;null!=E&&(A=Ff({inputs:{x:r},backend:s,attrs:{perm:E}}),f.push(A),g=Ce.backend_util.getInnerMostAxes(1,c)[0]);const Y=Ce.backend_util.segment_util.computeOutShape(A.shape,g,a),ne=Ce.D5U.sizeFromShape([A.shape[g]]),Ee=Kr({inputs:{x:A},backend:s,attrs:{shape:[-1,ne]}});f.push(Ee);const Ge=r.dtype,tt=[Ee.shape[0],a],Nt=Vd({backend:s,attrs:{shape:tt,value:0,dtype:Ge}}),kt=new Tce(Ee.shape,tt,Ge),on=[{type:"int32",data:[a]},{type:"int32",data:[Ce.D5U.sizeFromShape(Ee.shape)]}],fn=s.runWebGPUProgram(kt,[Ee,i],Ge,on,Nt),Tn=Kr({inputs:{x:fn},backend:s,attrs:{shape:Y}});f.push(fn);let Hn=Tn;if(null!=E){f.push(Tn);const Wn=Ce.backend_util.getUndoAxesPermutation(E);Hn=Ff({inputs:{x:Hn},backend:s,attrs:{perm:Wn}})}return f.forEach(Wn=>s.disposeData(Wn.dataId)),Hn}},Oce=[tne,Vne,zne,Hne,Gne,Yne,nse,rse,ose,lse,use,hse,fse,gse,yse,Cse,Dse,Ase,Ose,Nse,$se,zse,jse,Yse,Qse,tre,sne,rre,lre,gre,wre,Sre,Are,Ore,Nre,Pre,Lre,Vre,zre,Hre,Gre,Yre,nie,rie,Jre,aie,uie,fie,gie,vie,Cie,Die,Iie,Aie,Oie,Nie,Mie,Fie,$ie,Jte,Vie,Gie,zie,Hie,Yie,Qie,qie,noe,ioe,aoe,coe,nne,doe,ore,poe,moe,_oe,voe,xoe,Coe,Soe,koe,Toe,Roe,Moe,Foe,Voe,Woe,bse,joe,Koe,tae,Yoe,qoe,sae,xse,iae,aae,cae,dae,gae,bie,yae,bae,wae,Gse,Dae,Iae,Aae,Rae,Mae,Fae,$ae,Vae,Kse,zae,Hae,Gae,Xae,qte,Qae,ele,sle,ole,cle,dle,ple,mle,_le,ble,Cle,Dle,Ile,Ale,Ole,Nle,Fse,ice,lce,uce,fae,Ple,$le,Wle,jle,Zle,Jle,ece,tce,sce,hce,xie,fce,gce,yce,Xle,wce,Dce,Jne,Ice,kce,Sae];for(const t of Oce)(0,Ce.wCN)(t);var WU=function(t,e){return(WU=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(s,n){s.__proto__=n}||function(s,n){for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(s[r]=n[r])})(t,e)};function HU(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function s(){this.constructor=t}WU(t,e),t.prototype=null===e?Object.create(e):(s.prototype=e.prototype,new s)}var Ul=function(){return(Ul=Object.assign||function(t){for(var e,s=1,n=arguments.length;s<n;s++)for(var r in e=arguments[s])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}).apply(this,arguments)};function ra(t,e,s,n){return new(s||(s=Promise))(function(r,i){function a(g){try{f(n.next(g))}catch(E){i(E)}}function c(g){try{f(n.throw(g))}catch(E){i(E)}}function f(g){var E;g.done?r(g.value):(E=g.value,E instanceof s?E:new s(function(A){A(E)})).then(a,c)}f((n=n.apply(t,e||[])).next())})}function ia(t,e){var s,n,r,i,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:c(0),throw:c(1),return:c(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function c(f){return function(g){return function(E){if(s)throw new TypeError("Generator is already executing.");for(;a;)try{if(s=1,n&&(r=2&E[0]?n.return:E[0]?n.throw||((r=n.return)&&r.call(n),0):n.next)&&!(r=r.call(n,E[1])).done)return r;switch(n=0,r&&(E=[2&E[0],r.value]),E[0]){case 0:case 1:r=E;break;case 4:return a.label++,{value:E[1],done:!1};case 5:a.label++,n=E[1],E=[0];continue;case 7:E=a.ops.pop(),a.trys.pop();continue;default:if(!((r=(r=a.trys).length>0&&r[r.length-1])||6!==E[0]&&2!==E[0])){a=0;continue}if(3===E[0]&&(!r||E[1]>r[0]&&E[1]<r[3])){a.label=E[1];break}if(6===E[0]&&a.label<r[1]){a.label=r[1],r=E;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(E);break}r[2]&&a.ops.pop(),a.trys.pop();continue}E=e.call(t,a)}catch(A){E=[6,A],n=0}finally{s=r=0}if(5&E[0])throw E[1];return{value:E[0]?E[1]:void 0,done:!0}}([f,g])}}}function y0(t,e,s){if(s||2===arguments.length)for(var n,r=0,i=e.length;r<i;r++)!n&&r in e||(n||(n=Array.prototype.slice.call(e,0,r)),n[r]=e[r]);return t.concat(n||Array.prototype.slice.call(e))}var Lf=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],LC=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],Rce={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},Nce={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Mce=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],Pce=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function BI(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function jU(t){return ra(this,void 0,void 0,function(){var e,s;return ia(this,function(n){switch(n.label){case 0:return e=document.createElement("canvas"),t instanceof Ce.esB?[4,Ce.Xhn.toPixels(t,e)]:[3,2];case 1:return n.sent(),[3,3];case 2:e.width=BI(t.width),e.height=BI(t.height),s=e.getContext("2d"),t instanceof ImageData?s.putImageData(t,0,0):s.drawImage(t,0,0),n.label=3;case 3:return[2,e]}})})}function GU(t){return ra(this,void 0,void 0,function(){var e,s,n,r,i,a;return ia(this,function(c){switch(c.label){case 0:return t instanceof Ce.esB?(e=t.shape.slice(0,2),s=e[0],n=e[1],r=ImageData.bind,[4,Ce.Xhn.toPixels(t)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,c.sent(),n,s]))];case 2:return i=document.createElement("canvas"),a=i.getContext("2d"),i.width=BI(t.width),i.height=BI(t.height),a.drawImage(t,0,0),[2,a.getImageData(0,0,i.width,i.height)]}})})}function Fce(t){return ra(this,void 0,void 0,function(){var s;return ia(this,function(n){switch(n.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,jU(t)]:[3,2];case 1:return s=n.sent(),[3,3];case 2:s=t,n.label=3;case 3:return[2,Ce.Xhn.fromPixels(s,4)]}})})}function KU(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(t));if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got ".concat(t))}var $C={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},Lce=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ra(this,void 0,void 0,function(){return ia(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return ra(this,void 0,void 0,function(){return ia(this,function(e){return[2,GU(this.mask)]})})},t.prototype.toTensor=function(){return ra(this,void 0,void 0,function(){return ia(this,function(e){return[2,Fce(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function $ce(t){return KU(t),"person"}var Bce=function(){function t(e){var s,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new qq.Pose({locateFile:function(r,i){if(e.solutionPath){var a=e.solutionPath.replace(/\/+$/,"");return"".concat(a,"/").concat(r)}return"".concat(i,"/").concat(r)}}),e.modelType){case"lite":s=0;break;case"heavy":s=2;break;default:s=1}this.poseSolution.setOptions({modelComplexity:s,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(r){if(n.height=r.image.height,n.width=r.image.width,null==r.poseLandmarks)n.poses=[];else{var i=n.translateOutput(r.poseLandmarks,r.poseWorldLandmarks);r.segmentationMask&&(i.segmentation={maskValueToLabel:$ce,mask:new Lce(r.segmentationMask)}),n.poses=[i]}})}return t.prototype.translateOutput=function(e,s){var n=this,r={keypoints:e.map(function(i,a){return{x:i.x*n.width,y:i.y*n.height,z:i.z,score:i.visibility,name:LC[a]}})};return null!=s&&(r.keypoints3D=s.map(function(i,a){return{x:i.x,y:i.y,z:i.z,score:i.visibility,name:LC[a]}})),r},t.prototype.estimatePoses=function(e,s,n){return ra(this,void 0,void 0,function(){var r,i;return ia(this,function(a){switch(a.label){case 0:return s&&s.flipHorizontal&&s.flipHorizontal!==this.selfieMode&&(this.selfieMode=s.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Ce.esB?(i=ImageData.bind,[4,Ce.Xhn.toPixels(e)]):[3,2];case 1:return r=new(i.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return[4,this.poseSolution.send({image:e=r},n)];case 4:return a.sent(),[2,this.poses]}})})},t.prototype.dispose=function(){this.poseSolution.close()},t.prototype.reset=function(){this.poseSolution.reset()},t.prototype.initialize=function(){return this.poseSolution.initialize()},t}();function Vce(t){return ra(this,void 0,void 0,function(){var e,s;return ia(this,function(n){switch(n.label){case 0:return e=function(r){if(null==r)return Ul({},$C);var i=Ul({},r);return i.runtime="mediapipe",null==i.enableSegmentation&&(i.enableSegmentation=$C.enableSegmentation),null==i.enableSmoothing&&(i.enableSmoothing=$C.enableSmoothing),null==i.smoothSegmentation&&(i.smoothSegmentation=$C.smoothSegmentation),null==i.modelType&&(i.modelType=$C.modelType),i}(t),[4,(s=new Bce(e)).initialize()];case 1:return n.sent(),[2,s]}})})}function Ub(t){return t instanceof Ce.esB?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function XU(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function cN(t){return t instanceof Ce.esB?t:Ce.Xhn.fromPixels(t)}function YU(t,e,s){return uN(s,"inputResolution"),[1/s.width*t[0][0]*e.width,1/s.height*t[0][1]*e.width,t[0][3]*e.width,1/s.width*t[1][0]*e.height,1/s.height*t[1][1]*e.height,t[1][3]*e.height,0,0]}function uN(t,e){Ce.D5U.assert(0!==t.width,function(){return"".concat(e," width cannot be 0.")}),Ce.D5U.assert(0!==t.height,function(){return"".concat(e," height cannot be 0.")})}function dN(t,e,s){var ne,Ee,tt,Nt,kt,n=s.rotationVectorStartKeypointIndex,r=s.rotationVectorEndKeypointIndex,i=t.locationData,a=i.relativeKeypoints[n].x*e.width,c=i.relativeKeypoints[n].y*e.height,f=i.relativeKeypoints[r].x*e.width,g=i.relativeKeypoints[r].y*e.height,E=2*Math.sqrt((f-a)*(f-a)+(g-c)*(g-c)),A=(ne=e,tt=t.locationData,Nt=(Ee=s).rotationVectorStartKeypointIndex,kt=Ee.rotationVectorEndKeypointIndex,XU((Ee.rotationVectorTargetAngle?Ee.rotationVectorTargetAngle:Math.PI*Ee.rotationVectorTargetAngleDegree/180)-Math.atan2(-(tt.relativeKeypoints[kt].y*ne.height-tt.relativeKeypoints[Nt].y*ne.height),tt.relativeKeypoints[kt].x*ne.width-tt.relativeKeypoints[Nt].x*ne.width)));return{xCenter:a/e.width,yCenter:c/e.height,width:E/e.width,height:E/e.height,rotation:A}}function ZU(t){if(16!==t.length)throw new Error("Array length must be 16 but got ".concat(t.length));return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function hN(t,e,s,n,r,i,a){return t[e][r]*(t[s][i]*t[n][a]-t[s][a]*t[n][i])}function _d(t,e,s){var n=(e+1)%4,r=(e+2)%4,i=(e+3)%4,a=(s+1)%4,c=(s+2)%4,f=(s+3)%4;return hN(t,n,r,i,a,c,f)+hN(t,r,i,n,a,c,f)+hN(t,i,n,r,a,c,f)}function QU(t,e,s){void 0===s&&(s={ignoreRotation:!1});for(var n=[],r=0,i=t;r<i.length;r++){var a=i[r],c=a.x-.5,f=a.y-.5,g=s.ignoreRotation?0:e.rotation,E=Math.cos(g)*c-Math.sin(g)*f,A=Math.sin(g)*c+Math.cos(g)*f;E=E*e.width+e.xCenter,A=A*e.height+e.yCenter;var Y=a.z*e.width,ne=Ul({},a);ne.x=E,ne.y=A,ne.z=Y,n.push(ne)}return n}function JU(t,e){var i,g,s={scale:g=(e[1]-(i=e[0]))/255,offset:i-0*g};return(0,Ce.lub)(function(){return(0,Ce.IHx)((0,Ce.dC7)(t,s.scale),s.offset)})}function pN(t,e,s){var n,r,i,c,f,E,A,Y,ne,Ee,Ge,tt,fs,Ks,Nt=e.outputTensorSize,kt=e.keepAspectRatio,on=e.borderMode,fn=e.outputTensorFloatRange,Tn=Ub(t),Hn=(fs=Tn,(Ks=s)?{xCenter:Ks.xCenter*fs.width,yCenter:Ks.yCenter*fs.height,width:Ks.width*fs.width,height:Ks.height*fs.height,rotation:Ks.rotation}:{xCenter:.5*fs.width,yCenter:.5*fs.height,width:fs.width,height:fs.height,rotation:0}),Wn=function(fs,Ks,Hr){if(void 0===Hr&&(Hr=!1),!Hr)return{top:0,left:0,right:0,bottom:0};var xi=Ks.height,jr=Ks.width;uN(Ks,"targetSize"),uN(fs,"roi");var Co,ba,ws=xi/jr,Mr=fs.height/fs.width,Qr=0,Wi=0;return ws>Mr?(Co=fs.width,ba=fs.width*ws,Wi=(1-Mr/ws)/2):(Co=fs.height/ws,ba=fs.height,Qr=(1-ws/Mr)/2),fs.width=Co,fs.height=ba,{top:Wi,left:Qr,right:Qr,bottom:Wi}}(Hn,Nt,kt),xs=(r=Tn.width,i=Tn.height,c=(n=Hn).width,f=n.height,E=Math.cos(n.rotation),A=Math.sin(n.rotation),Y=n.xCenter,ne=n.yCenter,Ee=1/r,Ge=1/i,(tt=new Array(16))[0]=c*E*1*Ee,tt[1]=-f*A*Ee,tt[2]=0,tt[3]=(-.5*c*E*1+.5*f*A+Y)*Ee,tt[4]=c*A*1*Ge,tt[5]=f*E*Ge,tt[6]=0,tt[7]=(-.5*f*E-.5*c*A*1+ne)*Ge,tt[8]=0,tt[9]=0,tt[10]=c*Ee,tt[11]=0,tt[12]=0,tt[13]=0,tt[14]=0,tt[15]=1,ZU(tt));return{imageTensor:(0,Ce.lub)(function(){var fs=cN(t),Ks=(0,Ce.odF)(YU(xs,Tn,Nt),[1,8]),Hr="zero"===on?"constant":"nearest",xi=Ce.image.transform((0,Ce.dt4)((0,Ce.pju)(fs,"float32")),Ks,"bilinear",Hr,0,[Nt.height,Nt.width]);return null!=fn?JU(xi,fn):xi}),padding:Wn,transformationMatrix:xs}}function qU(t,e,s,n){return 1===n?.5*(t+e):t+(e-t)*s/(n-1)}function ez(t){return null!=t&&null!=t.currentTime}function tz(t){for(var e={locationData:{relativeKeypoints:[]}},s=Number.MAX_SAFE_INTEGER,n=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,a=0;a<t.length;++a){var c=t[a];s=Math.min(s,c.x),n=Math.max(n,c.x),r=Math.min(r,c.y),i=Math.max(i,c.y),e.locationData.relativeKeypoints.push({x:c.x,y:c.y})}return e.locationData.relativeBoundingBox={xMin:s,yMin:r,xMax:n,yMax:i,width:n-s,height:i-r},e}function zce(t,e,s,n){return ra(this,void 0,void 0,function(){var r,i,a,c,f;return ia(this,function(g){switch(g.label){case 0:return t.sort(function(E,A){return Math.max.apply(Math,A.score)-Math.max.apply(Math,E.score)}),r=(0,Ce.odF)(t.map(function(E){return[E.locationData.relativeBoundingBox.yMin,E.locationData.relativeBoundingBox.xMin,E.locationData.relativeBoundingBox.yMax,E.locationData.relativeBoundingBox.xMax]})),i=(0,Ce.RRF)(t.map(function(E){return E.score[0]})),[4,Ce.image.nonMaxSuppressionAsync(r,i,e,s)];case 1:return[4,(a=g.sent()).array()];case 2:return c=g.sent(),f=t.filter(function(E,A){return c.indexOf(A)>-1}),(0,Ce.B90)([r,i,a]),[2,f]}})})}function nz(t,e){return t.map(function(s){var n=Ul(Ul({},s),{x:s.x*e.width,y:s.y*e.height});return null!=s.z&&(n.z=s.z*e.width),n})}function Wce(t,e,s){return ra(this,void 0,void 0,function(){var n,r,i,a,c,f,g,E,Y,ne,Ee,Ge,tt,Nt,kt,on,fn,Tn,Hn,Wn,xs,fs,Ks;return ia(this,function(Hr){switch(Hr.label){case 0:if(n=(0,Ce.L9e)(e,[0]),i=(r=n.shape)[0],a=r[1],t.length!==(c=r[2]))throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(t.length,", heatmap length: ").concat(c));return f=[],[4,n.buffer()];case 1:for(g=Hr.sent(),E=0;E<t.length;E++)if(Y=Ul({},t[E]),f.push(Y),ne=Math.trunc(Y.x*a),Ee=Math.trunc(Y.y*i),!(ne<0||ne>=a||Ee<0||ne>=i)){for(Ge=Math.trunc((s.kernelSize-1)/2),tt=Math.max(0,ne-Ge),Nt=Math.min(a,ne+Ge+1),kt=Math.max(0,Ee-Ge),on=Math.min(i,Ee+Ge+1),fn=0,Tn=0,Hn=0,Wn=0,xs=kt;xs<on;++xs)for(fs=tt;fs<Nt;++fs)Ks=g.get(xs,fs,E),fn+=Ks,Wn=Math.max(Wn,Ks),Tn+=fs*Ks,Hn+=xs*Ks;Wn>=s.minConfidenceToRefine&&fn>0&&(Y.x=Tn/a/fn,Y.y=Hn/i/fn)}return n.dispose(),[2,f]}})})}function sz(t,e){var s=e.left,n=e.top,r=e.left+e.right,i=e.top+e.bottom;return t.map(function(a){return Ul(Ul({},a),{x:(a.x-s)/(1-r),y:(a.y-n)/(1-i),z:a.z/(1-r)})})}function jce(t,e,s){return ra(this,void 0,void 0,function(){var n,i,a,c;return ia(this,function(f){switch(f.label){case 0:return n=t[0],g=t[1],E=e,A=s,i=(0,Ce.lub)(function(){var Y,ne,Ee,Ge;A.reverseOutputOrder?(ne=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+0],[-1,1])),Y=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+1],[-1,1])),Ge=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+2],[-1,1])),Ee=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+3],[-1,1]))):(Y=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+0],[-1,1])),ne=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+1],[-1,1])),Ee=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+2],[-1,1])),Ge=(0,Ce.L9e)((0,Ce.tPi)(g,[0,A.boxCoordOffset+3],[-1,1]))),ne=(0,Ce.IHx)((0,Ce.dC7)((0,Ce.hiC)(ne,A.xScale),E.w),E.x),Y=(0,Ce.IHx)((0,Ce.dC7)((0,Ce.hiC)(Y,A.yScale),E.h),E.y),A.applyExponentialOnBoxSize?(Ee=(0,Ce.dC7)((0,Ce.Qqt)((0,Ce.hiC)(Ee,A.hScale)),E.h),Ge=(0,Ce.dC7)((0,Ce.Qqt)((0,Ce.hiC)(Ge,A.wScale)),E.w)):(Ee=(0,Ce.dC7)((0,Ce.hiC)(Ee,A.hScale),E.h),Ge=(0,Ce.dC7)((0,Ce.hiC)(Ge,A.wScale),E.h));var tt=(0,Ce.luU)(Y,(0,Ce.hiC)(Ee,2)),Nt=(0,Ce.luU)(ne,(0,Ce.hiC)(Ge,2)),kt=(0,Ce.IHx)(Y,(0,Ce.hiC)(Ee,2)),on=(0,Ce.IHx)(ne,(0,Ce.hiC)(Ge,2)),fn=(0,Ce.zoF)([(0,Ce.XLQ)(tt,[A.numBoxes,1]),(0,Ce.XLQ)(Nt,[A.numBoxes,1]),(0,Ce.XLQ)(kt,[A.numBoxes,1]),(0,Ce.XLQ)(on,[A.numBoxes,1])],1);if(A.numKeypoints)for(var Tn=0;Tn<A.numKeypoints;++Tn){var Hn=A.keypointCoordOffset+Tn*A.numValuesPerKeypoint,Wn=void 0,xs=void 0;A.reverseOutputOrder?(Wn=(0,Ce.L9e)((0,Ce.tPi)(g,[0,Hn],[-1,1])),xs=(0,Ce.L9e)((0,Ce.tPi)(g,[0,Hn+1],[-1,1]))):(xs=(0,Ce.L9e)((0,Ce.tPi)(g,[0,Hn],[-1,1])),Wn=(0,Ce.L9e)((0,Ce.tPi)(g,[0,Hn+1],[-1,1])));var fs=(0,Ce.IHx)((0,Ce.dC7)((0,Ce.hiC)(Wn,A.xScale),E.w),E.x),Ks=(0,Ce.IHx)((0,Ce.dC7)((0,Ce.hiC)(xs,A.yScale),E.h),E.y);fn=(0,Ce.zoF)([fn,(0,Ce.XLQ)(fs,[A.numBoxes,1]),(0,Ce.XLQ)(Ks,[A.numBoxes,1])],1)}return fn}),a=(0,Ce.lub)(function(){var g=n;return s.sigmoidScore?(null!=s.scoreClippingThresh&&(g=(0,Ce.iUl)(n,-s.scoreClippingThresh,s.scoreClippingThresh)),g=(0,Ce.XD2)(g)):g}),[4,Gce(i,a,s)];case 1:return c=f.sent(),(0,Ce.B90)([i,a]),[2,c]}var g,E,A})})}function Gce(t,e,s){return ra(this,void 0,void 0,function(){var n,r,i,a,c,f,g,E,A,Y,ne;return ia(this,function(Ge){switch(Ge.label){case 0:return n=[],[4,t.data()];case 1:return r=Ge.sent(),[4,e.data()];case 2:for(i=Ge.sent(),a=0;a<s.numBoxes;++a)if(!(null!=s.minScoreThresh&&i[a]<s.minScoreThresh||(c=a*s.numCoords,f=Kce(r[c+0],r[c+1],r[c+2],r[c+3],i[a],s.flipVertically,a),(g=f.locationData.relativeBoundingBox).width<0||g.height<0))){if(s.numKeypoints>0)for((E=f.locationData).relativeKeypoints=[],A=s.numKeypoints*s.numValuesPerKeypoint,Y=0;Y<A;Y+=s.numValuesPerKeypoint)E.relativeKeypoints.push({x:r[(ne=c+s.keypointCoordOffset+Y)+0],y:s.flipVertically?1-r[ne+1]:r[ne+1]});n.push(f)}return[2,n]}})})}function Kce(t,e,s,n,r,i,a){return{score:[r],ind:a,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-s:t,xMax:n,yMax:i?1-t:s,width:n-e,height:s-t}}}}function Xce(t,e){return"none"===t?e:1/(1+Math.exp(-e))}function rz(t,e,s,n){return ra(this,void 0,void 0,function(){var i,a,c,f,g,E,A;return ia(this,function(Y){switch(Y.label){case 0:return s=s||e.flipHorizontally||!1,n=n||e.flipVertically||!1,i=t.size/e.numLandmarks,[4,t.data()];case 1:for(a=Y.sent(),c=[],f=0;f<e.numLandmarks;++f)g=f*i,(A={x:0,y:0}).x=s?e.inputImageWidth-a[g]:a[g],i>1&&(A.y=n?e.inputImageHeight-a[g+1]:a[g+1]),i>2&&(A.z=a[g+2]),i>3&&(A.score=Xce(e.visibilityActivation,a[g+3])),c.push(A);for(E=0;E<c.length;++E)(A=c[E]).x=A.x/e.inputImageWidth,A.y=A.y/e.inputImageHeight,A.z=A.z/e.inputImageWidth/(e.normalizeZ||1);return[2,c]}})})}function iz(t,e,s){var E,A,n=t.width,r=t.height,i=t.rotation;if(null==s.rotation&&null==s.rotationDegree||(E=i,null!=(A=s).rotation?E+=A.rotation:null!=A.rotationDegree&&(E+=Math.PI*A.rotationDegree/180),i=XU(E)),0===i)t.xCenter=t.xCenter+n*s.shiftX,t.yCenter=t.yCenter+r*s.shiftY;else{var a=(e.width*n*s.shiftX*Math.cos(i)-e.height*r*s.shiftY*Math.sin(i))/e.width,c=(e.width*n*s.shiftX*Math.sin(i)+e.height*r*s.shiftY*Math.cos(i))/e.height;t.xCenter=t.xCenter+a,t.yCenter=t.yCenter+c}if(s.squareLong){var f=Math.max(n*e.width,r*e.height);n=f/e.width,r=f/e.height}else if(s.squareShort){var g=Math.min(n*e.width,r*e.height);n=g/e.width,r=g/e.height}return t.width=n*s.scaleX,t.height=r*s.scaleY,t}var __=function(){function t(e){this.alpha=e,this.initialized=!1}return t.prototype.apply=function(e,s){var n;return this.initialized?n=null==s?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*s*Math.asinh((e-this.storedValue)/s):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},t.prototype.applyWithAlpha=function(e,s,n){return this.alpha=s,this.apply(e,n)},t.prototype.hasLastRawValue=function(){return this.initialized},t.prototype.lastRawValue=function(){return this.rawValue},t.prototype.reset=function(){this.initialized=!1},t}(),fN=function(){function t(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new __(this.getAlpha(this.minCutOff)),this.dx=new __(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return t.prototype.apply=function(e,s,n){if(null==e)return e;var r=Math.trunc(s);if(this.lastTimestamp>=r)return e;0!==this.lastTimestamp&&0!==r&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,a=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),c=this.minCutOff+this.beta*Math.abs(a),f=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(a):null;return this.x.applyWithAlpha(e,this.getAlpha(c),f)},t.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},t}(),mN=function(){function t(e){this.config=e}return t.prototype.apply=function(e,s,n){var r=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return y0([],e,!0);i=1/n}return e.map(function(a,c){var f=Ul(Ul({},a),{x:r.xFilters[c].apply(a.x,s,i),y:r.yFilters[c].apply(a.y,s,i)});return null!=a.z&&(f.z=r.zFilters[c].apply(a.z,s,i)),f})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var s=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(n){return new fN(s.config)}),this.yFilters=e.map(function(n){return new fN(s.config)}),this.zFilters=e.map(function(n){return new fN(s.config)}))},t}(),gN=function(){function t(e){this.config=e,this.window=[],this.lowPassFilter=new __(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return t.prototype.apply=function(e,s,n){if(null==e)return e;var r,i=Math.trunc(s);if(this.lastTimestamp>=i)return e;if(-1===this.lastTimestamp)r=1;else{for(var a=e*n-this.lastValue*this.lastValueScale,c=i-this.lastTimestamp,f=a,g=c,E=(1+this.window.length)*(1e6/30),A=0,Y=this.window;A<Y.length;A++){var ne=Y[A];if(g+ne.duration>E)break;f+=ne.distance,g+=ne.duration}r=1-1/(1+this.config.velocityScale*Math.abs(f/(1e-6*g))),this.window.unshift({distance:a,duration:c}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,r)},t}(),Yce=function(){function t(e){this.config=e}return t.prototype.apply=function(e,s,n){var r=this;if(null==e)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return y0([],e,!0);i=1/n}return this.initializeFiltersIfEmpty(e),e.map(function(a,c){var f=Ul(Ul({},a),{x:r.xFilters[c].apply(a.x,s,i),y:r.yFilters[c].apply(a.y,s,i)});return null!=a.z&&(f.z=r.zFilters[c].apply(a.z,s,i)),f})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var s=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(n){return new gN(s.config)}),this.yFilters=e.map(function(n){return new gN(s.config)}),this.zFilters=e.map(function(n){return new gN(s.config)}))},t}(),_N=function(){function t(e){if(null!=e.velocityFilter)this.keypointsFilter=new Yce(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new mN(e.oneEuroFilter)}}return t.prototype.apply=function(e,s,n,r,i){if(void 0===r&&(r=!1),null==e)return this.keypointsFilter.reset(),null;var g,E,a=null!=i?((g=i).width*(E=n).width+g.height*E.height)/2:1,c=r?nz(e,n):e,f=this.keypointsFilter.apply(c,s,a);return r?function oz(t,e){return t.map(function(s){var n=Ul(Ul({},s),{x:s.x/e.width,y:s.y/e.height});return null!=s.z&&(s.z=s.z/e.width),n})}(f,n):f},t}(),az=function(){function t(e){this.alpha=e.alpha}return t.prototype.apply=function(e){var s=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(c){return new __(s.alpha)}));for(var n=[],r=0;r<e.length;++r){var i=e[r],a=Ul({},i);a.score=this.visibilityFilters[r].apply(i.score),n.push(a)}return n},t}(),Zce={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},zb={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Qce={maxPoses:1,flipHorizontal:!1},Jce={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},lz={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},eue={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},tue={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},nue={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},sue={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},rue={kernelSize:7,minConfidenceToRefine:.5},cz={alpha:.1},iue={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},oue={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},aue={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},lue={activation:"none"},cue={combineWithPreviousRatio:.7},uue=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return ra(this,void 0,void 0,function(){return ia(this,function(e){return[2,jU(this.mask)]})})},t.prototype.toImageData=function(){return ra(this,void 0,void 0,function(){return ia(this,function(e){return[2,GU(this.mask)]})})},t.prototype.toTensor=function(){return ra(this,void 0,void 0,function(){return ia(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function due(t){return KU(t),"person"}var hue=function(){function t(e,s,n,r,i,a){this.detectorModel=e,this.landmarkModel=s,this.enableSmoothing=n,this.enableSegmentation=r,this.smoothSegmentation=i,this.modelType=a,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(A){null==A.reduceBoxesInLowestLayer&&(A.reduceBoxesInLowestLayer=!1),null==A.interpolatedScaleAspectRatio&&(A.interpolatedScaleAspectRatio=1),null==A.fixedAnchorSize&&(A.fixedAnchorSize=!1);for(var Y=[],ne=0;ne<A.numLayers;){for(var Ee=[],Ge=[],tt=[],Nt=[],kt=ne;kt<A.strides.length&&A.strides[kt]===A.strides[ne];){var on=qU(A.minScale,A.maxScale,kt,A.strides.length);if(0===kt&&A.reduceBoxesInLowestLayer)tt.push(1),tt.push(2),tt.push(.5),Nt.push(.1),Nt.push(on),Nt.push(on);else{for(var fn=0;fn<A.aspectRatios.length;++fn)tt.push(A.aspectRatios[fn]),Nt.push(on);if(A.interpolatedScaleAspectRatio>0){var Tn=kt===A.strides.length-1?1:qU(A.minScale,A.maxScale,kt+1,A.strides.length);Nt.push(Math.sqrt(on*Tn)),tt.push(A.interpolatedScaleAspectRatio)}}kt++}for(var Hn=0;Hn<tt.length;++Hn){var Wn=Math.sqrt(tt[Hn]);Ee.push(Nt[Hn]/Wn),Ge.push(Nt[Hn]*Wn)}var xs=0,fs=0;if(A.featureMapHeight.length>0)xs=A.featureMapHeight[ne],fs=A.featureMapWidth[ne];else{var Ks=A.strides[ne];xs=Math.ceil(A.inputSizeHeight/Ks),fs=Math.ceil(A.inputSizeWidth/Ks)}for(var Hr=0;Hr<xs;++Hr)for(var xi=0;xi<fs;++xi)for(var jr=0;jr<Ee.length;++jr){var Co={xCenter:(xi+A.anchorOffsetX)/fs,yCenter:(Hr+A.anchorOffsetY)/xs,width:0,height:0};A.fixedAnchorSize?(Co.width=1,Co.height=1):(Co.width=Ge[jr],Co.height=Ee[jr]),Y.push(Co)}ne=kt}return Y}(Zce);var c=(0,Ce.RRF)(this.anchors.map(function(A){return A.width})),f=(0,Ce.RRF)(this.anchors.map(function(A){return A.height})),g=(0,Ce.RRF)(this.anchors.map(function(A){return A.xCenter})),E=(0,Ce.RRF)(this.anchors.map(function(A){return A.yCenter}));this.anchorTensor={x:g,y:E,w:c,h:f},this.prevFilteredSegmentationMask=this.enableSegmentation?(0,Ce.odF)([],[0,0]):null}return t.prototype.estimatePoses=function(e,s,n){return ra(this,void 0,void 0,function(){var r,i,a,c,f,E,ne,Ge,tt,Nt,on,fn,Tn,Hn,Wn,xs,fs,Ks;return ia(this,function(Hr){switch(Hr.label){case 0:return r=function(xi){var jr;if(null==(jr=null==xi?Qce:Ul({},xi)).maxPoses&&(jr.maxPoses=1),jr.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(jr.maxPoses,". Should be > 0."));if(jr.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return jr}(s),null==e?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=null!=n?1e3*n:ez(e)?1e6*e.currentTime:null,i=Ub(e),a=(0,Ce.lub)(function(){return(0,Ce.pju)(cN(e),"float32")}),null!=(c=this.regionOfInterest)?[3,2]:[4,this.detectPose(a)]);case 1:if(0===(f=Hr.sent()).length)return this.reset(),a.dispose(),[2,[]];c=this.poseDetectionToRoi(f[0],i),Hr.label=2;case 2:return[4,this.poseLandmarksByRoi(c,a)];case 3:return E=Hr.sent(),a.dispose(),null==E?(this.reset(),[2,[]]):(ne=E.poseScore,Ge=E.segmentationMask,tt=this.poseLandmarkFiltering(E.landmarks,E.auxiliaryLandmarks,E.worldLandmarks,i),Nt=tt.actualLandmarksFiltered,on=tt.actualWorldLandmarksFiltered,fn=this.poseLandmarksToRoi(tt.auxiliaryLandmarksFiltered,i),this.regionOfInterest=fn,Tn=this.smoothSegmentation&&null!=Ge?this.poseSegmentationFiltering(Ge):Ge,null!=(Hn=null!=Nt?nz(Nt,i):null)&&Hn.forEach(function(xi,jr){xi.name=LC[jr]}),null!=(Wn=on)&&Wn.forEach(function(xi,jr){xi.name=LC[jr]}),xs={score:ne,keypoints:Hn,keypoints3D:Wn},null!==Tn&&(fs=(0,Ce.lub)(function(){var xi=(0,Ce.dt4)(Tn,2),jr=(0,Ce.vku)(xi,[[0,0],[0,0],[0,1]]);return(0,Ce.VdP)(jr,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||(0,Ce.B90)(Tn),Ks={maskValueToLabel:due,mask:new uue(fs)},xs.segmentation=Ks),[2,[xs]])}})})},t.prototype.poseSegmentationFiltering=function(e){var s=this.prevFilteredSegmentationMask;return 0===s.size?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=function Hce(t,e,s){return"webgl"===(0,Ce.N_N)()?(n=t,r=e,a=s.combineWithPreviousRatio.toFixed(2),c={variableNames:["prevMask","newMask"],outputShape:n.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(a,");\n\n      setOutput(outputValue);\n    }\n")},f=(0,Ce.y3$)(),(0,Ce.lub)(function(){var g=f.compileAndRun(c,[n,r]);return(0,Ce.SRH)().makeTensorFromDataId(g.dataId,g.shape,g.dtype)})):(0,Ce.lub)(function(){var n=(0,Ce.luU)(e,.5),r=(0,Ce.h62)(n),i=(0,Ce.luU)(1,(0,Ce.LTh)(1,(0,Ce.dC7)(r,(0,Ce.IHx)(5.68842,(0,Ce.dC7)(r,(0,Ce.IHx)(-.748699,(0,Ce.dC7)(r,(0,Ce.IHx)(-57.8051,(0,Ce.dC7)(r,(0,Ce.IHx)(291.309,(0,Ce.dC7)(r,-624.717)))))))))));return(0,Ce.IHx)(e,(0,Ce.dC7)((0,Ce.luU)(t,e),(0,Ce.dC7)(i,s.combineWithPreviousRatio)))});var n,r,a,c,f}(s,e,cue),(0,Ce.B90)(e)),(0,Ce.B90)(s),this.prevFilteredSegmentationMask},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),(0,Ce.B90)([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},t.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&((0,Ce.B90)(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=(0,Ce.odF)([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},t.prototype.detectPose=function(e){return ra(this,void 0,void 0,function(){var s,n,r,i,a,c,f,g,E,A;return ia(this,function(Y){switch(Y.label){case 0:return s=pN(e,eue),r=s.padding,i=this.detectorModel.predict(n=s.imageTensor),a=function Uce(t){return(0,Ce.lub)(function(){var r,e=(r=t,(0,Ce.lub)(function(){return[(0,Ce.tPi)(r,[0,0,0],[1,-1,1]),(0,Ce.tPi)(r,[0,0,1],[1,-1,-1])]})),s=e[0];return{boxes:(0,Ce.L9e)(e[1]),logits:(0,Ce.L9e)(s)}})}(i),[4,jce([f=a.logits,c=a.boxes],this.anchorTensor,Jce)];case 1:return 0===(g=Y.sent()).length?((0,Ce.B90)([n,i,f,c]),[2,g]):[4,zce(g,this.maxPoses,.3)];case 2:return E=Y.sent(),A=function(ne,Ee){void 0===ne&&(ne=[]);for(var Ge=Ee.left,tt=Ee.top,Nt=Ee.left+Ee.right,kt=Ee.top+Ee.bottom,on=0;on<ne.length;on++){var fn=ne[on],Tn=fn.locationData.relativeBoundingBox,Hn=(Tn.xMin-Ge)/(1-Nt),Wn=(Tn.yMin-tt)/(1-kt),xs=Tn.width/(1-Nt),fs=Tn.height/(1-kt);Tn.xMin=Hn,Tn.yMin=Wn,Tn.width=xs,Tn.height=fs,Tn.xMax=Hn+xs,Tn.yMax=Wn+fs;var Ks=fn.locationData.relativeKeypoints;Ks&&Ks.forEach(function(Hr){var jr=(Hr.y-tt)/(1-kt);Hr.x=(Hr.x-Ge)/(1-Nt),Hr.y=jr})}return ne}(E,r),(0,Ce.B90)([n,i,f,c]),[2,A]}})})},t.prototype.poseDetectionToRoi=function(e,s){return iz(dN(e,s,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),s,lz)},t.prototype.poseLandmarksByRoi=function(e,s){return ra(this,void 0,void 0,function(){var n,r,i,a,c,f,g,E,ne,tt;return ia(this,function(Nt){switch(Nt.label){case 0:if(n=Ub(s),r=pN(s,tue,e),i=r.imageTensor,a=r.padding,c=r.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return f=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&f.push("activation_segmentation"),g=this.landmarkModel.execute(i,f),[4,this.tensorsToPoseLandmarksAndSegmentation(g)];case 1:return null==(E=Nt.sent())?((0,Ce.B90)(g),(0,Ce.B90)(i),[2,null]):(ne=E.poseScore,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,a,c,E.landmarks,E.auxiliaryLandmarks,E.worldLandmarks,E.segmentationMask)]);case 2:return tt=Nt.sent(),(0,Ce.B90)(g),(0,Ce.B90)(i),[2,Ul({poseScore:ne},tt)]}})})},t.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,s,n,r,i,a,c,f){return ra(this,void 0,void 0,function(){var g,E,A,Y,ne,Ee;return ia(this,function(Ge){return g=sz(i,n),E=sz(a,n),A=QU(g,s),Y=QU(E,s),ne=function(tt,Nt){for(var kt=[],on=0,fn=tt;on<fn.length;on++){var Tn=fn[on],Hn=Tn.x,Wn=Tn.y,xs=Nt.rotation,fs=Math.cos(xs)*Hn-Math.sin(xs)*Wn,Ks=Math.sin(xs)*Hn+Math.cos(xs)*Wn,Hr=Ul({},Tn);Hr.x=fs,Hr.y=Ks,kt.push(Hr)}return kt}(c,s),Ee=null,this.enableSegmentation&&(Ee=(0,Ce.lub)(function(){var tt=f.shape,Nt=tt[0],kt=tt[1],on=function(Hn){var Wn=ZU(new Array(16).fill(0));Wn[0][0]=_d(Hn,0,0),Wn[1][0]=-_d(Hn,0,1),Wn[2][0]=_d(Hn,0,2),Wn[3][0]=-_d(Hn,0,3),Wn[0][2]=_d(Hn,2,0),Wn[1][2]=-_d(Hn,2,1),Wn[2][2]=_d(Hn,2,2),Wn[3][2]=-_d(Hn,2,3),Wn[0][1]=-_d(Hn,1,0),Wn[1][1]=_d(Hn,1,1),Wn[2][1]=-_d(Hn,1,2),Wn[3][1]=_d(Hn,1,3),Wn[0][3]=-_d(Hn,3,0),Wn[1][3]=_d(Hn,3,1),Wn[2][3]=-_d(Hn,3,2),Wn[3][3]=_d(Hn,3,3);for(var xs=Hn[0][0]*Wn[0][0]+Hn[1][0]*Wn[0][1]+Hn[2][0]*Wn[0][2]+Hn[3][0]*Wn[0][3],fs=0;fs<Wn.length;fs++)for(var Ks=0;Ks<Wn.length;Ks++)Wn[fs][Ks]/=xs;return Wn}(r),fn=(0,Ce.odF)(YU(on,{width:kt,height:Nt},e),[1,8]);return(0,Ce.L9e)(Ce.image.transform((0,Ce.XLQ)(f,[1,Nt,kt,1]),fn,"bilinear","constant",0,[e.height,e.width]),[0,3])}),(0,Ce.B90)(f)),[2,{landmarks:A,auxiliaryLandmarks:Y,worldLandmarks:ne,segmentationMask:Ee}]})})},t.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return ra(this,void 0,void 0,function(){var s,r,i,a,c,f,g,E,A,Y,ne,Ee;return ia(this,function(Ge){switch(Ge.label){case 0:return s=e[0],r=e[2],i=e[3],a=this.enableSegmentation?e[4]:null,[4,e[1].data()];case 1:return(c=Ge.sent()[0])<.5?[2,null]:[4,rz(s,nue)];case 2:return[4,Wce(Ge.sent(),r,rue)];case 3:return f=Ge.sent(),g=f.slice(0,33),E=f.slice(33,35),[4,rz(i,sue)];case 4:return A=Ge.sent(),Y=A.slice(0,33),ne=function(tt,Nt,kt){void 0===kt&&(kt=!0);for(var on=[],fn=0;fn<tt.length;fn++){var Tn=Ul({},Nt[fn]);kt&&(Tn.score=tt[fn].score),on.push(Tn)}return on}(g,Y,!0),Ee=this.enableSegmentation?(tt=a,Nt=lue,(0,Ce.lub)(function(){var on=(0,Ce.L9e)(tt,[0]),fn=on.shape[2];if(1===fn){var Tn=on;switch(Nt.activation){case"none":break;case"sigmoid":Tn=(0,Ce.XD2)(Tn);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(Nt.activation,")"))}return(0,Ce.L9e)(Tn,[2])}throw new Error("Unsupported number of tensor channels ".concat(fn))})):null,[2,{landmarks:g,auxiliaryLandmarks:E,poseScore:c,worldLandmarks:ne,segmentationMask:Ee}]}var tt,Nt})})},t.prototype.poseLandmarksToRoi=function(e,s){return iz(dN(tz(e),s,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),s,lz)},t.prototype.poseLandmarkFiltering=function(e,s,n,r){var i,a,c;if(null!=this.timestamp&&this.enableSmoothing){var f=dN(tz(s),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new az(cz)),i=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new az(cz)),a=this.visibilitySmoothingFilterAuxiliary.apply(s),c=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new _N(iue)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,r,!0,f),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new _N(oue)),a=this.landmarksSmoothingFilterAuxiliary.apply(a,this.timestamp,r,!0,f),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new _N(aue)),c=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else i=e,a=s,c=n;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:a,actualWorldLandmarksFiltered:c}},t}();function pue(t){return ra(this,void 0,void 0,function(){var e,s,n,r;return ia(this,function(c){switch(c.label){case 0:return e=function(f){var g=Ul({},f??zb);if(null==g.enableSmoothing&&(g.enableSmoothing=zb.enableSmoothing),null==g.enableSegmentation&&(g.enableSegmentation=zb.enableSegmentation),null==g.smoothSegmentation&&(g.smoothSegmentation=zb.smoothSegmentation),null==g.modelType&&(g.modelType=zb.modelType),null==g.detectorModelUrl&&(g.detectorModelUrl=zb.detectorModelUrl),null==g.landmarkModelUrl)switch(g.modelType){case"lite":g.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":g.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;default:g.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return g}(t),s="string"==typeof e.detectorModelUrl&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,n="string"==typeof e.landmarkModelUrl&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([(0,Fb.YL)(e.detectorModelUrl,{fromTFHub:s}),(0,Fb.YL)(e.landmarkModelUrl,{fromTFHub:n})])];case 1:return r=c.sent(),[2,new hue(r[0],r[1],e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var v0,yd,t,uz=function(){function t(e){(function(s){if(s.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(s.maxTracks));if(s.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(s.maxAge));if(void 0!==s.keypointTrackerParams){if(s.keypointTrackerParams.keypointConfidenceThreshold<0||s.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(s.keypointTrackerParams.keypointConfidenceThreshold));if(s.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(s.keypointTrackerParams.minNumberOfKeypoints));for(var n=0,r=s.keypointTrackerParams.keypointFalloff;n<r.length;n++){var i=r[n];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return t.prototype.apply=function(e,s){this.filterOldTracks(s);var n=this.computeSimilarity(e);return this.assignTracks(e,n,s),this.updateTracks(s),e},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},t.prototype.filterOldTracks=function(e){var s=this;this.tracks=this.tracks.filter(function(n){return e-n.lastTimestamp<=s.maxAge})},t.prototype.assignTracks=function(e,s,n){for(var r=Array.from(Array(s[0].length).keys()),i=[],a=0,c=Array.from(Array(e.length).keys());a<c.length;a++){var f=c[a];if(0!==r.length){for(var g=-1,E=-1,A=0,Y=r;A<Y.length;A++){var ne=Y[A],Ee=s[f][ne];Ee>=this.minSimilarity&&Ee>E&&(g=ne,E=Ee)}if(g>=0){var Ge=this.tracks[g];Ge=Object.assign(Ge,this.createTrack(e[f],n,Ge.id)),e[f].id=Ge.id;var tt=r.indexOf(g);r.splice(tt,1)}else i.push(f)}else i.push(f)}for(var Nt=0,kt=i;Nt<kt.length;Nt++){var on=this.createTrack(e[f=kt[Nt]],n);this.tracks.push(on),e[f].id=on.id}},t.prototype.updateTracks=function(e){this.tracks.sort(function(s,n){return n.lastTimestamp-s.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(e,s,n){var r={id:n||this.nextTrackID(),lastTimestamp:s,keypoints:y0([],e.keypoints,!0).map(function(i){return Ul({},i)})};return void 0!==e.box&&(r.box=Ul({},e.box)),r},t.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},t.prototype.remove=function(){for(var e=[],s=0;s<arguments.length;s++)e[s]=arguments[s];this.tracks=this.tracks.filter(function(n){return!e.includes(n.id)})},t.prototype.reset=function(){this.tracks=[]},t}(),fue=function(t){function e(s){return t.call(this,s)||this}return HU(e,t),e.prototype.computeSimilarity=function(s){var n=this;return 0===s.length||0===this.tracks.length?[[]]:s.map(function(r){return n.tracks.map(function(i){return n.iou(r,i)})})},e.prototype.iou=function(s,n){var r=Math.max(s.box.xMin,n.box.xMin),i=Math.max(s.box.yMin,n.box.yMin),a=Math.min(s.box.xMax,n.box.xMax),c=Math.min(s.box.yMax,n.box.yMax);if(r>=a||i>=c)return 0;var f=(a-r)*(c-i);return f/(s.box.width*s.box.height+n.box.width*n.box.height-f)},e}(uz),mue=function(t){function e(s){var n=t.call(this,s)||this;return n.keypointThreshold=s.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=s.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=s.keypointTrackerParams.minNumberOfKeypoints,n}return HU(e,t),e.prototype.computeSimilarity=function(s){if(0===s.length||0===this.tracks.length)return[[]];for(var n=[],r=0,i=s;r<i.length;r++){for(var a=i[r],c=[],f=0,g=this.tracks;f<g.length;f++)c.push(this.oks(a,g[f]));n.push(c)}return n},e.prototype.oks=function(s,n){for(var r=this.area(n.keypoints)+1e-6,i=0,a=0,c=0;c<s.keypoints.length;++c){var f=s.keypoints[c],g=n.keypoints[c];if(!(f.score<this.keypointThreshold||g.score<this.keypointThreshold)){a+=1;var E=Math.pow(f.x-g.x,2)+Math.pow(f.y-g.y,2);i+=Math.exp(-1*E/(2*r*Math.pow(2*this.keypointFalloff[c],2)))}}return a<this.minNumKeyoints?0:i/a},e.prototype.area=function(s){var n=this,r=s.filter(function(f){return f.score>n.keypointThreshold}),i=Math.min.apply(Math,y0([1],r.map(function(f){return f.x}),!1)),a=Math.max.apply(Math,y0([0],r.map(function(f){return f.x}),!1)),c=Math.min.apply(Math,y0([1],r.map(function(f){return f.y}),!1));return(a-i)*(Math.max.apply(Math,y0([0],r.map(function(f){return f.y}),!1))-c)},e}(uz);function dz(t){switch(t){case yd.BlazePose:return LC.reduce(function(e,s,n){return e[s]=n,e},{});case yd.PoseNet:case yd.MoveNet:return Lf.reduce(function(e,s,n){return e[s]=n,e},{});default:throw new Error("Model ".concat(t," is not supported."))}}(t=v0||(v0={})).Keypoint="keypoint",t.BoundingBox="boundingBox",function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(yd||(yd={})),Object.freeze({__proto__:null,getKeypointIndexBySide:function(t){switch(t){case yd.BlazePose:return Rce;case yd.PoseNet:case yd.MoveNet:return Nce;default:throw new Error("Model ".concat(t," is not supported."))}},getAdjacentPairs:function(t){switch(t){case yd.BlazePose:return Pce;case yd.PoseNet:case yd.MoveNet:return Mce;default:throw new Error("Model ".concat(t," is not supported."))}},getKeypointIndexByName:dz});var hz=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],pz={modelType:"SinglePose.Lightning",enableSmoothing:!0},fz={},mz={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},yN={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},gz={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function vN(t,e){var s,n,r,i;return t?e.width>e.height?(s=1,n=e.height/e.width,r=0,i=(e.width/2-e.height/2)/e.width):(s=e.width/e.height,n=1,r=(e.height/2-e.width/2)/e.height,i=0):e.width>e.height?(s=e.width/e.height,n=1,r=(e.height/2-e.width/2)/e.height,i=0):(s=1,n=e.height/e.width,r=0,i=(e.width/2-e.height/2)/e.width),{yMin:r,xMin:i,yMax:r+s,xMax:i+n,height:s,width:n}}function _z(t,e){var s={maxTracks:t.maxTracks,maxAge:t.maxAge,minSimilarity:t.minSimilarity};return null!=e.maxTracks&&(s.maxTracks=e.maxTracks),null!=e.maxAge&&(s.maxAge=e.maxAge),null!=e.minSimilarity&&(s.minSimilarity=e.minSimilarity),s}var yue=function(){function t(e,s){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=dz(yd.MoveNet),"SinglePose.Lightning"===s.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===s.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===s.modelType,this.multiPoseModel||(this.keypointFilter=new mN(mz),this.cropRegionFilterYMin=new __(.9),this.cropRegionFilterXMin=new __(.9),this.cropRegionFilterYMax=new __(.9),this.cropRegionFilterXMax=new __(.9)),this.enableSmoothing=s.enableSmoothing,this.minPoseScore=s.minPoseScore?s.minPoseScore:.25,this.multiPoseMaxDimension=s.multiPoseMaxDimension?s.multiPoseMaxDimension:256,this.enableTracking=s.enableTracking,this.multiPoseModel&&this.enableTracking&&(s.trackerType===v0.Keypoint?this.tracker=new mue(s.trackerConfig):s.trackerType===v0.BoundingBox&&(this.tracker=new fue(s.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return t.prototype.runSinglePersonPoseModel=function(e){return ra(this,void 0,void 0,function(){var s,n,r,i,a;return ia(this,function(c){switch(c.label){case 0:if(4!==(s=this.moveNetModel.execute(e)).shape.length||1!==s.shape[0]||1!==s.shape[1]||17!==s.shape[2]||3!==s.shape[3])throw s.dispose(),new Error("Unexpected output shape from model: [".concat(s.shape,"]"));return"webgpu"===(0,Ce.N_N)()?[3,1]:(n=s.dataSync(),[3,3]);case 1:return[4,s.data()];case 2:n=c.sent(),c.label=3;case 3:for(s.dispose(),r={keypoints:[],score:0},i=0,a=0;a<17;++a)r.keypoints[a]={y:n[3*a],x:n[3*a+1],score:n[3*a+2]},r.keypoints[a].score>.2&&(++i,r.score+=r.keypoints[a].score);return i>0&&(r.score/=i),[2,r]}})})},t.prototype.runMultiPersonPoseModel=function(e){return ra(this,void 0,void 0,function(){var s,n,r,i,a,c,g;return ia(this,function(E){switch(E.label){case 0:if(3!==(s=this.moveNetModel.execute(e)).shape.length||1!==s.shape[0]||56!==s.shape[2])throw s.dispose(),new Error("Unexpected output shape from model: [".concat(s.shape,"]"));return"webgpu"===(0,Ce.N_N)()?[3,1]:(n=s.dataSync(),[3,3]);case 1:return[4,s.data()];case 2:n=E.sent(),E.label=3;case 3:for(s.dispose(),r=[],i=n.length/56,a=0;a<i;++a)for(r[a]={keypoints:[]},r[a].box={yMin:n[c=56*a+51],xMin:n[c+1],yMax:n[c+2],xMax:n[c+3],width:n[c+3]-n[c+1],height:n[c+2]-n[c]},r[a].score=n[56*a+55],r[a].keypoints=[],g=0;g<17;++g)r[a].keypoints[g]={y:n[56*a+3*g],x:n[56*a+3*g+1],score:n[56*a+3*g+2]};return[2,r]}})})},t.prototype.estimatePoses=function(e,s,n){return void 0===s&&(s=fz),ra(this,void 0,void 0,function(){var r,i,a,c,f,g;return ia(this,function(E){switch(E.label){case 0:return s=null==(A=s)?fz:Ul({},A),null==e?(this.reset(),[2,[]]):(null==n?ez(e)&&(n=1e6*e.currentTime):n*=1e3,r=cN(e),i=Ub(r),a=(0,Ce.dt4)(r,0),e instanceof Ce.esB||r.dispose(),c=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(a,i,n)]);case 1:return c=E.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(a,i,n)];case 3:c=E.sent(),E.label=4;case 4:for(f=0;f<c.length;++f)for(g=0;g<c[f].keypoints.length;++g)c[f].keypoints[g].name=Lf[g],c[f].keypoints[g].y*=i.height,c[f].keypoints[g].x*=i.width;return[2,c]}var A})})},t.prototype.estimateSinglePose=function(e,s,n){return ra(this,void 0,void 0,function(){var r,i,a,c,f=this;return ia(this,function(g){switch(g.label){case 0:return this.cropRegion||(this.cropRegion=vN(null==this.cropRegion,s)),r=(0,Ce.lub)(function(){var E=(0,Ce.odF)([[f.cropRegion.yMin,f.cropRegion.xMin,f.cropRegion.yMax,f.cropRegion.xMax]]),A=(0,Ce.lls)([1],"int32");return(0,Ce.pju)(Ce.image.cropAndResize(e,E,A,[f.modelInputResolution.height,f.modelInputResolution.width],"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(i=g.sent(),r.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(a=0;a<i.keypoints.length;++a)i.keypoints[a].y=this.cropRegion.yMin+i.keypoints[a].y*this.cropRegion.height,i.keypoints[a].x=this.cropRegion.xMin+i.keypoints[a].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,n,1)),c=function gue(t,e,s,n){for(var r={},i=0,a=Lf;i<a.length;i++){var c=a[i];r[c]=[e[s[c]].y*n.height,e[s[c]].x*n.width]}if(((kt=e)[(on=s).left_hip].score>.2||kt[on.right_hip].score>.2)&&(kt[on.left_shoulder].score>.2||kt[on.right_shoulder].score>.2)){var f=(r.left_hip[0]+r.right_hip[0])/2,g=(r.left_hip[1]+r.right_hip[1])/2,E=function(kt,on,fn,Tn,Hn){for(var Wn=["left_shoulder","right_shoulder","left_hip","right_hip"],xs=0,fs=0,Ks=0;Ks<Wn.length;Ks++)(ba=Math.abs(Tn-fn[Wn[Ks]][0]))>xs&&(xs=ba),(ws=Math.abs(Hn-fn[Wn[Ks]][1]))>fs&&(fs=ws);for(var Hr=0,xi=0,jr=0,Co=Object.keys(fn);jr<Co.length;jr++){var ba,ws,Mr=Co[jr];kt[on[Mr]].score<.2||((ba=Math.abs(Tn-fn[Mr][0]))>Hr&&(Hr=ba),(ws=Math.abs(Hn-fn[Mr][1]))>xi&&(xi=ws))}return[xs,fs,Hr,xi]}(e,s,r,f,g),Ge=Math.max(1.9*E[1],1.9*E[0],1.2*E[2],1.2*E[3]),tt=[f-(Ge=Math.min(Ge,Math.max(g,n.width-g,f,n.height-f))),g-Ge];if(Ge>Math.max(n.width,n.height)/2)return vN(null==t,n);var Nt=2*Ge;return{yMin:tt[0]/n.height,xMin:tt[1]/n.width,yMax:(tt[0]+Nt)/n.height,xMax:(tt[1]+Nt)/n.width,height:(tt[0]+Nt)/n.height-tt[0]/n.height,width:(tt[1]+Nt)/n.width-tt[1]/n.width}}var kt,on;return vN(null==t,n)}(this.cropRegion,i.keypoints,this.keypointIndexByName,s),this.cropRegion=this.filterCropRegion(c),[2,[i]]}})})},t.prototype.estimateMultiplePoses=function(e,s,n){return ra(this,void 0,void 0,function(){var r,i,a,c,f,g,E,A,Y,ne,Ee,Ge=this;return ia(this,function(tt){switch(tt.label){case 0:return s.width>s.height?(i=this.multiPoseMaxDimension,a=Math.round(this.multiPoseMaxDimension*s.height/s.width),r=Ce.image.resizeBilinear(e,[a,i]),f=i,g=32*Math.ceil(a/32),c=(0,Ce.vku)(r,[[0,0],[0,g-a],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*s.width/s.height),r=Ce.image.resizeBilinear(e,[a=this.multiPoseMaxDimension,i]),f=32*Math.ceil(i/32),g=a,c=(0,Ce.vku)(r,[[0,0],[0,0],[0,f-i],[0,0]])),r.dispose(),e.dispose(),E=(0,Ce.pju)(c,"int32"),c.dispose(),[4,this.runMultiPersonPoseModel(E)];case 1:for(A=tt.sent(),E.dispose(),A=A.filter(function(Nt){return Nt.score>=Ge.minPoseScore}),ne=0;ne<A.length;++ne)for(Y=0;Y<A[ne].keypoints.length;++Y)A[ne].keypoints[Y].y*=g/a,A[ne].keypoints[Y].x*=f/i;if(this.enableTracking&&(this.tracker.apply(A,n),this.enableSmoothing)){for(ne=0;ne<A.length;++ne)this.keypointFilterMap.has(A[ne].id)||this.keypointFilterMap.set(A[ne].id,new mN(mz)),A[ne].keypoints=this.keypointFilterMap.get(A[ne].id).apply(A[ne].keypoints,n,1);Ee=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(Nt,kt){Ee.has(kt)||Ge.keypointFilterMap.delete(kt)})}return[2,A]}})})},t.prototype.filterCropRegion=function(e){if(e){var s=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:s,xMin:n,yMax:r,xMax:i,height:r-s,width:i-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},t.prototype.dispose=function(){this.moveNetModel.dispose()},t.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},t.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},t}();function vue(t){return void 0===t&&(t=pz),ra(this,void 0,void 0,function(){var e,s,n,r;return ia(this,function(i){switch(i.label){case 0:return e=function _ue(t){var n,r,s=null==t?pz:Ul({},t);if(null==s.modelType)s.modelType="SinglePose.Lightning";else if(hz.indexOf(s.modelType)<0)throw new Error("Invalid architecture ".concat(s.modelType,". ")+"Should be one of ".concat(hz));if(null==s.enableSmoothing&&(s.enableSmoothing=!0),null!=s.minPoseScore&&(s.minPoseScore<0||s.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=s.multiPoseMaxDimension&&(s.multiPoseMaxDimension%32!=0||s.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if("MultiPose.Lightning"===s.modelType&&null==s.enableTracking&&(s.enableTracking=!0),"MultiPose.Lightning"===s.modelType&&!0===s.enableTracking)if(null==s.trackerType&&(s.trackerType=v0.BoundingBox),s.trackerType===v0.Keypoint)s.trackerConfig=null!=s.trackerConfig?((r=_z(yN,n=s.trackerConfig)).keypointTrackerParams=Ul({},yN.keypointTrackerParams),null!=n.keypointTrackerParams&&(null!=n.keypointTrackerParams.keypointConfidenceThreshold&&(r.keypointTrackerParams.keypointConfidenceThreshold=n.keypointTrackerParams.keypointConfidenceThreshold),null!=n.keypointTrackerParams.keypointFalloff&&(r.keypointTrackerParams.keypointFalloff=n.keypointTrackerParams.keypointFalloff),null!=n.keypointTrackerParams.minNumberOfKeypoints&&(r.keypointTrackerParams.minNumberOfKeypoints=n.keypointTrackerParams.minNumberOfKeypoints)),r):yN;else{if(s.trackerType!==v0.BoundingBox)throw new Error("Tracker type not supported by MoveNet");s.trackerConfig=null!=s.trackerConfig?_z(gz,s.trackerConfig):gz}return s}(t),n=!0,e.modelUrl?(n="string"==typeof e.modelUrl&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,(0,Fb.YL)(e.modelUrl,{fromTFHub:n})]):[3,2];case 1:return s=i.sent(),[3,4];case 2:return r=void 0,"SinglePose.Lightning"===e.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===e.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===e.modelType&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,(0,Fb.YL)(r,{fromTFHub:n})];case 3:s=i.sent(),i.label=4;case 4:return"webgl"===(0,Ce.N_N)()&&(0,Ce.OBj)().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new yue(s,e)]}})})}var yz={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},vz=["MobileNetV1","ResNet50"],bz={MobileNetV1:[8,16],ResNet50:[16]},bue=[8,16,32],xz={MobileNetV1:[.5,.75,1],ResNet50:[1]},wz=[1,2,4],Cz={maxPoses:1,flipHorizontal:!1},xue={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},wue=[-123.15,-115.9,-103.06];function bN(t){return Math.floor(t/2)}var Cue=function(){function t(e,s){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=s}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return-1===this.numberOfElements},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(bN(e),e);)this.exchange(e,bN(e)),e=bN(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var s=2*e;if(s<this.numberOfElements&&this.less(s,s+1)&&s++,!this.less(e,s))break;this.exchange(e,s),e=s}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,s){return this.getValueAt(e)<this.getValueAt(s)},t.prototype.exchange=function(e,s){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[s],this.priorityQueue[s]=n},t}();function Eue(t,e,s,n,r,i){for(var a=i.shape,c=a[0],f=a[1],g=!0,E=Math.max(s-r,0),A=Math.min(s+r+1,c),Y=E;Y<A;++Y){for(var ne=Math.max(n-r,0),Ee=Math.min(n+r+1,f),Ge=ne;Ge<Ee;++Ge)if(i.get(Y,Ge,t)>e){g=!1;break}if(!g)break}return g}function Due(t){return ra(this,void 0,void 0,function(){return ia(this,function(e){return[2,Promise.all(t.map(function(s){return s.buffer()}))]})})}function Ez(t,e,s,n){return{y:n.get(t,e,s),x:n.get(t,e,s+17)}}function Dz(t,e,s){var n=Ez(t.heatmapY,t.heatmapX,t.id,s);return{x:t.heatmapX*e+n.x,y:t.heatmapY*e+n.y}}function Sz(t,e,s,n){var r=s.x,i=s.y;return t.some(function(a){var A,Y,ne=a.keypoints;return(A=ne[n].y-i)*A+(Y=ne[n].x-r)*Y<=e})}var Iz=Lf.reduce(function(t,e,s){return t[e]=s,t},{}),Tz=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(t){return[Iz[t[0]],Iz[t[1]]]}),xN=Tz.map(function(t){return t[1]}),Az=Tz.map(function(t){return t[0]});function kz(t,e,s){return t<e?e:t>s?s:t}function wN(t,e,s,n){return{y:kz(Math.round(t.y/e),0,s-1),x:kz(Math.round(t.x/e),0,n-1)}}function Oz(t,e){return{x:t.x+e.x,y:t.y+e.y}}function Rz(t,e,s,n,r,i,a,c){void 0===c&&(c=2);for(var f=n.shape,g=f[0],E=f[1],A={y:e.y,x:e.x},Y=Oz(A,(kt=t,on=wN(A,i,g,E),void 0,Tn=(fn=a).shape[2]/2,{y:fn.get(on.y,on.x,kt),x:fn.get(on.y,on.x,Tn+kt)})),ne=0;ne<c;ne++){var Ee=wN(Y,i,g,E),Ge=Ez(Ee.y,Ee.x,s,r);Y=Oz({x:Ee.x*i,y:Ee.y*i},{x:Ge.x,y:Ge.y})}var kt,on,fn,Tn,tt=wN(Y,i,g,E),Nt=n.get(tt.y,tt.x,s);return{y:Y.y,x:Y.x,name:Lf[s],score:Nt}}function Sue(t,e,s,n,r,i){var c=xN.length,f=new Array(e.shape[2]),g=t.part,E=t.score,A=Dz(g,n,s);f[g.id]={score:E,name:Lf[g.id],y:A.y,x:A.x};for(var Y=c-1;Y>=0;--Y){var ne=xN[Y],Ee=Az[Y];f[ne]&&!f[Ee]&&(f[Ee]=Rz(Y,f[ne],Ee,e,s,n,i))}for(Y=0;Y<c;++Y)Ee=xN[Y],f[ne=Az[Y]]&&!f[Ee]&&(f[Ee]=Rz(Y,f[ne],Ee,e,s,n,r));return f}function Iue(t,e,s){return s.reduce(function(n,r,i){var f=r.score;return Sz(t,e,{y:r.y,x:r.x},i)||(n+=f),n},0)/s.length}function Tue(t,e,s,n,r,i,a,c){return void 0===a&&(a=.5),void 0===c&&(c=20),ra(this,void 0,void 0,function(){var f,g,E,A,Y,ne,Ee,Ge,tt,Nt,kt,on;return ia(this,function(fn){switch(fn.label){case 0:return[4,Due([t,e,s,n])];case 1:for(f=fn.sent(),E=f[1],A=f[2],Y=f[3],ne=[],Ee=function(Tn,Hn,Wn){for(var xs=Wn.shape,fs=xs[0],Ks=xs[1],Hr=xs[2],xi=new Cue(fs*Ks*Hr,function(Mr){return Mr.score}),jr=0;jr<fs;++jr)for(var Co=0;Co<Ks;++Co)for(var ba=0;ba<Hr;++ba){var ws=Wn.get(jr,Co,ba);ws<Tn||Eue(ba,ws,jr,Co,1,Wn)&&xi.enqueue({score:ws,part:{heatmapY:jr,heatmapX:Co,id:ba}})}return xi}(a,0,g=f[0]),Ge=c*c;ne.length<i&&!Ee.empty();)tt=Ee.dequeue(),Nt=Dz(tt.part,r,E),Sz(ne,Ge,Nt,tt.part.id)||(kt=Sue(tt,g,E,r,A,Y),on=Iue(ne,Ge,kt),ne.push({keypoints:kt,score:on}));return[2,ne]}})})}function Nz(){for(var t,e=[],s=0;s<arguments.length;s++)e[s]=arguments[s];switch(e.length){case 0:t="fn main() ";break;case 1:t="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return t}var Aue=function(){function t(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=br(this.outputShape),this.dispatch=tr(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return t.prototype.getUserCode=function(){return"\n        ".concat(Nz("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},t}(),Oue=function(){function t(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==e.length||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var s=[e[0],1];this.dispatchLayout=br(s),this.dispatch=tr(this.dispatchLayout,s,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return t.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(Nz("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},t}();function Mz(t){var e=t.shape,s=e[0],n=e[1],r=e[2];return(0,Ce.lub)(function(){var i,a,c=(0,Ce.XLQ)(t,[s*n,r]),f=(0,Ce.NqF)(c,0),g=(0,Ce.dt4)((0,Ce.hiC)(f,(0,Ce.iD$)(n,"int32")),1),E=(0,Ce.dt4)((i=f,a=n,(0,Ce.lub)(function(){var A=(0,Ce.hiC)(i,(0,Ce.iD$)(a,"int32"));return(0,Ce.luU)(i,(0,Ce.dC7)(A,(0,Ce.iD$)(a,"int32")))})),1);return(0,Ce.zoF)([g,E],1)})}function Nue(t,e,s){return(0,Ce.lub)(function(){var n=function(r,i){for(var a=[],c=0;c<Lf.length;c++){var E=Mue(r.get(c,0).valueOf(),r.get(c,1).valueOf(),c,i),A=E.x;a.push(E.y),a.push(A)}return(0,Ce.odF)(a,[Lf.length,2])}(t,s);return(0,Ce.IHx)((0,Ce.pju)((0,Ce.dC7)(t.toTensor(),(0,Ce.iD$)(e,"int32")),"float32"),n)})}function Mue(t,e,s,n){return{y:n.get(t,e,s),x:n.get(t,e,s+Lf.length)}}function Pue(t,e,s){return ra(this,void 0,void 0,function(){var n,r,i,a,f,g,E,A,Y;return ia(this,function(ne){switch(ne.label){case 0:return n=0,r=Mz(t),[4,Promise.all([t.buffer(),e.buffer(),r.buffer()])];case 1:return i=ne.sent(),a=i[0],[4,(g=Nue(f=i[2],s,i[1])).buffer()];case 2:return E=ne.sent(),A=Array.from(function(Ee,Ge){for(var tt=Ge.shape[0],Nt=new Float32Array(tt),kt=0;kt<tt;kt++){var on=Ge.get(kt,0),fn=Ge.get(kt,1);Nt[kt]=Ee.get(on,fn,kt)}return Nt}(a,f)),Y=A.map(function(Ee,Ge){return n+=Ee,{y:E.get(Ge,0),x:E.get(Ge,1),score:Ee,name:Lf[Ge]}}),r.dispose(),g.dispose(),[2,{keypoints:Y,score:n/Y.length}]}})})}function Fue(t,e,s){return ra(this,void 0,void 0,function(){var n,r,i;return ia(this,function(a){return n=Mz(t),c=n,f=s,g=e,r=(0,Ce.lub)(function(){var E=function Rue(t,e){if((0,Ce.y3$)()instanceof eN)return s=t,n=e,r=(0,Ce.y3$)(),i=new Oue(s.shape),a=r.runWebGPUProgram(i,[s,n],"float32"),(0,Ce.SRH)().makeTensorFromTensorInfo(a);var s,n,r,i,a;throw new Error("getOffsetVectorsGPU is not supported in this backend!")}(c,g);return(0,Ce.IHx)((0,Ce.pju)((0,Ce.dC7)(c,(0,Ce.iD$)(f,"int32")),"float32"),E)}),i=function kue(t,e){if((0,Ce.y3$)()instanceof eN)return s=t,n=e,r=(0,Ce.y3$)(),i=new Aue(n.shape),a=r.runWebGPUProgram(i,[s,n],"float32"),(0,Ce.SRH)().makeTensorFromTensorInfo(a);var s,n,r,i,a;throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}(t,n),[2,[r,i]];var c,f,g})})}function Pz(t,e){return(t-1)%e==0}var Fz="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Lz="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function $z(t,e){return(t-1)%e==0?t:Math.floor(t/e)*e+1}var Bz=function(){function t(e,s){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;Ce.D5U.assert(-1===n[1]&&-1===n[2],function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"});var r,i,c,a={height:$z((r=s.inputResolution).height,i=s.outputStride),width:$z(r.width,i)};Ce.D5U.assert(bue.indexOf(c=s.outputStride)>=0,function(){return"outputStride of ".concat(c," is invalid. ")+"It must be either 8 or 16."}),function(c,f){Ce.D5U.assert(Pz(c.height,f),function(){return"height of ".concat(c.height," is invalid for output stride ")+"".concat(f,".")}),Ce.D5U.assert(Pz(c.width,f),function(){return"width of ".concat(c.width," is invalid for output stride ")+"".concat(f,".")})}(a,s.outputStride),this.inputResolution=a,this.outputStride=s.outputStride,this.architecture=s.architecture}return t.prototype.estimatePoses=function(e,s){return void 0===s&&(s=Cz),ra(this,void 0,void 0,function(){return ia(this,function(n){return[2,this.estimatePosesGPU(e,s,!1)]})})},t.prototype.estimatePosesGPU=function(e,s,n){return void 0===s&&(s=Cz),void 0===n&&(n=!1),ra(this,void 0,void 0,function(){var r,i,a,c,f,g,E,A,Y,ne,Ee,Ge,tt,kt,on,fn,Tn;return ia(this,function(Hn){switch(Hn.label){case 0:return r=function(Wn){var xs=Wn;if(null==xs.maxPoses&&(xs.maxPoses=1),xs.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(xs.maxPoses,". Should be > 0."));if(xs.maxPoses>1){if((xs=Ul(Ul({},xue),xs)).scoreThreshold<0||xs.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(xs.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(xs.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(xs.nmsRadius,"."))}return xs}(s),null==e?[2,n?[[],[]]:[]]:(this.maxPoses=r.maxPoses,i=pN(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),a=i.imageTensor,c=i.padding,f="ResNet50"===this.architecture?(0,Ce.IHx)(a,wue):JU(a,[-1,1]),g=this.posenetModel.predict(f),"ResNet50"===this.architecture?(E=(0,Ce.L9e)(g[2],[0]),A=(0,Ce.L9e)(g[3],[0]),Y=(0,Ce.L9e)(g[0],[0]),ne=(0,Ce.L9e)(g[1],[0])):(E=(0,Ce.L9e)(g[0],[0]),A=(0,Ce.L9e)(g[1],[0]),Y=(0,Ce.L9e)(g[2],[0]),ne=(0,Ce.L9e)(g[3],[0])),Ee=(0,Ce.XD2)(A),1!==this.maxPoses?[3,5]:n?[4,Fue(Ee,E,this.outputStride)]:[3,2]);case 1:return tt=Hn.sent(),Ge=[kt=tt[0],tt[1]],[3,4];case 2:return[4,Pue(Ee,E,this.outputStride)];case 3:kt=Hn.sent(),Ge=[kt],Hn.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,Tue(Ee,E,Y,ne,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:Ge=Hn.sent(),Hn.label=7;case 7:if(n){if(!0===r.flipHorizontal)throw new Error("flipHorizontal is not supported!");on=this.getCanvasInfo(Ub(e),this.inputResolution,c)}else Tn=Ub(e),fn=function(Wn,xs,fs,Ks){var jr=xs.height/(fs.height*(1-Ks.top-Ks.bottom)),Co=xs.width/(fs.width*(1-Ks.left-Ks.right)),ba=-Ks.top*fs.height,ws=-Ks.left*fs.width;if(1===Co&&1===jr&&0===ba&&0===ws)return Wn;for(var Mr=0,Qr=Wn;Mr<Qr.length;Mr++)for(var Wi=0,rc=Qr[Mr].keypoints;Wi<rc.length;Wi++){var vu=rc[Wi];vu.x=(vu.x+ws)*Co,vu.y=(vu.y+ba)*jr}return Wn}(Ge,Tn,this.inputResolution,c),r.flipHorizontal&&(fn=function(Wn,xs){for(var fs=0,Ks=Wn;fs<Ks.length;fs++)for(var Hr=0,xi=Ks[fs].keypoints;Hr<xi.length;Hr++){var jr=xi[Hr];jr.x=xs.width-1-jr.x}return Wn}(fn,Tn));return a.dispose(),f.dispose(),(0,Ce.B90)(g),E.dispose(),A.dispose(),Y.dispose(),ne.dispose(),Ee.dispose(),[2,n?[Ge,on]:fn]}})})},t.prototype.getCanvasInfo=function(e,s,n){return[-n.left*s.width,-n.top*s.height,e.width/(s.width*(1-n.left-n.right)),e.height/(s.height*(1-n.top-n.bottom)),e.width,e.height]},t.prototype.dispose=function(){this.posenetModel.dispose()},t.prototype.reset=function(){},t}();function Lue(t){return void 0===t&&(t=yz),ra(this,void 0,void 0,function(){var e,s,n,r,i;return ia(this,function(a){switch(a.label){case 0:return"ResNet50"!==(e=function(E){var A=E||yz;if(null==A.architecture&&(A.architecture="MobileNetV1"),vz.indexOf(A.architecture)<0)throw new Error("Invalid architecture ".concat(A.architecture,". ")+"Should be one of ".concat(vz));if(null==A.inputResolution&&(A.inputResolution={height:257,width:257}),null==A.outputStride&&(A.outputStride=16),bz[A.architecture].indexOf(A.outputStride)<0)throw new Error("Invalid outputStride ".concat(A.outputStride,". ")+"Should be one of ".concat(bz[A.architecture]," ")+"for architecture ".concat(A.architecture,"."));if(null==A.multiplier&&(A.multiplier=1),xz[A.architecture].indexOf(A.multiplier)<0)throw new Error("Invalid multiplier ".concat(A.multiplier,". ")+"Should be one of ".concat(xz[A.architecture]," ")+"for architecture ".concat(A.architecture,"."));if(null==A.quantBytes&&(A.quantBytes=4),wz.indexOf(A.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(A.quantBytes,". ")+"Should be one of ".concat(wz," ")+"for architecture ".concat(A.architecture,"."));if("MobileNetV1"===A.architecture&&32===A.outputStride&&1!==A.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return A}(t)).architecture?[3,2]:(f=e.quantBytes,g="model-stride".concat(e.outputStride,".json"),s=4===f?Lz+"float/"+g:Lz+"quant".concat(f,"/")+g,[4,(0,Fb.YL)(e.modelUrl||s)]);case 1:return n=a.sent(),[2,new Bz(n,e)];case 2:return A=e.multiplier,Y=e.quantBytes,ne={1:"100",.75:"075",.5:"050"},Ee="model-stride".concat(e.outputStride,".json"),r=4===Y?Fz+"float/".concat(ne[A],"/")+Ee:Fz+"quant".concat(Y,"/").concat(ne[A],"/")+Ee,[4,(0,Fb.YL)(e.modelUrl||r)];case 3:return i=a.sent(),[2,new Bz(i,e)]}var A,Y,ne,Ee,f,g})})}var Bue_modelType_SINGLEPOSE_LIGHTNING="SinglePose.Lightning";h(3421);const Vue=["status"],Uue=["webcam"],zue=[{path:"",redirectTo:"home",pathMatch:"full"},{path:"home",component:Jq},{path:"trainer",component:(()=>{var t;class e{constructor(n){this.http=n,this.CLASS_NAMES=[],this.moveNet=void 0,this.gatherDataState="STOP_DATA_GATHER",this.videoPlaying=!1,this.trainingDataInputs=[],this.trainingDataOutputs=[],this.examplesCount=[],this.predict=!1}ngAfterViewInit(){console.log("STATUS element:",this.STATUS.nativeElement),console.log("VIDEO element:",this.VIDEO.nativeElement),this.loadMoveNetFeatureModel()}enableWebCam(){}trainAndPredict(){}resetTrainer(){}gatherDataForClass(n){}loadMoveNetFeatureModel(){var n=this;return(0,zm.Z)(function*(){try{const r={modelType:Bue_modelType_SINGLEPOSE_LIGHTNING},i=yield function $ue(t,e){return ra(this,void 0,void 0,function(){var s,n;return ia(this,function(r){switch(t){case yd.PoseNet:return[2,Lue(e)];case yd.BlazePose:if(n=void 0,null!=(s=e)){if("tfjs"===s.runtime)return[2,pue(e)];if("mediapipe"===s.runtime)return[2,Vce(e)];n=s.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(n));case yd.MoveNet:return[2,vue(e)];default:throw new Error("".concat(t," is not a supported model name."))}})})}(yd.MoveNet,r);console.log("Pose Detection model loaded successfully:",r.modelType),n.moveNet=i,n.STATUS.nativeElement.innerText="Pose Detection model loaded successfully!"}catch(r){console.error("Failed to load Pose Detection model:",r)}})()}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(Vw))},t.\u0275cmp=sr({type:t,selectors:[["app-gesture-trainer"]],viewQuery:function(n,r){if(1&n&&(qo(Vue,5),qo(Uue,5)),2&n){let i;Ar(i=kr())&&(r.STATUS=i.first),Ar(i=kr())&&(r.VIDEO=i.first)}},decls:20,vars:4,consts:[["status",""],["autoplay","","muted",""],["webcam",""],[3,"click"],["enableCam",""],[1,"dataCollector",3,"mousedown","mouseup"],["train",""],["reset",""]],template:function(n,r){1&n&&(yn(0,"h1"),Ys(1,"Pose Trainer with Movenet Lightning."),In(),yn(2,"p",null,0),Ys(4,"Awaiting TF.js load"),In(),ti(5,"video",1,2),yn(7,"button",3,4),qs("click",function(){return r.enableWebCam()}),Ys(9,"Enable Webcam"),In(),yn(10,"button",5),qs("mousedown",function(){return r.gatherDataForClass(0)})("mouseup",function(){return r.gatherDataForClass(0)}),Ys(11,"Gather Class 1 Data"),In(),yn(12,"button",5),qs("mousedown",function(){return r.gatherDataForClass(1)})("mouseup",function(){return r.gatherDataForClass(1)}),Ys(13,"Gather Class 2 Data"),In(),yn(14,"button",3,6),qs("click",function(){return r.trainAndPredict()}),Ys(16,"Train & Predict!"),In(),yn(17,"button",3,7),qs("click",function(){return r.resetTrainer()}),Ys(19,"Reset"),In()),2&n&&(Un(10),si("data-1hot",0)("data-name","Class 1"),Un(2),si("data-1hot",1)("data-name","Class 2"))},styles:["body[_ngcontent-%COMP%]{font-family:helvetica,arial,sans-serif;margin:2em}h1[_ngcontent-%COMP%]{font-style:italic;color:#ff6f00}video[_ngcontent-%COMP%]{clear:both;display:block;margin:10px;background:#000000;width:640px;height:480px}button[_ngcontent-%COMP%]{padding:10px;float:left;margin:5px 3px 5px 10px}.removed[_ngcontent-%COMP%]{display:none}#status[_ngcontent-%COMP%]{font-size:150%}"]}),e})()}];let Wue=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[l3.forRoot(zue),l3]}),e})(),Hue=(()=>{var t;class e{constructor(){this.title="samson"}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275cmp=sr({type:t,selectors:[["app-root"]],decls:1,vars:0,template:function(n,r){1&n&&ti(0,"router-outlet")},dependencies:[SO]}),e})();function Vz(t){return new En(3e3,!1)}function y_(t){switch(t.length){case 0:return new vC;case 1:return t[0];default:return new dB(t)}}function Uz(t,e,s=new Map,n=new Map){const r=[],i=[];let a=-1,c=null;if(e.forEach(f=>{const g=f.get("offset"),E=g==a,A=E&&c||new Map;f.forEach((Y,ne)=>{let Ee=ne,Ge=Y;if("offset"!==ne)switch(Ee=t.normalizePropertyName(Ee,r),Ge){case"!":Ge=s.get(ne);break;case Bm:Ge=n.get(ne);break;default:Ge=t.normalizeStyleValue(ne,Ee,Ge,r)}A.set(Ee,Ge)}),E||i.push(A),c=A,a=g}),r.length)throw function pde(t){return new En(3502,!1)}();return i}function CN(t,e,s,n){switch(e){case"start":t.onStart(()=>n(s&&EN(s,"start",t)));break;case"done":t.onDone(()=>n(s&&EN(s,"done",t)));break;case"destroy":t.onDestroy(()=>n(s&&EN(s,"destroy",t)))}}function EN(t,e,s){const i=DN(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,s.totalTime??t.totalTime,!!s.disabled),a=t._data;return null!=a&&(i._data=a),i}function DN(t,e,s,n,r="",i=0,a){return{element:t,triggerName:e,fromState:s,toState:n,phaseName:r,totalTime:i,disabled:!!a}}function Rh(t,e,s){let n=t.get(e);return n||t.set(e,n=s),n}function zz(t){const e=t.indexOf(":");return[t.substring(1,e),t.slice(e+1)]}const Dde=(()=>typeof document>"u"?null:document.documentElement)();function SN(t){const e=t.parentNode||t.host||null;return e===Dde?null:e}let b0=null,Wz=!1;function Hz(t,e){for(;e;){if(e===t)return!0;e=SN(e)}return!1}function jz(t,e,s){if(s)return Array.from(t.querySelectorAll(e));const n=t.querySelector(e);return n?[n]:[]}let Gz=(()=>{var t;class e{validateStyleProperty(n){return function Ide(t){b0||(b0=function Tde(){return typeof document<"u"?document.body:null}()||{},Wz=!!b0.style&&"WebkitAppearance"in b0.style);let e=!0;return b0.style&&!function Sde(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in b0.style,!e&&Wz&&(e="Webkit"+t.charAt(0).toUpperCase()+t.slice(1)in b0.style)),e}(n)}matchesElement(n,r){return!1}containsElement(n,r){return Hz(n,r)}getParentElement(n){return SN(n)}query(n,r,i){return jz(n,r,i)}computeStyle(n,r,i){return i||""}animate(n,r,i,a,c,f=[],g){return new vC(i,a)}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})(),IN=(()=>{class e{}return e.NOOP=new Gz,e})();const Ade=1e3,TN="ng-enter",VI="ng-leave",UI="ng-trigger",zI=".ng-trigger",Xz="ng-animating",AN=".ng-animating";function Gm(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:kN(parseFloat(e[1]),e[2])}function kN(t,e){return"s"===e?t*Ade:t}function WI(t,e,s){return t.hasOwnProperty("duration")?t:function Ode(t,e,s){let r,i=0,a="";if("string"==typeof t){const c=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===c)return e.push(Vz()),{duration:0,delay:0,easing:""};r=kN(parseFloat(c[1]),c[2]);const f=c[3];null!=f&&(i=kN(parseFloat(f),c[4]));const g=c[5];g&&(a=g)}else r=t;if(!s){let c=!1,f=e.length;r<0&&(e.push(function jue(){return new En(3100,!1)}()),c=!0),i<0&&(e.push(function Gue(){return new En(3101,!1)}()),c=!0),c&&e.splice(f,0,Vz())}return{duration:r,delay:i,easing:a}}(t,e,s)}function BC(t,e={}){return Object.keys(t).forEach(s=>{e[s]=t[s]}),e}function Yz(t){const e=new Map;return Object.keys(t).forEach(s=>{e.set(s,t[s])}),e}function v_(t,e=new Map,s){if(s)for(let[n,r]of s)e.set(n,r);for(let[n,r]of t)e.set(n,r);return e}function $f(t,e,s){e.forEach((n,r)=>{const i=RN(r);s&&!s.has(r)&&s.set(r,t.style[i]),t.style[i]=n})}function x0(t,e){e.forEach((s,n)=>{const r=RN(n);t.style[r]=""})}function VC(t){return Array.isArray(t)?1==t.length?t[0]:uB(t):t}const ON=new RegExp("{{\\s*(.+?)\\s*}}","g");function Qz(t){let e=[];if("string"==typeof t){let s;for(;s=ON.exec(t);)e.push(s[1]);ON.lastIndex=0}return e}function UC(t,e,s){const n=t.toString(),r=n.replace(ON,(i,a)=>{let c=e[a];return null==c&&(s.push(function Xue(t){return new En(3003,!1)}()),c=""),c.toString()});return r==n?t:r}function HI(t){const e=[];let s=t.next();for(;!s.done;)e.push(s.value),s=t.next();return e}const Mde=/-+([a-z0-9])/g;function RN(t){return t.replace(Mde,(...e)=>e[1].toUpperCase())}function Nh(t,e,s){switch(e.type){case 7:return t.visitTrigger(e,s);case 0:return t.visitState(e,s);case 1:return t.visitTransition(e,s);case 2:return t.visitSequence(e,s);case 3:return t.visitGroup(e,s);case 4:return t.visitAnimate(e,s);case 5:return t.visitKeyframes(e,s);case 6:return t.visitStyle(e,s);case 8:return t.visitReference(e,s);case 9:return t.visitAnimateChild(e,s);case 10:return t.visitAnimateRef(e,s);case 11:return t.visitQuery(e,s);case 12:return t.visitStagger(e,s);default:throw function Yue(t){return new En(3004,!1)}()}}function Jz(t,e){return window.getComputedStyle(t)[e]}const jI="*";function Lde(t,e){const s=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(n=>function $de(t,e,s){if(":"==t[0]){const f=function Bde(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(s,n)=>parseFloat(n)>parseFloat(s);case":decrement":return(s,n)=>parseFloat(n)<parseFloat(s);default:return e.push(function cde(t){return new En(3016,!1)}()),"* => *"}}(t,s);if("function"==typeof f)return void e.push(f);t=f}const n=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==n||n.length<4)return s.push(function lde(t){return new En(3015,!1)}()),e;const r=n[1],i=n[2],a=n[3];e.push(qz(r,a));"<"==i[0]&&!(r==jI&&a==jI)&&e.push(qz(a,r))}(n,s,e)):s.push(t),s}const GI=new Set(["true","1"]),KI=new Set(["false","0"]);function qz(t,e){const s=GI.has(t)||KI.has(t),n=GI.has(e)||KI.has(e);return(r,i)=>{let a=t==jI||t==r,c=e==jI||e==i;return!a&&s&&"boolean"==typeof r&&(a=r?GI.has(t):KI.has(t)),!c&&n&&"boolean"==typeof i&&(c=i?GI.has(e):KI.has(e)),a&&c}}const Vde=new RegExp("s*:selfs*,?","g");function NN(t,e,s,n){return new Ude(t).build(e,s,n)}class Ude{constructor(e){this._driver=e}build(e,s,n){const r=new Hde(s);return this._resetContextStyleTimingState(r),Nh(this,VC(e),r)}_resetContextStyleTimingState(e){e.currentQuerySelector="",e.collectedStyles=new Map,e.collectedStyles.set("",new Map),e.currentTime=0}visitTrigger(e,s){let n=s.queryCount=0,r=s.depCount=0;const i=[],a=[];return"@"==e.name.charAt(0)&&s.errors.push(function Que(){return new En(3006,!1)}()),e.definitions.forEach(c=>{if(this._resetContextStyleTimingState(s),0==c.type){const f=c,g=f.name;g.toString().split(/\s*,\s*/).forEach(E=>{f.name=E,i.push(this.visitState(f,s))}),f.name=g}else if(1==c.type){const f=this.visitTransition(c,s);n+=f.queryCount,r+=f.depCount,a.push(f)}else s.errors.push(function Jue(){return new En(3007,!1)}())}),{type:7,name:e.name,states:i,transitions:a,queryCount:n,depCount:r,options:null}}visitState(e,s){const n=this.visitStyle(e.styles,s),r=e.options&&e.options.params||null;if(n.containsDynamicStyles){const i=new Set,a=r||{};n.styles.forEach(c=>{c instanceof Map&&c.forEach(f=>{Qz(f).forEach(g=>{a.hasOwnProperty(g)||i.add(g)})})}),i.size&&(HI(i.values()),s.errors.push(function que(t,e){return new En(3008,!1)}()))}return{type:0,name:e.name,style:n,options:r?{params:r}:null}}visitTransition(e,s){s.queryCount=0,s.depCount=0;const n=Nh(this,VC(e.animation),s);return{type:1,matchers:Lde(e.expr,s.errors),animation:n,queryCount:s.queryCount,depCount:s.depCount,options:w0(e.options)}}visitSequence(e,s){return{type:2,steps:e.steps.map(n=>Nh(this,n,s)),options:w0(e.options)}}visitGroup(e,s){const n=s.currentTime;let r=0;const i=e.steps.map(a=>{s.currentTime=n;const c=Nh(this,a,s);return r=Math.max(r,s.currentTime),c});return s.currentTime=r,{type:3,steps:i,options:w0(e.options)}}visitAnimate(e,s){const n=function Gde(t,e){if(t.hasOwnProperty("duration"))return t;if("number"==typeof t)return MN(WI(t,e).duration,0,"");const s=t;if(s.split(/\s+/).some(i=>"{"==i.charAt(0)&&"{"==i.charAt(1))){const i=MN(0,0,"");return i.dynamic=!0,i.strValue=s,i}const r=WI(s,e);return MN(r.duration,r.delay,r.easing)}(e.timings,s.errors);s.currentAnimateTimings=n;let r,i=e.styles?e.styles:Mi({});if(5==i.type)r=this.visitKeyframes(i,s);else{let a=e.styles,c=!1;if(!a){c=!0;const g={};n.easing&&(g.easing=n.easing),a=Mi(g)}s.currentTime+=n.duration+n.delay;const f=this.visitStyle(a,s);f.isEmptyStep=c,r=f}return s.currentAnimateTimings=null,{type:4,timings:n,style:r,options:null}}visitStyle(e,s){const n=this._makeStyleAst(e,s);return this._validateStyleAst(n,s),n}_makeStyleAst(e,s){const n=[],r=Array.isArray(e.styles)?e.styles:[e.styles];for(let c of r)"string"==typeof c?c===Bm?n.push(c):s.errors.push(new En(3002,!1)):n.push(Yz(c));let i=!1,a=null;return n.forEach(c=>{if(c instanceof Map&&(c.has("easing")&&(a=c.get("easing"),c.delete("easing")),!i))for(let f of c.values())if(f.toString().indexOf("{{")>=0){i=!0;break}}),{type:6,styles:n,easing:a,offset:e.offset,containsDynamicStyles:i,options:null}}_validateStyleAst(e,s){const n=s.currentAnimateTimings;let r=s.currentTime,i=s.currentTime;n&&i>0&&(i-=n.duration+n.delay),e.styles.forEach(a=>{"string"!=typeof a&&a.forEach((c,f)=>{const g=s.collectedStyles.get(s.currentQuerySelector),E=g.get(f);let A=!0;E&&(i!=r&&i>=E.startTime&&r<=E.endTime&&(s.errors.push(function tde(t,e,s,n,r){return new En(3010,!1)}()),A=!1),i=E.startTime),A&&g.set(f,{startTime:i,endTime:r}),s.options&&function Nde(t,e,s){const n=e.params||{},r=Qz(t);r.length&&r.forEach(i=>{n.hasOwnProperty(i)||s.push(function Kue(t){return new En(3001,!1)}())})}(c,s.options,s.errors)})})}visitKeyframes(e,s){const n={type:5,styles:[],options:null};if(!s.currentAnimateTimings)return s.errors.push(function nde(){return new En(3011,!1)}()),n;let i=0;const a=[];let c=!1,f=!1,g=0;const E=e.steps.map(Nt=>{const kt=this._makeStyleAst(Nt,s);let on=null!=kt.offset?kt.offset:function jde(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(s=>{if(s instanceof Map&&s.has("offset")){const n=s;e=parseFloat(n.get("offset")),n.delete("offset")}});else if(t instanceof Map&&t.has("offset")){const s=t;e=parseFloat(s.get("offset")),s.delete("offset")}return e}(kt.styles),fn=0;return null!=on&&(i++,fn=kt.offset=on),f=f||fn<0||fn>1,c=c||fn<g,g=fn,a.push(fn),kt});f&&s.errors.push(function sde(){return new En(3012,!1)}()),c&&s.errors.push(function rde(){return new En(3200,!1)}());const A=e.steps.length;let Y=0;i>0&&i<A?s.errors.push(function ide(){return new En(3202,!1)}()):0==i&&(Y=1/(A-1));const ne=A-1,Ee=s.currentTime,Ge=s.currentAnimateTimings,tt=Ge.duration;return E.forEach((Nt,kt)=>{const on=Y>0?kt==ne?1:Y*kt:a[kt],fn=on*tt;s.currentTime=Ee+Ge.delay+fn,Ge.duration=fn,this._validateStyleAst(Nt,s),Nt.offset=on,n.styles.push(Nt)}),n}visitReference(e,s){return{type:8,animation:Nh(this,VC(e.animation),s),options:w0(e.options)}}visitAnimateChild(e,s){return s.depCount++,{type:9,options:w0(e.options)}}visitAnimateRef(e,s){return{type:10,animation:this.visitReference(e.animation,s),options:w0(e.options)}}visitQuery(e,s){const n=s.currentQuerySelector,r=e.options||{};s.queryCount++,s.currentQuery=e;const[i,a]=function zde(t){const e=!!t.split(/\s*,\s*/).find(s=>":self"==s);return e&&(t=t.replace(Vde,"")),t=t.replace(/@\*/g,zI).replace(/@\w+/g,s=>zI+"-"+s.slice(1)).replace(/:animating/g,AN),[t,e]}(e.selector);s.currentQuerySelector=n.length?n+" "+i:i,Rh(s.collectedStyles,s.currentQuerySelector,new Map);const c=Nh(this,VC(e.animation),s);return s.currentQuery=null,s.currentQuerySelector=n,{type:11,selector:i,limit:r.limit||0,optional:!!r.optional,includeSelf:a,animation:c,originalSelector:e.selector,options:w0(e.options)}}visitStagger(e,s){s.currentQuery||s.errors.push(function ode(){return new En(3013,!1)}());const n="full"===e.timings?{duration:0,delay:0,easing:"full"}:WI(e.timings,s.errors,!0);return{type:12,animation:Nh(this,VC(e.animation),s),timings:n,options:null}}}class Hde{constructor(e){this.errors=e,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function w0(t){return t?(t=BC(t)).params&&(t.params=function Wde(t){return t?BC(t):null}(t.params)):t={},t}function MN(t,e,s){return{duration:t,delay:e,easing:s}}function PN(t,e,s,n,r,i,a=null,c=!1){return{type:1,element:t,keyframes:e,preStyleProps:s,postStyleProps:n,duration:r,delay:i,totalTime:r+i,easing:a,subTimeline:c}}class XI{constructor(){this._map=new Map}get(e){return this._map.get(e)||[]}append(e,s){let n=this._map.get(e);n||this._map.set(e,n=[]),n.push(...s)}has(e){return this._map.has(e)}clear(){this._map.clear()}}const Yde=new RegExp(":enter","g"),Qde=new RegExp(":leave","g");function FN(t,e,s,n,r,i=new Map,a=new Map,c,f,g=[]){return(new Jde).buildKeyframes(t,e,s,n,r,i,a,c,f,g)}class Jde{buildKeyframes(e,s,n,r,i,a,c,f,g,E=[]){g=g||new XI;const A=new LN(e,s,g,r,i,E,[]);A.options=f;const Y=f.delay?Gm(f.delay):0;A.currentTimeline.delayNextStep(Y),A.currentTimeline.setStyles([a],null,A.errors,f),Nh(this,n,A);const ne=A.timelines.filter(Ee=>Ee.containsAnimation());if(ne.length&&c.size){let Ee;for(let Ge=ne.length-1;Ge>=0;Ge--){const tt=ne[Ge];if(tt.element===s){Ee=tt;break}}Ee&&!Ee.allowOnlyTimelineStyles()&&Ee.setStyles([c],null,A.errors,f)}return ne.length?ne.map(Ee=>Ee.buildKeyframes()):[PN(s,[],[],[],0,Y,"",!1)]}visitTrigger(e,s){}visitState(e,s){}visitTransition(e,s){}visitAnimateChild(e,s){const n=s.subInstructions.get(s.element);if(n){const r=s.createSubContext(e.options),i=s.currentTimeline.currentTime,a=this._visitSubInstructions(n,r,r.options);i!=a&&s.transformIntoNewTimeline(a)}s.previousNode=e}visitAnimateRef(e,s){const n=s.createSubContext(e.options);n.transformIntoNewTimeline(),this._applyAnimationRefDelays([e.options,e.animation.options],s,n),this.visitReference(e.animation,n),s.transformIntoNewTimeline(n.currentTimeline.currentTime),s.previousNode=e}_applyAnimationRefDelays(e,s,n){for(const r of e){const i=r?.delay;if(i){const a="number"==typeof i?i:Gm(UC(i,r?.params??{},s.errors));n.delayNextStep(a)}}}_visitSubInstructions(e,s,n){let i=s.currentTimeline.currentTime;const a=null!=n.duration?Gm(n.duration):null,c=null!=n.delay?Gm(n.delay):null;return 0!==a&&e.forEach(f=>{const g=s.appendInstructionToTimeline(f,a,c);i=Math.max(i,g.duration+g.delay)}),i}visitReference(e,s){s.updateOptions(e.options,!0),Nh(this,e.animation,s),s.previousNode=e}visitSequence(e,s){const n=s.subContextCount;let r=s;const i=e.options;if(i&&(i.params||i.delay)&&(r=s.createSubContext(i),r.transformIntoNewTimeline(),null!=i.delay)){6==r.previousNode.type&&(r.currentTimeline.snapshotCurrentStyles(),r.previousNode=YI);const a=Gm(i.delay);r.delayNextStep(a)}e.steps.length&&(e.steps.forEach(a=>Nh(this,a,r)),r.currentTimeline.applyStylesToKeyframe(),r.subContextCount>n&&r.transformIntoNewTimeline()),s.previousNode=e}visitGroup(e,s){const n=[];let r=s.currentTimeline.currentTime;const i=e.options&&e.options.delay?Gm(e.options.delay):0;e.steps.forEach(a=>{const c=s.createSubContext(e.options);i&&c.delayNextStep(i),Nh(this,a,c),r=Math.max(r,c.currentTimeline.currentTime),n.push(c.currentTimeline)}),n.forEach(a=>s.currentTimeline.mergeTimelineCollectedStyles(a)),s.transformIntoNewTimeline(r),s.previousNode=e}_visitTiming(e,s){if(e.dynamic){const n=e.strValue;return WI(s.params?UC(n,s.params,s.errors):n,s.errors)}return{duration:e.duration,delay:e.delay,easing:e.easing}}visitAnimate(e,s){const n=s.currentAnimateTimings=this._visitTiming(e.timings,s),r=s.currentTimeline;n.delay&&(s.incrementTime(n.delay),r.snapshotCurrentStyles());const i=e.style;5==i.type?this.visitKeyframes(i,s):(s.incrementTime(n.duration),this.visitStyle(i,s),r.applyStylesToKeyframe()),s.currentAnimateTimings=null,s.previousNode=e}visitStyle(e,s){const n=s.currentTimeline,r=s.currentAnimateTimings;!r&&n.hasCurrentStyleProperties()&&n.forwardFrame();const i=r&&r.easing||e.easing;e.isEmptyStep?n.applyEmptyStep(i):n.setStyles(e.styles,i,s.errors,s.options),s.previousNode=e}visitKeyframes(e,s){const n=s.currentAnimateTimings,r=s.currentTimeline.duration,i=n.duration,c=s.createSubContext().currentTimeline;c.easing=n.easing,e.styles.forEach(f=>{c.forwardTime((f.offset||0)*i),c.setStyles(f.styles,f.easing,s.errors,s.options),c.applyStylesToKeyframe()}),s.currentTimeline.mergeTimelineCollectedStyles(c),s.transformIntoNewTimeline(r+i),s.previousNode=e}visitQuery(e,s){const n=s.currentTimeline.currentTime,r=e.options||{},i=r.delay?Gm(r.delay):0;i&&(6===s.previousNode.type||0==n&&s.currentTimeline.hasCurrentStyleProperties())&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=YI);let a=n;const c=s.invokeQuery(e.selector,e.originalSelector,e.limit,e.includeSelf,!!r.optional,s.errors);s.currentQueryTotal=c.length;let f=null;c.forEach((g,E)=>{s.currentQueryIndex=E;const A=s.createSubContext(e.options,g);i&&A.delayNextStep(i),g===s.element&&(f=A.currentTimeline),Nh(this,e.animation,A),A.currentTimeline.applyStylesToKeyframe(),a=Math.max(a,A.currentTimeline.currentTime)}),s.currentQueryIndex=0,s.currentQueryTotal=0,s.transformIntoNewTimeline(a),f&&(s.currentTimeline.mergeTimelineCollectedStyles(f),s.currentTimeline.snapshotCurrentStyles()),s.previousNode=e}visitStagger(e,s){const n=s.parentContext,r=s.currentTimeline,i=e.timings,a=Math.abs(i.duration),c=a*(s.currentQueryTotal-1);let f=a*s.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":f=c-f;break;case"full":f=n.currentStaggerTime}const E=s.currentTimeline;f&&E.delayNextStep(f);const A=E.currentTime;Nh(this,e.animation,s),s.previousNode=e,n.currentStaggerTime=r.currentTime-A+(r.startTime-n.currentTimeline.startTime)}}const YI={};class LN{constructor(e,s,n,r,i,a,c,f){this._driver=e,this.element=s,this.subInstructions=n,this._enterClassName=r,this._leaveClassName=i,this.errors=a,this.timelines=c,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=YI,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=f||new ZI(this._driver,s,0),c.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(e,s){if(!e)return;const n=e;let r=this.options;null!=n.duration&&(r.duration=Gm(n.duration)),null!=n.delay&&(r.delay=Gm(n.delay));const i=n.params;if(i){let a=r.params;a||(a=this.options.params={}),Object.keys(i).forEach(c=>{(!s||!a.hasOwnProperty(c))&&(a[c]=UC(i[c],a,this.errors))})}}_copyOptions(){const e={};if(this.options){const s=this.options.params;if(s){const n=e.params={};Object.keys(s).forEach(r=>{n[r]=s[r]})}}return e}createSubContext(e=null,s,n){const r=s||this.element,i=new LN(this._driver,r,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(r,n||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(e),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(e){return this.previousNode=YI,this.currentTimeline=this.currentTimeline.fork(this.element,e),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(e,s,n){const r={duration:s??e.duration,delay:this.currentTimeline.currentTime+(n??0)+e.delay,easing:""},i=new qde(this._driver,e.element,e.keyframes,e.preStyleProps,e.postStyleProps,r,e.stretchStartingKeyframe);return this.timelines.push(i),r}incrementTime(e){this.currentTimeline.forwardTime(this.currentTimeline.duration+e)}delayNextStep(e){e>0&&this.currentTimeline.delayNextStep(e)}invokeQuery(e,s,n,r,i,a){let c=[];if(r&&c.push(this.element),e.length>0){e=(e=e.replace(Yde,"."+this._enterClassName)).replace(Qde,"."+this._leaveClassName);let g=this._driver.query(this.element,e,1!=n);0!==n&&(g=n<0?g.slice(g.length+n,g.length):g.slice(0,n)),c.push(...g)}return!i&&0==c.length&&a.push(function ade(t){return new En(3014,!1)}()),c}}class ZI{constructor(e,s,n,r){this._driver=e,this.element=s,this.startTime=n,this._elementTimelineStylesLookup=r,this.duration=0,this.easing=null,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(s),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(s,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(e){const s=1===this._keyframes.size&&this._pendingStyles.size;this.duration||s?(this.forwardTime(this.currentTime+e),s&&this.snapshotCurrentStyles()):this.startTime+=e}fork(e,s){return this.applyStylesToKeyframe(),new ZI(this._driver,e,s||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(e){this.applyStylesToKeyframe(),this.duration=e,this._loadKeyframe()}_updateStyle(e,s){this._localTimelineStyles.set(e,s),this._globalTimelineStyles.set(e,s),this._styleSummary.set(e,{time:this.currentTime,value:s})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(e){e&&this._previousKeyframe.set("easing",e);for(let[s,n]of this._globalTimelineStyles)this._backFill.set(s,n||Bm),this._currentKeyframe.set(s,Bm);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(e,s,n,r){s&&this._previousKeyframe.set("easing",s);const i=r&&r.params||{},a=function ehe(t,e){const s=new Map;let n;return t.forEach(r=>{if("*"===r){n=n||e.keys();for(let i of n)s.set(i,Bm)}else v_(r,s)}),s}(e,this._globalTimelineStyles);for(let[c,f]of a){const g=UC(f,i,n);this._pendingStyles.set(c,g),this._localTimelineStyles.has(c)||this._backFill.set(c,this._globalTimelineStyles.get(c)??Bm),this._updateStyle(c,g)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((e,s)=>{this._currentKeyframe.set(s,e)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((e,s)=>{this._currentKeyframe.has(s)||this._currentKeyframe.set(s,e)}))}snapshotCurrentStyles(){for(let[e,s]of this._localTimelineStyles)this._pendingStyles.set(e,s),this._updateStyle(e,s)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const e=[];for(let s in this._currentKeyframe)e.push(s);return e}mergeTimelineCollectedStyles(e){e._styleSummary.forEach((s,n)=>{const r=this._styleSummary.get(n);(!r||s.time>r.time)&&this._updateStyle(n,s.value)})}buildKeyframes(){this.applyStylesToKeyframe();const e=new Set,s=new Set,n=1===this._keyframes.size&&0===this.duration;let r=[];this._keyframes.forEach((c,f)=>{const g=v_(c,new Map,this._backFill);g.forEach((E,A)=>{"!"===E?e.add(A):E===Bm&&s.add(A)}),n||g.set("offset",f/this.duration),r.push(g)});const i=e.size?HI(e.values()):[],a=s.size?HI(s.values()):[];if(n){const c=r[0],f=new Map(c);c.set("offset",0),f.set("offset",1),r=[c,f]}return PN(this.element,r,i,a,this.duration,this.startTime,this.easing,!1)}}class qde extends ZI{constructor(e,s,n,r,i,a,c=!1){super(e,s,a.delay),this.keyframes=n,this.preStyleProps=r,this.postStyleProps=i,this._stretchStartingKeyframe=c,this.timings={duration:a.duration,delay:a.delay,easing:a.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let e=this.keyframes,{delay:s,duration:n,easing:r}=this.timings;if(this._stretchStartingKeyframe&&s){const i=[],a=n+s,c=s/a,f=v_(e[0]);f.set("offset",0),i.push(f);const g=v_(e[0]);g.set("offset",n4(c)),i.push(g);const E=e.length-1;for(let A=1;A<=E;A++){let Y=v_(e[A]);const ne=Y.get("offset");Y.set("offset",n4((s+ne*n)/a)),i.push(Y)}n=a,s=0,r="",e=i}return PN(this.element,e,this.preStyleProps,this.postStyleProps,n,s,r,!0)}}function n4(t,e=3){const s=Math.pow(10,e-1);return Math.round(t*s)/s}class $N{}const the=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class nhe extends $N{normalizePropertyName(e,s){return RN(e)}normalizeStyleValue(e,s,n,r){let i="";const a=n.toString().trim();if(the.has(s)&&0!==n&&"0"!==n)if("number"==typeof n)i="px";else{const c=n.match(/^[+-]?[\d\.]+([a-z]*)$/);c&&0==c[1].length&&r.push(function Zue(t,e){return new En(3005,!1)}())}return a+i}}function s4(t,e,s,n,r,i,a,c,f,g,E,A,Y){return{type:0,element:t,triggerName:e,isRemovalTransition:r,fromState:s,fromStyles:i,toState:n,toStyles:a,timelines:c,queriedElements:f,preStyleProps:g,postStyleProps:E,totalTime:A,errors:Y}}const BN={};class r4{constructor(e,s,n){this._triggerName=e,this.ast=s,this._stateStyles=n}match(e,s,n,r){return function she(t,e,s,n,r){return t.some(i=>i(e,s,n,r))}(this.ast.matchers,e,s,n,r)}buildStyles(e,s,n){let r=this._stateStyles.get("*");return void 0!==e&&(r=this._stateStyles.get(e?.toString())||r),r?r.buildStyles(s,n):new Map}build(e,s,n,r,i,a,c,f,g,E){const A=[],Y=this.ast.options&&this.ast.options.params||BN,Ee=this.buildStyles(n,c&&c.params||BN,A),Ge=f&&f.params||BN,tt=this.buildStyles(r,Ge,A),Nt=new Set,kt=new Map,on=new Map,fn="void"===r,Tn={params:rhe(Ge,Y),delay:this.ast.options?.delay},Hn=E?[]:FN(e,s,this.ast.animation,i,a,Ee,tt,Tn,g,A);let Wn=0;if(Hn.forEach(fs=>{Wn=Math.max(fs.duration+fs.delay,Wn)}),A.length)return s4(s,this._triggerName,n,r,fn,Ee,tt,[],[],kt,on,Wn,A);Hn.forEach(fs=>{const Ks=fs.element,Hr=Rh(kt,Ks,new Set);fs.preStyleProps.forEach(jr=>Hr.add(jr));const xi=Rh(on,Ks,new Set);fs.postStyleProps.forEach(jr=>xi.add(jr)),Ks!==s&&Nt.add(Ks)});const xs=HI(Nt.values());return s4(s,this._triggerName,n,r,fn,Ee,tt,Hn,xs,kt,on,Wn)}}function rhe(t,e){const s=BC(e);for(const n in t)t.hasOwnProperty(n)&&null!=t[n]&&(s[n]=t[n]);return s}class ihe{constructor(e,s,n){this.styles=e,this.defaultParams=s,this.normalizer=n}buildStyles(e,s){const n=new Map,r=BC(this.defaultParams);return Object.keys(e).forEach(i=>{const a=e[i];null!==a&&(r[i]=a)}),this.styles.styles.forEach(i=>{"string"!=typeof i&&i.forEach((a,c)=>{a&&(a=UC(a,r,s));const f=this.normalizer.normalizePropertyName(c,s);a=this.normalizer.normalizeStyleValue(c,f,a,s),n.set(c,a)})}),n}}class ahe{constructor(e,s,n){this.name=e,this.ast=s,this._normalizer=n,this.transitionFactories=[],this.states=new Map,s.states.forEach(r=>{this.states.set(r.name,new ihe(r.style,r.options&&r.options.params||{},n))}),i4(this.states,"true","1"),i4(this.states,"false","0"),s.transitions.forEach(r=>{this.transitionFactories.push(new r4(e,r,this.states))}),this.fallbackTransition=function lhe(t,e,s){return new r4(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(a,c)=>!0],options:null,queryCount:0,depCount:0},e)}(e,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(e,s,n,r){return this.transitionFactories.find(a=>a.match(e,s,n,r))||null}matchStyles(e,s,n){return this.fallbackTransition.buildStyles(e,s,n)}}function i4(t,e,s){t.has(e)?t.has(s)||t.set(s,t.get(e)):t.has(s)&&t.set(e,t.get(s))}const che=new XI;class uhe{constructor(e,s,n){this.bodyNode=e,this._driver=s,this._normalizer=n,this._animations=new Map,this._playersById=new Map,this.players=[]}register(e,s){const n=[],i=NN(this._driver,s,n,[]);if(n.length)throw function fde(t){return new En(3503,!1)}();this._animations.set(e,i)}_buildPlayer(e,s,n){const r=e.element,i=Uz(this._normalizer,e.keyframes,s,n);return this._driver.animate(r,i,e.duration,e.delay,e.easing,[],!0)}create(e,s,n={}){const r=[],i=this._animations.get(e);let a;const c=new Map;if(i?(a=FN(this._driver,s,i,TN,VI,new Map,new Map,n,che,r),a.forEach(E=>{const A=Rh(c,E.element,new Map);E.postStyleProps.forEach(Y=>A.set(Y,null))})):(r.push(function mde(){return new En(3300,!1)}()),a=[]),r.length)throw function gde(t){return new En(3504,!1)}();c.forEach((E,A)=>{E.forEach((Y,ne)=>{E.set(ne,this._driver.computeStyle(A,ne,Bm))})});const g=y_(a.map(E=>{const A=c.get(E.element);return this._buildPlayer(E,new Map,A)}));return this._playersById.set(e,g),g.onDestroy(()=>this.destroy(e)),this.players.push(g),g}destroy(e){const s=this._getPlayer(e);s.destroy(),this._playersById.delete(e);const n=this.players.indexOf(s);n>=0&&this.players.splice(n,1)}_getPlayer(e){const s=this._playersById.get(e);if(!s)throw function _de(t){return new En(3301,!1)}();return s}listen(e,s,n,r){const i=DN(s,"","","");return CN(this._getPlayer(e),n,i,r),()=>{}}command(e,s,n,r){if("register"==n)return void this.register(e,r[0]);if("create"==n)return void this.create(e,s,r[0]||{});const i=this._getPlayer(e);switch(n){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(r[0]));break;case"destroy":this.destroy(e)}}}const o4="ng-animate-queued",VN="ng-animate-disabled",mhe=[],a4={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},ghe={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Yp="__ng_removed";class UN{get params(){return this.options.params}constructor(e,s=""){this.namespaceId=s;const n=e&&e.hasOwnProperty("value");if(this.value=function bhe(t){return t??null}(n?e.value:e),n){const i=BC(e);delete i.value,this.options=i}else this.options={};this.options.params||(this.options.params={})}absorbOptions(e){const s=e.params;if(s){const n=this.options.params;Object.keys(s).forEach(r=>{null==n[r]&&(n[r]=s[r])})}}}const zC="void",zN=new UN(zC);class _he{constructor(e,s,n){this.id=e,this.hostElement=s,this._engine=n,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+e,mp(s,this._hostClassName)}listen(e,s,n,r){if(!this._triggers.has(s))throw function yde(t,e){return new En(3302,!1)}();if(null==n||0==n.length)throw function vde(t){return new En(3303,!1)}();if(!function xhe(t){return"start"==t||"done"==t}(n))throw function bde(t,e){return new En(3400,!1)}();const i=Rh(this._elementListeners,e,[]),a={name:s,phase:n,callback:r};i.push(a);const c=Rh(this._engine.statesByElement,e,new Map);return c.has(s)||(mp(e,UI),mp(e,UI+"-"+s),c.set(s,zN)),()=>{this._engine.afterFlush(()=>{const f=i.indexOf(a);f>=0&&i.splice(f,1),this._triggers.has(s)||c.delete(s)})}}register(e,s){return!this._triggers.has(e)&&(this._triggers.set(e,s),!0)}_getTrigger(e){const s=this._triggers.get(e);if(!s)throw function xde(t){return new En(3401,!1)}();return s}trigger(e,s,n,r=!0){const i=this._getTrigger(s),a=new WN(this.id,s,e);let c=this._engine.statesByElement.get(e);c||(mp(e,UI),mp(e,UI+"-"+s),this._engine.statesByElement.set(e,c=new Map));let f=c.get(s);const g=new UN(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&f&&g.absorbOptions(f.options),c.set(s,g),f||(f=zN),g.value!==zC&&f.value===g.value){if(!function Ehe(t,e){const s=Object.keys(t),n=Object.keys(e);if(s.length!=n.length)return!1;for(let r=0;r<s.length;r++){const i=s[r];if(!e.hasOwnProperty(i)||t[i]!==e[i])return!1}return!0}(f.params,g.params)){const Ge=[],tt=i.matchStyles(f.value,f.params,Ge),Nt=i.matchStyles(g.value,g.params,Ge);Ge.length?this._engine.reportError(Ge):this._engine.afterFlush(()=>{x0(e,tt),$f(e,Nt)})}return}const Y=Rh(this._engine.playersByElement,e,[]);Y.forEach(Ge=>{Ge.namespaceId==this.id&&Ge.triggerName==s&&Ge.queued&&Ge.destroy()});let ne=i.matchTransition(f.value,g.value,e,g.params),Ee=!1;if(!ne){if(!r)return;ne=i.fallbackTransition,Ee=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:e,triggerName:s,transition:ne,fromState:f,toState:g,player:a,isFallbackTransition:Ee}),Ee||(mp(e,o4),a.onStart(()=>{Wb(e,o4)})),a.onDone(()=>{let Ge=this.players.indexOf(a);Ge>=0&&this.players.splice(Ge,1);const tt=this._engine.playersByElement.get(e);if(tt){let Nt=tt.indexOf(a);Nt>=0&&tt.splice(Nt,1)}}),this.players.push(a),Y.push(a),a}deregister(e){this._triggers.delete(e),this._engine.statesByElement.forEach(s=>s.delete(e)),this._elementListeners.forEach((s,n)=>{this._elementListeners.set(n,s.filter(r=>r.name!=e))})}clearElementCache(e){this._engine.statesByElement.delete(e),this._elementListeners.delete(e);const s=this._engine.playersByElement.get(e);s&&(s.forEach(n=>n.destroy()),this._engine.playersByElement.delete(e))}_signalRemovalForInnerTriggers(e,s){const n=this._engine.driver.query(e,zI,!0);n.forEach(r=>{if(r[Yp])return;const i=this._engine.fetchNamespacesByElement(r);i.size?i.forEach(a=>a.triggerLeaveAnimation(r,s,!1,!0)):this.clearElementCache(r)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(r=>this.clearElementCache(r)))}triggerLeaveAnimation(e,s,n,r){const i=this._engine.statesByElement.get(e),a=new Map;if(i){const c=[];if(i.forEach((f,g)=>{if(a.set(g,f.value),this._triggers.has(g)){const E=this.trigger(e,g,zC,r);E&&c.push(E)}}),c.length)return this._engine.markElementAsRemoved(this.id,e,!0,s,a),n&&y_(c).onDone(()=>this._engine.processLeaveNode(e)),!0}return!1}prepareLeaveAnimationListeners(e){const s=this._elementListeners.get(e),n=this._engine.statesByElement.get(e);if(s&&n){const r=new Set;s.forEach(i=>{const a=i.name;if(r.has(a))return;r.add(a);const f=this._triggers.get(a).fallbackTransition,g=n.get(a)||zN,E=new UN(zC),A=new WN(this.id,a,e);this._engine.totalQueuedPlayers++,this._queue.push({element:e,triggerName:a,transition:f,fromState:g,toState:E,player:A,isFallbackTransition:!0})})}}removeNode(e,s){const n=this._engine;if(e.childElementCount&&this._signalRemovalForInnerTriggers(e,s),this.triggerLeaveAnimation(e,s,!0))return;let r=!1;if(n.totalAnimations){const i=n.players.length?n.playersByQueriedElement.get(e):[];if(i&&i.length)r=!0;else{let a=e;for(;a=a.parentNode;)if(n.statesByElement.get(a)){r=!0;break}}}if(this.prepareLeaveAnimationListeners(e),r)n.markElementAsRemoved(this.id,e,!1,s);else{const i=e[Yp];(!i||i===a4)&&(n.afterFlush(()=>this.clearElementCache(e)),n.destroyInnerAnimations(e),n._onRemovalComplete(e,s))}}insertNode(e,s){mp(e,this._hostClassName)}drainQueuedTransitions(e){const s=[];return this._queue.forEach(n=>{const r=n.player;if(r.destroyed)return;const i=n.element,a=this._elementListeners.get(i);a&&a.forEach(c=>{if(c.name==n.triggerName){const f=DN(i,n.triggerName,n.fromState.value,n.toState.value);f._data=e,CN(n.player,c.phase,f,c.callback)}}),r.markedForDestroy?this._engine.afterFlush(()=>{r.destroy()}):s.push(n)}),this._queue=[],s.sort((n,r)=>{const i=n.transition.ast.depCount,a=r.transition.ast.depCount;return 0==i||0==a?i-a:this._engine.driver.containsElement(n.element,r.element)?1:-1})}destroy(e){this.players.forEach(s=>s.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,e)}}class yhe{_onRemovalComplete(e,s){this.onRemovalComplete(e,s)}constructor(e,s,n){this.bodyNode=e,this.driver=s,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(r,i)=>{}}get queuedPlayers(){const e=[];return this._namespaceList.forEach(s=>{s.players.forEach(n=>{n.queued&&e.push(n)})}),e}createNamespace(e,s){const n=new _he(e,s,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,s)?this._balanceNamespaceList(n,s):(this.newHostElements.set(s,n),this.collectEnterElement(s)),this._namespaceLookup[e]=n}_balanceNamespaceList(e,s){const n=this._namespaceList,r=this.namespacesByHostElement;if(n.length-1>=0){let a=!1,c=this.driver.getParentElement(s);for(;c;){const f=r.get(c);if(f){const g=n.indexOf(f);n.splice(g+1,0,e),a=!0;break}c=this.driver.getParentElement(c)}a||n.unshift(e)}else n.push(e);return r.set(s,e),e}register(e,s){let n=this._namespaceLookup[e];return n||(n=this.createNamespace(e,s)),n}registerTrigger(e,s,n){let r=this._namespaceLookup[e];r&&r.register(s,n)&&this.totalAnimations++}destroy(e,s){e&&(this.afterFlush(()=>{}),this.afterFlushAnimationsDone(()=>{const n=this._fetchNamespace(e);this.namespacesByHostElement.delete(n.hostElement);const r=this._namespaceList.indexOf(n);r>=0&&this._namespaceList.splice(r,1),n.destroy(s),delete this._namespaceLookup[e]}))}_fetchNamespace(e){return this._namespaceLookup[e]}fetchNamespacesByElement(e){const s=new Set,n=this.statesByElement.get(e);if(n)for(let r of n.values())if(r.namespaceId){const i=this._fetchNamespace(r.namespaceId);i&&s.add(i)}return s}trigger(e,s,n,r){if(QI(s)){const i=this._fetchNamespace(e);if(i)return i.trigger(s,n,r),!0}return!1}insertNode(e,s,n,r){if(!QI(s))return;const i=s[Yp];if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const a=this.collectedLeaveElements.indexOf(s);a>=0&&this.collectedLeaveElements.splice(a,1)}if(e){const a=this._fetchNamespace(e);a&&a.insertNode(s,n)}r&&this.collectEnterElement(s)}collectEnterElement(e){this.collectedEnterElements.push(e)}markElementAsDisabled(e,s){s?this.disabledNodes.has(e)||(this.disabledNodes.add(e),mp(e,VN)):this.disabledNodes.has(e)&&(this.disabledNodes.delete(e),Wb(e,VN))}removeNode(e,s,n){if(QI(s)){const r=e?this._fetchNamespace(e):null;r?r.removeNode(s,n):this.markElementAsRemoved(e,s,!1,n);const i=this.namespacesByHostElement.get(s);i&&i.id!==e&&i.removeNode(s,n)}else this._onRemovalComplete(s,n)}markElementAsRemoved(e,s,n,r,i){this.collectedLeaveElements.push(s),s[Yp]={namespaceId:e,setForRemoval:r,hasAnimation:n,removedBeforeQueried:!1,previousTriggersValues:i}}listen(e,s,n,r,i){return QI(s)?this._fetchNamespace(e).listen(s,n,r,i):()=>{}}_buildInstruction(e,s,n,r,i){return e.transition.build(this.driver,e.element,e.fromState.value,e.toState.value,n,r,e.fromState.options,e.toState.options,s,i)}destroyInnerAnimations(e){let s=this.driver.query(e,zI,!0);s.forEach(n=>this.destroyActiveAnimationsForElement(n)),0!=this.playersByQueriedElement.size&&(s=this.driver.query(e,AN,!0),s.forEach(n=>this.finishActiveQueriedAnimationOnElement(n)))}destroyActiveAnimationsForElement(e){const s=this.playersByElement.get(e);s&&s.forEach(n=>{n.queued?n.markedForDestroy=!0:n.destroy()})}finishActiveQueriedAnimationOnElement(e){const s=this.playersByQueriedElement.get(e);s&&s.forEach(n=>n.finish())}whenRenderingDone(){return new Promise(e=>{if(this.players.length)return y_(this.players).onDone(()=>e());e()})}processLeaveNode(e){const s=e[Yp];if(s&&s.setForRemoval){if(e[Yp]=a4,s.namespaceId){this.destroyInnerAnimations(e);const n=this._fetchNamespace(s.namespaceId);n&&n.clearElementCache(e)}this._onRemovalComplete(e,s.setForRemoval)}e.classList?.contains(VN)&&this.markElementAsDisabled(e,!1),this.driver.query(e,".ng-animate-disabled",!0).forEach(n=>{this.markElementAsDisabled(n,!1)})}flush(e=-1){let s=[];if(this.newHostElements.size&&(this.newHostElements.forEach((n,r)=>this._balanceNamespaceList(n,r)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)mp(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{s=this._flushAnimations(n,e)}finally{for(let r=0;r<n.length;r++)n[r]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(n=>n()),this._flushFns=[],this._whenQuietFns.length){const n=this._whenQuietFns;this._whenQuietFns=[],s.length?y_(s).onDone(()=>{n.forEach(r=>r())}):n.forEach(r=>r())}}reportError(e){throw function wde(t){return new En(3402,!1)}()}_flushAnimations(e,s){const n=new XI,r=[],i=new Map,a=[],c=new Map,f=new Map,g=new Map,E=new Set;this.disabledNodes.forEach(ws=>{E.add(ws);const Mr=this.driver.query(ws,".ng-animate-queued",!0);for(let Qr=0;Qr<Mr.length;Qr++)E.add(Mr[Qr])});const A=this.bodyNode,Y=Array.from(this.statesByElement.keys()),ne=u4(Y,this.collectedEnterElements),Ee=new Map;let Ge=0;ne.forEach((ws,Mr)=>{const Qr=TN+Ge++;Ee.set(Mr,Qr),ws.forEach(Wi=>mp(Wi,Qr))});const tt=[],Nt=new Set,kt=new Set;for(let ws=0;ws<this.collectedLeaveElements.length;ws++){const Mr=this.collectedLeaveElements[ws],Qr=Mr[Yp];Qr&&Qr.setForRemoval&&(tt.push(Mr),Nt.add(Mr),Qr.hasAnimation?this.driver.query(Mr,".ng-star-inserted",!0).forEach(Wi=>Nt.add(Wi)):kt.add(Mr))}const on=new Map,fn=u4(Y,Array.from(Nt));fn.forEach((ws,Mr)=>{const Qr=VI+Ge++;on.set(Mr,Qr),ws.forEach(Wi=>mp(Wi,Qr))}),e.push(()=>{ne.forEach((ws,Mr)=>{const Qr=Ee.get(Mr);ws.forEach(Wi=>Wb(Wi,Qr))}),fn.forEach((ws,Mr)=>{const Qr=on.get(Mr);ws.forEach(Wi=>Wb(Wi,Qr))}),tt.forEach(ws=>{this.processLeaveNode(ws)})});const Tn=[],Hn=[];for(let ws=this._namespaceList.length-1;ws>=0;ws--)this._namespaceList[ws].drainQueuedTransitions(s).forEach(Qr=>{const Wi=Qr.player,rc=Qr.element;if(Tn.push(Wi),this.collectedEnterElements.length){const bd=rc[Yp];if(bd&&bd.setForMove){if(bd.previousTriggersValues&&bd.previousTriggersValues.has(Qr.triggerName)){const C0=bd.previousTriggersValues.get(Qr.triggerName),gp=this.statesByElement.get(Qr.element);if(gp&&gp.has(Qr.triggerName)){const nT=gp.get(Qr.triggerName);nT.value=C0,gp.set(Qr.triggerName,nT)}}return void Wi.destroy()}}const vu=!A||!this.driver.containsElement(A,rc),vd=on.get(rc),Bf=Ee.get(rc),Cc=this._buildInstruction(Qr,n,Bf,vd,vu);if(Cc.errors&&Cc.errors.length)return void Hn.push(Cc);if(vu)return Wi.onStart(()=>x0(rc,Cc.fromStyles)),Wi.onDestroy(()=>$f(rc,Cc.toStyles)),void r.push(Wi);if(Qr.isFallbackTransition)return Wi.onStart(()=>x0(rc,Cc.fromStyles)),Wi.onDestroy(()=>$f(rc,Cc.toStyles)),void r.push(Wi);const k4=[];Cc.timelines.forEach(bd=>{bd.stretchStartingKeyframe=!0,this.disabledNodes.has(bd.element)||k4.push(bd)}),Cc.timelines=k4,n.append(rc,Cc.timelines),a.push({instruction:Cc,player:Wi,element:rc}),Cc.queriedElements.forEach(bd=>Rh(c,bd,[]).push(Wi)),Cc.preStyleProps.forEach((bd,C0)=>{if(bd.size){let gp=f.get(C0);gp||f.set(C0,gp=new Set),bd.forEach((nT,YN)=>gp.add(YN))}}),Cc.postStyleProps.forEach((bd,C0)=>{let gp=g.get(C0);gp||g.set(C0,gp=new Set),bd.forEach((nT,YN)=>gp.add(YN))})});if(Hn.length){const ws=[];Hn.forEach(Mr=>{ws.push(function Cde(t,e){return new En(3505,!1)}())}),Tn.forEach(Mr=>Mr.destroy()),this.reportError(ws)}const Wn=new Map,xs=new Map;a.forEach(ws=>{const Mr=ws.element;n.has(Mr)&&(xs.set(Mr,Mr),this._beforeAnimationBuild(ws.player.namespaceId,ws.instruction,Wn))}),r.forEach(ws=>{const Mr=ws.element;this._getPreviousPlayers(Mr,!1,ws.namespaceId,ws.triggerName,null).forEach(Wi=>{Rh(Wn,Mr,[]).push(Wi),Wi.destroy()})});const fs=tt.filter(ws=>h4(ws,f,g)),Ks=new Map;c4(Ks,this.driver,kt,g,Bm).forEach(ws=>{h4(ws,f,g)&&fs.push(ws)});const xi=new Map;ne.forEach((ws,Mr)=>{c4(xi,this.driver,new Set(ws),f,"!")}),fs.forEach(ws=>{const Mr=Ks.get(ws),Qr=xi.get(ws);Ks.set(ws,new Map([...Mr?.entries()??[],...Qr?.entries()??[]]))});const jr=[],Co=[],ba={};a.forEach(ws=>{const{element:Mr,player:Qr,instruction:Wi}=ws;if(n.has(Mr)){if(E.has(Mr))return Qr.onDestroy(()=>$f(Mr,Wi.toStyles)),Qr.disabled=!0,Qr.overrideTotalTime(Wi.totalTime),void r.push(Qr);let rc=ba;if(xs.size>1){let vd=Mr;const Bf=[];for(;vd=vd.parentNode;){const Cc=xs.get(vd);if(Cc){rc=Cc;break}Bf.push(vd)}Bf.forEach(Cc=>xs.set(Cc,rc))}const vu=this._buildAnimation(Qr.namespaceId,Wi,Wn,i,xi,Ks);if(Qr.setRealPlayer(vu),rc===ba)jr.push(Qr);else{const vd=this.playersByElement.get(rc);vd&&vd.length&&(Qr.parentPlayer=y_(vd)),r.push(Qr)}}else x0(Mr,Wi.fromStyles),Qr.onDestroy(()=>$f(Mr,Wi.toStyles)),Co.push(Qr),E.has(Mr)&&r.push(Qr)}),Co.forEach(ws=>{const Mr=i.get(ws.element);if(Mr&&Mr.length){const Qr=y_(Mr);ws.setRealPlayer(Qr)}}),r.forEach(ws=>{ws.parentPlayer?ws.syncPlayerEvents(ws.parentPlayer):ws.destroy()});for(let ws=0;ws<tt.length;ws++){const Mr=tt[ws],Qr=Mr[Yp];if(Wb(Mr,VI),Qr&&Qr.hasAnimation)continue;let Wi=[];if(c.size){let vu=c.get(Mr);vu&&vu.length&&Wi.push(...vu);let vd=this.driver.query(Mr,AN,!0);for(let Bf=0;Bf<vd.length;Bf++){let Cc=c.get(vd[Bf]);Cc&&Cc.length&&Wi.push(...Cc)}}const rc=Wi.filter(vu=>!vu.destroyed);rc.length?whe(this,Mr,rc):this.processLeaveNode(Mr)}return tt.length=0,jr.forEach(ws=>{this.players.push(ws),ws.onDone(()=>{ws.destroy();const Mr=this.players.indexOf(ws);this.players.splice(Mr,1)}),ws.play()}),jr}afterFlush(e){this._flushFns.push(e)}afterFlushAnimationsDone(e){this._whenQuietFns.push(e)}_getPreviousPlayers(e,s,n,r,i){let a=[];if(s){const c=this.playersByQueriedElement.get(e);c&&(a=c)}else{const c=this.playersByElement.get(e);if(c){const f=!i||i==zC;c.forEach(g=>{g.queued||!f&&g.triggerName!=r||a.push(g)})}}return(n||r)&&(a=a.filter(c=>!(n&&n!=c.namespaceId||r&&r!=c.triggerName))),a}_beforeAnimationBuild(e,s,n){const i=s.element,a=s.isRemovalTransition?void 0:e,c=s.isRemovalTransition?void 0:s.triggerName;for(const f of s.timelines){const g=f.element,E=g!==i,A=Rh(n,g,[]);this._getPreviousPlayers(g,E,a,c,s.toState).forEach(ne=>{const Ee=ne.getRealPlayer();Ee.beforeDestroy&&Ee.beforeDestroy(),ne.destroy(),A.push(ne)})}x0(i,s.fromStyles)}_buildAnimation(e,s,n,r,i,a){const c=s.triggerName,f=s.element,g=[],E=new Set,A=new Set,Y=s.timelines.map(Ee=>{const Ge=Ee.element;E.add(Ge);const tt=Ge[Yp];if(tt&&tt.removedBeforeQueried)return new vC(Ee.duration,Ee.delay);const Nt=Ge!==f,kt=function Che(t){const e=[];return d4(t,e),e}((n.get(Ge)||mhe).map(Wn=>Wn.getRealPlayer())).filter(Wn=>!!Wn.element&&Wn.element===Ge),on=i.get(Ge),fn=a.get(Ge),Tn=Uz(this._normalizer,Ee.keyframes,on,fn),Hn=this._buildPlayer(Ee,Tn,kt);if(Ee.subTimeline&&r&&A.add(Ge),Nt){const Wn=new WN(e,c,Ge);Wn.setRealPlayer(Hn),g.push(Wn)}return Hn});g.forEach(Ee=>{Rh(this.playersByQueriedElement,Ee.element,[]).push(Ee),Ee.onDone(()=>function vhe(t,e,s){let n=t.get(e);if(n){if(n.length){const r=n.indexOf(s);n.splice(r,1)}0==n.length&&t.delete(e)}return n}(this.playersByQueriedElement,Ee.element,Ee))}),E.forEach(Ee=>mp(Ee,Xz));const ne=y_(Y);return ne.onDestroy(()=>{E.forEach(Ee=>Wb(Ee,Xz)),$f(f,s.toStyles)}),A.forEach(Ee=>{Rh(r,Ee,[]).push(ne)}),ne}_buildPlayer(e,s,n){return s.length>0?this.driver.animate(e.element,s,e.duration,e.delay,e.easing,n):new vC(e.duration,e.delay)}}class WN{constructor(e,s,n){this.namespaceId=e,this.triggerName=s,this.element=n,this._player=new vC,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.parentPlayer=null,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(e){this._containsRealPlayer||(this._player=e,this._queuedCallbacks.forEach((s,n)=>{s.forEach(r=>CN(e,n,void 0,r))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(e.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(e){this.totalTime=e}syncPlayerEvents(e){const s=this._player;s.triggerCallback&&e.onStart(()=>s.triggerCallback("start")),e.onDone(()=>this.finish()),e.onDestroy(()=>this.destroy())}_queueEvent(e,s){Rh(this._queuedCallbacks,e,[]).push(s)}onDone(e){this.queued&&this._queueEvent("done",e),this._player.onDone(e)}onStart(e){this.queued&&this._queueEvent("start",e),this._player.onStart(e)}onDestroy(e){this.queued&&this._queueEvent("destroy",e),this._player.onDestroy(e)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(e){this.queued||this._player.setPosition(e)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(e){const s=this._player;s.triggerCallback&&s.triggerCallback(e)}}function QI(t){return t&&1===t.nodeType}function l4(t,e){const s=t.style.display;return t.style.display=e??"none",s}function c4(t,e,s,n,r){const i=[];s.forEach(f=>i.push(l4(f)));const a=[];n.forEach((f,g)=>{const E=new Map;f.forEach(A=>{const Y=e.computeStyle(g,A,r);E.set(A,Y),(!Y||0==Y.length)&&(g[Yp]=ghe,a.push(g))}),t.set(g,E)});let c=0;return s.forEach(f=>l4(f,i[c++])),a}function u4(t,e){const s=new Map;if(t.forEach(c=>s.set(c,[])),0==e.length)return s;const r=new Set(e),i=new Map;function a(c){if(!c)return 1;let f=i.get(c);if(f)return f;const g=c.parentNode;return f=s.has(g)?g:r.has(g)?1:a(g),i.set(c,f),f}return e.forEach(c=>{const f=a(c);1!==f&&s.get(f).push(c)}),s}function mp(t,e){t.classList?.add(e)}function Wb(t,e){t.classList?.remove(e)}function whe(t,e,s){y_(s).onDone(()=>t.processLeaveNode(e))}function d4(t,e){for(let s=0;s<t.length;s++){const n=t[s];n instanceof dB?d4(n.players,e):e.push(n)}}function h4(t,e,s){const n=s.get(t);if(!n)return!1;let r=e.get(t);return r?n.forEach(i=>r.add(i)):e.set(t,n),s.delete(t),!0}class JI{constructor(e,s,n){this.bodyNode=e,this._driver=s,this._normalizer=n,this._triggerCache={},this.onRemovalComplete=(r,i)=>{},this._transitionEngine=new yhe(e,s,n),this._timelineEngine=new uhe(e,s,n),this._transitionEngine.onRemovalComplete=(r,i)=>this.onRemovalComplete(r,i)}registerTrigger(e,s,n,r,i){const a=e+"-"+r;let c=this._triggerCache[a];if(!c){const f=[],E=NN(this._driver,i,f,[]);if(f.length)throw function hde(t,e){return new En(3404,!1)}();c=function ohe(t,e,s){return new ahe(t,e,s)}(r,E,this._normalizer),this._triggerCache[a]=c}this._transitionEngine.registerTrigger(s,r,c)}register(e,s){this._transitionEngine.register(e,s)}destroy(e,s){this._transitionEngine.destroy(e,s)}onInsert(e,s,n,r){this._transitionEngine.insertNode(e,s,n,r)}onRemove(e,s,n){this._transitionEngine.removeNode(e,s,n)}disableAnimations(e,s){this._transitionEngine.markElementAsDisabled(e,s)}process(e,s,n,r){if("@"==n.charAt(0)){const[i,a]=zz(n);this._timelineEngine.command(i,s,a,r)}else this._transitionEngine.trigger(e,s,n,r)}listen(e,s,n,r,i){if("@"==n.charAt(0)){const[a,c]=zz(n);return this._timelineEngine.listen(a,s,c,i)}return this._transitionEngine.listen(e,s,n,r,i)}flush(e=-1){this._transitionEngine.flush(e)}get players(){return[...this._transitionEngine.players,...this._timelineEngine.players]}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}afterFlushAnimationsDone(e){this._transitionEngine.afterFlushAnimationsDone(e)}}let She=(()=>{class e{constructor(n,r,i){this._element=n,this._startStyles=r,this._endStyles=i,this._state=0;let a=e.initialStylesByElement.get(n);a||e.initialStylesByElement.set(n,a=new Map),this._initialStyles=a}start(){this._state<1&&(this._startStyles&&$f(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&($f(this._element,this._initialStyles),this._endStyles&&($f(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(e.initialStylesByElement.delete(this._element),this._startStyles&&(x0(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(x0(this._element,this._endStyles),this._endStyles=null),$f(this._element,this._initialStyles),this._state=3)}}return e.initialStylesByElement=new WeakMap,e})();function HN(t){let e=null;return t.forEach((s,n)=>{(function Ihe(t){return"display"===t||"position"===t})(n)&&(e=e||new Map,e.set(n,s))}),e}class p4{constructor(e,s,n,r){this.element=e,this.keyframes=s,this.options=n,this._specialStyles=r,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(e=>e()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const e=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,e,this.options),this._finalKeyframe=e.length?e[e.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(e){const s=[];return e.forEach(n=>{s.push(Object.fromEntries(n))}),s}_triggerWebAnimation(e,s,n){return e.animate(this._convertKeyframesToObject(s),n)}onStart(e){this._originalOnStartFns.push(e),this._onStartFns.push(e)}onDone(e){this._originalOnDoneFns.push(e),this._onDoneFns.push(e)}onDestroy(e){this._onDestroyFns.push(e)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(e=>e()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(e=>e()),this._onDestroyFns=[])}setPosition(e){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=e*this.time}getPosition(){return+(this.domPlayer.currentTime??0)/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const e=new Map;this.hasStarted()&&this._finalKeyframe.forEach((n,r)=>{"offset"!==r&&e.set(r,this._finished?n:Jz(this.element,r))}),this.currentSnapshot=e}triggerCallback(e){const s="start"===e?this._onStartFns:this._onDoneFns;s.forEach(n=>n()),s.length=0}}class The{validateStyleProperty(e){return!0}validateAnimatableStyleProperty(e){return!0}matchesElement(e,s){return!1}containsElement(e,s){return Hz(e,s)}getParentElement(e){return SN(e)}query(e,s,n){return jz(e,s,n)}computeStyle(e,s,n){return window.getComputedStyle(e)[s]}animate(e,s,n,r,i,a=[]){const f={duration:n,delay:r,fill:0==r?"both":"forwards"};i&&(f.easing=i);const g=new Map,E=a.filter(ne=>ne instanceof p4);(function Pde(t,e){return 0===t||0===e})(n,r)&&E.forEach(ne=>{ne.currentSnapshot.forEach((Ee,Ge)=>g.set(Ge,Ee))});let A=function Rde(t){return t.length?t[0]instanceof Map?t:t.map(e=>Yz(e)):[]}(s).map(ne=>v_(ne));A=function Fde(t,e,s){if(s.size&&e.length){let n=e[0],r=[];if(s.forEach((i,a)=>{n.has(a)||r.push(a),n.set(a,i)}),r.length)for(let i=1;i<e.length;i++){let a=e[i];r.forEach(c=>a.set(c,Jz(t,c)))}}return e}(e,A,g);const Y=function Dhe(t,e){let s=null,n=null;return Array.isArray(e)&&e.length?(s=HN(e[0]),e.length>1&&(n=HN(e[e.length-1]))):e instanceof Map&&(s=HN(e)),s||n?new She(t,s,n):null}(e,A);return new p4(e,A,f,Y)}}let Ahe=(()=>{var t;class e extends cB{constructor(n,r){super(),this._nextAnimationId=0,this._renderer=n.createRenderer(r.body,{id:"0",encapsulation:oo.None,styles:[],data:{animation:[]}})}build(n){const r=this._nextAnimationId.toString();this._nextAnimationId++;const i=Array.isArray(n)?uB(n):n;return f4(this._renderer,null,r,"register",[i]),new khe(r,this._renderer)}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(tp),cn(yi))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();class khe extends J9{constructor(e,s){super(),this._id=e,this._renderer=s}create(e,s){return new Ohe(this._id,e,s||{},this._renderer)}}class Ohe{constructor(e,s,n,r){this.id=e,this.element=s,this._renderer=r,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(e,s){return this._renderer.listen(this.element,`@@${this.id}:${e}`,s)}_command(e,...s){return f4(this._renderer,this.element,this.id,e,s)}onDone(e){this._listen("done",e)}onStart(e){this._listen("start",e)}onDestroy(e){this._listen("destroy",e)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(e){this._command("setPosition",e)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function f4(t,e,s,n,r){return t.setProperty(e,`@@${s}:${n}`,r)}const m4="@.disabled";let Rhe=(()=>{var t;class e{constructor(n,r,i){this.delegate=n,this.engine=r,this._zone=i,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,r.onRemovalComplete=(a,c)=>{const f=c?.parentNode(a);f&&c.removeChild(f,a)}}createRenderer(n,r){const a=this.delegate.createRenderer(n,r);if(!(n&&r&&r.data&&r.data.animation)){let A=this._rendererCache.get(a);return A||(A=new g4("",a,this.engine,()=>this._rendererCache.delete(a)),this._rendererCache.set(a,A)),A}const c=r.id,f=r.id+"-"+this._currentId;this._currentId++,this.engine.register(f,n);const g=A=>{Array.isArray(A)?A.forEach(g):this.engine.registerTrigger(c,f,n,A.name,A)};return r.data.animation.forEach(g),new Nhe(this,f,a,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){queueMicrotask(()=>{this._microtaskId++})}scheduleListenerCallback(n,r,i){n>=0&&n<this._microtaskId?this._zone.run(()=>r(i)):(0==this._animationCallbacksBuffer.length&&queueMicrotask(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(a=>{const[c,f]=a;c(f)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,i]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(tp),cn(JI),cn(Gs))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();class g4{constructor(e,s,n,r){this.namespaceId=e,this.delegate=s,this.engine=n,this._onDestroy=r}get data(){return this.delegate.data}destroyNode(e){this.delegate.destroyNode?.(e)}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.engine.afterFlushAnimationsDone(()=>{queueMicrotask(()=>{this.delegate.destroy()})}),this._onDestroy?.()}createElement(e,s){return this.delegate.createElement(e,s)}createComment(e){return this.delegate.createComment(e)}createText(e){return this.delegate.createText(e)}appendChild(e,s){this.delegate.appendChild(e,s),this.engine.onInsert(this.namespaceId,s,e,!1)}insertBefore(e,s,n,r=!0){this.delegate.insertBefore(e,s,n),this.engine.onInsert(this.namespaceId,s,e,r)}removeChild(e,s,n){this.engine.onRemove(this.namespaceId,s,this.delegate)}selectRootElement(e,s){return this.delegate.selectRootElement(e,s)}parentNode(e){return this.delegate.parentNode(e)}nextSibling(e){return this.delegate.nextSibling(e)}setAttribute(e,s,n,r){this.delegate.setAttribute(e,s,n,r)}removeAttribute(e,s,n){this.delegate.removeAttribute(e,s,n)}addClass(e,s){this.delegate.addClass(e,s)}removeClass(e,s){this.delegate.removeClass(e,s)}setStyle(e,s,n,r){this.delegate.setStyle(e,s,n,r)}removeStyle(e,s,n){this.delegate.removeStyle(e,s,n)}setProperty(e,s,n){"@"==s.charAt(0)&&s==m4?this.disableAnimations(e,!!n):this.delegate.setProperty(e,s,n)}setValue(e,s){this.delegate.setValue(e,s)}listen(e,s,n){return this.delegate.listen(e,s,n)}disableAnimations(e,s){this.engine.disableAnimations(e,s)}}class Nhe extends g4{constructor(e,s,n,r,i){super(s,n,r,i),this.factory=e,this.namespaceId=s}setProperty(e,s,n){"@"==s.charAt(0)?"."==s.charAt(1)&&s==m4?this.disableAnimations(e,n=void 0===n||!!n):this.engine.process(this.namespaceId,e,s.slice(1),n):this.delegate.setProperty(e,s,n)}listen(e,s,n){if("@"==s.charAt(0)){const r=function Mhe(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(e);let i=s.slice(1),a="";return"@"!=i.charAt(0)&&([i,a]=function Phe(t){const e=t.indexOf(".");return[t.substring(0,e),t.slice(e+1)]}(i)),this.engine.listen(this.namespaceId,r,i,a,c=>{this.factory.scheduleListenerCallback(c._data||-1,n,c)})}return this.delegate.listen(e,s,n)}}let Fhe=(()=>{var t;class e extends JI{constructor(n,r,i,a){super(n.body,r,i)}ngOnDestroy(){this.flush()}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(yi),cn(IN),cn($N),cn(i_))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();const _4=[{provide:cB,useClass:Ahe},{provide:$N,useFactory:function Lhe(){return new nhe}},{provide:JI,useClass:Fhe},{provide:tp,useFactory:function $he(t,e,s){return new Rhe(t,e,s)},deps:[F2,JI,Gs]}],jN=[{provide:IN,useFactory:()=>new The},{provide:ac,useValue:"BrowserAnimations"},..._4],y4=[{provide:IN,useClass:Gz},{provide:ac,useValue:"NoopAnimations"},..._4];let Bhe=(()=>{var t;class e{static withConfig(n){return{ngModule:e,providers:n.disableAnimations?y4:jN}}}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:jN,imports:[AF]}),e})();const Ghe={provide:new Zn("mat-autocomplete-scroll-strategy"),deps:[fp],useFactory:function jhe(t){return()=>t.scrollStrategies.reposition()}};let Yhe=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[Ghe],imports:[DC,WS,nl,Ah,Ab,WS,nl]}),e})();function Zhe(t,e){}class eT{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.closeOnNavigation=!0,this.closeOnDestroy=!0,this.closeOnOverlayDetachments=!0}}let x4=(()=>{var t;class e extends hR{constructor(n,r,i,a,c,f,g,E){super(),this._elementRef=n,this._focusTrapFactory=r,this._config=a,this._interactivityChecker=c,this._ngZone=f,this._overlayRef=g,this._focusMonitor=E,this._elementFocusedBeforeDialogWasOpened=null,this._closeInteractionType=null,this._ariaLabelledByQueue=[],this.attachDomPortal=A=>{this._portalOutlet.hasAttached();const Y=this._portalOutlet.attachDomPortal(A);return this._contentAttached(),Y},this._document=i,this._config.ariaLabelledBy&&this._ariaLabelledByQueue.push(this._config.ariaLabelledBy)}_contentAttached(){this._initializeFocusTrap(),this._handleBackdropClicks(),this._captureInitialFocus()}_captureInitialFocus(){this._trapFocus()}ngOnDestroy(){this._restoreFocus()}attachComponentPortal(n){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachComponentPortal(n);return this._contentAttached(),r}attachTemplatePortal(n){this._portalOutlet.hasAttached();const r=this._portalOutlet.attachTemplatePortal(n);return this._contentAttached(),r}_recaptureFocus(){this._containsFocus()||this._trapFocus()}_forceFocus(n,r){this._interactivityChecker.isFocusable(n)||(n.tabIndex=-1,this._ngZone.runOutsideAngular(()=>{const i=()=>{n.removeEventListener("blur",i),n.removeEventListener("mousedown",i),n.removeAttribute("tabindex")};n.addEventListener("blur",i),n.addEventListener("mousedown",i)})),n.focus(r)}_focusByCssSelector(n,r){let i=this._elementRef.nativeElement.querySelector(n);i&&this._forceFocus(i,r)}_trapFocus(){const n=this._elementRef.nativeElement;switch(this._config.autoFocus){case!1:case"dialog":this._containsFocus()||n.focus();break;case!0:case"first-tabbable":this._focusTrap.focusInitialElementWhenReady().then(r=>{r||this._focusDialogContainer()});break;case"first-heading":this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');break;default:this._focusByCssSelector(this._config.autoFocus)}}_restoreFocus(){const n=this._config.restoreFocus;let r=null;if("string"==typeof n?r=this._document.querySelector(n):"boolean"==typeof n?r=n?this._elementFocusedBeforeDialogWasOpened:null:n&&(r=n),this._config.restoreFocus&&r&&"function"==typeof r.focus){const i=$O(),a=this._elementRef.nativeElement;(!i||i===this._document.body||i===a||a.contains(i))&&(this._focusMonitor?(this._focusMonitor.focusVia(r,this._closeInteractionType),this._closeInteractionType=null):r.focus())}this._focusTrap&&this._focusTrap.destroy()}_focusDialogContainer(){this._elementRef.nativeElement.focus&&this._elementRef.nativeElement.focus()}_containsFocus(){const n=this._elementRef.nativeElement,r=$O();return n===r||n.contains(r)}_initializeFocusTrap(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._document&&(this._elementFocusedBeforeDialogWasOpened=$O())}_handleBackdropClicks(){this._overlayRef.backdropClick().subscribe(()=>{this._config.disableClose&&this._recaptureFocus()})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(KO),lt(yi,8),lt(eT),lt(LS),lt(Gs),lt(EC),lt($m))},t.\u0275cmp=sr({type:t,selectors:[["cdk-dialog-container"]],viewQuery:function(n,r){if(1&n&&qo(nI,7),2&n){let i;Ar(i=kr())&&(r._portalOutlet=i.first)}},hostAttrs:["tabindex","-1",1,"cdk-dialog-container"],hostVars:6,hostBindings:function(n,r){2&n&&si("id",r._config.id||null)("role",r._config.role)("aria-modal",r._config.ariaModal)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledByQueue[0])("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null)},features:[Ps],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(n,r){1&n&&Fs(0,Zhe,0,0,"ng-template",0)},dependencies:[nI],styles:[".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],encapsulation:2}),e})();class GN{constructor(e,s){this.overlayRef=e,this.config=s,this.closed=new Bt,this.disableClose=s.disableClose,this.backdropClick=e.backdropClick(),this.keydownEvents=e.keydownEvents(),this.outsidePointerEvents=e.outsidePointerEvents(),this.id=s.id,this.keydownEvents.subscribe(n=>{27===n.keyCode&&!this.disableClose&&!lh(n)&&(n.preventDefault(),this.close(void 0,{focusOrigin:"keyboard"}))}),this.backdropClick.subscribe(()=>{this.disableClose||this.close(void 0,{focusOrigin:"mouse"})}),this._detachSubscription=e.detachments().subscribe(()=>{!1!==s.closeOnOverlayDetachments&&this.close()})}close(e,s){if(this.containerInstance){const n=this.closed;this.containerInstance._closeInteractionType=s?.focusOrigin||"program",this._detachSubscription.unsubscribe(),this.overlayRef.dispose(),n.next(e),n.complete(),this.componentInstance=this.containerInstance=null}}updatePosition(){return this.overlayRef.updatePosition(),this}updateSize(e="",s=""){return this.overlayRef.updateSize({width:e,height:s}),this}addPanelClass(e){return this.overlayRef.addPanelClass(e),this}removePanelClass(e){return this.overlayRef.removePanelClass(e),this}}const w4=new Zn("DialogScrollStrategy"),Qhe=new Zn("DialogData"),Jhe=new Zn("DefaultDialogConfig"),epe={provide:w4,deps:[fp],useFactory:function qhe(t){return()=>t.scrollStrategies.block()}};let tpe=0,C4=(()=>{var t;class e{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}constructor(n,r,i,a,c,f){this._overlay=n,this._injector=r,this._defaultOptions=i,this._parentDialog=a,this._overlayContainer=c,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new Bt,this._afterOpenedAtThisLevel=new Bt,this._ariaHiddenElements=new Map,this.afterAllClosed=hb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(ed(void 0))),this._scrollStrategy=f}open(n,r){(r={...this._defaultOptions||new eT,...r}).id=r.id||"cdk-dialog-"+tpe++,r.id&&this.getDialogById(r.id);const a=this._getOverlayConfig(r),c=this._overlay.create(a),f=new GN(c,r),g=this._attachContainer(c,f,r);return f.containerInstance=g,this._attachDialogContent(n,f,g,r),this.openDialogs.length||this._hideNonDialogContentFromAssistiveTechnology(),this.openDialogs.push(f),f.closed.subscribe(()=>this._removeOpenDialog(f,!0)),this.afterOpened.next(f),f}closeAll(){KN(this.openDialogs,n=>n.close())}getDialogById(n){return this.openDialogs.find(r=>r.id===n)}ngOnDestroy(){KN(this._openDialogsAtThisLevel,n=>{!1===n.config.closeOnDestroy&&this._removeOpenDialog(n,!1)}),KN(this._openDialogsAtThisLevel,n=>n.close()),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete(),this._openDialogsAtThisLevel=[]}_getOverlayConfig(n){const r=new oI({positionStrategy:n.positionStrategy||this._overlay.position().global().centerHorizontally().centerVertically(),scrollStrategy:n.scrollStrategy||this._scrollStrategy(),panelClass:n.panelClass,hasBackdrop:n.hasBackdrop,direction:n.direction,minWidth:n.minWidth,minHeight:n.minHeight,maxWidth:n.maxWidth,maxHeight:n.maxHeight,width:n.width,height:n.height,disposeOnNavigation:n.closeOnNavigation});return n.backdropClass&&(r.backdropClass=n.backdropClass),r}_attachContainer(n,r,i){const a=i.injector||i.viewContainerRef?.injector,c=[{provide:eT,useValue:i},{provide:GN,useValue:r},{provide:EC,useValue:n}];let f;i.container?"function"==typeof i.container?f=i.container:(f=i.container.type,c.push(...i.container.providers(i))):f=x4;const g=new tI(f,i.viewContainerRef,Wc.create({parent:a||this._injector,providers:c}),i.componentFactoryResolver);return n.attach(g).instance}_attachDialogContent(n,r,i,a){if(n instanceof Hc){const c=this._createInjector(a,r,i,void 0);let f={$implicit:a.data,dialogRef:r};a.templateContext&&(f={...f,..."function"==typeof a.templateContext?a.templateContext():a.templateContext}),i.attachTemplatePortal(new xC(n,null,f,c))}else{const c=this._createInjector(a,r,i,this._injector),f=i.attachComponentPortal(new tI(n,a.viewContainerRef,c,a.componentFactoryResolver));r.componentRef=f,r.componentInstance=f.instance}}_createInjector(n,r,i,a){const c=n.injector||n.viewContainerRef?.injector,f=[{provide:Qhe,useValue:n.data},{provide:GN,useValue:r}];return n.providers&&("function"==typeof n.providers?f.push(...n.providers(r,n,i)):f.push(...n.providers)),n.direction&&(!c||!c.get(td,null,{optional:!0}))&&f.push({provide:td,useValue:{value:n.direction,change:Xs()}}),Wc.create({parent:c||a,providers:f})}_removeOpenDialog(n,r){const i=this.openDialogs.indexOf(n);i>-1&&(this.openDialogs.splice(i,1),this.openDialogs.length||(this._ariaHiddenElements.forEach((a,c)=>{a?c.setAttribute("aria-hidden",a):c.removeAttribute("aria-hidden")}),this._ariaHiddenElements.clear(),r&&this._getAfterAllClosed().next()))}_hideNonDialogContentFromAssistiveTechnology(){const n=this._overlayContainer.getContainerElement();if(n.parentElement){const r=n.parentElement.children;for(let i=r.length-1;i>-1;i--){const a=r[i];a!==n&&"SCRIPT"!==a.nodeName&&"STYLE"!==a.nodeName&&!a.hasAttribute("aria-live")&&(this._ariaHiddenElements.set(a,a.getAttribute("aria-hidden")),a.setAttribute("aria-hidden","true"))}}}_getAfterAllClosed(){const n=this._parentDialog;return n?n._getAfterAllClosed():this._afterAllClosedAtThisLevel}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(fp),cn(Wc),cn(Jhe,8),cn(t,12),cn(aI),cn(w4))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})();function KN(t,e){let s=t.length;for(;s--;)e(t[s])}let npe=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[C4,epe],imports:[DC,wC,M3,wC]}),e})();function spe(t,e){}class tT{constructor(){this.role="dialog",this.panelClass="",this.hasBackdrop=!0,this.backdropClass="",this.disableClose=!1,this.width="",this.height="",this.maxWidth="80vw",this.data=null,this.ariaDescribedBy=null,this.ariaLabelledBy=null,this.ariaLabel=null,this.ariaModal=!0,this.autoFocus="first-tabbable",this.restoreFocus=!0,this.delayFocusTrap=!0,this.closeOnNavigation=!0}}const XN="mdc-dialog--open",E4="mdc-dialog--opening",D4="mdc-dialog--closing";let ope=(()=>{var t;class e extends x4{constructor(n,r,i,a,c,f,g,E){super(n,r,i,a,c,f,g,E),this._animationStateChanged=new Rr}_captureInitialFocus(){this._config.delayFocusTrap||this._trapFocus()}_openAnimationDone(n){this._config.delayFocusTrap&&this._trapFocus(),this._animationStateChanged.next({state:"opened",totalTime:n})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(KO),lt(yi,8),lt(tT),lt(LS),lt(Gs),lt(EC),lt($m))},t.\u0275cmp=sr({type:t,selectors:[["ng-component"]],features:[Ps],decls:0,vars:0,template:function(n,r){},encapsulation:2}),e})();const S4="--mat-dialog-transition-duration";function I4(t){return null==t?null:"number"==typeof t?t:t.endsWith("ms")?Bl(t.substring(0,t.length-2)):t.endsWith("s")?1e3*Bl(t.substring(0,t.length-1)):"0"===t?0:null}let ape=(()=>{var t;class e extends ope{constructor(n,r,i,a,c,f,g,E,A){super(n,r,i,a,c,f,g,A),this._animationMode=E,this._animationsEnabled="NoopAnimations"!==this._animationMode,this._hostElement=this._elementRef.nativeElement,this._enterAnimationDuration=this._animationsEnabled?I4(this._config.enterAnimationDuration)??150:0,this._exitAnimationDuration=this._animationsEnabled?I4(this._config.exitAnimationDuration)??75:0,this._animationTimer=null,this._finishDialogOpen=()=>{this._clearAnimationClasses(),this._openAnimationDone(this._enterAnimationDuration)},this._finishDialogClose=()=>{this._clearAnimationClasses(),this._animationStateChanged.emit({state:"closed",totalTime:this._exitAnimationDuration})}}_contentAttached(){super._contentAttached(),this._startOpenAnimation()}ngOnDestroy(){super.ngOnDestroy(),null!==this._animationTimer&&clearTimeout(this._animationTimer)}_startOpenAnimation(){this._animationStateChanged.emit({state:"opening",totalTime:this._enterAnimationDuration}),this._animationsEnabled?(this._hostElement.style.setProperty(S4,`${this._enterAnimationDuration}ms`),this._requestAnimationFrame(()=>this._hostElement.classList.add(E4,XN)),this._waitForAnimationToComplete(this._enterAnimationDuration,this._finishDialogOpen)):(this._hostElement.classList.add(XN),Promise.resolve().then(()=>this._finishDialogOpen()))}_startExitAnimation(){this._animationStateChanged.emit({state:"closing",totalTime:this._exitAnimationDuration}),this._hostElement.classList.remove(XN),this._animationsEnabled?(this._hostElement.style.setProperty(S4,`${this._exitAnimationDuration}ms`),this._requestAnimationFrame(()=>this._hostElement.classList.add(D4)),this._waitForAnimationToComplete(this._exitAnimationDuration,this._finishDialogClose)):Promise.resolve().then(()=>this._finishDialogClose())}_clearAnimationClasses(){this._hostElement.classList.remove(E4,D4)}_waitForAnimationToComplete(n,r){null!==this._animationTimer&&clearTimeout(this._animationTimer),this._animationTimer=setTimeout(r,n)}_requestAnimationFrame(n){this._ngZone.runOutsideAngular(()=>{"function"==typeof requestAnimationFrame?requestAnimationFrame(n):n()})}}return(t=e).\u0275fac=function(n){return new(n||t)(lt(yr),lt(KO),lt(yi,8),lt(tT),lt(LS),lt(Gs),lt(EC),lt(ac,8),lt($m))},t.\u0275cmp=sr({type:t,selectors:[["mat-dialog-container"]],hostAttrs:["tabindex","-1",1,"mat-mdc-dialog-container","mdc-dialog"],hostVars:8,hostBindings:function(n,r){2&n&&(ih("id",r._config.id),si("aria-modal",r._config.ariaModal)("role",r._config.role)("aria-labelledby",r._config.ariaLabel?null:r._ariaLabelledByQueue[0])("aria-label",r._config.ariaLabel)("aria-describedby",r._config.ariaDescribedBy||null),Ei("_mat-animation-noopable",!r._animationsEnabled))},features:[Ps],decls:3,vars:0,consts:[[1,"mdc-dialog__container"],[1,"mat-mdc-dialog-surface","mdc-dialog__surface"],["cdkPortalOutlet",""]],template:function(n,r){1&n&&(yn(0,"div",0)(1,"div",1),Fs(2,spe,0,0,"ng-template",2),In()())},dependencies:[nI],styles:['.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto;outline:0}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{display:block;width:100%;height:100%}.mat-mdc-dialog-container{--mdc-dialog-container-elevation-shadow:0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);--mdc-dialog-container-shadow-color:#000;--mdc-dialog-container-shape:4px;--mdc-dialog-container-elevation: var(--mdc-dialog-container-elevation-shadow);outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, 4px)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, Roboto, sans-serif);line-height:var(--mdc-dialog-subhead-line-height, 1.5rem);font-size:var(--mdc-dialog-subhead-size, 1rem);font-weight:var(--mdc-dialog-subhead-weight, 400);letter-spacing:var(--mdc-dialog-subhead-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, rgba(0, 0, 0, 0.87))}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, Roboto, sans-serif);line-height:var(--mdc-dialog-supporting-text-line-height, 1.5rem);font-size:var(--mdc-dialog-supporting-text-size, 1rem);font-weight:var(--mdc-dialog-supporting-text-weight, 400);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, rgba(0, 0, 0, 0.6))}.mat-mdc-dialog-container .mdc-dialog__container{transition-duration:var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container{transition:none}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-actions{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}'],encapsulation:2}),e})();class lpe{constructor(e,s,n){this._ref=e,this._containerInstance=n,this._afterOpened=new Bt,this._beforeClosed=new Bt,this._state=0,this.disableClose=s.disableClose,this.id=e.id,n._animationStateChanged.pipe(tc(r=>"opened"===r.state),$l(1)).subscribe(()=>{this._afterOpened.next(),this._afterOpened.complete()}),n._animationStateChanged.pipe(tc(r=>"closed"===r.state),$l(1)).subscribe(()=>{clearTimeout(this._closeFallbackTimeout),this._finishDialogClose()}),e.overlayRef.detachments().subscribe(()=>{this._beforeClosed.next(this._result),this._beforeClosed.complete(),this._finishDialogClose()}),ji(this.backdropClick(),this.keydownEvents().pipe(tc(r=>27===r.keyCode&&!this.disableClose&&!lh(r)))).subscribe(r=>{this.disableClose||(r.preventDefault(),function cpe(t,e,s){t._closeInteractionType=e,t.close(s)}(this,"keydown"===r.type?"keyboard":"mouse"))})}close(e){this._result=e,this._containerInstance._animationStateChanged.pipe(tc(s=>"closing"===s.state),$l(1)).subscribe(s=>{this._beforeClosed.next(e),this._beforeClosed.complete(),this._ref.overlayRef.detachBackdrop(),this._closeFallbackTimeout=setTimeout(()=>this._finishDialogClose(),s.totalTime+100)}),this._state=1,this._containerInstance._startExitAnimation()}afterOpened(){return this._afterOpened}afterClosed(){return this._ref.closed}beforeClosed(){return this._beforeClosed}backdropClick(){return this._ref.backdropClick}keydownEvents(){return this._ref.keydownEvents}updatePosition(e){let s=this._ref.config.positionStrategy;return e&&(e.left||e.right)?e.left?s.left(e.left):s.right(e.right):s.centerHorizontally(),e&&(e.top||e.bottom)?e.top?s.top(e.top):s.bottom(e.bottom):s.centerVertically(),this._ref.updatePosition(),this}updateSize(e="",s=""){return this._ref.updateSize(e,s),this}addPanelClass(e){return this._ref.addPanelClass(e),this}removePanelClass(e){return this._ref.removePanelClass(e),this}getState(){return this._state}_finishDialogClose(){this._state=2,this._ref.close(this._result,{focusOrigin:this._closeInteractionType}),this.componentInstance=null}}const upe=new Zn("MatMdcDialogData"),dpe=new Zn("mat-mdc-dialog-default-options"),T4=new Zn("mat-mdc-dialog-scroll-strategy"),ppe={provide:T4,deps:[fp],useFactory:function hpe(t){return()=>t.scrollStrategies.block()}};let fpe=0,mpe=(()=>{var t;class e{get openDialogs(){return this._parentDialog?this._parentDialog.openDialogs:this._openDialogsAtThisLevel}get afterOpened(){return this._parentDialog?this._parentDialog.afterOpened:this._afterOpenedAtThisLevel}_getAfterAllClosed(){const n=this._parentDialog;return n?n._getAfterAllClosed():this._afterAllClosedAtThisLevel}constructor(n,r,i,a,c,f,g,E,A,Y){this._overlay=n,this._defaultOptions=i,this._parentDialog=a,this._dialogRefConstructor=g,this._dialogContainerType=E,this._dialogDataToken=A,this._openDialogsAtThisLevel=[],this._afterAllClosedAtThisLevel=new Bt,this._afterOpenedAtThisLevel=new Bt,this._idPrefix="mat-dialog-",this.dialogConfigClass=tT,this.afterAllClosed=hb(()=>this.openDialogs.length?this._getAfterAllClosed():this._getAfterAllClosed().pipe(ed(void 0))),this._scrollStrategy=f,this._dialog=r.get(C4)}open(n,r){let i;(r={...this._defaultOptions||new tT,...r}).id=r.id||`${this._idPrefix}${fpe++}`,r.scrollStrategy=r.scrollStrategy||this._scrollStrategy();const a=this._dialog.open(n,{...r,positionStrategy:this._overlay.position().global().centerHorizontally().centerVertically(),disableClose:!0,closeOnDestroy:!1,closeOnOverlayDetachments:!1,container:{type:this._dialogContainerType,providers:()=>[{provide:this.dialogConfigClass,useValue:r},{provide:eT,useValue:r}]},templateContext:()=>({dialogRef:i}),providers:(c,f,g)=>(i=new this._dialogRefConstructor(c,r,g),i.updatePosition(r?.position),[{provide:this._dialogContainerType,useValue:g},{provide:this._dialogDataToken,useValue:f.data},{provide:this._dialogRefConstructor,useValue:i}])});return i.componentRef=a.componentRef,i.componentInstance=a.componentInstance,this.openDialogs.push(i),this.afterOpened.next(i),i.afterClosed().subscribe(()=>{const c=this.openDialogs.indexOf(i);c>-1&&(this.openDialogs.splice(c,1),this.openDialogs.length||this._getAfterAllClosed().next())}),i}closeAll(){this._closeDialogs(this.openDialogs)}getDialogById(n){return this.openDialogs.find(r=>r.id===n)}ngOnDestroy(){this._closeDialogs(this._openDialogsAtThisLevel),this._afterAllClosedAtThisLevel.complete(),this._afterOpenedAtThisLevel.complete()}_closeDialogs(n){let r=n.length;for(;r--;)n[r].close()}}return(t=e).\u0275fac=function(n){Tf()},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})(),gpe=(()=>{var t;class e extends mpe{constructor(n,r,i,a,c,f,g,E){super(n,r,a,f,g,c,lpe,ape,upe,E),this._idPrefix="mat-mdc-dialog-"}}return(t=e).\u0275fac=function(n){return new(n||t)(cn(fp),cn(Wc),cn(Aw,8),cn(dpe,8),cn(T4),cn(t,12),cn(aI),cn(ac,8))},t.\u0275prov=wt({token:t,factory:t.\u0275fac}),e})(),_pe=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({providers:[gpe,ppe],imports:[npe,DC,wC,nl,nl]}),e})(),ype=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t}),t.\u0275inj=pn({imports:[Yhe,_B,B9,Dq,PX,uI,Q9,hJ,xQ,BX,nY,sV,OQ,tJ,_pe,Lq]}),e})(),vpe=(()=>{var t;class e{}return(t=e).\u0275fac=function(n){return new(n||t)},t.\u0275mod=Vr({type:t,bootstrap:[Hue]}),t.\u0275inj=pn({imports:[AF,Wue,Bhe,b6,H6,ype,IY,Ab]}),e})();lG().bootstrapModule(vpe).catch(t=>console.error(t))},7869:function(Et,le,h){"use strict";var U=this&&this.__awaiter||function(we,We,Oe,ie){return new(Oe||(Oe=Promise))(function(De,te){function de(ye){try{oe(ie.next(ye))}catch(Te){te(Te)}}function P(ye){try{oe(ie.throw(ye))}catch(Te){te(Te)}}function oe(ye){ye.done?De(ye.value):function Le(De){return De instanceof Oe?De:new Oe(function(te){te(De)})}(ye.value).then(de,P)}oe((ie=ie.apply(we,We||[])).next())})},Z=this&&this.__generator||function(we,We){var ie,Le,De,te,Oe={label:0,sent:function(){if(1&De[0])throw De[1];return De[1]},trys:[],ops:[]};return te={next:de(0),throw:de(1),return:de(2)},"function"==typeof Symbol&&(te[Symbol.iterator]=function(){return this}),te;function de(oe){return function(ye){return function P(oe){if(ie)throw new TypeError("Generator is already executing.");for(;Oe;)try{if(ie=1,Le&&(De=2&oe[0]?Le.return:oe[0]?Le.throw||((De=Le.return)&&De.call(Le),0):Le.next)&&!(De=De.call(Le,oe[1])).done)return De;switch(Le=0,De&&(oe=[2&oe[0],De.value]),oe[0]){case 0:case 1:De=oe;break;case 4:return Oe.label++,{value:oe[1],done:!1};case 5:Oe.label++,Le=oe[1],oe=[0];continue;case 7:oe=Oe.ops.pop(),Oe.trys.pop();continue;default:if(!(De=(De=Oe.trys).length>0&&De[De.length-1])&&(6===oe[0]||2===oe[0])){Oe=0;continue}if(3===oe[0]&&(!De||oe[1]>De[0]&&oe[1]<De[3])){Oe.label=oe[1];break}if(6===oe[0]&&Oe.label<De[1]){Oe.label=De[1],De=oe;break}if(De&&Oe.label<De[2]){Oe.label=De[2],Oe.ops.push(oe);break}De[2]&&Oe.ops.pop(),Oe.trys.pop();continue}oe=We.call(we,Oe)}catch(ye){oe=[6,ye],Le=0}finally{ie=De=0}if(5&oe[0])throw oe[1];return{value:oe[0]?oe[1]:void 0,done:!0}}([oe,ye])}}};Object.defineProperty(le,"__esModule",{value:!0});var y=h(7494),F=h(1435),I=h(9305),N=h(6516),W=h(1435),w=function(we){return we.packageVersion=we.packageVersion||N.version,we.packageName="@teachablemachine/pose",we.timeStamp=we.timeStamp||(new Date).toISOString(),we.userMetadata=we.userMetadata||{},we.modelName=we.modelName||"untitled",we.labels=we.labels||[],we.modelSettings=D(we.modelSettings),we},T=function(we){return U(void 0,void 0,void 0,function(){var We;return Z(this,function(ie){switch(ie.label){case 0:return"string"!=typeof we?[3,3]:[4,fetch(we)];case 1:return[4,ie.sent().json()];case 2:return We=ie.sent(),[3,4];case 3:if(!function(we){return!!we&&Array.isArray(we.labels)}(we))throw new Error("Invalid Metadata provided");We=we,ie.label=4;case 4:return[2,w(We)]}})})},D=function(we){return void 0===we&&(we={}),we.posenet||(we.posenet={}),we.posenet.architecture=we.posenet.architecture||"MobileNetV1",we.posenet.outputStride=we.posenet.outputStride||16,we.posenet.inputResolution=we.posenet.inputResolution||257,we.posenet.multiplier=we.posenet.multiplier||.75,we};function G(we,We,Oe){return void 0===Oe&&(Oe=3),U(this,void 0,void 0,function(){var ie;return Z(this,function(Le){switch(Le.label){case 0:return[4,We.data()];case 1:return ie=Le.sent(),[2,y.tidy(function(){Oe=Math.min(Oe,ie.length);for(var De=[],te=0;te<ie.length;te++)De.push({value:ie[te],index:te});De.sort(function(ye,Te){return Te.value-ye.value});var de=new Float32Array(Oe),P=new Int32Array(Oe);for(te=0;te<Oe;te++)de[te]=De[te].value,P[te]=De[te].index;var oe=[];for(te=0;te<P.length;te++)oe.push({className:we[P[te]],probability:de[te]});return oe})]}})})}le.getTopKClasses=G;var J=function(){function we(We,Oe,ie){this.model=We,this.posenetModel=Oe,this._metadata=w(ie)}return we.prototype.getMetadata=function(){return this._metadata},we.prototype.getClassLabels=function(){return this._metadata.labels},we.prototype.getTotalClasses=function(){return this.model.output.shape[1]},we.prototype.estimatePose=function(We,Oe){return void 0===Oe&&(Oe=!1),U(this,void 0,void 0,function(){var ie,Le,De,te,de,P,oe;return Z(this,function(Te){switch(Te.label){case 0:return[4,this.estimatePoseOutputs(We)];case 1:return ie=Te.sent(),P=ie.padding,oe=this.poseOutputsToAray(Le=ie.heatmapScores,De=ie.offsets,te=ie.displacementFwd,de=ie.displacementBwd),[4,this.poseOutputsToKeypoints(We,Le,De,te,de,P,Oe)];case 2:return[2,{pose:Te.sent(),posenetOutput:oe}]}})})},we.prototype.estimatePoseOutputs=function(We){return U(this,void 0,void 0,function(){var ie,Le,De,te,de,P,oe,ye;return Z(this,function(Te){switch(Te.label){case 0:return ie=I.padAndResizeTo(We,this.posenetModel.inputResolution),De=ie.padding,[4,this.posenetModel.baseModel.predict(Le=ie.resized)];case 1:return te=Te.sent(),de=te.heatmapScores,P=te.offsets,oe=te.displacementFwd,ye=te.displacementBwd,Le.dispose(),[2,{heatmapScores:de,offsets:P,displacementFwd:oe,displacementBwd:ye,padding:De}]}})})},we.prototype.poseOutputsToAray=function(We,Oe,ie,Le){var te=y.concat([We,Oe],2),de=te.dataSync();return te.dispose(),de},we.prototype.poseOutputsToKeypoints=function(We,Oe,ie,Le,De,te,de){return void 0===de&&(de=!1),U(this,void 0,void 0,function(){var P,oe,ye,Te,v,at,Xe,nn,Bt;return Z(this,function(bn){switch(bn.label){case 0:return P={maxDetections:3,scoreThreshold:.5,nmsRadius:20},oe=I.getInputTensorDimensions(We),ye=oe[0],Te=oe[1],v=this.posenetModel.baseModel.outputStride,at=this.posenetModel.inputResolution,[4,I.toTensorBuffers3D([Oe,ie,Le,De])];case 1:return Xe=bn.sent(),[4,W.decodeMultiplePoses(Xe[0],Xe[1],Xe[2],Xe[3],v,P.maxDetections,P.scoreThreshold,P.nmsRadius)];case 2:return nn=bn.sent(),Bt=I.scaleAndFlipPoses(nn,[ye,Te],at,te,de),Oe.dispose(),ie.dispose(),Le.dispose(),De.dispose(),[2,Bt[0]]}})})},we.prototype.predict=function(We){return U(this,void 0,void 0,function(){var Oe,ie,Le,De,te;return Z(this,function(de){switch(de.label){case 0:return Oe=y.tensor([We]),[4,(ie=this.model.predict(Oe)).data()];case 1:for(Le=de.sent(),De=[],te=0;te<Le.length;te++)De.push({className:this._metadata.labels[te],probability:Le[te]});return Oe.dispose(),ie.dispose(),[2,De]}})})},we.prototype.predictTopK=function(We,Oe){return void 0===Oe&&(Oe=3),U(this,void 0,void 0,function(){var ie,Le,De;return Z(this,function(te){switch(te.label){case 0:return ie=y.tensor([We]),Le=this.model.predict(ie),[4,G(this._metadata.labels,Le,Oe)];case 1:return De=te.sent(),ie.dispose(),Le.dispose(),[2,De]}})})},we.prototype.dispose=function(){this.posenetModel.dispose()},we}();function K(we){return void 0===we&&(we={}),U(this,void 0,void 0,function(){return Z(this,function(Oe){switch(Oe.label){case 0:return we=D(we),[4,F.load({architecture:we.posenet.architecture,outputStride:we.posenet.outputStride,inputResolution:we.posenet.inputResolution,multiplier:we.posenet.multiplier})];case 1:return[2,Oe.sent()]}})})}le.CustomPoseNet=J,le.loadPoseNet=K,le.load=function _e(we,We){return U(this,void 0,void 0,function(){var Oe,ie,Le,De;return Z(this,function(te){switch(te.label){case 0:return[4,y.loadLayersModel(we)];case 1:return Oe=te.sent(),We?[4,T(We)]:[3,3];case 2:return Le=te.sent(),[3,4];case 3:Le=null,te.label=4;case 4:return[4,K((ie=Le).modelSettings)];case 5:return De=te.sent(),[2,new J(Oe,De,ie)]}})})},le.loadFromFiles=function Re(we,We,Oe){return U(this,void 0,void 0,function(){var ie,Le,De,te,de;return Z(this,function(P){switch(P.label){case 0:return[4,y.loadLayersModel(y.io.browserFiles([we,We]))];case 1:return ie=P.sent(),[4,new Response(Oe).json()];case 2:return Le=P.sent(),Oe?[4,T(Le)]:[3,4];case 3:return te=P.sent(),[3,5];case 4:te=null,P.label=5;case 5:return[4,K((De=te).modelSettings)];case 6:return de=P.sent(),[2,new J(ie,de,De)]}})})}},2535:(Et,le,h)=>{"use strict";var Z=h(7869);le.zD=Z.load;h(2351);var F=h(5285);le.bb=F.Webcam,h(7430);h(7118);h(6516)},2351:function(Et,le,h){"use strict";var G,U=this&&this.__extends||(G=function(J,K){return(G=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,Re){_e.__proto__=Re}||function(_e,Re){for(var we in Re)Re.hasOwnProperty(we)&&(_e[we]=Re[we])})(J,K)},function(J,K){function _e(){this.constructor=J}G(J,K),J.prototype=null===K?Object.create(K):(_e.prototype=K.prototype,new _e)}),Z=this&&this.__awaiter||function(G,J,K,_e){return new(K||(K=Promise))(function(we,We){function Oe(De){try{Le(_e.next(De))}catch(te){We(te)}}function ie(De){try{Le(_e.throw(De))}catch(te){We(te)}}function Le(De){De.done?we(De.value):function Re(we){return we instanceof K?we:new K(function(We){We(we)})}(De.value).then(Oe,ie)}Le((_e=_e.apply(G,J||[])).next())})},y=this&&this.__generator||function(G,J){var _e,Re,we,We,K={label:0,sent:function(){if(1&we[0])throw we[1];return we[1]},trys:[],ops:[]};return We={next:Oe(0),throw:Oe(1),return:Oe(2)},"function"==typeof Symbol&&(We[Symbol.iterator]=function(){return this}),We;function Oe(Le){return function(De){return function ie(Le){if(_e)throw new TypeError("Generator is already executing.");for(;K;)try{if(_e=1,Re&&(we=2&Le[0]?Re.return:Le[0]?Re.throw||((we=Re.return)&&we.call(Re),0):Re.next)&&!(we=we.call(Re,Le[1])).done)return we;switch(Re=0,we&&(Le=[2&Le[0],we.value]),Le[0]){case 0:case 1:we=Le;break;case 4:return K.label++,{value:Le[1],done:!1};case 5:K.label++,Re=Le[1],Le=[0];continue;case 7:Le=K.ops.pop(),K.trys.pop();continue;default:if(!(we=(we=K.trys).length>0&&we[we.length-1])&&(6===Le[0]||2===Le[0])){K=0;continue}if(3===Le[0]&&(!we||Le[1]>we[0]&&Le[1]<we[3])){K.label=Le[1];break}if(6===Le[0]&&K.label<we[1]){K.label=we[1],we=Le;break}if(we&&K.label<we[2]){K.label=we[2],K.ops.push(Le);break}we[2]&&K.ops.pop(),K.trys.pop();continue}Le=J.call(G,K)}catch(De){Le=[6,De],Re=0}finally{_e=we=0}if(5&Le[0])throw Le[1];return{value:Le[0]?Le[1]:void 0,done:!0}}([Le,De])}}};Object.defineProperty(le,"__esModule",{value:!0});var F=h(7494),I=h(7494),N=h(7869),W=h(9128);function M(G,J){for(var K,_e=G.length,Re=G.slice(),we=_e-1;we>0;we-=1){var We;We=J?Math.floor(J()*(we+1)):Math.floor(Math.random()*(we+1)),Re[we]=(K=[Re[We],Re[we]])[0],Re[We]=K[1]}return Re}var T=function(G){function J(K,_e,Re){var we=G.call(this,K,_e,Re)||this;return we.model=K,we.posenetModel=_e,we.examples=[],we}return U(J,G),Object.defineProperty(J.prototype,"isTrained",{get:function(){return!!this.model&&this.model.layers&&this.model.layers.length>2},enumerable:!0,configurable:!0}),Object.defineProperty(J.prototype,"isPrepared",{get:function(){return!!this.trainDataset},enumerable:!0,configurable:!0}),Object.defineProperty(J.prototype,"numClasses",{get:function(){return this._metadata.labels.length},enumerable:!0,configurable:!0}),J.prototype.addExample=function(K,_e){return Z(this,void 0,void 0,function(){return y(this,function(Re){return this.examples[K].push(_e),[2]})})},J.prototype.predict=function(K){return Z(this,void 0,void 0,function(){return y(this,function(_e){if(!this.model)throw new Error("Model has not been trained yet, called train() first");return[2,G.prototype.predict.call(this,K)]})})},J.prototype.predictTopK=function(K,_e){return void 0===_e&&(_e=3),Z(this,void 0,void 0,function(){return y(this,function(Re){if(!this.model)throw new Error("Model has not been trained yet, called train() first");return[2,G.prototype.predictTopK.call(this,K,_e)]})})},J.prototype.prepare=function(){for(var K in this.examples)if(0===K.length)throw new Error("Add some examples before training");var _e=this.convertToTfDataset();this.trainDataset=_e.trainDataset,this.validationDataset=_e.validationDataset},J.prototype.convertToTfDataset=function(){for(var K=0;K<this.examples.length;K++)this.examples[K]=M(this.examples[K],this.seed);var _e=[],Re=[],we=function(te){var de=function w(G,J){var K=new Array(J).fill(0);return K[G]=1,K}(te,We.numClasses),P=We.examples[te].length,ye=P-Math.ceil(.15*P),Te=We.examples[te].slice(0,ye).map(function(at){return{data:at,label:de}}),v=We.examples[te].slice(ye).map(function(at){return{data:at,label:de}});_e=_e.concat(Te),Re=Re.concat(v)},We=this;for(K=0;K<this.examples.length;K++)we(K);_e=M(_e,this.seed),Re=M(Re,this.seed);var Oe=F.data.array(_e.map(function(te){return te.data})),ie=F.data.array(Re.map(function(te){return te.data})),Le=F.data.array(_e.map(function(te){return te.label})),De=F.data.array(Re.map(function(te){return te.label}));return{trainDataset:F.data.zip({xs:Oe,ys:Le}),validationDataset:F.data.zip({xs:ie,ys:De})}},J.prototype.save=function(K,_e){return Z(this,void 0,void 0,function(){return y(this,function(Re){return[2,this.model.save(K,_e)]})})},J.prototype.train=function(K,_e){return void 0===_e&&(_e={}),Z(this,void 0,void 0,function(){var Re,we,We,Oe,ie,Le,De,te=this;return y(this,function(de){switch(de.label){case 0:if(Re=_e.onTrainEnd||function(){},_e.onTrainEnd=function(P){te.__stopTrainingResolve&&(te.__stopTrainingResolve(),te.__stopTrainingResolve=null),Re(P)},this.isPrepared||this.prepare(),we=this.getLabels().length,I.util.assert(we===this.numClasses,function(){return"Can not train, has "+we+" labels and "+te.numClasses+" classes"}),We=this.examples[0][1].length,Oe=F.initializers.varianceScaling(this.seed?{seed:3.14}:{}),this.model=F.sequential({layers:[F.layers.dense({inputShape:[We],units:K.denseUnits,activation:"relu",kernelInitializer:Oe,useBias:!0}),F.layers.dropout({rate:.5}),F.layers.dense({units:this.numClasses,kernelInitializer:Oe,useBias:!1,activation:"softmax"})]}),ie=F.train.rmsprop(K.learningRate),this.model.compile({optimizer:ie,loss:"categoricalCrossentropy",metrics:["accuracy"]}),!(K.batchSize>0))throw new Error("Batch size is 0 or NaN. Please choose a non-zero fraction");return Le=this.trainDataset.batch(K.batchSize),De=this.validationDataset.batch(K.batchSize),[4,this.model.fitDataset(Le,{epochs:K.epochs,validationData:De,callbacks:_e})];case 1:return de.sent(),ie.dispose(),[2,this.model]}})})},J.prototype.prepareDataset=function(){for(var K=0;K<this.numClasses;K++)this.examples[K]=[]},J.prototype.stopTraining=function(){var K=this;return new Promise(function(Re,we){K.model.stopTraining=!0,K.__stopTrainingResolve=Re})},J.prototype.dispose=function(){this.model.dispose(),G.prototype.dispose.call(this)},J.prototype.setLabel=function(K,_e){this._metadata.labels[K]=_e},J.prototype.setLabels=function(K){this._metadata.labels=K,this.prepareDataset()},J.prototype.getLabel=function(K){return this._metadata.labels[K]},J.prototype.getLabels=function(){return this._metadata.labels},J.prototype.setName=function(K){this._metadata.modelName=K},J.prototype.getName=function(){return this._metadata.modelName},J.prototype.calculateAccuracyPerClass=function(){return Z(this,void 0,void 0,function(){var K,_e,Re,we,We,Oe,ie,Le,De,te,de,P,oe,ye,Te,v,at,Xe,Ue=this;return y(this,function(pt){switch(pt.label){case 0:return K=this.validationDataset.mapAsync(function(Ct){return Z(Ue,void 0,void 0,function(){return y(this,function(It){return[2,Ct.xs]})})}),_e=this.validationDataset.mapAsync(function(Ct){return Z(Ue,void 0,void 0,function(){return y(this,function(It){return[2,Ct.ys]})})}),Re=Math.min(_e.size,32),we=Math.ceil(_e.size/Re),We=K.batch(Re),Oe=_e.batch(Re),[4,We.iterator()];case 1:return ie=pt.sent(),[4,Oe.iterator()];case 2:Le=pt.sent(),De=[],te=[],Xe=0,pt.label=3;case 3:return Xe<we?[4,ie.next()]:[3,7];case 4:return de=pt.sent(),P=this.model.predict(de.value),oe=P.argMax(1),De.push(oe),[4,Le.next()];case 5:ye=pt.sent(),Te=ye.value.argMax(1),te.push(Te),de.value.dispose(),P.dispose(),ye.value.dispose(),pt.label=6;case 6:return Xe++,[3,3];case 7:if(v=F.concat(te),at=F.concat(De),1!==we)for(Xe=0;Xe<De.length;Xe++)De[Xe].dispose(),te[Xe].dispose();return[2,{reference:v,predictions:at}]}})})},J.prototype.setSeed=function(K){this.seed=W(K)},J}(N.CustomPoseNet);le.TeachablePoseNet=T,le.createTeachable=function D(G){return Z(this,void 0,void 0,function(){var J;return y(this,function(K){switch(K.label){case 0:return[4,N.loadPoseNet(G.modelSettings)];case 1:return J=K.sent(),[2,new T(F.sequential(),J,G)]}})})}},7430:(Et,le)=>{"use strict";Object.defineProperty(le,"__esModule",{value:!0}),le.createCanvas=function U(y,F,I){void 0===y&&(y=200),void 0===F&&(F=200),void 0===I&&(I=!1);var N=document.createElement("canvas");if(N.width=y,N.height=F,I){var W=N.getContext("2d");W.translate(y,0),W.scale(-1,1)}return N},le.cropTo=function Z(y,F,I,N){void 0===I&&(I=!1),void 0===N&&(N=document.createElement("canvas"));var W=y.width,l=y.height;y instanceof HTMLVideoElement&&(W=y.videoWidth,l=y.videoHeight);var M=F/Math.min(W,l),T=Math.ceil(W*M),D=Math.ceil(l*M),G=T-F,J=D-F;N.width=N.height=F;var K=N.getContext("2d");return K.drawImage(y,-1*~~(G/2),-1*~~(J/2),T,D),I&&(K.scale(-1,1),K.drawImage(N,-1*F,0)),N}},7118:(Et,le,h)=>{"use strict";Object.defineProperty(le,"__esModule",{value:!0});var U=h(9305),y="aqua";function W(T,D,G,J,K,_e){T.fillStyle=K,T.strokeStyle=_e,T.beginPath(),T.arc(G,D,J,0,2*Math.PI),T.fill(),T.stroke()}function l(T){return[T.y,T.x]}function M(T,D,G,J,K,_e){var Re=T[0],we=T[1],We=D[0],Oe=D[1];G.beginPath(),G.moveTo(we*_e,Re*_e),G.lineTo(Oe*_e,We*_e),G.lineWidth=J,G.strokeStyle=K,G.stroke()}le.drawKeypoints=function N(T,D,G,J,K,_e,Re){void 0===J&&(J=4),void 0===K&&(K="aqua"),void 0===_e&&(_e=y),void 0===Re&&(Re=1);for(var we=0;we<T.length;we++){var We=T[we];if(!(We.score<D)){var Oe=We.position;W(G,Oe.y*Re,Oe.x*Re,J,K,_e)}}},le.drawPoint=W,le.toTuple=l,le.drawSkeleton=function w(T,D,G,J,K,_e){void 0===J&&(J=2),void 0===K&&(K=y),void 0===_e&&(_e=1),U.getAdjacentKeyPoints(T,D).forEach(function(we){M(l(we[0].position),l(we[1].position),G,J,K,_e)})},le.drawSegment=M},5285:function(Et,le,h){"use strict";var U=this&&this.__decorate||function(w,M,T,D){var K,G=arguments.length,J=G<3?M:null===D?D=Object.getOwnPropertyDescriptor(M,T):D;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)J=Reflect.decorate(w,M,T,D);else for(var _e=w.length-1;_e>=0;_e--)(K=w[_e])&&(J=(G<3?K(J):G>3?K(M,T,J):K(M,T))||J);return G>3&&J&&Object.defineProperty(M,T,J),J},Z=this&&this.__awaiter||function(w,M,T,D){return new(T||(T=Promise))(function(J,K){function _e(We){try{we(D.next(We))}catch(Oe){K(Oe)}}function Re(We){try{we(D.throw(We))}catch(Oe){K(Oe)}}function we(We){We.done?J(We.value):function G(J){return J instanceof T?J:new T(function(K){K(J)})}(We.value).then(_e,Re)}we((D=D.apply(w,M||[])).next())})},y=this&&this.__generator||function(w,M){var D,G,J,K,T={label:0,sent:function(){if(1&J[0])throw J[1];return J[1]},trys:[],ops:[]};return K={next:_e(0),throw:_e(1),return:_e(2)},"function"==typeof Symbol&&(K[Symbol.iterator]=function(){return this}),K;function _e(we){return function(We){return function Re(we){if(D)throw new TypeError("Generator is already executing.");for(;T;)try{if(D=1,G&&(J=2&we[0]?G.return:we[0]?G.throw||((J=G.return)&&J.call(G),0):G.next)&&!(J=J.call(G,we[1])).done)return J;switch(G=0,J&&(we=[2&we[0],J.value]),we[0]){case 0:case 1:J=we;break;case 4:return T.label++,{value:we[1],done:!1};case 5:T.label++,G=we[1],we=[0];continue;case 7:we=T.ops.pop(),T.trys.pop();continue;default:if(!(J=(J=T.trys).length>0&&J[J.length-1])&&(6===we[0]||2===we[0])){T=0;continue}if(3===we[0]&&(!J||we[1]>J[0]&&we[1]<J[3])){T.label=we[1];break}if(6===we[0]&&T.label<J[1]){T.label=J[1],J=we;break}if(J&&T.label<J[2]){T.label=J[2],T.ops.push(we);break}J[2]&&T.ops.pop(),T.trys.pop();continue}we=M.call(w,T)}catch(We){we=[6,We],G=0}finally{D=J=0}if(5&we[0])throw we[1];return{value:we[0]?we[1]:void 0,done:!0}}([we,We])}}};Object.defineProperty(le,"__esModule",{value:!0});var F=h(4860),I=h(7430),N={facingMode:"user",frameRate:24},l=function(){function w(M,T,D){void 0===M&&(M=400),void 0===T&&(T=400),void 0===D&&(D=!1),this.width=M,this.height=T,this.flip=D}return w.prototype.getWebcam=function(M){if(void 0===M&&(M={}),!window.navigator.mediaDevices||!window.navigator.mediaDevices.getUserMedia)return Promise.reject("Your browser does not support WebRTC. Please try another one.");M.width=640;var T=function(w){return w.facingMode=w.facingMode||N.facingMode,w.frameRate=w.frameRate||N.frameRate,w.aspectRatio=w.aspectRatio||N.aspectRatio,w}(M),D=document.createElement("video");return window.navigator.mediaDevices.getUserMedia({video:T}).then(function(G){return D.srcObject=G,D.addEventListener("loadedmetadata",function(J){var _e=D.videoHeight;D.width=D.videoWidth,D.height=_e}),D},function(){return Promise.reject("Could not open your camera. You may have denied access.")})},w.prototype.setup=function(M){return void 0===M&&(M={}),Z(this,void 0,void 0,function(){var T;return y(this,function(D){switch(D.label){case 0:return this.webcam?[3,2]:(T=this,[4,this.getWebcam(M)]);case 1:T.webcam=D.sent(),this.canvas||(this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height),D.label=2;case 2:return[2]}})})},w.prototype.play=function(){return this.webcam.play()},w.prototype.pause=function(){this.webcam.pause()},w.prototype.stop=function(){this.stopStreamedVideo(this.webcam)},w.prototype.update=function(){this.renderCameraToCanvas()},w.prototype.stopStreamedVideo=function(M){M.srcObject.getTracks().forEach(function(G){G.stop()}),M.srcObject=null},w.prototype.renderCameraToCanvas=function(){if(this.canvas&&this.webcam){var M=this.canvas.getContext("2d");if(0!==this.webcam.videoWidth){var T=I.cropTo(this.webcam,this.width,this.flip);M.drawImage(T,0,0)}}},U([F.default],w.prototype,"getWebcam",null),U([F.default],w.prototype,"setup",null),U([F.default],w.prototype,"play",null),U([F.default],w.prototype,"pause",null),U([F.default],w.prototype,"stop",null),U([F.default],w.prototype,"update",null),U([F.default],w.prototype,"stopStreamedVideo",null),U([F.default],w.prototype,"renderCameraToCanvas",null),w}();le.Webcam=l},6516:(Et,le)=>{"use strict";Object.defineProperty(le,"__esModule",{value:!0}),le.version="0.8.6"},9284:(Et,le)=>{"use strict";Object.defineProperty(le,"__esModule",{value:!0}),le.partNames=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],le.NUM_KEYPOINTS=le.partNames.length,le.partIds=le.partNames.reduce(function(U,Z,y){return U[Z]=y,U},{}),le.poseChain=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]],le.connectedPartIndices=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(U){return[le.partIds[U[0]],le.partIds[U[1]]]}),le.partChannels=["left_face","right_face","right_upper_leg_front","right_lower_leg_back","right_upper_leg_back","left_lower_leg_front","left_upper_leg_front","left_upper_leg_back","left_lower_leg_back","right_feet","right_lower_leg_front","left_feet","torso_front","torso_back","right_upper_arm_front","right_upper_arm_back","right_lower_arm_back","left_lower_arm_front","left_upper_arm_front","left_upper_arm_back","left_lower_arm_back","right_hand","right_lower_arm_front","left_hand"]},1435:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{MobileNet:()=>_l,PoseNet:()=>Tu,decodeMultiplePoses:()=>Fi,decodeSinglePose:()=>Fc,getAdjacentKeyPoints:()=>st,getBoundingBox:()=>Yt,getBoundingBoxPoints:()=>xn,load:()=>rd,partChannels:()=>pn,partIds:()=>it,partNames:()=>He,poseChain:()=>wt,scaleAndFlipPoses:()=>jl,scalePose:()=>Jn,version:()=>Au});var U={};h.r(U),h.d(U,{json:()=>bn});var Z={};h.r(Z),h.d(Z,{json:()=>Qn});var y={};h.r(y),h.d(y,{json:()=>Dn});var F={};h.r(F),h.d(F,{json:()=>ps});var I={};h.r(I),h.d(I,{json:()=>Es});var N={};h.r(N),h.d(N,{json:()=>Xn});var W={};h.r(W),h.d(W,{json:()=>Ts});var l={};h.r(l),h.d(l,{json:()=>or});var w={};h.r(w),h.d(w,{json:()=>Ir});var M={};h.r(M),h.d(M,{json:()=>Ss});var T={};h.r(T),h.d(T,{json:()=>Qe});var D={};h.r(D),h.d(D,{json:()=>Lt});var G={};h.r(G),h.d(G,{json:()=>Qt});var J={};h.r(J),h.d(J,{json:()=>Nn});var K={};h.r(K),h.d(K,{json:()=>Os});var _e={};h.r(_e),h.d(_e,{json:()=>zs});var Re={};h.r(Re),h.d(Re,{json:()=>cr});var we={};h.r(we),h.d(we,{json:()=>xr});var We={};h.r(We),h.d(We,{json:()=>$r});var Oe={};h.r(Oe),h.d(Oe,{OP_SCOPE_SUFFIX:()=>qe.zvA,abs:()=>qe.WnP,acos:()=>qe.Khb,acosh:()=>qe.__u,add:()=>qe.IHx,addN:()=>qe.QBD,all:()=>qe.$6P,any:()=>qe.YjB,argMax:()=>qe.NqF,argMin:()=>qe.vHJ,asin:()=>qe.ZRM,asinh:()=>qe.VfV,atan:()=>qe.z4N,atan2:()=>qe.fvJ,atanh:()=>qe.C80,avgPool:()=>qe.wS1,avgPool3d:()=>qe.uR5,basicLSTMCell:()=>qe.zEQ,batchNorm:()=>qe.tgs,batchNorm2d:()=>qe.Dxk,batchNorm3d:()=>qe.JY5,batchNorm4d:()=>qe.p3b,batchToSpaceND:()=>qe.E4h,bincount:()=>qe.yE8,booleanMaskAsync:()=>qe.anm,broadcastArgs:()=>qe.XsQ,broadcastTo:()=>qe.UFq,buffer:()=>qe.f3b,cast:()=>qe.pju,ceil:()=>qe.mDi,clipByValue:()=>qe.iUl,clone:()=>qe.d9v,complex:()=>qe.PYB,concat:()=>qe.zoF,concat1d:()=>qe.gME,concat2d:()=>qe.Izb,concat3d:()=>qe.MNy,concat4d:()=>qe.ZaL,conv1d:()=>qe.PAt,conv2d:()=>qe.Tek,conv2dTranspose:()=>qe.bc,conv3d:()=>qe.pdZ,conv3dTranspose:()=>qe.$QV,cos:()=>qe.mCk,cosh:()=>qe.f9Y,cosineWindow:()=>qe.mew,cumprod:()=>qe.$Gn,cumsum:()=>qe.zbp,denseBincount:()=>qe.ppE,depthToSpace:()=>qe.nTT,depthwiseConv2d:()=>qe.B10,diag:()=>qe.Ka3,dilation2d:()=>qe.WmZ,div:()=>qe.hiC,divNoNan:()=>qe.NTj,dot:()=>qe.AKD,dropout:()=>qe.rvX,einsum:()=>qe.WYO,elu:()=>qe.pyx,enclosingPowerOfTwo:()=>qe.GRh,equal:()=>qe.DgJ,erf:()=>qe.qNN,euclideanNorm:()=>qe.d2q,exp:()=>qe.Qqt,expandDims:()=>qe.dt4,expm1:()=>qe.t$B,eye:()=>qe.iyy,fft:()=>qe.kp_,fill:()=>qe.hlL,floor:()=>qe.GWj,floorDiv:()=>qe.qPi,fused:()=>qe.imm,gather:()=>qe.Iqj,gatherND:()=>qe.dbB,greater:()=>qe.pjt,greaterEqual:()=>qe.brS,ifft:()=>qe.Sxn,imag:()=>qe.asL,image:()=>qe.BHj,inTopKAsync:()=>qe.V3u,irfft:()=>qe.wx0,isFinite:()=>qe.xVT,isInf:()=>qe.UWc,isNaN:()=>qe.i2d,leakyRelu:()=>qe.hi7,less:()=>qe.d9m,lessEqual:()=>qe.zN1,linalg:()=>qe.$r2,linspace:()=>qe.SX3,localResponseNormalization:()=>qe.G9k,log:()=>qe.cM7,log1p:()=>qe.Krr,logSigmoid:()=>qe.e_t,logSoftmax:()=>qe.CmS,logSumExp:()=>qe.l_t,logicalAnd:()=>qe.HvI,logicalNot:()=>qe.hJK,logicalOr:()=>qe.K5V,logicalXor:()=>qe.egP,losses:()=>qe.MB5,lowerBound:()=>qe.eab,matMul:()=>qe.OI3,max:()=>qe.Fp7,maxPool:()=>qe._sB,maxPool3d:()=>qe.YQQ,maxPoolWithArgmax:()=>qe.Ip$,maximum:()=>qe.gWQ,mean:()=>qe.J69,meshgrid:()=>qe.ry_,min:()=>qe.VV$,minimum:()=>qe.LTh,mirrorPad:()=>qe.VdP,mod:()=>qe.wQq,moments:()=>qe.Gi7,movingAverage:()=>qe.p_,mul:()=>qe.dC7,multiRNNCell:()=>qe.rq4,multinomial:()=>qe.SJ_,neg:()=>qe.W76,norm:()=>qe.KOy,notEqual:()=>qe.Quu,oneHot:()=>qe.lfX,ones:()=>qe.iUs,onesLike:()=>qe.JpU,op:()=>qe.op,outerProduct:()=>qe.N2O,pad:()=>qe.vku,pad1d:()=>qe.pNR,pad2d:()=>qe.koy,pad3d:()=>qe.t1L,pad4d:()=>qe.lGY,pool:()=>qe.d_R,pow:()=>qe.sQ3,prelu:()=>qe.AL3,print:()=>qe.S0v,prod:()=>qe.WVs,raggedGather:()=>qe.$gW,raggedTensorToTensor:()=>qe.N89,rand:()=>qe.TN_,randomGamma:()=>qe.wzB,randomNormal:()=>qe.nGf,randomStandardNormal:()=>qe.ruB,randomUniform:()=>qe.LGj,range:()=>qe.w6H,real:()=>qe.kwC,reciprocal:()=>qe.M25,relu:()=>qe.UYe,relu6:()=>qe.btT,reshape:()=>qe.XLQ,reverse:()=>qe.GYS,reverse1d:()=>qe.SDf,reverse2d:()=>qe.diP,reverse3d:()=>qe.sx7,reverse4d:()=>qe.mG2,rfft:()=>qe.QEs,round:()=>qe.NMM,rsqrt:()=>qe.bp0,scalar:()=>qe.iD$,scatterND:()=>qe.snQ,searchSorted:()=>qe.zcT,selu:()=>qe.U8D,separableConv2d:()=>qe.U_I,setdiff1dAsync:()=>qe.ODp,sigmoid:()=>qe.XD2,sign:()=>qe.Xxe,signal:()=>qe.tdS,sin:()=>qe.O$l,sinh:()=>qe.R_K,slice:()=>qe.tPi,slice1d:()=>qe.jZU,slice2d:()=>qe.SmN,slice3d:()=>qe.CnO,slice4d:()=>qe.p0P,softmax:()=>qe.XAC,softplus:()=>qe.Wvh,spaceToBatchND:()=>qe.fBT,sparse:()=>qe.rVs,sparseToDense:()=>qe.ers,spectral:()=>qe.uN7,split:()=>qe.Vl2,sqrt:()=>qe._b3,square:()=>qe.h62,squaredDifference:()=>qe.$i,squeeze:()=>qe.L9e,stack:()=>qe.knu,step:()=>qe.Nbs,stridedSlice:()=>qe.NXj,string:()=>qe.Z_8,sub:()=>qe.luU,sum:()=>qe.Smz,tan:()=>qe.ORZ,tanh:()=>qe.AEp,tensor:()=>qe.XeE,tensor1d:()=>qe.RRF,tensor2d:()=>qe.odF,tensor3d:()=>qe.wOQ,tensor4d:()=>qe.yXz,tensor5d:()=>qe.Bfx,tensor6d:()=>qe.xZs,tile:()=>qe.Gg6,topk:()=>qe.hg7,transpose:()=>qe.p4s,truncatedNormal:()=>qe.Xu6,unique:()=>qe.Two,unsortedSegmentSum:()=>qe.pUJ,unstack:()=>qe.HHK,upperBound:()=>qe.GaM,variable:()=>qe.VD$,where:()=>qe.arb,whereAsync:()=>qe.itS,zeros:()=>qe.lls,zerosLike:()=>qe.P84});var ie=h(4678);(0,ie.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,V=>{V&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var de,De=h(5861),te=function(V){return V[V.DT_INVALID=0]="DT_INVALID",V[V.DT_FLOAT=1]="DT_FLOAT",V[V.DT_DOUBLE=2]="DT_DOUBLE",V[V.DT_INT32=3]="DT_INT32",V[V.DT_UINT8=4]="DT_UINT8",V[V.DT_INT16=5]="DT_INT16",V[V.DT_INT8=6]="DT_INT8",V[V.DT_STRING=7]="DT_STRING",V[V.DT_COMPLEX64=8]="DT_COMPLEX64",V[V.DT_INT64=9]="DT_INT64",V[V.DT_BOOL=10]="DT_BOOL",V[V.DT_QINT8=11]="DT_QINT8",V[V.DT_QUINT8=12]="DT_QUINT8",V[V.DT_QINT32=13]="DT_QINT32",V[V.DT_BFLOAT16=14]="DT_BFLOAT16",V[V.DT_QINT16=15]="DT_QINT16",V[V.DT_QUINT16=16]="DT_QUINT16",V[V.DT_UINT16=17]="DT_UINT16",V[V.DT_COMPLEX128=18]="DT_COMPLEX128",V[V.DT_HALF=19]="DT_HALF",V[V.DT_RESOURCE=20]="DT_RESOURCE",V[V.DT_VARIANT=21]="DT_VARIANT",V[V.DT_UINT32=22]="DT_UINT32",V[V.DT_UINT64=23]="DT_UINT64",V[V.DT_FLOAT_REF=101]="DT_FLOAT_REF",V[V.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",V[V.DT_INT32_REF=103]="DT_INT32_REF",V[V.DT_UINT8_REF=104]="DT_UINT8_REF",V[V.DT_INT16_REF=105]="DT_INT16_REF",V[V.DT_INT8_REF=106]="DT_INT8_REF",V[V.DT_STRING_REF=107]="DT_STRING_REF",V[V.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",V[V.DT_INT64_REF=109]="DT_INT64_REF",V[V.DT_BOOL_REF=110]="DT_BOOL_REF",V[V.DT_QINT8_REF=111]="DT_QINT8_REF",V[V.DT_QUINT8_REF=112]="DT_QUINT8_REF",V[V.DT_QINT32_REF=113]="DT_QINT32_REF",V[V.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",V[V.DT_QINT16_REF=115]="DT_QINT16_REF",V[V.DT_QUINT16_REF=116]="DT_QUINT16_REF",V[V.DT_UINT16_REF=117]="DT_UINT16_REF",V[V.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",V[V.DT_HALF_REF=119]="DT_HALF_REF",V[V.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",V[V.DT_VARIANT_REF=121]="DT_VARIANT_REF",V[V.DT_UINT32_REF=122]="DT_UINT32_REF",V[V.DT_UINT64_REF=123]="DT_UINT64_REF",V}(te||{});!function(V){let O;var z;(z=O=V.CheckpointFormatVersion||(V.CheckpointFormatVersion={}))[z.LEGACY=0]="LEGACY",z[z.V1=1]="V1",z[z.V2=2]="V2"}(de||(de={}));const P={};function ye(V){return P[V]}function v(V,O,z,pe,Pe){const Ve=O.inputParams[V];if(Ve&&void 0!==Ve.inputIndexStart){const mt=Ve.inputIndexStart,Wt=0===Ve.inputIndexEnd?void 0:void 0===Ve.inputIndexEnd?mt+1:Ve.inputIndexEnd;if("tensor"===Ve.type)return at(O.inputNames[Ve.inputIndexStart],z,pe,Pe);if("tensors"===Ve.type)return O.inputNames.slice(mt,Wt).map(zn=>at(zn,z,pe,Pe));const mn=at(O.inputNames.slice(mt)[0],z,pe,Pe),rn=mn.dataSync();return"number"===Ve.type?rn[0]:ie.util.toNestedArray(mn.shape,rn)}const et=O.attrParams[V];return et&&et.value}function at(V,O,z,pe){const[Pe,Ve]=Ct(V);if(null!=pe){const mt=pe.getHashTableHandleByName(Pe);if(null!=mt)return mt}const et=z.currentContextIds.find(mt=>!!O[pt(Pe,mt)]);return void 0!==et?O[pt(Pe,et)][Ve]:void 0}function Ue(V,O){const[z,pe,Pe]=Ct(V);return[pt(z,O&&O.currentContextId),pe,Pe]}function pt(V,O){return O?`${V}-${O}`:V}function Ct(V){const O=V.split(":");if(1===O.length)return[V,0,void 0];const pe=3===O.length?O[1]:void 0;return[O[0],Number(O[O.length-1]),pe]}function nn(V,O,z){let pe=v("pad",V,O,z);if("explicit"===pe){pe=v("explicitPaddings",V,O,z);const Pe=[[0,0],[0,0],[0,0],[0,0]];for(let Ve=0;Ve<4;Ve++)Pe[Ve][0]=pe[2*Ve],Pe[Ve][1]=pe[2*Ve+1];return Pe}return pe}function Bt(V){return V.kept?V:(0,ie.clone)(V)}const bn=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qn=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Dn=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],ps=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Es=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Xn=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ts=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],or=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ir=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Ss=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Qe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Lt=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Qt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Nn=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Os=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],zs=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],cr=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],xr=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],$r=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class eo{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const z=[].concat(...[U,Z,y,F,I,N,W,l,w,M,T,D,G,J,K,_e,Re,we,We].map(pe=>pe.json));this.opMappers=z.reduce((pe,Pe)=>(pe[Pe.tfOpName]=Pe,pe),{})}transformGraph(O,z={}){const Pe=[],Ve=[],et=[],mt=O.node.reduce((Rs,Or)=>(Rs[Or.name]=this.mapNode(Or),Or.op.startsWith("Placeholder")?Pe.push(Rs[Or.name]):"Const"===Or.op?Ve.push(Rs[Or.name]):(null==Or.input||0===Or.input.length)&&et.push(Rs[Or.name]),Rs),{});let Wt=[];const mn=[];let rn={},$n={};null!=z&&(rn=this.mapSignatureEntries(z.inputs),$n=this.mapSignatureEntries(z.outputs));const zn=Object.keys(mt);zn.forEach(Rs=>{const Or=mt[Rs];Or.inputNames.forEach((zr,sr)=>{const[No,,ho]=Ue(zr),Rc=mt[No];if(null!=Rc.outputs){const Vr=Rc.outputs.indexOf(ho);-1!==Vr&&(Or.inputNames[sr]=`${No}:${Vr}`)}Or.inputs.push(Rc),Rc.children.push(Or)})}),0===Object.keys($n).length?zn.forEach(Rs=>{const Or=mt[Rs];0===Or.children.length&&mn.push(Or)}):Object.keys($n).forEach(Rs=>{const[Or]=Ue(Rs),zr=mt[Or];null!=zr&&(zr.signatureKey=$n[Rs],mn.push(zr))}),Object.keys(rn).length>0?Object.keys(rn).forEach(Rs=>{const[Or]=Ue(Rs),zr=mt[Or];zr&&(zr.signatureKey=rn[Rs],Wt.push(zr))}):Wt=Pe;let Bs={};null!=O.library&&null!=O.library.function&&(Bs=O.library.function.reduce((Rs,Or)=>(Rs[Or.signature.name]=this.mapFunction(Or),Rs),{}));const ur={nodes:mt,inputs:Wt,outputs:mn,weights:Ve,placeholders:Pe,signature:z,functions:Bs};return et.length>0&&(ur.initNodes=et),ur}mapSignatureEntries(O){return Object.keys(O||{}).reduce((z,pe)=>(z[O[pe].name]=pe,z),{})}mapNode(O){const z=ye(O.op)||this.opMappers[O.op]||{};null==O.attr&&(O.attr={});const pe={name:O.name,op:O.op,category:z.category,inputNames:(O.input||[]).map(Pe=>Pe.startsWith("^")?Pe.slice(1):Pe),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:O.attr,outputs:z.outputs};return null!=z.inputs&&(pe.inputParams=z.inputs.reduce((Pe,Ve)=>(Pe[Ve.name]={type:Ve.type,inputIndexStart:Ve.start,inputIndexEnd:Ve.end},Pe),{})),null!=z.attrs&&(pe.attrParams=z.attrs.reduce((Pe,Ve)=>{const et=Ve.type;let mt;switch(Ve.type){case"string":mt=Po(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=Po(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"string[]":mt=rl(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=rl(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"number":mt=za(O.attr,Ve.tfName,Ve.defaultValue||0),void 0===mt&&Ve.tfDeprecatedName&&(mt=za(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"number[]":mt=to(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=to(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"bool":mt=xa(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=xa(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"bool[]":mt=Fo(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=Fo(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"shape":mt=ka(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=ka(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"shape[]":mt=Wa(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=Wa(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"dtype":mt=Ao(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=Ao(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"dtype[]":mt=Ho(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=Ho(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"func":mt=lo(O.attr,Ve.tfName,Ve.defaultValue),void 0===mt&&Ve.tfDeprecatedName&&(mt=lo(O.attr,Ve.tfDeprecatedName,Ve.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${Ve.type} for op: ${O.op}`)}return Pe[Ve.name]={value:mt,type:et},Pe},{})),pe}mapFunction(O){const z=O.nodeDef,Pe=[];let Ve={};null!=z&&(Ve=z.reduce(($n,zn)=>($n[zn.name]=this.mapNode(zn),"Const"===zn.op&&Pe.push($n[zn.name]),$n),{}));const et=[],mt=[];O.signature.inputArg.forEach($n=>{const[zn]=Ue($n.name),Bs={name:zn,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:To($n.type),type:"dtype"}},children:[]};Bs.signatureKey=$n.name,et.push(Bs),Ve[zn]=Bs}),Object.keys(Ve).forEach($n=>{const zn=Ve[$n];zn.inputNames.forEach((Bs,ur)=>{const[Rs,,Or]=Ue(Bs),zr=Ve[Rs];if(null!=zr.outputs){const sr=zr.outputs.indexOf(Or);-1!==sr&&(zn.inputNames[ur]=`${Rs}:${sr}`)}zn.inputs.push(zr),zr.children.push(zn)})});const mn=O.ret;O.signature.outputArg.forEach($n=>{const[zn,Bs]=Ue(mn[$n.name]),ur=Ve[zn];null!=ur&&(ur.defaultOutput=Bs,mt.push(ur))});const rn=this.mapArgsToSignature(O);return{nodes:Ve,inputs:et,outputs:mt,weights:Pe,placeholders:[],signature:rn}}mapArgsToSignature(O){return{methodName:O.signature.name,inputs:O.signature.inputArg.reduce((z,pe)=>(z[pe.name]=this.mapArgToTensorInfo(pe),z),{}),outputs:O.signature.outputArg.reduce((z,pe)=>(z[pe.name]=this.mapArgToTensorInfo(pe,O.ret),z),{})}}mapArgToTensorInfo(O,z){let pe=O.name;return null!=z&&(pe=z[pe]),{name:pe,dtype:O.type}}}function aa(V,O){const z=Array.isArray(V)?String.fromCharCode.apply(null,V):function oa(V){const O=(0,ie.env)().global;if(typeof O.atob<"u")return O.atob(V);if(typeof Buffer<"u")return new Buffer(V,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(V);return O?z:z.toLowerCase()}function Po(V,O,z,pe=!1){const Pe=V[O];return null!=Pe?aa(Pe.s,pe):z}function xa(V,O,z){const pe=V[O];return pe?pe.b:z}function za(V,O,z){const pe=V[O]||{},Pe=null!=pe.i?pe.i:null!=pe.f?pe.f:z;return"number"==typeof Pe?Pe:parseInt(Pe,10)}function To(V){switch("string"==typeof V&&(V=te[V]),V){case te.DT_FLOAT:case te.DT_HALF:return"float32";case te.DT_INT32:case te.DT_INT64:case te.DT_INT8:case te.DT_UINT8:return"int32";case te.DT_BOOL:return"bool";case te.DT_DOUBLE:return"float32";case te.DT_STRING:return"string";default:return null}}function lo(V,O,z){const pe=V[O];return pe&&pe.func?pe.func.name:z}function Ao(V,O,z){const pe=V[O];return pe&&pe.type?To(pe.type):z}function Ho(V,O,z){const pe=V[O];return pe&&pe.list&&pe.list.type?pe.list.type.map(Pe=>To(Pe)):z}function sl(V){if(!V.unknownRank)return null!=V.dim?V.dim.map(O=>"number"==typeof O.size?O.size:parseInt(O.size,10)):[]}function ka(V,O,z){const pe=V[O];return pe&&pe.shape?sl(pe.shape):z}function to(V,O,z){const pe=V[O];return pe?((pe.list.f&&pe.list.f.length?pe.list.f:pe.list.i)||[]).map(Pe=>"number"==typeof Pe?Pe:parseInt(Pe,10)):z}function rl(V,O,z,pe=!1){const Pe=V[O];return Pe&&Pe.list&&Pe.list.s?Pe.list.s.map(Ve=>aa(Ve,pe)):z}function Wa(V,O,z){const pe=V[O];return pe&&pe.list&&pe.list.shape?pe.list.shape.map(Pe=>sl(Pe)):z}function Fo(V,O,z){const pe=V[O];return pe&&pe.list&&pe.list.b?pe.list.b:z}class Ha{constructor(O,z,pe){this.node=O,this.tensorMap=z,this.context=pe,this.inputs=[],this.attrs={},this.inputs=O.inputNames.map(Pe=>this.getInput(Pe)),null!=O.rawAttrs&&(this.attrs=Object.keys(O.rawAttrs).reduce((Pe,Ve)=>(Pe[Ve]=this.getAttr(Ve),Pe),{}))}getInput(O){return at(O,this.tensorMap,this.context)}getAttr(O,z){const pe=this.node.rawAttrs[O];if(null!=pe.tensor)return at(O,this.tensorMap,this.context);if(null!=pe.i||null!=pe.f)return za(this.node.rawAttrs,O,z);if(null!=pe.s)return Po(this.node.rawAttrs,O,z);if(null!=pe.b)return xa(this.node.rawAttrs,O,z);if(null!=pe.shape)return ka(this.node.rawAttrs,O,z);if(null!=pe.type)return Ao(this.node.rawAttrs,O,z);if(null!=pe.list){if(null!=pe.list.i||null!=pe.list.f)return to(this.node.rawAttrs,O,z);if(null!=pe.list.s)return rl(this.node.rawAttrs,O,z);if(null!=pe.list.shape)return Wa(this.node.rawAttrs,O,z);if(null!=pe.list.b)return Fo(this.node.rawAttrs,O,z);if(null!=pe.list.type)return Ho(this.node.rawAttrs,O,z)}return z}}var Jr,qe=h(2497);function ui(V,O,z=""){if("number"!=typeof V&&"number"!=typeof O){ie.util.assert(V.length===O.length,()=>z+` Shapes ${V} and ${O} must match`);for(let pe=0;pe<V.length;pe++){const Pe=V[pe],Ve=O[pe];ie.util.assert(Pe<0||Ve<0||Pe===Ve,()=>z+` Shapes ${V} and ${O} must match`)}}}function ja(V){return!("number"==typeof V||V.some(O=>O<0))}function Go(V,O,z){let pe=Li(V,z);const Pe=!ja(pe);if(Pe&&0===O.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${pe}`);if(Pe&&O.forEach(Ve=>{pe=Li(Ve.shape,pe)}),!ja(pe))throw new Error(`Non-fully-defined elementShape: ${pe}`);return pe}function Li(V,O){if("number"==typeof V)return O;if("number"==typeof O)return V;if(V.length!==O.length)throw new Error(`Incompatible ranks during merge: ${V} vs. ${O}`);const z=[];for(let pe=0;pe<V.length;++pe){const Pe=V[pe],Ve=O[pe];if(Pe>=0&&Ve>=0&&Pe!==Ve)throw new Error(`Incompatible shape during merge: ${V} vs. ${O}`);z[pe]=Pe>=0?Pe:Ve}return z}class wa{constructor(O,z,pe,Pe,Ve,et,mt){this.name=O,this.dtype=z,this.maxSize=pe,this.elementShape=Pe,this.identicalElementShapes=Ve,this.dynamicSize=et,this.clearAfterRead=mt,this.tensors=[],this.closed_=!1,this.idTensor=(0,ie.scalar)(0),(0,ie.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(O){this.tensors.forEach(z=>{(null==O||!O.has(z.tensor.id))&&z.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(O){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(O<0||O>=this.size())throw new Error(`Tried to read from index ${O}, but array size is: ${this.size()}`);const z=this.tensors[O];if(z.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${O} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(z.cleared=!0),z.read=!0,z.tensor}readMany(O){return O.map(z=>this.read(z))}write(O,z){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(O<0||!this.dynamicSize&&O>=this.maxSize)throw new Error(`Tried to write to index ${O}, but array is not resizeable and size is: ${this.maxSize}`);const pe=this.tensors[O]||{};if(z.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${O},\n          because the value dtype is ${z.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=z.shape),ui(this.elementShape,z.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${O}.`),pe.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${O}, because it has already been read.`);if(pe.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${O}, because it has already been written.`);pe.tensor=z,(0,ie.keep)(z),pe.written=!0,this.tensors[O]=pe}writeMany(O,z){if(O.length!==z.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${O.length} is not the same as tensors size: ${z.length}.`);O.forEach((pe,Pe)=>this.write(pe,z[Pe]))}gather(O,z){if(z&&z!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${z}`);if(O)O=O.slice(0,this.size());else{O=[];for(let Pe=0;Pe<this.size();Pe++)O.push(Pe)}if(0===O.length)return(0,ie.tensor)([],[0].concat(this.elementShape));const pe=this.readMany(O);return ui(this.elementShape,pe[0].shape,"TensorArray shape mismatch: "),(0,ie.stack)(pe,0)}concat(O){if(O&&O!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${O}`);if(0===this.size())return(0,ie.tensor)([],[0].concat(this.elementShape));const z=[];for(let Pe=0;Pe<this.size();Pe++)z.push(Pe);const pe=this.readMany(z);return ui(this.elementShape,pe[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${pe[0].shape})`),(0,ie.concat)(pe,0)}scatter(O,z){if(z.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${z.dtype}`);if(O.length!==z.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${O.length} vs. ${z.shape[0]}`);const pe=Math.max(...O);if(!this.dynamicSize&&pe>=this.maxSize)throw new Error(`Max index must be < array size (${pe}  vs. ${this.maxSize})`);this.writeMany(O,(0,ie.unstack)(z,0))}split(O,z){if(z.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${z.dtype}`);let pe=0;const Pe=O.map(Wt=>(pe+=Wt,pe));if(pe!==z.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${pe}, and tensor's shape is: ${z.shape}`);if(!this.dynamicSize&&O.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${O.length}), and the TensorArray is not marked as dynamically resizeable`);const Ve=0===pe?0:z.size/pe,et=[];(0,ie.tidy)(()=>{z=(0,ie.reshape)(z,[1,pe,Ve]);for(let Wt=0;Wt<O.length;++Wt)et[Wt]=(0,ie.reshape)((0,ie.slice)(z,[0,0===Wt?0:Pe[Wt-1],0],[1,O[Wt],Ve]),this.elementShape);return et});const mt=[];for(let Wt=0;Wt<O.length;Wt++)mt[Wt]=Wt;this.writeMany(mt,et)}}class Ki{constructor(O,z,pe,Pe=-1){this.tensors=O,this.elementShape=z,this.elementDtype=pe,O?.forEach(Ve=>{if(pe!==Ve.dtype)throw new Error(`Invalid data types; op elements ${pe}, but list elements ${Ve.dtype}`);ui(z,Ve.shape,"TensorList shape mismatch: "),(0,ie.keep)(Ve)}),this.idTensor=(0,ie.scalar)(0),this.maxNumElements=Pe,(0,ie.keep)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ki([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(O){this.tensors.forEach(z=>{(null==O||!O.has(z.id))&&z.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(O,z,pe=-1){if(z!==this.elementDtype)throw new Error(`Invalid data types; op elements ${z}, but list elements ${this.elementDtype}`);if(-1!==pe&&this.tensors.length!==pe)throw new Error(`Operation expected a list with ${pe} elements but got a list with ${this.tensors.length} elements.`);ui(O,this.elementShape,"TensorList shape mismatch: ");const Pe=Go(this.elementShape,this.tensors,O);return(0,ie.tidy)(()=>{const Ve=this.tensors.map(et=>(0,ie.reshape)(et,Pe));return(0,ie.stack)(Ve,0)})}popBack(O,z){if(z!==this.elementDtype)throw new Error(`Invalid data types; op elements ${z}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const pe=Go(this.elementShape,this.tensors,O),Pe=this.tensors.pop();return Pe.kept=!1,ui(Pe.shape,O,"TensorList shape mismatch: "),(0,ie.reshape)(Pe,pe)}pushBack(O){if(O.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${O.dtype}, but list elements ${this.elementDtype}`);if(ui(O.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,ie.keep)(O),this.tensors.push(O)}resize(O){if(O<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${O}`);if(-1!==this.maxNumElements&&O>this.maxNumElements)throw new Error(`TensorListResize input size ${O} is greater maxNumElement ${this.maxNumElements}.`);const z=new Ki([],this.elementShape,this.elementDtype,this.maxNumElements);z.tensors.length=O;for(let pe=0;pe<Math.min(this.tensors.length,O);++pe)z.tensors[pe]=this.tensors[pe];return z}getItem(O,z,pe){if(pe!==this.elementDtype)throw new Error(`Invalid data types; op elements ${pe}, but list elements ${this.elementDtype}`);if(O<0||O>this.tensors.length)throw new Error(`Trying to access element ${O} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[O])throw new Error(`element at index ${O} is null.`);ui(this.tensors[O].shape,z,"TensorList shape mismatch: ");const Pe=Go(this.elementShape,this.tensors,z);return(0,ie.reshape)(this.tensors[O],Pe)}setItem(O,z){if(z.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${z.dtype}, but list elements ${this.elementDtype}`);if(O<0||-1!==this.maxNumElements&&O>=this.maxNumElements)throw new Error(`Trying to set element ${O} in a list with max ${this.maxNumElements} elements.`);ui(this.elementShape,z.shape,"TensorList shape mismatch: "),(0,ie.keep)(z),null!=this.tensors[O]&&(this.tensors[O].kept=!1),this.tensors[O]=z}gather(O,z,pe){if(z!==this.elementDtype)throw new Error(`Invalid data types; op elements ${z}, but list elements ${this.elementDtype}`);ui(this.elementShape,pe,"TensorList shape mismatch: "),O=O.slice(0,this.size());const Pe=Go(this.elementShape,this.tensors,pe);return 0===O.length?(0,ie.tensor)([],[0].concat(Pe)):(0,ie.tidy)(()=>{const Ve=O.map(et=>(0,ie.reshape)(this.tensors[et],Pe));return(0,ie.stack)(Ve,0)})}concat(O,z){if(O&&O!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${O}`);ui(this.elementShape,z,"TensorList shape mismatch: ");const pe=Go(this.elementShape,this.tensors,z);return 0===this.size()?(0,ie.tensor)([],[0].concat(pe)):(0,ie.tidy)(()=>{const Pe=this.tensors.map(Ve=>(0,ie.reshape)(Ve,pe));return(0,ie.concat)(Pe,0)})}}function hc(V,O,z){const[pe,Pe]=v("fusedOps",V,O,z),Ve="biasadd"===pe,et=!Ve,mt="prelu"===Pe,Wt="fusedbatchnorm"===pe,mn=v("numArgs",V,O,z);if(Ve){if(mt&&2!==mn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!mt&&Ve&&1!==mn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(Wt)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const rn=v("strides",V,O,z),$n=nn(V,O,z),zn=v("dataFormat",V,O,z).toUpperCase(),Bs=v("dilations",V,O,z);let[ur,Rs]=v("args",V,O,z);return et&&(Rs=ur,ur=void 0),{stride:rn,pad:$n,dataFormat:zn,dilations:Bs,biasArg:ur,preluArg:Rs,activationFunc:Pe,leakyreluAlpha:v("leakyreluAlpha",V,O,z)}}var ko;function fl(V,O,z){return{boxes:v("boxes",V,O,z),scores:v("scores",V,O,z),maxOutputSize:v("maxOutputSize",V,O,z),iouThreshold:v("iouThreshold",V,O,z),scoreThreshold:v("scoreThreshold",V,O,z),softNmsSigma:v("softNmsSigma",V,O,z)}}var Xa,zl=h(9418);class ol{constructor(O,z){this.keyDType=O,this.valueDType=z,this.handle=(0,ie.scalar)(0),this.tensorMap=new Map,(0,ie.keep)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(O=>O.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return zl.i(this.size(),"int32")}import(O,z){var pe=this;return(0,De.Z)(function*(){pe.checkKeyAndValueTensor(O,z);const Pe=yield O.data();return pe.tensorMap.forEach(Ve=>Ve.dispose()),pe.tensorMap.clear(),(0,ie.tidy)(()=>{const Ve=(0,ie.unstack)(z),et=Pe.length,mt=Ve.length;ie.util.assert(et===mt,()=>`The number of elements doesn't match, keys has ${et} elements, the values has ${mt} elements.`);for(let Wt=0;Wt<et;Wt++){const mn=Pe[Wt],rn=Ve[Wt];(0,ie.keep)(rn),pe.tensorMap.set(mn,rn)}return pe.handle})})()}find(O,z){var pe=this;return(0,De.Z)(function*(){pe.checkKeyAndValueTensor(O,z);const Pe=yield O.data();return(0,ie.tidy)(()=>{const Ve=[];for(let et=0;et<Pe.length;et++){const Wt=pe.findWithDefault(Pe[et],z);Ve.push(Wt)}return(0,ie.stack)(Ve)})})()}findWithDefault(O,z){return this.tensorMap.get(O)??z}checkKeyAndValueTensor(O,z){if(O.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${O.dtype}`);if(z.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${z.dtype}`)}}function mi(V,O,z,pe,Pe=ie.tidy){const Ve=((et,mt,Wt)=>{switch(et.category){case"arithmetic":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"BiasAdd":case"AddV2":case"Add":return[pe.add(v("a",V,O,z),v("b",V,O,z))];case"AddN":return[pe.addN(v("tensors",V,O,z))];case"FloorMod":case"Mod":return[pe.mod(v("a",V,O,z),v("b",V,O,z))];case"Mul":return[pe.mul(v("a",V,O,z),v("b",V,O,z))];case"RealDiv":case"Div":return[pe.div(v("a",V,O,z),v("b",V,O,z))];case"DivNoNan":return[pe.divNoNan(v("a",V,O,z),v("b",V,O,z))];case"FloorDiv":return[pe.floorDiv(v("a",V,O,z),v("b",V,O,z))];case"Sub":return[pe.sub(v("a",V,O,z),v("b",V,O,z))];case"Minimum":return[pe.minimum(v("a",V,O,z),v("b",V,O,z))];case"Maximum":return[pe.maximum(v("a",V,O,z),v("b",V,O,z))];case"Pow":return[pe.pow(v("a",V,O,z),v("b",V,O,z))];case"SquaredDifference":return[pe.squaredDifference(v("a",V,O,z),v("b",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"basic_math":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"Abs":case"ComplexAbs":return[pe.abs(v("x",V,O,z))];case"Acos":return[pe.acos(v("x",V,O,z))];case"Acosh":return[pe.acosh(v("x",V,O,z))];case"Asin":return[pe.asin(v("x",V,O,z))];case"Asinh":return[pe.asinh(v("x",V,O,z))];case"Atan":return[pe.atan(v("x",V,O,z))];case"Atan2":return[pe.atan2(v("x",V,O,z),v("y",V,O,z))];case"Atanh":return[pe.atanh(v("x",V,O,z))];case"Ceil":return[pe.ceil(v("x",V,O,z))];case"Complex":return[pe.complex(v("real",V,O,z),v("imag",V,O,z))];case"Cos":return[pe.cos(v("x",V,O,z))];case"Cosh":return[pe.cosh(v("x",V,O,z))];case"Elu":return[pe.elu(v("x",V,O,z))];case"Erf":return[pe.erf(v("x",V,O,z))];case"Exp":return[pe.exp(v("x",V,O,z))];case"Expm1":return[pe.expm1(v("x",V,O,z))];case"Floor":return[pe.floor(v("x",V,O,z))];case"Log":return[pe.log(v("x",V,O,z))];case"Log1p":return[pe.log1p(v("x",V,O,z))];case"Imag":return[pe.imag(v("x",V,O,z))];case"Neg":return[pe.neg(v("x",V,O,z))];case"Reciprocal":return[pe.reciprocal(v("x",V,O,z))];case"Real":return[pe.real(v("x",V,O,z))];case"Relu":return[pe.relu(v("x",V,O,z))];case"Round":return[pe.round(v("x",V,O,z))];case"Selu":return[pe.selu(v("x",V,O,z))];case"Sigmoid":return[pe.sigmoid(v("x",V,O,z))];case"Sin":return[pe.sin(v("x",V,O,z))];case"Sign":return[pe.sign(v("x",V,O,z))];case"Sinh":return[pe.sinh(v("x",V,O,z))];case"Softplus":return[pe.softplus(v("x",V,O,z))];case"Sqrt":return[pe.sqrt(v("x",V,O,z))];case"Square":return[pe.square(v("x",V,O,z))];case"Tanh":return[pe.tanh(v("x",V,O,z))];case"Tan":return[pe.tan(v("x",V,O,z))];case"ClipByValue":return[pe.clipByValue(v("x",V,O,z),v("clipValueMin",V,O,z),v("clipValueMax",V,O,z))];case"Relu6":return[pe.relu6(v("x",V,O,z))];case"Rsqrt":return[pe.rsqrt(at(V.inputNames[0],O,z))];case"Prod":return[pe.prod(v("x",V,O,z),v("axes",V,O,z))];case"LeakyRelu":return[pe.leakyRelu(v("x",V,O,z),v("alpha",V,O,z))];case"Prelu":return[pe.prelu(v("x",V,O,z),v("alpha",V,O,z))];case"IsNan":return[pe.isNaN(at(V.inputNames[0],O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"control":return function(O,z,pe){return(Jr=Jr||(0,De.Z)(function*(Pe,Ve,et){switch(Pe.op){case"If":case"StatelessIf":{const mt=v("thenBranch",Pe,Ve,et),Wt=v("elseBranch",Pe,Ve,et),mn=v("cond",Pe,Ve,et),rn=v("args",Pe,Ve,et);return(yield mn.data())[0]?et.functionMap[mt].executeFunctionAsync(rn,et.tensorArrayMap,et.tensorListMap):et.functionMap[Wt].executeFunctionAsync(rn,et.tensorArrayMap,et.tensorListMap)}case"While":case"StatelessWhile":{const mt=v("body",Pe,Ve,et),Wt=v("cond",Pe,Ve,et),mn=v("args",Pe,Ve,et),rn=yield et.functionMap[Wt].executeFunctionAsync(mn,et.tensorArrayMap,et.tensorListMap),$n=mn.map(ur=>ur.id);let zn=yield rn[0].data();rn.forEach(ur=>{!ur.kept&&-1===$n.indexOf(ur.id)&&ur.dispose()});let Bs=mn;for(;zn[0];){const ur=Bs;Bs=yield et.functionMap[mt].executeFunctionAsync(Bs,et.tensorArrayMap,et.tensorListMap);const Rs=Bs.map(zr=>zr.id);ur.forEach(zr=>{!zr.kept&&-1===$n.indexOf(zr.id)&&-1===Rs.indexOf(zr.id)&&zr.dispose()});const Or=yield et.functionMap[Wt].executeFunctionAsync(Bs,et.tensorArrayMap,et.tensorListMap);zn=yield Or[0].data(),Or.forEach(zr=>{!zr.kept&&-1===$n.indexOf(zr.id)&&-1===Rs.indexOf(zr.id)&&zr.dispose()})}return Bs}case"LoopCond":return[Bt(v("pred",Pe,Ve,et))];case"Switch":{const mt=v("pred",Pe,Ve,et);let Wt=v("data",Pe,Ve,et);return Wt.kept||(Wt=Bt(Wt)),(yield mt.data())[0]?[void 0,Wt]:[Wt,void 0]}case"Merge":{const mt=Pe.inputNames.find(Wt=>void 0!==at(Wt,Ve,et));return mt?[Bt(at(mt,Ve,et))]:void 0}case"Enter":{const mt=v("frameName",Pe,Ve,et),Wt=v("tensor",Pe,Ve,et);return et.enterFrame(mt),[Bt(Wt)]}case"Exit":{const mt=v("tensor",Pe,Ve,et);return et.exitFrame(),[Bt(mt)]}case"NextIteration":{const mt=v("tensor",Pe,Ve,et);return et.nextIteration(),[Bt(mt)]}case"TensorArrayV3":{const mt=v("size",Pe,Ve,et),Wt=v("dtype",Pe,Ve,et),mn=v("elementShape",Pe,Ve,et),rn=v("dynamicSize",Pe,Ve,et),$n=v("clearAfterRead",Pe,Ve,et),zn=v("identicalElementShapes",Pe,Ve,et),Bs=v("name",Pe,Ve,et),ur=new wa(Bs,Wt,mt,mn,zn,rn,$n);return et.addTensorArray(ur),[ur.idTensor,(0,ie.scalar)(1)]}case"TensorArrayWriteV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=v("index",Pe,Ve,et),mn=v("tensor",Pe,Ve,et),rn=et.getTensorArray(mt.id);return rn.write(Wt,mn),[rn.idTensor]}case"TensorArrayReadV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=v("index",Pe,Ve,et);return[et.getTensorArray(mt.id).read(Wt)]}case"TensorArrayGatherV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=v("indices",Pe,Ve,et),mn=v("dtype",Pe,Ve,et);return[et.getTensorArray(mt.id).gather(Wt,mn)]}case"TensorArrayScatterV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=v("indices",Pe,Ve,et),mn=v("tensor",Pe,Ve,et),rn=et.getTensorArray(mt.id);return rn.scatter(Wt,mn),[rn.idTensor]}case"TensorArrayConcatV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=et.getTensorArray(mt.id),mn=v("dtype",Pe,Ve,et);return[Wt.concat(mn)]}case"TensorArraySplitV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=v("tensor",Pe,Ve,et),mn=v("lengths",Pe,Ve,et),rn=et.getTensorArray(mt.id);return rn.split(mn,Wt),[rn.idTensor]}case"TensorArraySizeV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=et.getTensorArray(mt.id);return[(0,ie.scalar)(Wt.size(),"int32")]}case"TensorArrayCloseV3":{const mt=v("tensorArrayId",Pe,Ve,et),Wt=et.getTensorArray(mt.id);return Wt.clearAndClose(),[Wt.idTensor]}case"TensorListSetItem":{const mt=v("tensorListId",Pe,Ve,et),Wt=v("index",Pe,Ve,et),mn=v("tensor",Pe,Ve,et),rn=et.getTensorList(mt.id);return rn.setItem(Wt,mn),[rn.idTensor]}case"TensorListGetItem":{const mt=v("tensorListId",Pe,Ve,et),Wt=v("index",Pe,Ve,et),mn=v("elementShape",Pe,Ve,et),rn=v("elementDType",Pe,Ve,et);return[et.getTensorList(mt.id).getItem(Wt,mn,rn)]}case"TensorListScatterV2":case"TensorListScatter":{const mt=v("indices",Pe,Ve,et),$n=function Bi(V,O,z,pe){if(O.length!==V.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${O.length} vs. ${V.shape[0]}`);const Pe=Math.max(...O);if(null!=pe&&-1!==pe&&Pe>=pe)throw new Error(`Max index must be < array size (${Pe}  vs. ${pe})`);const Ve=new Ki([],z,V.dtype,pe),et=(0,ie.unstack)(V,0);return O.forEach((mt,Wt)=>{Ve.setItem(mt,et[Wt])}),Ve}(v("tensor",Pe,Ve,et),mt,v("elementShape",Pe,Ve,et),v("numElements",Pe,Ve,et));return et.addTensorList($n),[$n.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const mt=v("elementShape",Pe,Ve,et),Wt=v("elementDType",Pe,Ve,et);let mn;mn="TensorListReserve"===Pe.op?"numElements":"maxNumElements";const rn=v(mn,Pe,Ve,et),zn=function $i(V,O,z,pe){return new Ki([],V,O,pe)}(mt,Wt,0,"TensorListReserve"===Pe.op?-1:rn);return et.addTensorList(zn),[zn.idTensor]}case"TensorListGather":{const mt=v("tensorListId",Pe,Ve,et),Wt=v("indices",Pe,Ve,et),mn=v("elementShape",Pe,Ve,et),rn=v("elementDType",Pe,Ve,et);return[et.getTensorList(mt.id).gather(Wt,rn,mn)]}case"TensorListStack":{const mt=v("tensorListId",Pe,Ve,et),Wt=v("elementShape",Pe,Ve,et),mn=v("elementDType",Pe,Ve,et),rn=v("numElements",Pe,Ve,et);return[et.getTensorList(mt.id).stack(Wt,mn,rn)]}case"TensorListFromTensor":{const rn=function Xi(V,O,z){const pe=V.dtype;if(V.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${V.shape}`);if(V.dtype!==z)throw new Error(`Invalid data types; op elements ${V.dtype}, but list elements ${z}`);ui(V.shape.slice(1),O,"TensorList shape mismatch: ");const Ve=(0,ie.unstack)(V);return new Ki(Ve,O,pe)}(v("tensor",Pe,Ve,et),v("elementShape",Pe,Ve,et),v("elementDType",Pe,Ve,et));return et.addTensorList(rn),[rn.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const mt=v("tensorListId",Pe,Ve,et),Wt=et.getTensorList(mt.id),mn=v("dtype",Pe,Ve,et),rn=v("elementShape",Pe,Ve,et);return[Wt.concat(mn,rn)]}case"TensorListPushBack":{const mt=v("tensorListId",Pe,Ve,et),Wt=v("tensor",Pe,Ve,et),mn=et.getTensorList(mt.id);return mn.pushBack(Wt),[mn.idTensor]}case"TensorListPopBack":{const mt=v("tensorListId",Pe,Ve,et),Wt=v("elementShape",Pe,Ve,et),mn=v("elementDType",Pe,Ve,et);return[et.getTensorList(mt.id).popBack(Wt,mn)]}case"TensorListSplit":{const mt=v("tensor",Pe,Ve,et),Wt=v("elementShape",Pe,Ve,et),rn=function hl(V,O,z){let pe=0;const Pe=O.map(rn=>(pe+=rn,pe));if(pe!==V.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${pe}, and tensor's shape is: ${V.shape}`);const et=Li(V.shape.slice(1),z),mt=0===pe?0:V.size/pe,Wt=(0,ie.tidy)(()=>{const rn=[];V=(0,ie.reshape)(V,[1,pe,mt]);for(let $n=0;$n<O.length;++$n)rn[$n]=(0,ie.reshape)((0,ie.slice)(V,[0,0===$n?0:Pe[$n-1],0],[1,O[$n],mt]),et);return V.dispose(),rn}),mn=new Ki([],z,V.dtype,O.length);for(let rn=0;rn<Wt.length;rn++)mn.setItem(rn,Wt[rn]);return mn}(mt,v("lengths",Pe,Ve,et),Wt);return et.addTensorList(rn),[rn.idTensor]}case"TensorListLength":{const mt=v("tensorListId",Pe,Ve,et),Wt=et.getTensorList(mt.id);return[(0,ie.scalar)(Wt.size(),"int32")]}case"TensorListResize":{const mt=v("tensorListId",Pe,Ve,et),Wt=v("size",Pe,Ve,et),rn=et.getTensorList(mt.id).resize(Wt);return et.addTensorList(rn),[rn.idTensor]}default:throw TypeError(`Node type ${Pe.op} is not implemented`)}})).apply(this,arguments)}(et,mt,Wt);case"convolution":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"Conv1D":{const Pe=v("stride",V,O,z),Ve=v("pad",V,O,z),et=v("dataFormat",V,O,z).toUpperCase(),mt=v("dilation",V,O,z);return[pe.conv1d(v("x",V,O,z),v("filter",V,O,z),Pe,Ve,et,mt)]}case"Conv2D":{const Pe=v("strides",V,O,z),Ve=nn(V,O,z),et=v("dataFormat",V,O,z).toUpperCase(),mt=v("dilations",V,O,z);return[pe.conv2d(v("x",V,O,z),v("filter",V,O,z),[Pe[1],Pe[2]],Ve,et,[mt[1],mt[2]])]}case"_FusedConv2D":{const{stride:Pe,pad:Ve,dataFormat:et,dilations:mt,biasArg:Wt,preluArg:mn,activationFunc:rn,leakyreluAlpha:$n}=hc(V,O,z);return[pe.fused.conv2d({x:v("x",V,O,z),filter:v("filter",V,O,z),strides:[Pe[1],Pe[2]],pad:Ve,dataFormat:et,dilations:[mt[1],mt[2]],bias:Wt,activation:rn,preluActivationWeights:mn,leakyreluAlpha:$n})]}case"FusedDepthwiseConv2dNative":{const{stride:Pe,pad:Ve,dataFormat:et,dilations:mt,biasArg:Wt,preluArg:mn,activationFunc:rn,leakyreluAlpha:$n}=hc(V,O,z);return[pe.fused.depthwiseConv2d({x:v("x",V,O,z),filter:v("filter",V,O,z),strides:[Pe[1],Pe[2]],pad:Ve,dataFormat:et,dilations:[mt[1],mt[2]],bias:Wt,activation:rn,preluActivationWeights:mn,leakyreluAlpha:$n})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const Pe=v("outputShape",V,O,z),Ve=v("strides",V,O,z),et=nn(V,O,z);return[pe.conv2dTranspose(v("x",V,O,z),v("filter",V,O,z),Pe,[Ve[1],Ve[2]],et)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const Pe=v("strides",V,O,z),Ve=nn(V,O,z),et=v("dilations",V,O,z),mt=v("dataFormat",V,O,z).toUpperCase();return[pe.depthwiseConv2d(v("input",V,O,z),v("filter",V,O,z),[Pe[1],Pe[2]],Ve,mt,[et[1],et[2]])]}case"Conv3D":{const Pe=v("strides",V,O,z),Ve=v("pad",V,O,z),et=v("dataFormat",V,O,z).toUpperCase(),mt=v("dilations",V,O,z);return[pe.conv3d(v("x",V,O,z),v("filter",V,O,z),[Pe[1],Pe[2],Pe[3]],Ve,et,[mt[1],mt[2],mt[3]])]}case"AvgPool":{const Pe=v("strides",V,O,z),Ve=v("pad",V,O,z),et=v("kernelSize",V,O,z);return[pe.avgPool(v("x",V,O,z),[et[1],et[2]],[Pe[1],Pe[2]],Ve)]}case"MaxPool":{const Pe=v("strides",V,O,z),Ve=v("pad",V,O,z),et=v("kernelSize",V,O,z);return[pe.maxPool(v("x",V,O,z),[et[1],et[2]],[Pe[1],Pe[2]],Ve)]}case"MaxPoolWithArgmax":{const Pe=v("strides",V,O,z),Ve=v("pad",V,O,z),et=v("kernelSize",V,O,z),mt=v("includeBatchInIndex",V,O,z),{result:Wt,indexes:mn}=pe.maxPoolWithArgmax(v("x",V,O,z),[et[1],et[2]],[Pe[1],Pe[2]],Ve,mt);return[Wt,mn]}case"AvgPool3D":{const Pe=v("strides",V,O,z),Ve=v("pad",V,O,z),et=v("kernelSize",V,O,z);return[pe.avgPool3d(v("x",V,O,z),[et[1],et[2],et[3]],[Pe[1],Pe[2],Pe[3]],Ve)]}case"MaxPool3D":{const Pe=v("strides",V,O,z),Ve=v("pad",V,O,z),et=v("kernelSize",V,O,z);return[pe.maxPool3d(v("x",V,O,z),[et[1],et[2],et[3]],[Pe[1],Pe[2],Pe[3]],Ve)]}case"Dilation2D":{const Pe=v("strides",V,O,z),Ve=v("pad",V,O,z),et=v("dilations",V,O,z),mt=Pe[1],Wt=Pe[2],mn=et[1],rn=et[2];return[pe.dilation2d(v("x",V,O,z),v("filter",V,O,z),[mt,Wt],Ve,[mn,rn],"NHWC")]}default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"creation":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"Fill":{const Pe=v("shape",V,O,z),Ve=v("dtype",V,O,z),et=v("value",V,O,z);return[pe.fill(Pe,et,Ve)]}case"LinSpace":{const Pe=v("start",V,O,z),Ve=v("stop",V,O,z),et=v("num",V,O,z);return[pe.linspace(Pe,Ve,et)]}case"Multinomial":{const Pe=v("logits",V,O,z),Ve=v("numSamples",V,O,z),et=v("seed",V,O,z);return[pe.multinomial(Pe,Ve,et)]}case"OneHot":{const Pe=v("indices",V,O,z),Ve=v("depth",V,O,z),et=v("onValue",V,O,z),mt=v("offValue",V,O,z),Wt=v("dtype",V,O,z);return[pe.oneHot(Pe,Ve,et,mt,Wt)]}case"Ones":return[pe.ones(v("shape",V,O,z),v("dtype",V,O,z))];case"OnesLike":return[pe.onesLike(v("x",V,O,z))];case"RandomStandardNormal":return[pe.randomStandardNormal(v("shape",V,O,z),v("dtype",V,O,z),v("seed",V,O,z))];case"RandomUniform":return[pe.randomUniform(v("shape",V,O,z),v("minval",V,O,z),v("maxval",V,O,z),v("dtype",V,O,z))];case"Range":{const Pe=v("start",V,O,z),Ve=v("stop",V,O,z),et=v("step",V,O,z);return[pe.range(Pe,Ve,et,v("dtype",V,O,z))]}case"TruncatedNormal":{const Pe=v("shape",V,O,z),Ve=v("mean",V,O,z),et=v("stdDev",V,O,z),mt=v("seed",V,O,z);return[pe.truncatedNormal(Pe,Ve,et,v("dtype",V,O,z),mt)]}case"Zeros":return[pe.zeros(v("shape",V,O,z),v("dtype",V,O,z))];case"ZerosLike":return[pe.zerosLike(v("x",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"dynamic":return function(O,z,pe,Pe){return(ko=ko||(0,De.Z)(function*(Ve,et,mt,Wt,mn=Oe){switch(Ve.op){case"NonMaxSuppressionV5":{const{boxes:rn,scores:$n,maxOutputSize:zn,iouThreshold:Bs,scoreThreshold:ur,softNmsSigma:Rs}=fl(Ve,et,mt),Or=yield mn.image.nonMaxSuppressionWithScoreAsync(rn,$n,zn,Bs,ur,Rs);return[Or.selectedIndices,Or.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:rn,scores:$n,maxOutputSize:zn,iouThreshold:Bs,scoreThreshold:ur}=fl(Ve,et,mt),Rs=v("padToMaxOutputSize",Ve,et,mt),Or=yield mn.image.nonMaxSuppressionPaddedAsync(rn,$n,zn,Bs,ur,Rs);return[Or.selectedIndices,Or.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:rn,scores:$n,maxOutputSize:zn,iouThreshold:Bs,scoreThreshold:ur}=fl(Ve,et,mt);return[yield mn.image.nonMaxSuppressionAsync(rn,$n,zn,Bs,ur)]}case"Where":{const rn=mn.cast(v("condition",Ve,et,mt),"bool"),$n=[yield mn.whereAsync(rn)];return rn.dispose(),$n}case"ListDiff":return mn.setdiff1dAsync(v("x",Ve,et,mt),v("y",Ve,et,mt));default:throw TypeError(`Node type ${Ve.op} is not implemented`)}})).apply(this,arguments)}(et,mt,Wt);case"evaluation":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"LowerBound":{const Pe=v("sortedSequence",V,O,z),Ve=v("values",V,O,z);return[pe.lowerBound(Pe,Ve)]}case"TopKV2":{const Pe=v("x",V,O,z),Ve=v("k",V,O,z),et=v("sorted",V,O,z),mt=pe.topk(Pe,Ve,et);return[mt.values,mt.indices]}case"UpperBound":{const Pe=v("sortedSequence",V,O,z),Ve=v("values",V,O,z);return[pe.upperBound(Pe,Ve)]}case"Unique":{const Pe=v("x",V,O,z),Ve=pe.unique(Pe);return[Ve.values,Ve.indices]}case"UniqueV2":{const Pe=v("x",V,O,z),Ve=v("axis",V,O,z),et=pe.unique(Pe,Ve);return[et.values,et.indices]}default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"image":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"ResizeBilinear":{const Pe=v("images",V,O,z),Ve=v("size",V,O,z),et=v("alignCorners",V,O,z),mt=v("halfPixelCenters",V,O,z);return[pe.image.resizeBilinear(Pe,[Ve[0],Ve[1]],et,mt)]}case"ResizeNearestNeighbor":{const Pe=v("images",V,O,z),Ve=v("size",V,O,z),et=v("alignCorners",V,O,z),mt=v("halfPixelCenters",V,O,z);return[pe.image.resizeNearestNeighbor(Pe,[Ve[0],Ve[1]],et,mt)]}case"CropAndResize":{const Pe=v("image",V,O,z),Ve=v("boxes",V,O,z),et=v("boxInd",V,O,z),mt=v("cropSize",V,O,z),Wt=v("method",V,O,z),mn=v("extrapolationValue",V,O,z);return[pe.image.cropAndResize(Pe,Ve,et,mt,Wt,mn)]}case"ImageProjectiveTransformV3":{const Pe=v("images",V,O,z),Ve=v("transforms",V,O,z),et=v("outputShape",V,O,z),mt=v("fillValue",V,O,z),Wt=v("interpolation",V,O,z),mn=v("fillMode",V,O,z);return[pe.image.transform(Pe,Ve,Wt.toLowerCase(),mn.toLowerCase(),mt,et)]}default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"graph":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"Const":return O[V.name];case"PlaceholderWithDefault":const Pe=v("default",V,O,z);return[at(V.name,O,z)||Pe];case"Placeholder":return[at(V.name,O,z)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Bt(v("x",V,O,z))];case"IdentityN":return v("x",V,O,z).map(rn=>Bt(rn));case"Shape":return[pe.tensor1d(v("x",V,O,z).shape,"int32")];case"ShapeN":return v("x",V,O,z).map(rn=>pe.tensor1d(rn.shape));case"Size":return[pe.scalar(v("x",V,O,z).size,"int32")];case"Rank":return[pe.scalar(v("x",V,O,z).rank,"int32")];case"NoOp":return[pe.scalar(1)];case"Print":const et=v("x",V,O,z),mt=v("data",V,O,z),Wt=v("message",V,O,z),mn=v("summarize",V,O,z);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(Wt);for(let rn=0;rn<mt.length;rn++)console.log(Array.prototype.slice.call(mt[rn].dataSync()).slice(0,mn));return[et];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"logical":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"Equal":return[pe.equal(v("a",V,O,z),v("b",V,O,z))];case"NotEqual":return[pe.notEqual(v("a",V,O,z),v("b",V,O,z))];case"Greater":return[pe.greater(v("a",V,O,z),v("b",V,O,z))];case"GreaterEqual":return[pe.greaterEqual(v("a",V,O,z),v("b",V,O,z))];case"Less":return[pe.less(v("a",V,O,z),v("b",V,O,z))];case"LessEqual":return[pe.lessEqual(v("a",V,O,z),v("b",V,O,z))];case"LogicalAnd":return[pe.logicalAnd(v("a",V,O,z),v("b",V,O,z))];case"LogicalNot":return[pe.logicalNot(v("a",V,O,z))];case"LogicalOr":return[pe.logicalOr(v("a",V,O,z),v("b",V,O,z))];case"Select":case"SelectV2":return[pe.where(v("condition",V,O,z),v("a",V,O,z),v("b",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"matrices":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[pe.matMul(v("a",V,O,z),v("b",V,O,z),v("transposeA",V,O,z),v("transposeB",V,O,z))];case"Einsum":return[pe.einsum(v("equation",V,O,z),...v("tensors",V,O,z))];case"Transpose":return[pe.transpose(v("x",V,O,z),v("perm",V,O,z))];case"_FusedMatMul":const[Pe,Ve]=v("fusedOps",V,O,z),et="biasadd"===Pe,mt="prelu"===Ve,Wt=v("numArgs",V,O,z),mn=v("leakyreluAlpha",V,O,z);if(et){if(mt&&2!==Wt)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!mt&&1!==Wt)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[rn,$n]=v("args",V,O,z);return[pe.fused.matMul({a:v("a",V,O,z),b:v("b",V,O,z),transposeA:v("transposeA",V,O,z),transposeB:v("transposeB",V,O,z),bias:rn,activation:Ve,preluActivationWeights:$n,leakyreluAlpha:mn})];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"normalization":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"EuclideanNorm":return[pe.euclideanNorm(v("x",V,O,z),v("axis",V,O,z),v("keepDims",V,O,z))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[pe.batchNorm(v("x",V,O,z),v("mean",V,O,z),v("variance",V,O,z),v("offset",V,O,z),v("scale",V,O,z),v("epsilon",V,O,z))];case"LRN":return[pe.localResponseNormalization(v("x",V,O,z),v("radius",V,O,z),v("bias",V,O,z),v("alpha",V,O,z),v("beta",V,O,z))];case"Softmax":return[pe.softmax(v("x",V,O,z))];case"LogSoftmax":return[pe.logSoftmax(v("x",V,O,z))];case"SparseToDense":return[pe.sparseToDense(v("sparseIndices",V,O,z),v("outputShape",V,O,z),v("sparseValues",V,O,z),v("defaultValue",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"reduction":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"Max":{const mt=v("axis",V,O,z),Wt=v("keepDims",V,O,z);return[pe.max(v("x",V,O,z),mt,Wt)]}case"Mean":{const mt=v("axis",V,O,z),Wt=v("keepDims",V,O,z);return[pe.mean(v("x",V,O,z),mt,Wt)]}case"Min":{const mt=v("axis",V,O,z),Wt=v("keepDims",V,O,z);return[pe.min(v("x",V,O,z),mt,Wt)]}case"Sum":{const mt=v("axis",V,O,z),Wt=v("keepDims",V,O,z);return[pe.sum(v("x",V,O,z),mt,Wt)]}case"All":{const mt=v("axis",V,O,z),Wt=v("keepDims",V,O,z);return[pe.all(v("x",V,O,z),mt,Wt)]}case"Any":{const mt=v("axis",V,O,z),Wt=v("keepDims",V,O,z);return[pe.any(v("x",V,O,z),mt,Wt)]}case"ArgMax":{const mt=v("axis",V,O,z);return[pe.argMax(v("x",V,O,z),mt)]}case"ArgMin":{const mt=v("axis",V,O,z);return[pe.argMin(v("x",V,O,z),mt)]}case"Prod":{const mt=v("axis",V,O,z),Wt=v("keepDims",V,O,z);return[pe.prod(v("x",V,O,z),mt,Wt)]}case"Cumprod":{const mt=v("axis",V,O,z),Wt=v("exclusive",V,O,z),mn=v("reverse",V,O,z);return[pe.cumprod(v("x",V,O,z),mt,Wt,mn)]}case"Cumsum":{const mt=v("axis",V,O,z),Wt=v("exclusive",V,O,z),mn=v("reverse",V,O,z);return[pe.cumsum(v("x",V,O,z),mt,Wt,mn)]}case"Bincount":const Pe=v("x",V,O,z),Ve=v("weights",V,O,z),et=v("size",V,O,z);return[pe.bincount(Pe,Ve,et)];case"DenseBincount":{const mt=v("x",V,O,z),Wt=v("weights",V,O,z),mn=v("size",V,O,z),rn=v("binaryOutput",V,O,z);return[pe.denseBincount(mt,Wt,mn,rn)]}default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"slice_join":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"ConcatV2":case"Concat":{const Pe=v("n",V,O,z),Ve=v("axis",V,O,z);let et=v("tensors",V,O,z);return et=et.slice(0,Pe),[pe.concat(et,Ve)]}case"Gather":{const Pe=v("x",V,O,z),Ve=v("indices",V,O,z);return[pe.gather(Pe,pe.cast(Ve,"int32"),0)]}case"GatherV2":{const Pe=v("axis",V,O,z),Ve=v("batchDims",V,O,z),et=v("x",V,O,z),mt=v("indices",V,O,z);return[pe.gather(et,pe.cast(mt,"int32"),Pe,Ve)]}case"Reverse":{const Pe=v("dims",V,O,z),Ve=[];for(let mt=0;mt<Pe.length;mt++)Pe[mt]&&Ve.push(mt);const et=v("x",V,O,z);return[pe.reverse(et,Ve)]}case"ReverseV2":{const Pe=v("axis",V,O,z),Ve=v("x",V,O,z);return[pe.reverse(Ve,Pe)]}case"Slice":{const Pe=v("begin",V,O,z),Ve=v("size",V,O,z);return[pe.slice(v("x",V,O,z),Pe,Ve)]}case"StridedSlice":{const Pe=v("begin",V,O,z),Ve=v("end",V,O,z),et=v("strides",V,O,z),mt=v("beginMask",V,O,z),Wt=v("endMask",V,O,z),mn=v("ellipsisMask",V,O,z),rn=v("newAxisMask",V,O,z),$n=v("shrinkAxisMask",V,O,z),zn=v("x",V,O,z);return[pe.stridedSlice(zn,Pe,Ve,et,mt,Wt,mn,rn,$n)]}case"Pack":return(0,ie.tidy)(()=>{const Pe=v("axis",V,O,z),Ve=v("tensors",V,O,z),et=Ve[0].shape,mt=pe.squeeze(Ve[0]).shape,Wt=Ve.map(mn=>{const rn=ie.util.arraysEqual(mn.shape,et);if(!rn&&!ie.util.arraysEqual(pe.squeeze(mn).shape,mt))throw new Error("the input tensors shape does not match");return rn?mn:pe.reshape(mn,et)});return[pe.stack(Wt,Pe)]});case"Unpack":{const Pe=v("axis",V,O,z),Ve=v("tensor",V,O,z);return pe.unstack(Ve,Pe)}case"Tile":{const Pe=v("reps",V,O,z);return[pe.tile(v("x",V,O,z),Pe)]}case"Split":case"SplitV":{const Pe=v("axis",V,O,z),Ve=v("numOrSizeSplits",V,O,z),et=v("x",V,O,z);return pe.split(et,Ve,Pe)}case"ScatterNd":{const Pe=v("indices",V,O,z),Ve=v("values",V,O,z),et=v("shape",V,O,z);return[pe.scatterND(Pe,Ve,et)]}case"GatherNd":{const Pe=v("x",V,O,z),Ve=v("indices",V,O,z);return[pe.gatherND(Pe,Ve)]}case"SparseToDense":{const Pe=v("sparseIndices",V,O,z),Ve=v("outputShape",V,O,z),et=v("sparseValues",V,O,z),mt=v("defaultValue",V,O,z);return[pe.sparseToDense(Pe,et,Ve,et.dtype===mt.dtype?mt:pe.cast(mt,et.dtype))]}default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"sparse":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"SparseFillEmptyRows":{const{outputIndices:Pe,outputValues:Ve,emptyRowIndicator:et,reverseIndexMap:mt}=pe.sparse.sparseFillEmptyRows(v("indices",V,O,z),v("values",V,O,z),v("denseShape",V,O,z),v("defaultValue",V,O,z));return[Pe,Ve,et,mt]}case"SparseReshape":{const{outputIndices:Pe,outputShape:Ve}=pe.sparse.sparseReshape(v("inputIndices",V,O,z),v("inputShape",V,O,z),v("newShape",V,O,z));return[Pe,Ve]}case"SparseSegmentMean":return[pe.sparse.sparseSegmentMean(v("data",V,O,z),v("indices",V,O,z),v("segmentIds",V,O,z))];case"SparseSegmentSum":return[pe.sparse.sparseSegmentSum(v("data",V,O,z),v("indices",V,O,z),v("segmentIds",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"spectral":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"FFT":return[pe.fft(v("x",V,O,z))];case"IFFT":return[pe.ifft(v("x",V,O,z))];case"RFFT":return[pe.rfft(v("x",V,O,z))];case"IRFFT":return[pe.irfft(v("x",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"string":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"StringNGrams":{const{nGrams:Pe,nGramsSplits:Ve}=pe.string.stringNGrams(v("data",V,O,z),v("dataSplits",V,O,z),v("separator",V,O,z),v("nGramWidths",V,O,z),v("leftPad",V,O,z),v("rightPad",V,O,z),v("padWidth",V,O,z),v("preserveShortSequences",V,O,z));return[Pe,Ve]}case"StringSplit":{const{indices:Pe,values:Ve,shape:et}=pe.string.stringSplit(v("input",V,O,z),v("delimiter",V,O,z),v("skipEmpty",V,O,z));return[Pe,Ve,et]}case"StringToHashBucketFast":return[pe.string.stringToHashBucketFast(v("input",V,O,z),v("numBuckets",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"transformation":return Pe(()=>((V,O,z,pe=Oe)=>{switch(V.op){case"Cast":return[pe.cast(v("x",V,O,z),v("dtype",V,O,z))];case"ExpandDims":{const Pe=v("axis",V,O,z);return[pe.expandDims(v("x",V,O,z),Pe)]}case"Squeeze":{const Pe=v("axis",V,O,z);return[pe.squeeze(v("x",V,O,z),Pe)]}case"Reshape":return[pe.reshape(v("x",V,O,z),v("shape",V,O,z))];case"MirrorPad":return[pe.mirrorPad(v("x",V,O,z),v("padding",V,O,z),v("mode",V,O,z))];case"PadV2":case"Pad":return[pe.pad(v("x",V,O,z),v("padding",V,O,z),v("constantValue",V,O,z))];case"SpaceToBatchND":{const Pe=v("blockShape",V,O,z),Ve=v("paddings",V,O,z);return[pe.spaceToBatchND(v("x",V,O,z),Pe,Ve)]}case"BatchToSpaceND":{const Pe=v("blockShape",V,O,z),Ve=v("crops",V,O,z);return[pe.batchToSpaceND(v("x",V,O,z),Pe,Ve)]}case"DepthToSpace":{const Pe=v("blockSize",V,O,z),Ve=v("dataFormat",V,O,z).toUpperCase();return[pe.depthToSpace(v("x",V,O,z),Pe,Ve)]}case"BroadcastTo":return[pe.broadcastTo(v("x",V,O,z),v("shape",V,O,z))];case"BroadcastArgs":return[pe.broadcastArgs(v("s0",V,O,z),v("s1",V,O,z))];default:throw TypeError(`Node type ${V.op} is not implemented`)}})(et,mt,Wt));case"hash_table":return function(O,z,pe,Pe){return(Xa=Xa||(0,De.Z)(function*(Ve,et,mt,Wt){switch(Ve.op){case"HashTable":case"HashTableV2":{const mn=v("keyDType",Ve,et,mt),rn=v("valueDType",Ve,et,mt),$n=new ol(mn,rn);return Wt.addHashTable(Ve.name,$n),[$n.handle]}case"LookupTableImport":case"LookupTableImportV2":{const mn=v("tableHandle",Ve,et,mt,Wt),rn=v("keys",Ve,et,mt),$n=v("values",Ve,et,mt);return[yield Wt.getHashTableById(mn.id).import(rn,$n)]}case"LookupTableFind":case"LookupTableFindV2":{const mn=v("tableHandle",Ve,et,mt,Wt),rn=v("keys",Ve,et,mt),$n=v("defaultValue",Ve,et,mt);return[yield Wt.getHashTableById(mn.id).find(rn,$n)]}case"LookupTableSize":case"LookupTableSizeV2":{const mn=v("tableHandle",Ve,et,mt,Wt);return[Wt.getHashTableById(mn.id).tensorSize()]}default:throw TypeError(`Node type ${Ve.op} is not implemented`)}})).apply(this,arguments)}(et,mt,Wt,pe);case"custom":const mn=ye(et.op);if(mn&&mn.customExecutor)return mn.customExecutor(new Ha(et,mt,Wt));throw TypeError(`Custom op ${et.op} is not registered.`);default:throw TypeError(`Unknown op '${et.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(V,O,z);return ie.util.isPromise(Ve)?Ve.then(et=>[].concat(et)):[].concat(Ve)}class ic{constructor(O={},z={},pe={},Pe={}){this.weightMap=O,this.tensorArrayMap=z,this.tensorListMap=pe,this.functionMap=Pe,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(O,z){return{id:O,frameName:z,iterationId:0}}set currentContext(O){this.contexts!==O&&(this.contexts=O,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const O=[];for(let z=0;z<this.contexts.length-1;z++){const pe=this.contexts.slice(0,this.contexts.length-z);O.push(this.contextIdforContexts(pe))}O.push(""),this._currentContextIds=O}contextIdforContexts(O){return O?O.map(z=>0===z.id&&0===z.iterationId?"":`${z.frameName}-${z.iterationId}`).join("/"):""}enterFrame(O){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,O)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const O=Object.assign({},this.contexts[this.contexts.length-1]);O.iterationId+=1,O.id=this.lastId,this.contexts.splice(-1,1,O),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(O){return this.weightMap[O]}addTensorArray(O){this.tensorArrayMap[O.id]=O}getTensorArray(O){return this.tensorArrayMap[O]}addTensorList(O){this.tensorListMap[O.id]=O}getTensorList(O){return this.tensorListMap[O]}dispose(O){for(const z in this.tensorArrayMap)this.tensorArrayMap[z].clearAndClose(O);for(const z in this.tensorListMap)this.tensorListMap[z].clearAndClose(O)}}function Br(V,O,z,pe){const Pe=new Set,Ve=[];let et=null,mt=null;const Wt=new Set,mn=Object.keys(V).map(zn=>Ct(zn)[0]);let rn=[];null!=pe&&(rn=pe.map(zn=>Ct(zn.name)[0]));const $n=[...O];for(;$n.length>0;){const zn=$n.pop();if((Na(zn)||En(zn)||ki(zn))&&null==et&&(et=zn,mt=et.children.map(Bs=>Bs.name).filter(Bs=>Pe.has(Bs))),Pe.add(zn.name),null==z[zn.name]&&-1===mn.indexOf(zn.name)&&-1===rn.indexOf(zn.name)){if(0===zn.inputs.length){Ve.push(zn.name);continue}zn.inputs.forEach(Bs=>{Wt.has(Bs.name)||(Wt.add(Bs.name),$n.push(Bs))})}}return{inputs:V,outputs:O,usedNodes:Pe,missingInputs:Ve,dynamicNode:et,syncInputs:mt}}const Xo=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],go=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],ml=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Na(V){return Xo.indexOf(V.op)>=0}function En(V){return go.indexOf(V.op)>=0}function ki(V){return ml.indexOf(V.op)>=0}class wr{constructor(O,z){this.graph=O,this.parent=z,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=O.outputs,this._inputs=O.inputs,this._initNodes=O.initNodes,this._signature=O.signature,this._functions=O.functions,null!=O.functions&&Object.keys(O.functions).forEach(pe=>{this._functionExecutorMap[pe]=new wr(O.functions[pe],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(O){const z=Object.keys(O).map(pe=>O[pe].map(Pe=>Pe.id));this._weightIds=[].concat(...z),this._weightMap=O}set resourceManager(O){this._resourceManager=O}get inputs(){return this._inputs.map(O=>({name:O.name,shape:O.attrParams.shape?O.attrParams.shape.value:void 0,dtype:O.attrParams.dtype?O.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(O=>({name:O.name,shape:O.attrParams.shape?O.attrParams.shape.value:void 0,dtype:O.attrParams.dtype?O.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(O=>O.signatureKey||O.name)}get outputNodes(){return this._outputs.map(O=>{const z=O.signatureKey||O.name;return O.defaultOutput?`${z}:${O.defaultOutput}`:z})}get functions(){return Object.keys(this._functions).reduce((O,z)=>(O[z]=this._functions[z].signature,O),{})}getCompilationKey(O,z){const pe=O.map(Ve=>Ve.name).sort(),Pe=z.map(Ve=>Ve.name).sort();return pe.join(this.SEPERATOR)+"--"+Pe.join(this.SEPERATOR)}compile(O,z){const pe=Br(O,z,this.weightMap,this._initNodes),{missingInputs:Pe,dynamicNode:Ve,syncInputs:et}=pe;if(null!=Ve)throw new Error(`This execution contains the node '${Ve.name}', which has the dynamic op '${Ve.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${et}]`);if(Pe.length>0){const mt=z.map(mn=>mn.name),Wt=Object.keys(O);throw new Error(`Cannot compute the outputs [${mt}] from the provided inputs [${Wt}]. Missing the following inputs: [${Pe}]`)}return function dr(V,O,z){const{usedNodes:pe,inputs:Pe}=z,Ve=[],et=Object.keys(Pe).map(rn=>Ct(rn)[0]).map(rn=>V.nodes[rn]),mt=V.initNodes;et.forEach(rn=>{pe.has(rn.name)&&Ve.push(rn)}),V.weights.forEach(rn=>{pe.has(rn.name)&&Ve.push(rn)}),mt?.forEach(rn=>{pe.has(rn.name)&&Ve.push(rn)});const Wt=new Set,mn=[];for(;Ve.length>0;){const rn=Ve.pop();Wt.add(rn.name),O[rn.name]||mn.push(rn),rn.children.forEach($n=>{!Wt.has($n.name)&&pe.has($n.name)&&$n.inputs.every(zn=>Wt.has(zn.name))&&Ve.push($n)})}return mn}(this.graph,this.weightMap,pe)}execute(O,z){O=this.mapInputs(O);const pe=Object.keys(O).sort();this.checkInputs(O),this.checkInputShapeAndType(O),z=this.mapOutputs(z),this.checkOutputs(z);const Pe=pe.map($n=>this.graph.nodes[Ct($n)[0]]),Ve=z.map($n=>Ct($n)[0]);let et=Ve.map($n=>this.graph.nodes[$n]);this.resetIntermediateTensors(),0===et.length&&(et=this._outputs);const mt=this.getCompilationKey(Pe,et);let Wt=this.compiledMap.get(mt);null==Wt&&(Wt=this.compile(O,et),this.compiledMap.set(mt,Wt));const mn={},rn={};return(0,ie.tidy)(()=>{const $n=new ic(this.weightMap,mn,rn,this.functionExecutorMap),zn=Object.assign({},this.weightMap);Object.keys(O).forEach(Rs=>{const[Or,zr]=Ct(Rs),sr=[];sr[zr]=O[Rs],zn[Or]=sr});const Bs=this.getFrozenTensorIds(zn),ur={};for(let Rs=0;Rs<Wt.length;Rs++){const Or=Wt[Rs];if(!zn[Or.name]){const zr=mi(Or,zn,$n,this._resourceManager);if(ie.util.isPromise(zr))throw new Error(`The execution of the op '${Or.op}' returned a promise. Please use model.executeAsync() instead.`);zn[Or.name]=zr,this.checkTensorForDisposal(Or.name,Or,zn,$n,Bs,Ve,ur)}}return null==this.parent&&$n.dispose(Bs),z.map(Rs=>at(Rs,zn,$n))})}getFrozenTensorIds(O){const z=[].concat.apply([],Object.keys(O).map(pe=>O[pe]).map(pe=>pe.map(Pe=>Pe.id)));return new Set(z)}checkTensorForDisposal(O,z,pe,Pe,Ve,et,mt){"control"===z.category||-1!==et.indexOf(O)||(pe[O].forEach(Wt=>{null!=Wt&&(mt[Wt.id]=(mt[Wt.id]||0)+z.children.length)}),z.inputs.forEach(Wt=>{if("control"!==Wt.category){const mn=function Xe(V,O,z){return O[pt(V,z.currentContextId)]}(Wt.name,pe,Pe);mn?.forEach(rn=>{if(rn&&!rn.kept&&!Ve.has(rn.id)){const $n=mt[rn.id];if(1===$n){if(this.keepTensorForDebug){const[zn,Bs]=Ue(z.name,Pe);this.intermediateTensors[zn]||(this.intermediateTensors[zn]=[]),this.intermediateTensors[zn][Bs]=rn}else rn.dispose();delete mt[rn.id]}else null!=$n&&mt[rn.id]--}})}}))}executeAsync(O,z){var pe=this;return(0,De.Z)(function*(){return pe._executeAsync(O,z)})()}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach(O=>this.intermediateTensors[O].forEach(z=>z.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach(O=>{this.tensorsMap[O].forEach(pe=>{pe&&!pe.kept&&!pe.isDisposed&&!this.keepIds.has(pe.id)&&pe.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const O in this.intermediateTensors)this.intermediateTensors[O].forEach(z=>z.dispose()),delete this.intermediateTensors[O]}_executeAsync(O,z,pe=!1,Pe={},Ve={}){var et=this;return(0,De.Z)(function*(){pe||(O=et.mapInputs(O),et.checkInputs(O),et.checkInputShapeAndType(O),z=et.mapOutputs(z),et.checkOutputs(z));try{et.keepTensorForDebug=(0,ie.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch($n){console.warn($n.message)}et.resetIntermediateTensors();const mt=new ic(et.weightMap,Pe,Ve,et.functionExecutorMap);et.tensorsMap=yield et.executeWithControlFlow(O,mt,z,pe);const Wt=z.map($n=>at($n,et.tensorsMap,mt)),mn=Wt.map($n=>$n.id),rn=Object.keys(O).map($n=>O[$n].id);return et.keepIds=new Set([...mn,...rn,...et.weightIds]),et.keepTensorForDebug||et.disposeTensorsMap(),null==et.parent&&mt.dispose(et.keepIds),Wt})()}executeFunctionAsync(O,z,pe){var Pe=this;return(0,De.Z)(function*(){const Ve=O.reduce((et,mt,Wt)=>(et[Pe.inputs[Wt].name]=mt,et),{});return Pe._executeAsync(Ve,Pe.outputNodes,!0,z,pe)})()}executeWithControlFlow(O,z,pe,Pe){var Ve=this;return(0,De.Z)(function*(){const et=Object.keys(O),mt=et.map(ho=>Ve.graph.nodes[Ct(ho)[0]]),Wt=pe.map(ho=>Ct(ho)[0]);let mn=Wt.map(ho=>Ve.graph.nodes[ho]);0===mn.length&&(mn=Ve._outputs);const{usedNodes:rn,missingInputs:$n,dynamicNode:zn,syncInputs:Bs}=Br(O,mn,Ve.weightMap,Ve._initNodes),ur=[...mt,...Ve.graph.weights,...Ve._initNodes||[]].map(ho=>({node:ho,contexts:z.currentContext})),Rs=Object.assign({},Ve.weightMap);Object.keys(O).forEach(ho=>{const[Rc,Vr]=Ct(ho),Ec=[];Ec[Vr]=O[ho],Rs[Rc]=Ec});const Or={},zr=Ve.getFrozenTensorIds(Rs),sr={};for(;ur.length>0;){const ho=Ve.processStack(mt,ur,z,Rs,sr,zr,Wt,Or,rn);yield Promise.all(ho)}null==zn&&!Pe&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const No=mn.filter(ho=>!Na(ho)&&!at(ho.name,Rs,z)).map(ho=>ho.name);if(No.length>0){let ho="";throw null!=zn&&(ho=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${Bs}]`),new Error(`Cannot compute the outputs [${No}] from the provided inputs [${et}]. Consider providing the following inputs: [${$n}]. ${ho}`)}return Rs})()}processStack(O,z,pe,Pe,Ve,et,mt,Wt,mn){const rn=[];for(;z.length>0;){const $n=z.pop();pe.currentContext=$n.contexts;let zn="";if("Enter"===$n.node.op&&v("isConstant",$n.node,Pe,pe)&&([zn]=Ue($n.node.name,pe)),null==Pe[$n.node.name]){const Bs=mi($n.node,Pe,pe,this._resourceManager);zn||([zn]=Ue($n.node.name,pe));const ur=pe.currentContext;ie.util.isPromise(Bs)?rn.push(Bs.then(Rs=>(Pe[zn]=Rs,pe.currentContext=ur,this.checkTensorForDisposal(zn,$n.node,Pe,pe,et,mt,Wt),this.processChildNodes($n.node,z,pe,Pe,Ve,mn),Rs))):(Pe[zn]=Bs,this.checkTensorForDisposal(zn,$n.node,Pe,pe,et,mt,Wt),this.processChildNodes($n.node,z,pe,Pe,Ve,mn))}else this.processChildNodes($n.node,z,pe,Pe,Ve,mn)}return rn}processChildNodes(O,z,pe,Pe,Ve,et){O.children.forEach(mt=>{const[Wt]=Ue(mt.name,pe);Ve[Wt]||!et.has(mt.name)||("Merge"===mt.op?mt.inputNames.some(mn=>!!at(mn,Pe,pe))&&(Ve[Wt]=!0,z.push({contexts:pe.currentContext,node:mt})):mt.inputNames.every(mn=>!!at(mn,Pe,pe))&&(Ve[Wt]=!0,z.push({contexts:pe.currentContext,node:mt})))})}dispose(){Object.keys(this.weightMap).forEach(O=>this.weightMap[O].forEach(z=>z.dispose()))}checkInputShapeAndType(O){Object.keys(O).forEach(z=>{const pe=O[z],[Pe]=Ct(z),Ve=this.graph.nodes[Pe];if(Ve.attrParams.shape&&Ve.attrParams.shape.value){const et=Ve.attrParams.shape.value,mt=et.length===pe.shape.length&&pe.shape.every((Wt,mn)=>-1===et[mn]||et[mn]===Wt);ie.util.assert(mt,()=>`The shape of dict['${Ve.name}'] provided in model.execute(dict) must be [${et}], but was [${pe.shape}]`)}Ve.attrParams.dtype&&Ve.attrParams.dtype.value&&ie.util.assert(pe.dtype===Ve.attrParams.dtype.value,()=>`The dtype of dict['${Ve.name}'] provided in model.execute(dict) must be ${Ve.attrParams.dtype.value}, but was ${pe.dtype}`)})}mapInputs(O){const z={};for(const pe in O)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[pe]?z[this._signature.inputs[pe].name]=O[pe]:z[pe]=O[pe];return z}checkInputs(O){const z=Object.keys(O).filter(pe=>{const[Pe]=Ct(pe);return null==this.graph.nodes[Pe]});if(z.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${z}] that are not part of graph`)}mapOutputs(O){return O.map(z=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[z]?this._signature.outputs[z].name:z,{})}checkOutputs(O){O.forEach(z=>{const[pe]=Ct(z);if(!this.graph.nodes[pe])throw new Error(`The output '${z}' is not found in the graph`)})}}class ar{constructor(O={},z={}){this.hashTableNameToHandle=O,this.hashTableMap=z}addHashTable(O,z){this.hashTableNameToHandle[O]=z.handle,this.hashTableMap[z.id]=z}getHashTableHandleByName(O){return this.hashTableNameToHandle[O]}getHashTableById(O){return this.hashTableMap[O]}dispose(){for(const O in this.hashTableMap)this.hashTableMap[O].clearAndClose(),delete this.hashTableMap[O];for(const O in this.hashTableNameToHandle)this.hashTableNameToHandle[O].dispose(),delete this.hashTableNameToHandle[O]}}var Ma;const gn="?tfjs-format=file",qr="model.json";class Wl{constructor(O,z={},pe=ie.io){this.modelUrl=O,this.loadOptions=z,this.version="n/a",this.io=pe,null==z&&(this.loadOptions={}),this.resourceManager=new ar}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const O=this.modelUrl;if(null!=O.load)this.handler=O;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(O,this.loadOptions);else{const z=this.io.getLoadHandlers(O,this.loadOptions);if(0===z.length)z.push(this.io.browserHTTPRequest(O,this.loadOptions));else if(z.length>1)throw new Error(`Found more than one (${z.length}) load handlers for URL '${[O]}'`);this.handler=z[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const O=this.handler.load();return ie.util.isPromise(O)?O.then(z=>this.loadSync(z)):this.loadSync(O)}loadSync(O){this.artifacts=O;const z=this.artifacts.modelTopology;let pe=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const Ve=this.artifacts.userDefinedMetadata;null!=Ve.signature&&(pe=Ve.signature),null!=Ve.structuredOutputKeys&&(this.structuredOutputKeys=Ve.structuredOutputKeys)}this.signature=pe,this.version=`${z.versions.producer}.${z.versions.minConsumer}`;const Pe=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new wr(eo.Instance.transformGraph(z,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(Pe),this.executor.resourceManager=this.resourceManager,null!=O.modelInitializer&&null!=O.modelInitializer.node){const Ve=eo.Instance.transformGraph(O.modelInitializer);this.initializer=new wr(Ve),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(O,z){var pe=this;return(0,De.Z)(function*(){if("string"==typeof O){const Pe=pe.io.getSaveHandlers(O);if(0===Pe.length)throw new Error(`Cannot find any save handlers for URL '${O}'`);if(Pe.length>1)throw new Error(`Found more than one (${Pe.length}) save handlers for URL '${O}'`);O=Pe[0]}if(null==O.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return O.save(pe.artifacts)})()}predict(O,z){const pe=this.execute(O,this.outputNodes);if(this.structuredOutputKeys){const Ve={};return(pe instanceof ie.Tensor?[pe]:pe).forEach((et,mt)=>Ve[this.structuredOutputKeys[mt]]=et),Ve}return pe}normalizeInputs(O){if(!(O instanceof ie.Tensor||Array.isArray(O)))return O;if((O=Array.isArray(O)?O:[O]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${O.length} input tensors.`);return this.inputNodes.reduce((z,pe,Pe)=>(z[pe]=O[Pe],z),{})}normalizeOutputs(O){return O=O||this.outputNodes,Array.isArray(O)?O:[O]}execute(O,z){O=this.normalizeInputs(O),z=this.normalizeOutputs(z);const pe=this.executor.execute(O,z);return pe.length>1?pe:pe[0]}executeAsync(O,z){var pe=this;return(0,De.Z)(function*(){O=pe.normalizeInputs(O),z=pe.normalizeOutputs(z);const Pe=yield pe.executor.executeAsync(O,z);return Pe.length>1?Pe:Pe[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(O){return Object.keys(O).reduce((z,pe)=>(z[pe]=[O[pe]],z),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function _o(V){return(Ma=Ma||(0,De.Z)(function*(O,z={},pe=ie.io){if(null==O)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==z&&(z={}),z.fromTFHub&&"string"==typeof O&&(O=function Ro(V){return V.endsWith("/")||(V+="/"),`${V}${qr}${gn}`}(O));const Pe=new Wl(O,z,pe);return yield Pe.load(),Pe})).apply(this,arguments)}var ll=function(V,O){return(ll=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(z,pe){z.__proto__=pe}||function(z,pe){for(var Pe in pe)pe.hasOwnProperty(Pe)&&(z[Pe]=pe[Pe])})(V,O)};function Si(V,O){function z(){this.constructor=V}ll(V,O),V.prototype=null===O?Object.create(O):(z.prototype=O.prototype,new z)}var Ca=function(){return(Ca=Object.assign||function(V){for(var O,z=1,pe=arguments.length;z<pe;z++)for(var Pe in O=arguments[z])Object.prototype.hasOwnProperty.call(O,Pe)&&(V[Pe]=O[Pe]);return V}).apply(this,arguments)};function Pa(V,O,z,pe){return new(z||(z=Promise))(function(Pe,Ve){function et(mn){try{Wt(pe.next(mn))}catch(rn){Ve(rn)}}function mt(mn){try{Wt(pe.throw(mn))}catch(rn){Ve(rn)}}function Wt(mn){mn.done?Pe(mn.value):new z(function(rn){rn(mn.value)}).then(et,mt)}Wt((pe=pe.apply(V,O||[])).next())})}function Ea(V,O){var z,pe,Pe,Ve,et={label:0,sent:function(){if(1&Pe[0])throw Pe[1];return Pe[1]},trys:[],ops:[]};return Ve={next:mt(0),throw:mt(1),return:mt(2)},"function"==typeof Symbol&&(Ve[Symbol.iterator]=function(){return this}),Ve;function mt(Wt){return function(mn){return function(rn){if(z)throw new TypeError("Generator is already executing.");for(;et;)try{if(z=1,pe&&(Pe=2&rn[0]?pe.return:rn[0]?pe.throw||((Pe=pe.return)&&Pe.call(pe),0):pe.next)&&!(Pe=Pe.call(pe,rn[1])).done)return Pe;switch(pe=0,Pe&&(rn=[2&rn[0],Pe.value]),rn[0]){case 0:case 1:Pe=rn;break;case 4:return et.label++,{value:rn[1],done:!1};case 5:et.label++,pe=rn[1],rn=[0];continue;case 7:rn=et.ops.pop(),et.trys.pop();continue;default:if(!(Pe=(Pe=et.trys).length>0&&Pe[Pe.length-1])&&(6===rn[0]||2===rn[0])){et=0;continue}if(3===rn[0]&&(!Pe||rn[1]>Pe[0]&&rn[1]<Pe[3])){et.label=rn[1];break}if(6===rn[0]&&et.label<Pe[1]){et.label=Pe[1],Pe=rn;break}if(Pe&&et.label<Pe[2]){et.label=Pe[2],et.ops.push(rn);break}Pe[2]&&et.ops.pop(),et.trys.pop();continue}rn=O.call(V,et)}catch($n){rn=[6,$n],pe=0}finally{z=Pe=0}if(5&rn[0])throw rn[1];return{value:rn[0]?rn[1]:void 0,done:!0}}([Wt,mn])}}}var gl=function(){function V(O,z){this.model=O,this.outputStride=z;var pe=this.model.inputs[0].shape;ie.util.assert(-1===pe[1]&&-1===pe[2],function(){return"Input shape ["+pe[1]+", "+pe[2]+"] must both be equal to or -1"})}return V.prototype.predict=function(O){var z=this;return(0,ie.tidy)(function(){var pe=z.preprocessInput((0,ie.cast)(O,"float32")),Pe=(0,ie.expandDims)(pe,0),Ve=z.model.predict(Pe).map(function(mt){return(0,ie.squeeze)(mt,[0])}),et=z.nameOutputResults(Ve);return{heatmapScores:(0,ie.sigmoid)(et.heatmap),offsets:et.offsets,displacementFwd:et.displacementFwd,displacementBwd:et.displacementBwd}})},V.prototype.dispose=function(){this.model.dispose()},V}(),_l=function(V){function O(){return null!==V&&V.apply(this,arguments)||this}return Si(O,V),O.prototype.preprocessInput=function(z){return(0,ie.tidy)(function(){return(0,ie.sub)((0,ie.div)(z,127.5),1)})},O.prototype.nameOutputResults=function(z){return{offsets:z[0],heatmap:z[1],displacementFwd:z[2],displacementBwd:z[3]}},O}(gl);function q(V){return Math.floor(V/2)}var L=function(){function V(O,z){this.priorityQueue=new Array(O),this.numberOfElements=-1,this.getElementValue=z}return V.prototype.enqueue=function(O){this.priorityQueue[++this.numberOfElements]=O,this.swim(this.numberOfElements)},V.prototype.dequeue=function(){var O=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,O},V.prototype.empty=function(){return-1===this.numberOfElements},V.prototype.size=function(){return this.numberOfElements+1},V.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},V.prototype.max=function(){return this.priorityQueue[0]},V.prototype.swim=function(O){for(;O>0&&this.less(q(O),O);)this.exchange(O,q(O)),O=q(O)},V.prototype.sink=function(O){for(;2*O<=this.numberOfElements;){var z=2*O;if(z<this.numberOfElements&&this.less(z,z+1)&&z++,!this.less(O,z))break;this.exchange(O,z),O=z}},V.prototype.getValueAt=function(O){return this.getElementValue(this.priorityQueue[O])},V.prototype.less=function(O,z){return this.getValueAt(O)<this.getValueAt(z)},V.prototype.exchange=function(O,z){var pe=this.priorityQueue[O];this.priorityQueue[O]=this.priorityQueue[z],this.priorityQueue[z]=pe},V}();function X(V,O,z,pe,Pe,Ve){for(var et=Ve.shape,mt=et[0],Wt=et[1],mn=!0,rn=Math.max(z-Pe,0),$n=Math.min(z+Pe+1,mt),zn=rn;zn<$n;++zn){for(var Bs=Math.max(pe-Pe,0),ur=Math.min(pe+Pe+1,Wt),Rs=Bs;Rs<ur;++Rs)if(Ve.get(zn,Rs,V)>O){mn=!1;break}if(!mn)break}return mn}var He=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],Ye=He.length,it=He.reduce(function(V,O,z){return V[O]=z,V},{}),wt=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]],kn=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(V){return[it[V[0]],it[V[1]]]}),pn=["left_face","right_face","right_upper_leg_front","right_lower_leg_back","right_upper_leg_back","left_lower_leg_front","left_upper_leg_front","left_upper_leg_back","left_lower_leg_back","right_feet","right_lower_leg_front","left_feet","torso_front","torso_back","right_upper_arm_front","right_upper_arm_back","right_lower_arm_back","left_lower_arm_front","left_upper_arm_front","left_upper_arm_back","left_lower_arm_back","right_hand","right_lower_arm_front","left_hand"];function qn(V,O,z,pe){return{y:pe.get(V,O,z),x:pe.get(V,O,z+Ye)}}function os(V,O,z){var pe=qn(V.heatmapY,V.heatmapX,V.id,z);return{x:V.heatmapX*O+pe.x,y:V.heatmapY*O+pe.y}}function Ms(V,O,z){return V<O?O:V>z?z:V}function Cr(V,O){return{x:V.x+O.x,y:V.y+O.y}}var Is=wt.map(function(V){return[it[V[0]],it[V[1]]]}),lr=Is.map(function(V){return V[1]}),yo=Is.map(function(V){return V[0]});function Jt(V,O,z,pe){return{y:Ms(Math.round(V.y/O),0,z-1),x:Ms(Math.round(V.x/O),0,pe-1)}}function ai(V,O,z,pe,Pe,Ve,et,mt){void 0===mt&&(mt=2);for(var Wt=pe.shape,mn=Wt[0],rn=Wt[1],$n=function Da(V,O,z){var pe=z.shape[2]/2;return{y:z.get(O.y,O.x,V),x:z.get(O.y,O.x,pe+V)}}(V,Jt(O.position,Ve,mn,rn),et),zn=Cr(O.position,$n),Bs=0;Bs<mt;Bs++){var ur=Jt(zn,Ve,mn,rn),Rs=qn(ur.y,ur.x,z,Pe);zn=Cr({x:ur.x*Ve,y:ur.y*Ve},{x:Rs.x,y:Rs.y})}var Or=Jt(zn,Ve,mn,rn),zr=pe.get(Or.y,Or.x,z);return{position:zn,part:He[z],score:zr}}function oc(V,O,z,pe,Pe,Ve){var mt=lr.length,Wt=new Array(O.shape[2]),mn=V.part,rn=V.score,$n=os(mn,pe,z);Wt[mn.id]={score:rn,part:He[mn.id],position:$n};for(var zn=mt-1;zn>=0;--zn){var Bs=lr[zn],ur=yo[zn];Wt[Bs]&&!Wt[ur]&&(Wt[ur]=ai(zn,Wt[Bs],ur,O,z,pe,Ve))}for(zn=0;zn<mt;++zn)ur=lr[zn],Wt[Bs=yo[zn]]&&!Wt[ur]&&(Wt[ur]=ai(zn,Wt[Bs],ur,O,z,pe,Pe));return Wt}function wo(V,O,z,pe){var Pe=z.x,Ve=z.y;return V.some(function(et){var mt=et.keypoints[pe].position;return function Tr(V,O,z,pe){var Pe=z-V,Ve=pe-O;return Pe*Pe+Ve*Ve}(Ve,Pe,mt.y,mt.x)<=O})}function Fa(V,O,z){return z.reduce(function(pe,Pe,Ve){var mt=Pe.score;return wo(V,O,Pe.position,Ve)||(pe+=mt),pe},0)/z.length}var yl=1;function Fi(V,O,z,pe,Pe,Ve,et,mt){void 0===et&&(et=.5),void 0===mt&&(mt=20);for(var Wt=[],mn=function Ae(V,O,z){for(var pe=z.shape,Pe=pe[0],Ve=pe[1],et=pe[2],mt=new L(Pe*Ve*et,function(zn){return zn.score}),Wt=0;Wt<Pe;++Wt)for(var mn=0;mn<Ve;++mn)for(var rn=0;rn<et;++rn){var $n=z.get(Wt,mn,rn);$n<V||X(rn,$n,Wt,mn,O,z)&&mt.enqueue({score:$n,part:{heatmapY:Wt,heatmapX:mn,id:rn}})}return mt}(et,yl,V),rn=mt*mt;Wt.length<Ve&&!mn.empty();){var $n=mn.dequeue();if(!wo(Wt,rn,os($n.part,Pe,O),$n.part.id)){var zn=oc($n,V,O,Pe,z,pe),Bs=Fa(Wt,rn,zn);Wt.push({keypoints:zn,score:Bs})}}return Wt}function Hl(V,O,z,pe){return{y:pe.get(V,O,z),x:pe.get(V,O,z+Ye)}}function Oc(V,O,z){return(0,ie.tidy)(function(){var pe=function Zc(V,O){for(var z=[],pe=0;pe<Ye;pe++){var Pe=Hl(V.get(pe,0).valueOf(),V.get(pe,1).valueOf(),pe,O),Ve=Pe.x;z.push(Pe.y),z.push(Ve)}return(0,ie.tensor2d)(z,[Ye,2])}(V,z);return(0,ie.add)((0,ie.cast)((0,ie.mul)(V.toTensor(),(0,ie.scalar)(O,"int32")),"float32"),pe)})}function Fc(V,O,z){return Pa(this,void 0,void 0,function(){var pe,Pe,Ve,et,Wt,mn,rn,$n,zn;return Ea(this,function(Bs){switch(Bs.label){case 0:return pe=0,Pe=function Wu(V){var O=V.shape,z=O[0],pe=O[1],Pe=O[2];return(0,ie.tidy)(function(){var Ve=(0,ie.reshape)(V,[z*pe,Pe]),et=(0,ie.argMax)(Ve,0),mt=(0,ie.expandDims)((0,ie.div)(et,(0,ie.scalar)(pe,"int32")),1),Wt=(0,ie.expandDims)(function Yc(V,O){return(0,ie.tidy)(function(){var z=(0,ie.div)(V,(0,ie.scalar)(O,"int32"));return(0,ie.sub)(V,(0,ie.mul)(z,(0,ie.scalar)(O,"int32")))})}(et,pe),1);return(0,ie.concat)([mt,Wt],1)})}(V),[4,Promise.all([V.buffer(),O.buffer(),Pe.buffer()])];case 1:return Ve=Bs.sent(),et=Ve[0],[4,(mn=Oc(Wt=Ve[2],z,Ve[1])).buffer()];case 2:return rn=Bs.sent(),$n=Array.from(function vl(V,O){for(var z=O.shape[0],pe=new Float32Array(z),Pe=0;Pe<z;Pe++){var Ve=O.get(Pe,0),et=O.get(Pe,1);pe[Pe]=V.get(Ve,et,Pe)}return pe}(et,Wt)),zn=$n.map(function(ur,Rs){return pe+=ur,{position:{y:rn.get(Rs,0),x:rn.get(Rs,1)},part:He[Rs],score:ur}}),Pe.dispose(),mn.dispose(),[2,{keypoints:zn,score:pe/zn.length}]}})})}var Qc="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Ai="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/",ve=[-123.15,-115.9,-103.06],Be=function(V){function O(){return null!==V&&V.apply(this,arguments)||this}return Si(O,V),O.prototype.preprocessInput=function(z){return(0,ie.add)(z,ve)},O.prototype.nameOutputResults=function(z){return{offsets:z[2],heatmap:z[3],displacementFwd:z[0],displacementBwd:z[1]}},O}(gl);function st(V,O){return kn.reduce(function(z,pe){var Pe=pe[0],Ve=pe[1];return function ot(V,O,z){return V<z||O<z}(V[Pe].score,V[Ve].score,O)||z.push([V[Pe],V[Ve]]),z},[])}var Xt=Number.NEGATIVE_INFINITY,jt=Number.POSITIVE_INFINITY;function Yt(V){return V.reduce(function(O,z){var Pe=O.maxY,Ve=O.minX,et=O.minY,mt=z.position,Wt=mt.x,mn=mt.y;return{maxX:Math.max(O.maxX,Wt),maxY:Math.max(Pe,mn),minX:Math.min(Ve,Wt),minY:Math.min(et,mn)}},{maxX:Xt,maxY:Xt,minX:jt,minY:jt})}function xn(V){var O=Yt(V),z=O.minX,pe=O.minY,Pe=O.maxX,Ve=O.maxY;return[{x:z,y:pe},{x:Pe,y:pe},{x:Pe,y:Ve},{x:z,y:Ve}]}function ss(V){return Pa(this,void 0,void 0,function(){return Ea(this,function(O){return[2,Promise.all(V.map(function(z){return z.buffer()}))]})})}function Jn(V,O,z,pe,Pe){return void 0===pe&&(pe=0),void 0===Pe&&(Pe=0),{score:V.score,keypoints:V.keypoints.map(function(Ve){var Wt=Ve.position;return{score:Ve.score,part:Ve.part,position:{x:Wt.x*z+Pe,y:Wt.y*O+pe}}})}}function cn(V,O){return Yo(V,O)?V:Math.floor(V/O)*O+1}function Zr(V){ie.util.assert("number"==typeof V||"object"==typeof V,function(){return"Invalid inputResolution "+V+". Should be a number or an object with width and height"}),"object"==typeof V&&(ie.util.assert("number"==typeof V.width,function(){return"inputResolution.width has a value of "+V.width+" which is invalid; it must be a number"}),ie.util.assert("number"==typeof V.height,function(){return"inputResolution.height has a value of "+V.height+" which is invalid; it must be a number"}))}function jn(V,O){return Zr(V),"object"==typeof V?[cn(V.height,O),cn(V.width,O)]:[cn(V,O),cn(V,O)]}var Oi=[8,16,32];function Yo(V,O){return(V-1)%O==0}function hi(V){return V instanceof ie.Tensor?[V.shape[0],V.shape[1]]:[V.height,V.width]}function qt(V,O){var z=O[0],pe=O[1],Pe=hi(V),Ve=Pe[0],et=Pe[1],mt=pe/z,Wt=[0,0,0,0],mn=Wt[0],rn=Wt[1],$n=Wt[2],zn=Wt[3];return et/Ve<mt?(mn=0,rn=0,$n=Math.round(.5*(mt*Ve-et)),zn=Math.round(.5*(mt*Ve-et))):(mn=Math.round(.5*(1/mt*et-Ve)),rn=Math.round(.5*(1/mt*et-Ve)),$n=0,zn=0),{resized:(0,ie.tidy)(function(){var Bs=function ci(V){return V instanceof ie.Tensor?V:ie.browser.fromPixels(V)}(V);return Bs=(0,ie.pad3d)(Bs,[[mn,rn],[$n,zn],[0,0]]),ie.image.resizeBilinear(Bs,[z,pe])}),padding:{top:mn,left:$n,right:zn,bottom:rn}}}function jl(V,O,z,pe,Pe){var et=O[1],mn=function _r(V,O,z,pe,Pe){return void 0===pe&&(pe=0),void 0===Pe&&(Pe=0),1===z&&1===O&&0===pe&&0===Pe?V:V.map(function(Ve){return Jn(Ve,O,z,pe,Pe)})}(V,(O[0]+pe.top+pe.bottom)/z[0],(et+pe.left+pe.right)/z[1],-pe.top,-pe.left);return Pe?function As(V,O){return O<=0?V:V.map(function(z){return function Qs(V,O){return{score:V.score,keypoints:V.keypoints.map(function(z){var Ve=z.position;return{score:z.score,part:z.part,position:{x:O-1-Ve.x,y:Ve.y}}})}}(z,O)})}(mn,et):mn}var oo={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:257},Bo=["MobileNetV1","ResNet50"],wi={MobileNetV1:[8,16,32],ResNet50:[32,16]},$a={MobileNetV1:[.5,.75,1],ResNet50:[1]},Gi=[1,2,4],an={flipHorizontal:!1},kl={flipHorizontal:!1,maxDetections:5,scoreThreshold:.5,nmsRadius:20},Tu=function(){function V(O,z){(function ca(V){ie.util.assert("number"==typeof V,function(){return"outputStride is not a number"}),ie.util.assert(Oi.indexOf(V)>=0,function(){return"outputStride of "+V+" is invalid. It must be either 8, 16, or 32"})})(O.outputStride),function La(V,O){ie.util.assert("number"==typeof V[0]&&"number"==typeof V[1],function(){return"both resolution values must be a number but had values "+V}),ie.util.assert(Yo(V[0],O),function(){return"height of "+V[0]+" is invalid for output stride "+O+"."}),ie.util.assert(Yo(V[1],O),function(){return"width of "+V[1]+" is invalid for output stride "+O+"."})}(z,O.outputStride),this.baseModel=O,this.inputResolution=z}return V.prototype.estimateMultiplePoses=function(O,z){return void 0===z&&(z=kl),Pa(this,void 0,void 0,function(){var pe,Pe,Ve,et,mt,Wt,mn,rn,$n,zn,Bs,ur,Rs,Or,zr,Vr,Ec;return Ea(this,function(ku){switch(ku.label){case 0:return pe=Ca({},kl,z),function Gl(V){var O=V.maxDetections,z=V.scoreThreshold,pe=V.nmsRadius;if(O<=0)throw new Error("Invalid maxDetections "+O+". Should be > 0");if(z<0||z>1)throw new Error("Invalid scoreThreshold "+z+". Should be in range [0.0, 1.0]");if(pe<=0)throw new Error("Invalid nmsRadius "+pe+".")}(z),Pe=this.baseModel.outputStride,Ve=this.inputResolution,et=hi(O),mt=et[0],Wt=et[1],mn=qt(O,Ve),$n=mn.padding,zn=this.baseModel.predict(rn=mn.resized),[4,ss([Bs=zn.heatmapScores,ur=zn.offsets,Rs=zn.displacementFwd,Or=zn.displacementBwd])];case 1:return[4,Fi((zr=ku.sent())[0],zr[1],zr[2],zr[3],Pe,pe.maxDetections,pe.scoreThreshold,pe.nmsRadius)];case 2:return Vr=ku.sent(),Ec=jl(Vr,[mt,Wt],Ve,$n,pe.flipHorizontal),Bs.dispose(),ur.dispose(),Rs.dispose(),Or.dispose(),rn.dispose(),[2,Ec]}})})},V.prototype.estimateSinglePose=function(O,z){return void 0===z&&(z=an),Pa(this,void 0,void 0,function(){var pe,Pe,Ve,et,mt,Wt,mn,rn,$n,zn,Bs,ur,Rs,Or,zr,sr;return Ea(this,function(No){switch(No.label){case 0:return pe=Ca({},an,z),Pe=this.baseModel.outputStride,Ve=this.inputResolution,et=hi(O),mt=et[0],Wt=et[1],mn=qt(O,Ve),$n=mn.padding,zn=this.baseModel.predict(rn=mn.resized),Rs=zn.displacementFwd,Or=zn.displacementBwd,[4,Fc(Bs=zn.heatmapScores,ur=zn.offsets,Pe)];case 1:return zr=No.sent(),sr=jl([zr],[mt,Wt],Ve,$n,pe.flipHorizontal),Bs.dispose(),ur.dispose(),Rs.dispose(),Or.dispose(),rn.dispose(),[2,sr[0]]}})})},V.prototype.estimatePoses=function(O,z){return Pa(this,void 0,void 0,function(){return Ea(this,function(pe){switch(pe.label){case 0:return"single-person"!==z.decodingMethod?[3,2]:[4,this.estimateSinglePose(O,z)];case 1:return[2,[pe.sent()]];case 2:return[2,this.estimateMultiplePoses(O,z)]}})})},V.prototype.dispose=function(){this.baseModel.dispose()},V}();function sd(V){return Pa(this,void 0,void 0,function(){var O,z,pe,Pe,Ve,et,mt;return Ea(this,function(Wt){switch(Wt.label){case 0:if(O=V.outputStride,z=V.quantBytes,pe=V.multiplier,null==ie)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return Pe=function B(V,O,z){var pe={1:"100",.75:"075",.5:"050"},Pe="model-stride"+V+".json";return 4===z?Qc+"float/"+pe[O]+"/"+Pe:Qc+"quant"+z+"/"+pe[O]+"/"+Pe}(O,pe,z),[4,_o(V.modelUrl||Pe)];case 1:return Ve=Wt.sent(),et=new _l(Ve,O),mt=jn(V.inputResolution,et.outputStride),[2,new Tu(et,mt)]}})})}function gc(V){return Pa(this,void 0,void 0,function(){var O,z,pe,Pe,Ve,et;return Ea(this,function(mt){switch(mt.label){case 0:if(O=V.outputStride,z=V.quantBytes,null==ie)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return pe=function Iu(V,O){var z="model-stride"+V+".json";return 4===O?Ai+"float/"+z:Ai+"quant"+O+"/"+z}(O,z),[4,_o(V.modelUrl||pe)];case 1:return Pe=mt.sent(),Ve=new Be(Pe,O),et=jn(V.inputResolution,Ve.outputStride),[2,new Tu(Ve,et)]}})})}function rd(V){return void 0===V&&(V=oo),Pa(this,void 0,void 0,function(){return Ea(this,function(O){return"ResNet50"===(V=function uu(V){if(null==(V=V||oo).architecture&&(V.architecture="MobileNetV1"),Bo.indexOf(V.architecture)<0)throw new Error("Invalid architecture "+V.architecture+". Should be one of "+Bo);if(null==V.inputResolution&&(V.inputResolution=257),Zr(V.inputResolution),null==V.outputStride&&(V.outputStride=16),wi[V.architecture].indexOf(V.outputStride)<0)throw new Error("Invalid outputStride "+V.outputStride+". Should be one of "+wi[V.architecture]+" for architecture "+V.architecture+".");if(null==V.multiplier&&(V.multiplier=1),$a[V.architecture].indexOf(V.multiplier)<0)throw new Error("Invalid multiplier "+V.multiplier+". Should be one of "+$a[V.architecture]+" for architecture "+V.architecture+".");if(null==V.quantBytes&&(V.quantBytes=4),Gi.indexOf(V.quantBytes)<0)throw new Error("Invalid quantBytes "+V.quantBytes+". Should be one of "+Gi+" for architecture "+V.architecture+".");if("MobileNetV1"===V.architecture&&32===V.outputStride&&1!==V.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return V}(V)).architecture?[2,gc(V)]:"MobileNetV1"===V.architecture?[2,sd(V)]:[2,null]})})}var Au="2.2.2"},9305:function(Et,le,h){"use strict";var U=this&&this.__awaiter||function(ye,Te,v,at){return new(v||(v=Promise))(function(Xe,Ue){function pt(nn){try{It(at.next(nn))}catch(Bt){Ue(Bt)}}function Ct(nn){try{It(at.throw(nn))}catch(Bt){Ue(Bt)}}function It(nn){nn.done?Xe(nn.value):new v(function(Bt){Bt(nn.value)}).then(pt,Ct)}It((at=at.apply(ye,Te||[])).next())})},Z=this&&this.__generator||function(ye,Te){var at,Xe,Ue,pt,v={label:0,sent:function(){if(1&Ue[0])throw Ue[1];return Ue[1]},trys:[],ops:[]};return pt={next:Ct(0),throw:Ct(1),return:Ct(2)},"function"==typeof Symbol&&(pt[Symbol.iterator]=function(){return this}),pt;function Ct(nn){return function(Bt){return function It(nn){if(at)throw new TypeError("Generator is already executing.");for(;v;)try{if(at=1,Xe&&(Ue=2&nn[0]?Xe.return:nn[0]?Xe.throw||((Ue=Xe.return)&&Ue.call(Xe),0):Xe.next)&&!(Ue=Ue.call(Xe,nn[1])).done)return Ue;switch(Xe=0,Ue&&(nn=[2&nn[0],Ue.value]),nn[0]){case 0:case 1:Ue=nn;break;case 4:return v.label++,{value:nn[1],done:!1};case 5:v.label++,Xe=nn[1],nn=[0];continue;case 7:nn=v.ops.pop(),v.trys.pop();continue;default:if(!(Ue=(Ue=v.trys).length>0&&Ue[Ue.length-1])&&(6===nn[0]||2===nn[0])){v=0;continue}if(3===nn[0]&&(!Ue||nn[1]>Ue[0]&&nn[1]<Ue[3])){v.label=nn[1];break}if(6===nn[0]&&v.label<Ue[1]){v.label=Ue[1],Ue=nn;break}if(Ue&&v.label<Ue[2]){v.label=Ue[2],v.ops.push(nn);break}Ue[2]&&v.ops.pop(),v.trys.pop();continue}nn=Te.call(ye,v)}catch(Bt){nn=[6,Bt],Xe=0}finally{at=Ue=0}if(5&nn[0])throw nn[1];return{value:nn[0]?nn[1]:void 0,done:!0}}([nn,Bt])}}};Object.defineProperty(le,"__esModule",{value:!0});var y=h(4678),F=h(9284);le.getAdjacentKeyPoints=function N(ye,Te){return F.connectedPartIndices.reduce(function(v,at){var Xe=at[0],Ue=at[1];return function I(ye,Te,v){return ye<v||Te<v}(ye[Xe].score,ye[Ue].score,Te)||v.push([ye[Xe],ye[Ue]]),v},[])};var W=Number.NEGATIVE_INFINITY,l=Number.POSITIVE_INFINITY;function w(ye){return ye.reduce(function(Te,v){var Xe=Te.maxY,Ue=Te.minX,pt=Te.minY,Ct=v.position,It=Ct.x,nn=Ct.y;return{maxX:Math.max(Te.maxX,It),maxY:Math.max(Xe,nn),minX:Math.min(Ue,It),minY:Math.min(pt,nn)}},{maxX:W,maxY:W,minX:l,minY:l})}function D(ye,Te,v,at,Xe){return void 0===at&&(at=0),void 0===Xe&&(Xe=0),{score:ye.score,keypoints:ye.keypoints.map(function(Ue){var It=Ue.position;return{score:Ue.score,part:Ue.part,position:{x:It.x*v+Xe,y:It.y*Te+at}}})}}function G(ye,Te,v,at,Xe){return void 0===at&&(at=0),void 0===Xe&&(Xe=0),1===v&&1===Te&&0===at&&0===Xe?ye:ye.map(function(Ue){return D(Ue,Te,v,at,Xe)})}function J(ye,Te){return{score:ye.score,keypoints:ye.keypoints.map(function(v){var Ue=v.position;return{score:v.score,part:v.part,position:{x:Te-1-Ue.x,y:Ue.y}}})}}function K(ye,Te){return Te<=0?ye:ye.map(function(v){return J(v,Te)})}function _e(ye,Te){return ie(ye,Te)?ye:Math.floor(ye/Te)*Te+1}function Re(ye){y.util.assert("number"==typeof ye||"object"==typeof ye,function(){return"Invalid inputResolution "+ye+". Should be a number or an object with width and height"}),"object"==typeof ye&&(y.util.assert("number"==typeof ye.width,function(){return"inputResolution.width has a value of "+ye.width+" which is invalid; it must be a number"}),y.util.assert("number"==typeof ye.height,function(){return"inputResolution.height has a value of "+ye.height+" which is invalid; it must be a number"}))}le.getBoundingBox=w,le.getBoundingBoxPoints=function M(ye){var Te=w(ye),v=Te.minX,at=Te.minY,Xe=Te.maxX,Ue=Te.maxY;return[{x:v,y:at},{x:Xe,y:at},{x:Xe,y:Ue},{x:v,y:Ue}]},le.toTensorBuffers3D=function T(ye){return U(this,void 0,void 0,function(){return Z(this,function(Te){return[2,Promise.all(ye.map(function(v){return v.buffer()}))]})})},le.scalePose=D,le.scalePoses=G,le.flipPoseHorizontal=J,le.flipPosesHorizontal=K,le.toValidInputResolution=_e,le.validateInputResolution=Re,le.getValidInputResolutionDimensions=function we(ye,Te){return Re(ye),"object"==typeof ye?[_e(ye.height,Te),_e(ye.width,Te)]:[_e(ye,Te),_e(ye,Te)]};var We=[8,16,32];function ie(ye,Te){return(ye-1)%Te==0}function De(ye){return ye instanceof y.Tensor?[ye.shape[0],ye.shape[1]]:[ye.height,ye.width]}function te(ye){return ye instanceof y.Tensor?ye:y.browser.fromPixels(ye)}le.assertValidOutputStride=function Oe(ye){y.util.assert("number"==typeof ye,function(){return"outputStride is not a number"}),y.util.assert(We.indexOf(ye)>=0,function(){return"outputStride of "+ye+" is invalid. It must be either 8, 16, or 32"})},le.assertValidResolution=function Le(ye,Te){y.util.assert("number"==typeof ye[0]&&"number"==typeof ye[1],function(){return"both resolution values must be a number but had values "+ye}),y.util.assert(ie(ye[0],Te),function(){return"height of "+ye[0]+" is invalid for output stride "+Te+"."}),y.util.assert(ie(ye[1],Te),function(){return"width of "+ye[1]+" is invalid for output stride "+Te+"."})},le.getInputTensorDimensions=De,le.toInputTensor=te,le.toResizedInputTensor=function de(ye,Te,v,at){return y.tidy(function(){var Xe=te(ye);return y.image.resizeBilinear(at?y.reverse(Xe,1):Xe,[Te,v])})},le.padAndResizeTo=function P(ye,Te){var v=Te[0],at=Te[1],Xe=De(ye),Ue=Xe[0],pt=Xe[1],Ct=at/v,nn=[0,0,0,0],Bt=nn[0],bn=nn[1],Qn=nn[2],Dn=nn[3];return pt/Ue<Ct?(Bt=0,bn=0,Qn=Math.round(.5*(Ct*Ue-pt)),Dn=Math.round(.5*(Ct*Ue-pt))):(Bt=Math.round(.5*(1/Ct*pt-Ue)),bn=Math.round(.5*(1/Ct*pt-Ue)),Qn=0,Dn=0),{resized:y.tidy(function(){var Es=te(ye);return Es=y.pad3d(Es,[[Bt,bn],[Qn,Dn],[0,0]]),y.image.resizeBilinear(Es,[v,at])}),padding:{top:Bt,left:Qn,right:Dn,bottom:bn}}},le.scaleAndFlipPoses=function oe(ye,Te,v,at,Xe){var pt=Te[1],bn=G(ye,(Te[0]+at.top+at.bottom)/v[0],(pt+at.left+at.right)/v[1],-at.top,-at.left);return Xe?K(bn,pt):bn}},7437:(Et,le,h)=>{"use strict";h.d(le,{JL:()=>y,Zu:()=>F});class y{constructor(W,l){this.backend=W,this.dataMover=l,this.data=new WeakMap,this.dataIdsCount=0}get(W){return this.data.has(W)||this.dataMover.moveData(this.backend,W),this.data.get(W)}set(W,l){this.dataIdsCount++,this.data.set(W,l)}has(W){return this.data.has(W)}delete(W){return this.dataIdsCount--,this.data.delete(W)}numDataIds(){return this.dataIdsCount}}class F{refCount(W){return I("refCount")}incRef(W){return I("incRef")}timerAvailable(){return!0}time(W){return I("time")}read(W){return I("read")}readSync(W){return I("readSync")}readToGPU(W,l){return I("readToGPU")}numDataIds(){return I("numDataIds")}disposeData(W,l){return I("disposeData")}write(W,l,w){return I("write")}move(W,l,w,M,T){return I("move")}memory(){return I("memory")}floatPrecision(){return I("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return I("dispose")}}function I(N){throw new Error(`'${N}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},501:(Et,le,h)=>{"use strict";function U(D,G,J){const K=function Z(D,G,J){return function F(D,G,J){let K=0,_e=D.length,Re=0,we=!1;for(;K<_e;){Re=K+(_e-K>>>1);const We=J(G,D[Re]);We>0?K=Re+1:(_e=Re,we=!We)}return we?K:-K-1}(D,G,J||y)}(D,G,J);D.splice(K<0?-(K+1):K,0,G)}function y(D,G){return D>G?1:D<G?-1:0}function I(D,G,J,K,_e){return l(D,G,J,K,_e,0)}function N(D,G,J,K,_e,Re){return l(D,G,J,K,_e,0,!1,Re,!0)}function W(D,G,J,K,_e,Re){return l(D,G,J,K,_e,Re,!0)}function l(D,G,J,K,_e,Re,we=!1,We=!1,Oe=!1){const ie=[];for(let ye=0;ye<G.length;ye++)G[ye]>_e&&ie.push({score:G[ye],boxIndex:ye,suppressBeginIndex:0});ie.sort(T);const Le=Re>0?-.5/Re:0,De=[],te=[];for(;De.length<J&&ie.length>0;){const ye=ie.pop(),{score:Te,boxIndex:v,suppressBeginIndex:at}=ye;if(Te<_e)break;let Xe=!1;for(let Ue=De.length-1;Ue>=at;--Ue){const pt=w(D,v,De[Ue]);if(pt>=K){Xe=!0;break}if(ye.score=ye.score*M(K,Le,pt),ye.score<=_e)break}ye.suppressBeginIndex=De.length,Xe||(ye.score===Te?(De.push(v),te.push(ye.score)):ye.score>_e&&U(ie,ye,T))}const de=De.length,P=J-de;We&&P>0&&(De.push(...new Array(P).fill(0)),te.push(...new Array(P).fill(0)));const oe={selectedIndices:De};return we&&(oe.selectedScores=te),Oe&&(oe.validOutputs=de),oe}function w(D,G,J){const K=D.subarray(4*G,4*G+4),_e=D.subarray(4*J,4*J+4),Re=Math.min(K[0],K[2]),we=Math.min(K[1],K[3]),We=Math.max(K[0],K[2]),Oe=Math.max(K[1],K[3]),ie=Math.min(_e[0],_e[2]),Le=Math.min(_e[1],_e[3]),De=Math.max(_e[0],_e[2]),te=Math.max(_e[1],_e[3]),de=(We-Re)*(Oe-we),P=(De-ie)*(te-Le);if(de<=0||P<=0)return 0;const oe=Math.max(Re,ie),ye=Math.max(we,Le),Te=Math.min(We,De),v=Math.min(Oe,te),at=Math.max(Te-oe,0)*Math.max(v-ye,0);return at/(de+P-at)}function M(D,G,J){const K=Math.exp(G*J*J);return J<=D?K:0}function T(D,G){return D.score-G.score||D.score===G.score&&G.boxIndex-D.boxIndex}h.d(le,{GP:()=>I,qP:()=>N,pA:()=>W})},2553:(Et,le,h)=>{"use strict";h.d(le,{Z:()=>Z});var U=h(94);function Z(y,F){const I=[];for(let l=0;l<F.length;l++)F[l]&&I.push(l);const N=(0,U.f)(y,"int32"),W=(0,U.f)([I.length,y.length],"int32");for(let l=0;l<I.length;l++){const w=N.indexToLoc(I[l]);W.values.set(w,l*y.length)}return W.toTensor()}},1379:(Et,le,h)=>{"use strict";h.d(le,{BV:()=>Le,wv:()=>ie});var U=h(5861),Z=h(7437),y=h(8514),F=h(3565),I=h(351),N=h(6096),W=h(1590),l=h(2775),w=h(4944);class M{constructor(de,P){this.backendTimer=de,this.logger=P,null==P&&(this.logger=new D)}profileKernel(de,P,oe){let ye;const Te=()=>{ye=oe()};let v;const at=l.now();if(this.backendTimer.timerAvailable())v=this.backendTimer.time(Te);else{Te();for(const Ue of ye)Ue.dataSync();v=Promise.resolve({kernelMs:l.now()-at})}if((0,y.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let Ue=0;Ue<ye.length;Ue++){const pt=ye[Ue];pt.data().then(Ct=>{T(Ct,pt.dtype,de)})}return{kernelName:de,outputs:ye,inputs:P,timeMs:v.then(Ue=>Ue.kernelMs),extraInfo:v.then(Ue=>null!=Ue.getExtraProfileInfo?Ue.getExtraProfileInfo():"")}}logKernelProfile(de){const{kernelName:P,outputs:oe,timeMs:ye,inputs:Te,extraInfo:v}=de;oe.forEach(at=>{Promise.all([at.data(),ye,v]).then(Xe=>{this.logger.logKernelProfile(P,at,Xe[0],Xe[1],Te,Xe[2])})})}}function T(te,de,P){if("float32"!==de)return!1;for(let oe=0;oe<te.length;oe++){const ye=te[oe];if(isNaN(ye)||!isFinite(ye))return console.warn(`Found ${ye} in the result of '${P}'`),!0}return!1}class D{logKernelProfile(de,P,oe,ye,Te,v){const at="number"==typeof ye?w.oj(`${ye}ms`,9):ye.error,Xe=w.oj(de,25),Ue=P.rank,pt=P.size,Ct=w.oj(P.shape.toString(),14);let It="";for(const nn in Te){const Bt=Te[nn];if(null!=Bt){const bn=Bt.shape||P.shape,Qn=bn.length;It+=`${nn}: ${Qn}D ${Qn>0?bn:""} `}}console.log(`%c${Xe}\t%c${at}\t%c${Ue}D ${Ct}\t%c${pt}\t%c${It}\t%c${v}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var K=h(9089),_e=h(1931);function Re(te){return null!=te.kernelName}class we{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(de=>de.name)))}}}dispose(){for(const de in this.registeredVariables)this.registeredVariables[de].dispose()}}let We=(()=>{class te{constructor(P){this.ENV=P,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new we}ready(){var P=this;return(0,U.Z)(function*(){if(null!=P.pendingBackendInit)return P.pendingBackendInit.then(()=>{});if(null!=P.backendInstance)return;const oe=P.getSortedBackends();for(let ye=0;ye<oe.length;ye++){const Te=oe[ye];if(yield P.initializeBackend(Te).success)return void(yield P.setBackend(Te))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:P,asyncInit:oe}=this.initializeBackendsAndReturnBest();if(oe)throw new Error(`The highest priority backend '${P}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(P)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(P){if(!(P in this.registry)){if(!(P in this.registryFactory))return null;{const{asyncInit:oe}=this.initializeBackend(P);if(oe)return null}}return this.registry[P]}findBackendFactory(P){return P in this.registryFactory?this.registryFactory[P].factory:null}registerBackend(P,oe,ye=1){return P in this.registryFactory?(W.Z(`${P} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[P]={factory:oe,priority:ye},!0)}setBackend(P){var oe=this;return(0,U.Z)(function*(){if(null==oe.registryFactory[P])throw new Error(`Backend name '${P}' not found in registry`);if(oe.backendName=P,null==oe.registry[P]){oe.backendInstance=null;const{success:ye,asyncInit:Te}=oe.initializeBackend(P);if(!(Te?yield ye:ye))return!1}return oe.backendInstance=oe.registry[P],oe.setupRegisteredKernels(),oe.profiler=new M(oe.backendInstance),!0})()}setupRegisteredKernels(){(0,N.tr)(this.backendName).forEach(oe=>{null!=oe.setupFunc&&oe.setupFunc(this.backendInstance)})}disposeRegisteredKernels(P){(0,N.tr)(P).forEach(ye=>{null!=ye.disposeFunc&&ye.disposeFunc(this.registry[P])})}initializeBackend(P){const oe=this.registryFactory[P];if(null==oe)throw new Error(`Cannot initialize backend ${P}, no registration found.`);try{const ye=oe.factory();if(!ye||ye instanceof Z.Zu||"function"!=typeof ye.then)return this.registry[P]=ye,{success:!0,asyncInit:!1};{const Te=++this.pendingBackendInitId,v=ye.then(at=>!(Te<this.pendingBackendInitId||(this.registry[P]=at,this.pendingBackendInit=null,0))).catch(at=>(Te<this.pendingBackendInitId||(this.pendingBackendInit=null,W.Z(`Initialization of backend ${P} failed`),W.Z(at.stack||at.message)),!1));return this.pendingBackendInit=v,{success:v,asyncInit:!0}}}catch(ye){return W.Z(`Initialization of backend ${P} failed`),W.Z(ye.stack||ye.message),{success:!1,asyncInit:!1}}}removeBackend(P){if(!(P in this.registryFactory))throw new Error(`${P} backend not found in registry`);this.backendName===P&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,P in this.registry&&(this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P]),delete this.registryFactory[P],this.backendName===P&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((P,oe)=>this.registryFactory[oe].priority-this.registryFactory[P].priority)}initializeBackendsAndReturnBest(){const P=this.getSortedBackends();for(let oe=0;oe<P.length;oe++){const ye=P[oe],{success:Te,asyncInit:v}=this.initializeBackend(ye);if(v||Te)return{name:ye,asyncInit:v}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(P,oe){const ye=this.state.tensorInfo.get(oe),Te=ye.backend,v=this.readSync(oe),at=Te.refCount(oe);Te.disposeData(oe,!0),ye.backend=P,P.move(oe,v,ye.shape,ye.dtype,at),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(P,oe){let Te,ye=null;if(null==oe){if("function"!=typeof P)throw new Error("Please provide a function to tidy()");oe=P}else{if("string"!=typeof P&&!(P instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof oe)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");ye=P}return this.scopedRun(()=>this.startScope(ye),()=>this.endScope(Te),()=>(Te=oe(),Te instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Te))}scopedRun(P,oe,ye){P();try{const Te=ye();return oe(),Te}catch(Te){throw oe(),Te}}nextTensorId(){return te.nextTensorId++}nextVariableId(){return te.nextVariableId++}clone(P){const oe=Le.runKernel(I.iJz,{x:P});return this.addTapeNode(this.state.activeScope.name,{x:P},[oe],at=>({x:()=>Le.runKernel(I.RFZ,{x:at},{dtype:"float32"})}),[],{}),oe}runKernel(P,oe,ye){if(null==(0,N.pI)(P,this.backendName))throw new Error(`Kernel '${P}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:P,inputs:oe,attrs:ye})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(P,oe,ye){const Te=this.backend.numDataIds();let v=0;ye.forEach(Ue=>{v+="complex64"===Ue.dtype?3:1});const Xe=Te-oe-v-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(Xe>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${Xe} data ids) after running '${P}'`)}runKernelFunc(P){let oe,ye=[];const Te=this.isTapeOn(),v=this.state.numBytes,at=this.state.numTensors;let Xe,Ue;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const pt=Re(P)?P.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Re(P)){const{kernelName:bn,inputs:Qn,attrs:Dn}=P,ps=(0,N.pI)(bn,this.backendName);w.hu(null!=ps,()=>`Cannot find registered kernel '${bn}' for backend '${this.backendName}'`),Xe=()=>{const Es=this.backend.numDataIds();Ue=ps.kernelFunc({inputs:Qn,attrs:Dn,backend:this.backend});const Xn=Array.isArray(Ue)?Ue:[Ue];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(bn,Es,Xn);const Ts=Xn.map(or=>null!=or.rank?or:this.makeTensorFromTensorInfo(or));if(Te){const or=this.getTensorsForGradient(bn,Qn,Ts);ye=this.saveTensorsForBackwardMode(or)}return Ts}}else{const{forwardFunc:bn}=P,Qn=Dn=>{Te&&(ye=Dn.map(ps=>this.keep(this.clone(ps))))};Xe=()=>{const Dn=this.backend.numDataIds();Ue=this.tidy(()=>bn(this.backend,Qn));const ps=Array.isArray(Ue)?Ue:[Ue];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(pt,Dn,ps),ps}}const{inputs:Ct,attrs:It}=P,nn=Re(P)?null:P.backwardsFunc;let Bt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Bt=this.profiler.profileKernel(pt,Ct,()=>Xe()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Bt),oe=Bt.outputs):oe=Xe()}),Te&&this.addTapeNode(pt,Ct,oe,nn,ye,It),this.state.profiling&&this.state.activeProfile.kernels.push({name:pt,bytesAdded:this.state.numBytes-v,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-at,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Ct).map(bn=>null!=Ct[bn]?Ct[bn].shape:null),outputShapes:oe.map(bn=>bn.shape),kernelTimeMs:Bt.timeMs,extraInfo:Bt.extraInfo}),Array.isArray(Ue)?oe:oe[0]}saveTensorsForBackwardMode(P){return P.map(ye=>this.keep(this.clone(ye)))}getTensorsForGradient(P,oe,ye){const Te=(0,N.uk)(P);if(null!=Te){const v=Te.inputsToSave||[],at=Te.outputsToSave||[];let Xe;Te.saveAllInputs?(w.hu(Array.isArray(oe),()=>"saveAllInputs is true, expected inputs to be an array."),Xe=Object.keys(oe).map(pt=>oe[pt])):Xe=v.map(pt=>oe[pt]);const Ue=ye.filter((pt,Ct)=>at[Ct]);return Xe.concat(Ue)}return[]}makeTensor(P,oe,ye,Te){if(null==P)throw new Error("Values passed to engine.makeTensor() are null");Te=Te||this.backend;let v=P;"string"===(ye=ye||"float32")&&w.HD(P[0])&&(v=P.map(Ue=>l.encodeString(Ue)));const at=Te.write(v,oe,ye),Xe=new K.es(oe,ye,at,this.nextTensorId());if(this.trackTensor(Xe,Te),"string"===ye){const Ue=this.state.tensorInfo.get(at),pt=(0,w.Ub)(v);this.state.numBytes+=pt-Ue.bytes,Ue.bytes=pt}return Xe}makeTensorFromDataId(P,oe,ye,Te){return this.makeTensorFromTensorInfo({dataId:P,shape:oe,dtype:ye=ye||"float32"},Te)}makeTensorFromTensorInfo(P,oe){const{dataId:ye,shape:Te,dtype:v}=P,at=new K.es(Te,v,ye,this.nextTensorId());return this.trackTensor(at,oe),at}makeVariable(P,oe=!0,ye,Te){ye=ye||this.nextVariableId().toString(),null!=Te&&Te!==P.dtype&&(P=P.cast(Te));const v=new K._w(P,oe,ye,this.nextTensorId());if(null!=this.state.registeredVariables[v.name])throw new Error(`Variable with name ${v.name} was already registered`);return this.state.registeredVariables[v.name]=v,this.incRef(v,this.backend),v}trackTensor(P,oe){this.state.numTensors++,"string"===P.dtype&&this.state.numStringTensors++;let ye=0;"complex64"!==P.dtype&&"string"!==P.dtype&&(ye=P.size*w.bT(P.dtype)),this.state.numBytes+=ye,this.state.tensorInfo.has(P.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(P.dataId,{backend:oe||this.backend,dtype:P.dtype,shape:P.shape,bytes:ye})),P instanceof K._w||this.track(P)}incRef(P,oe){this.trackTensor(P,oe),this.backend.incRef(P.dataId)}removeDataId(P,oe){this.state.tensorInfo.has(P)&&this.state.tensorInfo.get(P).backend===oe&&(this.state.tensorInfo.delete(P),this.state.numDataBuffers--)}disposeTensor(P){if(!this.state.tensorInfo.has(P.dataId))return;const oe=this.state.tensorInfo.get(P.dataId);if(this.state.numTensors--,"string"===P.dtype&&(this.state.numStringTensors--,this.state.numBytes-=oe.bytes),"complex64"!==P.dtype&&"string"!==P.dtype){const ye=P.size*w.bT(P.dtype);this.state.numBytes-=ye}oe.backend.disposeData(P.dataId)&&this.removeDataId(P.dataId,oe.backend)}disposeVariables(){for(const P in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[P])}disposeVariable(P){this.disposeTensor(P),null!=this.state.registeredVariables[P.name]&&delete this.state.registeredVariables[P.name]}memory(){const P=this.backend.memory();return P.numTensors=this.state.numTensors,P.numDataBuffers=this.state.numDataBuffers,P.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(P.unreliable=!0,null==P.reasons&&(P.reasons=[]),P.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),P}profile(P){var oe=this;return(0,U.Z)(function*(){oe.state.profiling=!0;const ye=oe.state.numBytes,Te=oe.state.numTensors;oe.state.activeProfile.kernels=[],oe.state.activeProfile.result=yield P(),oe.state.profiling=!1,oe.state.activeProfile.peakBytes=Math.max(...oe.state.activeProfile.kernels.map(v=>v.totalBytesSnapshot)),oe.state.activeProfile.newBytes=oe.state.numBytes-ye,oe.state.activeProfile.newTensors=oe.state.numTensors-Te;for(const v of oe.state.activeProfile.kernels)v.kernelTimeMs=yield v.kernelTimeMs,v.extraInfo=yield v.extraInfo;return oe.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(P,oe,ye,Te,v,at){const Xe={id:this.state.nextTapeNodeId++,kernelName:P,inputs:oe,outputs:ye,saved:v},Ue=(0,N.uk)(P);null!=Ue&&(Te=Ue.gradFunc),null!=Te&&(Xe.gradient=pt=>(pt=pt.map((Ct,It)=>{if(null==Ct){const nn=ye[It],Bt=w.wT(nn.size,nn.dtype);return this.makeTensor(Bt,nn.shape,nn.dtype)}return Ct}),Te(pt.length>1?pt:pt[0],v,at))),this.state.activeTape.push(Xe)}keep(P){return P.kept=!0,P}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(P){const oe={track:[],name:"unnamed scope",id:this.state.nextScopeId++};P&&(oe.name=P),this.state.scopeStack.push(oe),this.state.activeScope=oe}endScope(P){const oe=(0,_e.getTensorsInContainer)(P),ye=new Set(oe.map(v=>v.id));for(let v=0;v<this.state.activeScope.track.length;v++){const at=this.state.activeScope.track[v];!at.kept&&!ye.has(at.id)&&at.dispose()}const Te=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],oe.forEach(v=>{!v.kept&&v.scopeId===Te.id&&this.track(v)})}gradients(P,oe,ye,Te=!1){if(w.hu(oe.length>0,()=>"gradients() received an empty list of xs."),null!=ye&&"float32"!==ye.dtype)throw new Error(`dy must have 'float32' dtype, but has '${ye.dtype}'`);const v=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",P));w.hu(v instanceof K.es,()=>"The result y returned by f() must be a tensor.");const at=function G(te,de,P){const oe={},ye={};for(let Xe=0;Xe<de.length;Xe++)oe[de[Xe].id]=!0;for(let Xe=0;Xe<te.length;Xe++){const Ue=te[Xe],pt=Ue.inputs;for(const Ct in pt){const It=pt[Ct];let nn=!1;for(let Bt=0;Bt<de.length;Bt++)if(oe[It.id]){Ue.outputs.forEach(bn=>oe[bn.id]=!0),nn=!0,ye[Ue.id]=!0;break}if(nn)break}}const Te={};Te[P.id]=!0;const v={};for(let Xe=te.length-1;Xe>=0;Xe--){const Ue=te[Xe],pt=Ue.inputs;for(let Ct=0;Ct<Ue.outputs.length;Ct++)if(Te[Ue.outputs[Ct].id]){for(const It in pt)Te[pt[It].id]=!0,v[Ue.id]=!0;break}}const at=[];for(let Xe=0;Xe<te.length;Xe++){const Ue=te[Xe];if(ye[Ue.id]&&v[Ue.id]){const pt={};for(const It in Ue.inputs){const nn=Ue.inputs[It];oe[nn.id]&&(pt[It]=nn)}const Ct=Object.assign({},Ue);Ct.inputs=pt,Ct.outputs=Ue.outputs,at.push(Ct)}}return at}(this.state.activeTape,oe,v);if(!Te&&0===at.length&&oe.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const Xe={};Xe[v.id]=ye??function Oe(te){const de=(0,w.p8)((0,w.NA)(te),"float32");return Le.makeTensor(de,te,"float32")}(v.shape),function J(te,de,P,oe){for(let ye=de.length-1;ye>=0;ye--){const Te=de[ye],v=[];if(Te.outputs.forEach(Xe=>{const Ue=te[Xe.id];v.push(null!=Ue?Ue:null)}),null==Te.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${Te.kernelName}.`);const at=Te.gradient(v);for(const Xe in Te.inputs){if(!(Xe in at))throw new Error(`Cannot backprop through input ${Xe}. Available gradients found: ${Object.keys(at)}.`);const Ue=P(()=>at[Xe]());if("float32"!==Ue.dtype)throw new Error(`Error in gradient for op ${Te.kernelName}. The gradient of input ${Xe} must have 'float32' dtype, but has '${Ue.dtype}'`);const pt=Te.inputs[Xe];if(!w.cO(Ue.shape,pt.shape))throw new Error(`Error in gradient for op ${Te.kernelName}. The gradient of input '${Xe}' has shape '${Ue.shape}', which does not match the shape of the input '${pt.shape}'`);if(null==te[pt.id])te[pt.id]=Ue;else{const Ct=te[pt.id];te[pt.id]=oe(Ct,Ue),Ct.dispose()}}}}(Xe,at,pt=>this.tidy(pt),De);const Ue=oe.map(pt=>Xe[pt.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(pt=>{for(const Ct of pt.saved)Ct.dispose()}),this.state.activeTape=null),{value:v,grads:Ue}})}customGrad(P){return w.hu(w.mf(P),()=>"The f passed in customGrad(f) must be a function."),(...oe)=>{let ye;w.hu(oe.every(Xe=>Xe instanceof K.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const Te={};return oe.forEach((Xe,Ue)=>{Te[Ue]=Xe}),this.runKernelFunc({forwardFunc:(Xe,Ue)=>(ye=P(...oe,Ue),w.hu(ye.value instanceof K.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),w.hu(w.mf(ye.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),ye.value),backwardsFunc:(Xe,Ue)=>{const pt=ye.gradFunc(Xe,Ue),Ct=Array.isArray(pt)?pt:[pt];w.hu(Ct.length===oe.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),w.hu(Ct.every(nn=>nn instanceof K.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const It={};return Ct.forEach((nn,Bt)=>{It[Bt]=()=>nn}),It},inputs:Te})}}readSync(P){return this.state.tensorInfo.get(P).backend.readSync(P)}read(P){return this.state.tensorInfo.get(P).backend.read(P)}readToGPU(P,oe){return this.state.tensorInfo.get(P).backend.readToGPU(P,oe)}time(P){var oe=this;return(0,U.Z)(function*(){const ye=(0,l.now)(),Te=yield oe.backend.time(P);return Te.wallMs=(0,l.now)()-ye,Te})()}track(P){return null!=this.state.activeScope&&(P.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(P)),P}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new we;for(const P in this.registry)this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return te.nextTensorId=0,te.nextVariableId=0,te})();function ie(){const te=(0,F.D)();if(null==te._tfengine){const de=new y.qA(te);te._tfengine=new We(de)}return(0,y.iG)(te._tfengine.ENV),(0,K.Vi)(()=>te._tfengine),te._tfengine}const Le=ie();function De(te,de){return Le.runKernel(I.mm_,{a:te,b:de})}},8514:(Et,le,h)=>{"use strict";h.d(le,{OB:()=>l,Vi:()=>w,iG:()=>M,qA:()=>F});var U=h(5861),Z=h(4944);const y="tfjsflags";class F{constructor(D){this.global=D,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=I,this.populateURLFlags()}setPlatform(D,G){null!=this.platform&&(l().getBool("IS_TEST")||l().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${D}.`)),this.platformName=D,this.platform=G}registerFlag(D,G,J){if(this.flagRegistry[D]={evaluationFn:G,setHook:J},null!=this.urlFlags[D]){const K=this.urlFlags[D];l().getBool("IS_TEST")||l().getBool("PROD")||console.warn(`Setting feature override from URL ${D}: ${K}.`),this.set(D,K)}}getAsync(D){var G=this;return(0,U.Z)(function*(){return D in G.flags||(G.flags[D]=yield G.evaluateFlag(D)),G.flags[D]})()}get(D){if(D in this.flags)return this.flags[D];const G=this.evaluateFlag(D);if((0,Z.tI)(G))throw new Error(`Flag ${D} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[D]=G,this.flags[D]}getNumber(D){return this.get(D)}getBool(D){return this.get(D)}getFlags(){return this.flags}get features(){return this.flags}set(D,G){if(null==this.flagRegistry[D])throw new Error(`Cannot set flag ${D} as it has not been registered.`);this.flags[D]=G,null!=this.flagRegistry[D].setHook&&this.flagRegistry[D].setHook(G)}evaluateFlag(D){if(null==this.flagRegistry[D])throw new Error(`Cannot evaluate flag '${D}': no evaluation function found.`);return this.flagRegistry[D].evaluationFn()}setFlags(D){this.flags=Object.assign({},D)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const D=this.getQueryParams(this.global.location.search);y in D&&D[y].split(",").forEach(J=>{const[K,_e]=J.split(":");this.urlFlags[K]=function W(T,D){if("true"===(D=D.toLowerCase())||"false"===D)return"true"===D;if(""+ +D===D)return+D;throw new Error(`Could not parse value flag value ${D} for flag ${T}.`)}(K,_e)})}}function I(T){const D={};return T.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(G,...J)=>(function N(T,D,G){T[decodeURIComponent(D)]=decodeURIComponent(G||"")}(D,J[0],J[1]),J.join("="))),D}function l(){return w}let w=null;function M(T){w=T}},3565:(Et,le,h)=>{"use strict";let U;function Z(){if(null==U){let I;if(typeof window<"u")I=window;else if(typeof global<"u")I=global;else if(typeof process<"u")I=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");I=self}U=I}return U}function F(I,N){const W=function y(){const I=Z();return null==I._tfGlobals&&(I._tfGlobals=new Map),I._tfGlobals}();if(W.has(I))return W.get(I);{const l=N();return W.set(I,l),W.get(I)}}h.d(le,{D:()=>Z,R:()=>F})},1633:(Et,le,h)=>{"use strict";h.d(le,{B9:()=>J,CQ:()=>Re,Cd:()=>we,Cn:()=>K,G4:()=>I,MX:()=>l,N5:()=>D,N8:()=>w,N_:()=>We,R:()=>N,SR:()=>M,VY:()=>de,XV:()=>_e,cF:()=>W,cj:()=>Oe,jq:()=>De,lu:()=>G,sq:()=>T,x3:()=>ie,y3:()=>te,ze:()=>Le});var U=h(1379),Z=h(8514),y=h(9089),F=h(1931);function I(){(0,Z.OB)().set("PROD",!0)}function N(){(0,Z.OB)().set("DEBUG",!0)}function W(){(0,Z.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function l(P){(0,Z.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(P+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function w(){U.BV.disposeVariables()}function M(){return U.BV}function T(){return U.BV.memory()}function D(P){return U.BV.profile(P)}function G(P,oe){return U.BV.tidy(P,oe)}function J(P){(0,F.getTensorsInContainer)(P).forEach(ye=>ye.dispose())}function K(P){return U.BV.keep(P)}function _e(P){return U.BV.time(P)}function Re(P){return U.BV.setBackend(P)}function we(){return U.BV.ready()}function We(){return U.BV.backendName}function Oe(P){U.BV.removeBackend(P)}function ie(P){return U.BV.findBackend(P)}function Le(P){return U.BV.findBackendFactory(P)}function De(P,oe,ye=1){return U.BV.registerBackend(P,oe,ye)}function te(){return U.BV.backend}function de(P,oe){(0,Z.OB)().setPlatform(P,oe)}(0,y.FZ)(l)},6541:(Et,le,h)=>{"use strict";h.d(le,{UQ:()=>I,cb:()=>M,fN:()=>l,h7:()=>W,pn:()=>w,ti:()=>N});var U=h(1379),Z=h(9089),y=h(58),F=h(4944);function I(D){return F.hu(F.mf(D),()=>"The f passed in grad(f) must be a function"),(G,J)=>{const K=(0,y._1)(G,"x","tf.grad","string_or_numeric"),_e=null!=J?(0,y._1)(J,"dy","tf.grad"):null;return U.BV.tidy(()=>{const{value:Re,grads:we}=U.BV.gradients(()=>D(K),[K],_e);return null!=_e&&F.k5(Re.shape,_e.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),T(we),we[0]})}}function N(D){return F.hu(F.mf(D),()=>"The f passed in grads(f) must be a function"),(G,J)=>{F.hu(Array.isArray(G),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const K=(0,y.sI)(G,"args","tf.grads","string_or_numeric"),_e=null!=J?(0,y._1)(J,"dy","tf.grads"):null;return U.BV.tidy(()=>{const{value:Re,grads:we}=U.BV.gradients(()=>D(...K),K,_e);return null!=_e&&F.k5(Re.shape,_e.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),T(we),we})}}function W(D){return F.hu(F.mf(D),()=>"The f passed in valueAndGrad(f) must be a function"),(G,J)=>{F.hu(G instanceof Z.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),F.hu(null==J||J instanceof Z.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:K,value:_e}=U.BV.gradients(()=>D(G),[G],J);return T(K),{grad:K[0],value:_e}}}function l(D){return F.hu(F.mf(D),()=>"The f passed in valueAndGrads(f) must be a function"),(G,J)=>{F.hu(Array.isArray(G)&&G.every(_e=>_e instanceof Z.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),F.hu(null==J||J instanceof Z.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const K=U.BV.gradients(()=>D(...G),G,J);return null!=J&&F.k5(K.value.shape,J.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),T(K.grads),K}}function w(D,G){F.hu(F.mf(D),()=>"The f passed in variableGrads(f) must be a function"),F.hu(null==G||Array.isArray(G)&&G.every(ie=>ie instanceof Z._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const J=null!=G;if(!J){G=[];for(const ie in U.BV.registeredVariables)G.push(U.BV.registeredVariables[ie])}const K=J?G.filter(ie=>!ie.trainable):null,_e=G.length;G=G.filter(ie=>ie.trainable),F.hu(G.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${_e} variables is trainable.`);const{value:we,grads:We}=U.BV.gradients(D,G,null,!0);F.hu(We.some(ie=>null!=ie),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),F.hu(0===we.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${we.rank} tensor`);const Oe={};return G.forEach((ie,Le)=>{null!=We[Le]&&(Oe[ie.name]=We[Le])}),K?.forEach(ie=>Oe[ie.name]=null),{value:we,grads:Oe}}function M(D){return U.BV.customGrad(D)}function T(D){if(D.filter(J=>null==J).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},4678:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{Abs:()=>gn.SYM,Acos:()=>gn.VGw,Acosh:()=>gn.SpW,AdadeltaOptimizer:()=>Oi,AdagradOptimizer:()=>Yo,AdamOptimizer:()=>ci,AdamaxOptimizer:()=>oo,Add:()=>gn.mm_,AddN:()=>gn.Xze,All:()=>gn.oT6,Any:()=>gn.IKK,ArgMax:()=>gn.sJF,ArgMin:()=>gn.aJk,Asin:()=>gn.M2y,Asinh:()=>gn.qw7,Atan:()=>gn.jMg,Atan2:()=>gn.QCc,Atanh:()=>gn.Oyi,AvgPool:()=>gn.JhU,AvgPool3D:()=>gn._k9,AvgPool3DGrad:()=>gn.IMb,AvgPoolGrad:()=>gn.ROF,BatchMatMul:()=>gn.XLW,BatchToSpaceND:()=>gn.zws,Bincount:()=>gn.zvY,BroadcastArgs:()=>gn.eEB,BroadcastTo:()=>gn.Ly9,Cast:()=>gn.RFZ,Ceil:()=>gn.gJX,ClipByValue:()=>gn.xnO,Complex:()=>gn.Zz9,ComplexAbs:()=>gn.yj2,Concat:()=>gn.Eh3,Conv2D:()=>gn.mhS,Conv2DBackpropFilter:()=>gn.wUP,Conv2DBackpropInput:()=>gn.wm,Conv3D:()=>gn.x12,Conv3DBackpropFilterV2:()=>gn.o2y,Conv3DBackpropInputV2:()=>gn.ik2,Cos:()=>gn.mc4,Cosh:()=>gn.TR1,CropAndResize:()=>gn.VcC,Cumprod:()=>gn.Byc,Cumsum:()=>gn.iHb,DataStorage:()=>en.JL,DenseBincount:()=>gn.QRR,DepthToSpace:()=>gn.T0n,DepthwiseConv2dNative:()=>gn.cie,DepthwiseConv2dNativeBackpropFilter:()=>gn.sL$,DepthwiseConv2dNativeBackpropInput:()=>gn.y7R,Diag:()=>gn.$w,Dilation2D:()=>gn.p4S,Dilation2DBackpropFilter:()=>gn.Vn9,Dilation2DBackpropInput:()=>gn.ekb,ENV:()=>we.Vi,Einsum:()=>gn.$g6,Elu:()=>gn.SX0,EluGrad:()=>gn.HEU,Environment:()=>we.qA,Equal:()=>gn.hdR,Erf:()=>gn.Omj,Exp:()=>gn.NEP,ExpandDims:()=>gn.YFo,Expm1:()=>gn.Y0y,FFT:()=>gn.vwp,Fill:()=>gn.deh,FlipLeftRight:()=>gn.Uyb,Floor:()=>gn.OR,FloorDiv:()=>gn.jeX,FromPixels:()=>gn.eBW,FusedBatchNorm:()=>gn.sHE,FusedConv2D:()=>gn._V0,FusedDepthwiseConv2D:()=>gn.luS,GatherNd:()=>gn.q1x,GatherV2:()=>gn.qi_,Greater:()=>gn.iZT,GreaterEqual:()=>gn.Acj,IFFT:()=>gn.Qg5,Identity:()=>gn.iJz,Imag:()=>gn.J_u,IsFinite:()=>gn.avt,IsInf:()=>gn.iWB,IsNan:()=>gn.r7n,KernelBackend:()=>en.Zu,LRN:()=>gn.eZ0,LRNGrad:()=>gn.Hhh,LeakyRelu:()=>gn.J$2,Less:()=>gn.vtC,LessEqual:()=>gn.CAk,LinSpace:()=>gn.e7N,Log:()=>gn.ZbH,Log1p:()=>gn.kU,LogSoftmax:()=>gn.qCd,LogicalAnd:()=>gn.PYm,LogicalNot:()=>gn.VfG,LogicalOr:()=>gn.MZg,LogicalXor:()=>gn.w6g,LowerBound:()=>gn.qIC,Max:()=>gn.YoZ,MaxPool:()=>gn.mTV,MaxPool3D:()=>gn.OAf,MaxPool3DGrad:()=>gn.OU7,MaxPoolGrad:()=>gn.OV7,MaxPoolWithArgmax:()=>gn.vFR,Maximum:()=>gn.BMI,Mean:()=>gn.q2K,Min:()=>gn.c17,Minimum:()=>gn.q8u,MirrorPad:()=>gn.jQs,Mod:()=>gn.Vbg,MomentumOptimizer:()=>wi,Multinomial:()=>gn.NZg,Multiply:()=>gn.wYn,Neg:()=>gn.kuV,NonMaxSuppressionV3:()=>gn.uv1,NonMaxSuppressionV4:()=>gn.cye,NonMaxSuppressionV5:()=>gn.W0H,NotEqual:()=>gn.yQU,OP_SCOPE_SUFFIX:()=>an.zvA,OneHot:()=>gn.we_,OnesLike:()=>gn.qWM,Optimizer:()=>jn,OptimizerConstructors:()=>Gi,Pack:()=>gn.QiL,PadV2:()=>gn.lyA,Pool:()=>gn.Kgp,Pow:()=>gn.pe_,Prelu:()=>gn.o0g,Prod:()=>gn.DlI,RMSPropOptimizer:()=>$a,RaggedGather:()=>gn.dDz,RaggedTensorToTensor:()=>gn.BiW,Range:()=>gn.e6w,Rank:()=>uu.yw,Real:()=>gn.xJR,RealDiv:()=>gn.oHH,Reciprocal:()=>gn.$HU,Reduction:()=>kl.I,Relu:()=>gn.qkr,Relu6:()=>gn.SbG,Reshape:()=>gn.HZH,ResizeBilinear:()=>gn._Yw,ResizeBilinearGrad:()=>gn.zbQ,ResizeNearestNeighbor:()=>gn.dpD,ResizeNearestNeighborGrad:()=>gn.Hmb,Reverse:()=>gn.mKl,RotateWithOffset:()=>gn.b9H,Round:()=>gn.e07,Rsqrt:()=>gn.bV0,SGDOptimizer:()=>Bo,ScatterNd:()=>gn.xQA,SearchSorted:()=>gn.nr8,Select:()=>gn.PhF,Selu:()=>gn.oFR,Sigmoid:()=>gn.a5O,Sign:()=>gn.i5y,Sin:()=>gn.RQH,Sinh:()=>gn.wYB,Slice:()=>gn.p2w,Softmax:()=>gn.Gcp,Softplus:()=>gn.MRv,SpaceToBatchND:()=>gn.TQc,SparseFillEmptyRows:()=>gn.O3z,SparseReshape:()=>gn.nhH,SparseSegmentMean:()=>gn.w3H,SparseSegmentSum:()=>gn.ZjV,SparseToDense:()=>gn.D2d,SplitV:()=>gn.L8s,Sqrt:()=>gn.FKq,Square:()=>gn.bK0,SquaredDifference:()=>gn._tC,Step:()=>gn.h8e,StridedSlice:()=>gn.jQk,StringNGrams:()=>gn._JP,StringSplit:()=>gn.s1s,StringToHashBucketFast:()=>gn.XkS,Sub:()=>gn.Tr8,Sum:()=>gn.GBy,Tan:()=>gn.sEM,Tanh:()=>gn.MIZ,Tensor:()=>Yi.es,TensorBuffer:()=>Yi.YD,Tile:()=>gn.n9L,TopK:()=>gn.cWu,Transform:()=>gn.wx7,Transpose:()=>gn.G3Y,Unique:()=>gn.kpP,Unpack:()=>gn.ToN,UnsortedSegmentSum:()=>gn.Qvg,UpperBound:()=>gn.XDQ,Variable:()=>Yi._w,ZerosLike:()=>gn.RuY,_FusedMatMul:()=>gn.usg,abs:()=>an.WnP,acos:()=>an.Khb,acosh:()=>an.__u,add:()=>an.IHx,addN:()=>an.QBD,all:()=>an.$6P,any:()=>an.YjB,argMax:()=>an.NqF,argMin:()=>an.vHJ,asin:()=>an.ZRM,asinh:()=>an.VfV,atan:()=>an.z4N,atan2:()=>an.fvJ,atanh:()=>an.C80,avgPool:()=>an.wS1,avgPool3d:()=>an.uR5,backend:()=>Yt.y3,backend_util:()=>M,basicLSTMCell:()=>an.zEQ,batchNorm:()=>an.tgs,batchNorm2d:()=>an.Dxk,batchNorm3d:()=>an.JY5,batchNorm4d:()=>an.p3b,batchToSpaceND:()=>an.E4h,bincount:()=>an.yE8,booleanMaskAsync:()=>an.anm,broadcastArgs:()=>an.XsQ,broadcastTo:()=>an.UFq,broadcast_util:()=>Ma,browser:()=>F,buffer:()=>an.f3b,cast:()=>an.pju,ceil:()=>an.mDi,clipByValue:()=>an.iUl,clone:()=>an.d9v,complex:()=>an.PYB,concat:()=>an.zoF,concat1d:()=>an.gME,concat2d:()=>an.Izb,concat3d:()=>an.MNy,concat4d:()=>an.ZaL,conv1d:()=>an.PAt,conv2d:()=>an.Tek,conv2dTranspose:()=>an.bc,conv3d:()=>an.pdZ,conv3dTranspose:()=>an.$QV,copyRegisteredKernels:()=>qr.T3,cos:()=>an.mCk,cosh:()=>an.f9Y,cosineWindow:()=>an.mew,cumprod:()=>an.$Gn,cumsum:()=>an.zbp,customGrad:()=>cn.cb,denseBincount:()=>an.ppE,deprecationWarn:()=>Yt.MX,depthToSpace:()=>an.nTT,depthwiseConv2d:()=>an.B10,device_util:()=>U,diag:()=>an.Ka3,dilation2d:()=>an.WmZ,disableDeprecationWarnings:()=>Yt.cF,dispose:()=>Yt.B9,disposeVariables:()=>Yt.N8,div:()=>an.hiC,divNoNan:()=>an.NTj,dot:()=>an.AKD,dropout:()=>an.rvX,einsum:()=>an.WYO,elu:()=>an.pyx,enableDebugMode:()=>Yt.R,enableProdMode:()=>Yt.G4,enclosingPowerOfTwo:()=>an.GRh,engine:()=>Yt.SR,env:()=>we.OB,equal:()=>an.DgJ,erf:()=>an.qNN,euclideanNorm:()=>an.d2q,exp:()=>an.Qqt,expandDims:()=>an.dt4,expm1:()=>an.t$B,eye:()=>an.iyy,fft:()=>an.kp_,fill:()=>an.hlL,findBackend:()=>Yt.x3,findBackendFactory:()=>Yt.ze,floor:()=>an.GWj,floorDiv:()=>an.qPi,fused:()=>an.imm,gather:()=>an.Iqj,gatherND:()=>an.dbB,gather_util:()=>I,getBackend:()=>Yt.N_,getGradient:()=>qr.uk,getKernel:()=>qr.pI,getKernelsForBackend:()=>qr.tr,grad:()=>cn.UQ,grads:()=>cn.ti,greater:()=>an.pjt,greaterEqual:()=>an.brS,ifft:()=>an.Sxn,imag:()=>an.asL,image:()=>an.BHj,inTopKAsync:()=>an.V3u,io:()=>Z,irfft:()=>an.wx0,isFinite:()=>an.xVT,isInf:()=>an.UWc,isNaN:()=>an.i2d,keep:()=>Yt.Cn,kernel_impls:()=>T,leakyRelu:()=>an.hi7,less:()=>an.d9m,lessEqual:()=>an.zN1,linalg:()=>an.$r2,linspace:()=>an.SX3,localResponseNormalization:()=>an.G9k,log:()=>an.cM7,log1p:()=>an.Krr,logSigmoid:()=>an.e_t,logSoftmax:()=>an.CmS,logSumExp:()=>an.l_t,logicalAnd:()=>an.HvI,logicalNot:()=>an.hJK,logicalOr:()=>an.K5V,logicalXor:()=>an.egP,losses:()=>an.MB5,lowerBound:()=>an.eab,matMul:()=>an.OI3,math:()=>y,max:()=>an.Fp7,maxPool:()=>an._sB,maxPool3d:()=>an.YQQ,maxPoolWithArgmax:()=>an.Ip$,maximum:()=>an.gWQ,mean:()=>an.J69,memory:()=>Yt.sq,meshgrid:()=>an.ry_,min:()=>an.VV$,minimum:()=>an.LTh,mirrorPad:()=>an.VdP,mod:()=>an.wQq,moments:()=>an.Gi7,movingAverage:()=>an.p_,mul:()=>an.dC7,multiRNNCell:()=>an.rq4,multinomial:()=>an.SJ_,neg:()=>an.W76,nextFrame:()=>sd,norm:()=>an.KOy,notEqual:()=>an.Quu,oneHot:()=>an.lfX,ones:()=>an.iUs,onesLike:()=>an.JpU,op:()=>an.op,outerProduct:()=>an.N2O,pad:()=>an.vku,pad1d:()=>an.pNR,pad2d:()=>an.koy,pad3d:()=>an.t1L,pad4d:()=>an.lGY,pool:()=>an.d_R,pow:()=>an.sQ3,prelu:()=>an.AL3,print:()=>an.S0v,prod:()=>an.WVs,profile:()=>Yt.N5,raggedGather:()=>an.$gW,raggedTensorToTensor:()=>an.N89,rand:()=>an.TN_,randomGamma:()=>an.wzB,randomNormal:()=>an.nGf,randomStandardNormal:()=>an.ruB,randomUniform:()=>an.LGj,range:()=>an.w6H,ready:()=>Yt.Cd,real:()=>an.kwC,reciprocal:()=>an.M25,registerBackend:()=>Yt.jq,registerGradient:()=>qr.Li,registerKernel:()=>qr.wC,relu:()=>an.UYe,relu6:()=>an.btT,removeBackend:()=>Yt.cj,reshape:()=>an.XLQ,reverse:()=>an.GYS,reverse1d:()=>an.SDf,reverse2d:()=>an.diP,reverse3d:()=>an.sx7,reverse4d:()=>an.mG2,rfft:()=>an.QEs,round:()=>an.NMM,rsqrt:()=>an.bp0,scalar:()=>an.iD$,scatterND:()=>an.snQ,scatter_util:()=>X,searchSorted:()=>an.zcT,selu:()=>an.U8D,separableConv2d:()=>an.U_I,serialization:()=>W,setBackend:()=>Yt.CQ,setPlatform:()=>Yt.VY,setdiff1dAsync:()=>an.ODp,sigmoid:()=>an.XD2,sign:()=>an.Xxe,signal:()=>an.tdS,sin:()=>an.O$l,sinh:()=>an.R_K,slice:()=>an.tPi,slice1d:()=>an.jZU,slice2d:()=>an.SmN,slice3d:()=>an.CnO,slice4d:()=>an.p0P,slice_util:()=>N,softmax:()=>an.XAC,softplus:()=>an.Wvh,spaceToBatchND:()=>an.fBT,sparse:()=>an.rVs,sparseToDense:()=>an.ers,spectral:()=>an.uN7,split:()=>an.Vl2,sqrt:()=>an._b3,square:()=>an.h62,squaredDifference:()=>an.$i,squeeze:()=>an.L9e,stack:()=>an.knu,step:()=>an.Nbs,stridedSlice:()=>an.NXj,string:()=>an.Z_8,sub:()=>an.luU,sum:()=>an.Smz,sumOutType:()=>uu.z4,tan:()=>an.ORZ,tanh:()=>an.AEp,tensor:()=>an.XeE,tensor1d:()=>an.RRF,tensor2d:()=>an.odF,tensor3d:()=>an.wOQ,tensor4d:()=>an.yXz,tensor5d:()=>an.Bfx,tensor6d:()=>an.xZs,tensor_util:()=>Fi,test_util:()=>l,tidy:()=>Yt.lu,tile:()=>an.Gg6,time:()=>Yt.XV,topk:()=>an.hg7,train:()=>Gl,transpose:()=>an.p4s,truncatedNormal:()=>an.Xu6,unique:()=>an.Two,unregisterGradient:()=>qr.bt,unregisterKernel:()=>qr.nE,unsortedSegmentSum:()=>an.pUJ,unstack:()=>an.HHK,upcastType:()=>uu.x8,upperBound:()=>an.GaM,util:()=>Yc,valueAndGrad:()=>cn.h7,valueAndGrads:()=>cn.fN,variable:()=>an.VD$,variableGrads:()=>cn.pn,version_core:()=>jt,where:()=>an.arb,whereAsync:()=>an.itS,zeros:()=>an.lls,zerosLike:()=>an.P84});var U={};h.r(U),h.d(U,{isBrowser:()=>Re,isMobile:()=>_e,mockIsMobile:()=>K});var Z={};h.r(Z),h.d(Z,{browserFiles:()=>Al,browserHTTPRequest:()=>di,concatenateArrayBuffers:()=>Ct,copyModel:()=>Lo,decodeWeights:()=>Te,encodeWeights:()=>ye,fromMemory:()=>ic,fromMemorySync:()=>Br,getLoadHandlers:()=>Lt,getModelArtifactsForJSON:()=>bn,getModelArtifactsForJSONSync:()=>Bt,getModelArtifactsInfoForJSON:()=>Qn,getSaveHandlers:()=>Qe,getWeightSpecs:()=>Dn,http:()=>fa,isHTTPScheme:()=>Qi,listModels:()=>hl,loadWeights:()=>Hi,moveModel:()=>dc,registerLoadRouter:()=>Ss,registerSaveRouter:()=>Ir,removeModel:()=>Jr,weightsLoaderFactory:()=>ji,withSaveHandler:()=>dr,withSaveHandlerSync:()=>Xo});var y={};h.r(y),h.d(y,{confusionMatrix:()=>ar});var F={};h.r(F),h.d(F,{fromPixels:()=>q,fromPixelsAsync:()=>gl,toPixels:()=>_l});var I={};h.r(I),h.d(I,{prepareAndValidate:()=>L});var N={};h.r(N),h.d(N,{assertParamsValid:()=>Ye,computeFlatOffset:()=>yo,computeOutShape:()=>_t,getNormalizedAxes:()=>qn,isSliceContinous:()=>lr,maskToAxes:()=>it,parseSliceParams:()=>Da,sliceInfo:()=>Jt,startForAxis:()=>Cr,startIndicesWithElidedDims:()=>os,stopForAxis:()=>Is,stopIndicesWithElidedDims:()=>Ms,stridesForAxis:()=>Tr,stridesWithElidedDims:()=>wt});var W={};h.r(W),h.d(W,{Serializable:()=>wo,SerializationMap:()=>Fa,registerClass:()=>yl});var l={};h.r(l),h.d(l,{TEST_EPSILON_FLOAT16:()=>Hl,createVideoElement:()=>st,encodeStrings:()=>ot,expectArrayBuffersEqual:()=>Be,expectArraysClose:()=>Zc,expectArraysEqual:()=>Ai,expectNumbersClose:()=>Iu,expectPromiseToFail:()=>Qc,expectValuesInRange:()=>ve,play:()=>Xt,testEpsilon:()=>Oc});var w={};h.r(w),h.d(w,{collectGatherOpShapeInfo:()=>Ke,computeOutShape:()=>ke,segOpComputeOptimalWindowSize:()=>ge});var M={};h.r(M),h.d(M,{ERF_A1:()=>sr,ERF_A2:()=>No,ERF_A3:()=>ho,ERF_A4:()=>Rc,ERF_A5:()=>Vr,ERF_P:()=>zr,PARALLELIZE_THRESHOLD:()=>mt,RowPartitionType:()=>z,SELU_SCALE:()=>Or,SELU_SCALEALPHA:()=>Rs,applyActivation:()=>O.QH,assertAndGetBroadcastShape:()=>Ma.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>gc.lB,assertParamsConsistent:()=>rd,assignToTypedArray:()=>Kl,axesAreInnerMostDims:()=>gc.YB,calculateShapes:()=>X.calculateShapes,checkEinsumDimSizes:()=>Ws,checkPadOnDimRoundingMode:()=>V.m,combineLocations:()=>gc.Vh,combineRaggedTensorToTensorShapes:()=>pe,complexWithEvenIndex:()=>bl,complexWithOddIndex:()=>Vi,computeConv2DInfo:()=>V.Ix,computeConv3DInfo:()=>V.jw,computeDefaultPad:()=>V.aO,computeDilation2DInfo:()=>V.Rf,computeOptimalWindowSize:()=>Wt,computeOutAndReduceShapes:()=>gc.kz,computeOutShape:()=>Au,computePool2DInfo:()=>V.Xw,computePool3DInfo:()=>V.pl,convertConv2DDataFormat:()=>V.sl,decodeEinsumEquation:()=>Ru,eitherStridesOrDilationsAreOne:()=>V.jT,expandShapeToKeepDim:()=>gc.rv,exponent:()=>_c,exponents:()=>bu,fromStringArrayToUint8:()=>$t,fromUint8ToStringArray:()=>dt,getAxesPermutation:()=>gc.Q3,getBroadcastDims:()=>Ma.getBroadcastDims,getComplexWithIndex:()=>xl,getEinsumComputePath:()=>Wr,getEinsumPermutation:()=>Sa,getFusedBiasGradient:()=>O.pf,getFusedDyActivation:()=>O.Fr,getImageCenter:()=>mn,getInnerMostAxes:()=>gc.sY,getPermuted:()=>$n,getRaggedRank:()=>Ve,getReductionAxes:()=>Ma.getReductionAxes,getReshaped:()=>rn,getReshapedPermuted:()=>zn,getRowPartitionTypesHelper:()=>Pe,getSliceBeginCoords:()=>Bs,getSliceSize:()=>ur,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>ln,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>ei,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>ua,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Ur,getSparseReshapeInputOutputMismatchErrorMessage:()=>wd,getSparseReshapeInputOutputMultipleErrorMessage:()=>wl,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Nc,getSparseReshapeNegativeOutputDimErrorMessage:()=>Mc,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Me,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Do,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ks,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Zo,getUndoAxesPermutation:()=>gc.LJ,isIdentityPermutation:()=>Mo,log:()=>Ec.c,mergeRealAndImagArrays:()=>ku,prepareAndValidate:()=>L,prepareSplitSize:()=>Ol,segment_util:()=>w,shouldFuse:()=>O.uy,slice_util:()=>N,splitRealAndImagArrays:()=>Gn,tupleValuesAreOne:()=>V.I0,upcastType:()=>uu.x8,validateDefaultValueShape:()=>et,validateInput:()=>X.validateInput,validateUpdateShape:()=>X.validateUpdateShape,warn:()=>Ec.Z});var T={};h.r(T),h.d(T,{nonMaxSuppressionV3Impl:()=>dn.GP,nonMaxSuppressionV4Impl:()=>dn.qP,nonMaxSuppressionV5Impl:()=>dn.pA,whereImpl:()=>Sn.Z});var D=h(1379);let J;function K(re){J=re}function _e(re){if(void 0!==J)return J;if(re||function G(){return typeof navigator<"u"&&null!=navigator}()){if(re||(re=navigator),"ReactNative"===re.product)return!0;const xe=re.userAgent||re.vendor||(typeof window<"u"?window.opera:"");return xe?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(xe)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(xe.substr(0,4)):re.userAgentData&&re.userAgentData.mobile}return!1}function Re(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}var we=h(8514);const We=(0,we.OB)();We.registerFlag("DEBUG",()=>!1,re=>{re&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),We.registerFlag("IS_BROWSER",()=>Re()),We.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),We.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),We.registerFlag("PROD",()=>!1),We.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>We.getBool("DEBUG")),We.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),We.registerFlag("IS_TEST",()=>!1),We.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),We.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),We.registerFlag("ENGINE_COMPILE_ONLY",()=>!1),We.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),We.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var Oe=h(5861),ie=h(7507),Le=h(4712),De=h(4944);const te={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var de,P;const oe=4;function ye(re,xe){return(de=de||(0,Oe.Z)(function*(ee,me){const Fe=[],gt=[],At=Array.isArray(ee)?ee.map(On=>On.name):Object.keys(ee);for(let On=0;On<At.length;++On){const Kn=At[On],Ln=Array.isArray(ee)?ee[On].tensor:ee[Kn];if("float32"!==Ln.dtype&&"int32"!==Ln.dtype&&"bool"!==Ln.dtype&&"string"!==Ln.dtype&&"complex64"!==Ln.dtype)throw new Error(`Unsupported dtype in weight '${Kn}': ${Ln.dtype}`);const An={name:Kn,shape:Ln.shape,dtype:Ln.dtype};if("string"===Ln.dtype){var zt;const vs=new Promise(function(ir){return(zt=zt||(0,Oe.Z)(function*(Er){const gi=yield Ln.bytes(),So=gi.reduce((Qo,Ci)=>Qo+Ci.length,0)+oe*gi.length,vc=new Uint8Array(So);let Nr=0;for(let Qo=0;Qo<gi.length;Qo++){const Ci=gi[Qo],Rl=new Uint8Array(new Uint32Array([Ci.length]).buffer);vc.set(Rl,Nr),Nr+=oe,vc.set(Ci,Nr),Nr+=Ci.length}Er(vc)})).apply(this,arguments)});gt.push(vs)}else gt.push(Ln.data());null!=me&&(An.group=me),Fe.push(An)}return{data:v(yield Promise.all(gt)),specs:Fe}})).apply(this,arguments)}function Te(re,xe){const ee={};let me,Fe=0;for(const gt of xe){const At=gt.name,zt=gt.dtype,Pn=gt.shape,On=(0,De.NA)(Pn);let Kn;if("quantization"in gt){const Ln=gt.quantization;if("uint8"===Ln.dtype||"uint16"===Ln.dtype){if(!("min"in Ln)||!("scale"in Ln))throw new Error(`Weight ${gt.name} with quantization ${Ln.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==Ln.dtype)throw new Error(`Weight ${gt.name} has unknown quantization dtype ${Ln.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==zt)throw new Error(`Weight ${gt.name} is quantized with ${Ln.dtype} which only supports weights of type float32 not ${zt}.`)}const An=te[Ln.dtype],vs=re.slice(Fe,Fe+On*An),ir="uint8"===Ln.dtype?new Uint8Array(vs):new Uint16Array(vs);if("float32"===zt)if("uint8"===Ln.dtype||"uint16"===Ln.dtype){Kn=new Float32Array(ir.length);for(let Er=0;Er<ir.length;Er++)Kn[Er]=ir[Er]*Ln.scale+Ln.min}else{if("float16"!==Ln.dtype)throw new Error(`Unsupported quantization type ${Ln.dtype} for weight type float32.`);void 0===me&&(me=Ts()),Kn=me(ir)}else{if("int32"!==zt)throw new Error(`Unsupported dtype in weight '${At}': ${zt}`);if("uint8"!==Ln.dtype&&"uint16"!==Ln.dtype)throw new Error(`Unsupported quantization type ${Ln.dtype} for weight type int32.`);Kn=new Int32Array(ir.length);for(let Er=0;Er<ir.length;Er++)Kn[Er]=Math.round(ir[Er]*Ln.scale+Ln.min)}Fe+=On*An}else if("string"===zt){const Ln=(0,De.NA)(gt.shape);Kn=[];for(let An=0;An<Ln;An++){const vs=new Uint32Array(re.slice(Fe,Fe+oe))[0];Fe+=oe;const ir=new Uint8Array(re.slice(Fe,Fe+vs));Kn.push(ir),Fe+=vs}}else{const Ln=te[zt],An=re.slice(Fe,Fe+On*Ln);if("float32"===zt)Kn=new Float32Array(An);else if("int32"===zt)Kn=new Int32Array(An);else if("bool"===zt)Kn=new Uint8Array(An);else{if("complex64"!==zt)throw new Error(`Unsupported dtype in weight '${At}': ${zt}`);{Kn=new Float32Array(An);const vs=new Float32Array(Kn.length/2),ir=new Float32Array(Kn.length/2);for(let So=0;So<vs.length;So++)vs[So]=Kn[2*So],ir[So]=Kn[2*So+1];const Er=(0,Le.X)(vs,Pn,"float32"),gi=(0,Le.X)(ir,Pn,"float32");ee[At]=(0,ie.P)(Er,gi),Er.dispose(),gi.dispose()}}Fe+=On*Ln}"complex64"!==zt&&(ee[At]=(0,Le.X)(Kn,Pn,zt))}return ee}function v(re){if(null===re)throw new Error(`Invalid input value: ${JSON.stringify(re)}`);let xe=0;const ee=[];re.forEach(gt=>{if(xe+=gt.byteLength,ee.push(gt.byteLength===gt.buffer.byteLength?gt:new gt.constructor(gt)),!(gt instanceof Float32Array||gt instanceof Int32Array||gt instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${gt.constructor.name}`)});const me=new Uint8Array(xe);let Fe=0;return ee.forEach(gt=>{me.set(new Uint8Array(gt.buffer),Fe),Fe+=gt.byteLength}),me.buffer}const at=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Xe(re){return at?Buffer.byteLength(re):new Blob([re]).size}function Ct(re){if(1===re.length)return re[0];let xe=0;re.forEach(Fe=>{xe+=Fe.byteLength});const ee=new Uint8Array(xe);let me=0;return re.forEach(Fe=>{ee.set(new Uint8Array(Fe),me),me+=Fe.byteLength}),ee.buffer}function It(re){for(re=re.trim();re.endsWith("/");)re=re.slice(0,re.length-1);const ee=re.split("/");return ee[ee.length-1]}function nn(re,xe){const ee={modelTopology:re.modelTopology,format:re.format,generatedBy:re.generatedBy,convertedBy:re.convertedBy,weightsManifest:xe};return null!=re.signature&&(ee.signature=re.signature),null!=re.userDefinedMetadata&&(ee.userDefinedMetadata=re.userDefinedMetadata),null!=re.modelInitializer&&(ee.modelInitializer=re.modelInitializer),null!=re.trainingConfig&&(ee.trainingConfig=re.trainingConfig),ee}function Bt(re,xe,ee){const me={modelTopology:re.modelTopology,format:re.format,generatedBy:re.generatedBy,convertedBy:re.convertedBy};if(null!=re.trainingConfig&&(me.trainingConfig=re.trainingConfig),null!=re.weightsManifest){if(!xe)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!ee)throw new Error("modelJSON has weightsManifest but weightData is null");me.weightSpecs=xe,me.weightData=ee}return null!=re.signature&&(me.signature=re.signature),null!=re.userDefinedMetadata&&(me.userDefinedMetadata=re.userDefinedMetadata),null!=re.modelInitializer&&(me.modelInitializer=re.modelInitializer),me}function bn(re,xe){return(P=P||(0,Oe.Z)(function*(ee,me){let Fe,gt;return null!=ee.weightsManifest&&([Fe,gt]=yield me(ee.weightsManifest)),Bt(ee,Fe,gt)})).apply(this,arguments)}function Qn(re){if(re.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==re.modelTopology?0:Xe(JSON.stringify(re.modelTopology)),weightSpecsBytes:null==re.weightSpecs?0:Xe(JSON.stringify(re.weightSpecs)),weightDataBytes:null==re.weightData?0:re.weightData.byteLength}}function Dn(re){const xe=[];for(const ee of re)xe.push(...ee.weights);return xe}function Ts(){const re=function ps(){const re=ee=>{let me=ee<<13,Fe=0;for(;!(8388608&me);)Fe-=8388608,me<<=1;return me&=-8388609,Fe+=947912704,me|Fe},xe=new Uint32Array(2048);xe[0]=0;for(let ee=1;ee<1024;ee++)xe[ee]=re(ee);for(let ee=1024;ee<2048;ee++)xe[ee]=939524096+(ee-1024<<13);return xe}(),xe=function Es(){const re=new Uint32Array(64);re[0]=0,re[31]=1199570944,re[32]=2147483648,re[63]=3347054592;for(let xe=1;xe<31;xe++)re[xe]=xe<<23;for(let xe=33;xe<63;xe++)re[xe]=2147483648+(xe-32<<23);return re}(),ee=function Xn(){const re=new Uint32Array(64);for(let xe=0;xe<64;xe++)re[xe]=1024;return re[0]=re[32]=0,re}();return me=>{const Fe=new ArrayBuffer(4*me.length),gt=new Uint32Array(Fe);for(let At=0;At<me.length;At++){const zt=me[At];gt[At]=re[ee[zt>>10]+(1023&zt)]+xe[zt>>10]}return new Float32Array(Fe)}}class or{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==or.instance&&(or.instance=new or),or.instance}static registerSaveRouter(xe){or.getInstance().saveRouters.push(xe)}static registerLoadRouter(xe){or.getInstance().loadRouters.push(xe)}static getSaveHandlers(xe){return or.getHandlers(xe,"save")}static getLoadHandlers(xe,ee){return or.getHandlers(xe,"load",ee)}static getHandlers(xe,ee,me){const Fe=[];return("load"===ee?or.getInstance().loadRouters:or.getInstance().saveRouters).forEach(At=>{const zt=At(xe,me);null!==zt&&Fe.push(zt)}),Fe}}const Ir=re=>or.registerSaveRouter(re),Ss=re=>or.registerLoadRouter(re),Qe=re=>or.getSaveHandlers(re),Lt=(re,xe)=>or.getLoadHandlers(re,xe),Nn="tensorflowjs",zs="models_store",cr="model_info_store";function $r(){if(!(0,we.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const re=typeof window>"u"?self:window,xe=re.indexedDB||re.mozIndexedDB||re.webkitIndexedDB||re.msIndexedDB||re.shimIndexedDB;if(null==xe)throw new Error("The current browser does not appear to support IndexedDB.");return xe}function eo(re){const xe=re.result;xe.createObjectStore(zs,{keyPath:"modelPath"}),xe.createObjectStore(cr,{keyPath:"modelPath"})}let oa=(()=>{class re{constructor(ee){if(this.indexedDB=$r(),null==ee||!ee)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=ee}save(ee){var me=this;return(0,Oe.Z)(function*(){if(ee.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return me.databaseAction(me.modelPath,ee)})()}load(){var ee=this;return(0,Oe.Z)(function*(){return ee.databaseAction(ee.modelPath)})()}databaseAction(ee,me){return new Promise((Fe,gt)=>{const At=this.indexedDB.open(Nn,1);At.onupgradeneeded=()=>eo(At),At.onsuccess=()=>{const zt=At.result;if(null==me){const Pn=zt.transaction(zs,"readonly"),Kn=Pn.objectStore(zs).get(this.modelPath);Kn.onsuccess=()=>{if(null==Kn.result)return zt.close(),gt(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));Fe(Kn.result.modelArtifacts)},Kn.onerror=Ln=>(zt.close(),gt(Kn.error)),Pn.oncomplete=()=>zt.close()}else{const Pn=Qn(me),On=zt.transaction(cr,"readwrite");let Kn=On.objectStore(cr);const Ln=Kn.put({modelPath:this.modelPath,modelArtifactsInfo:Pn});let An;Ln.onsuccess=()=>{An=zt.transaction(zs,"readwrite");const ir=An.objectStore(zs).put({modelPath:this.modelPath,modelArtifacts:me,modelArtifactsInfo:Pn});ir.onsuccess=()=>Fe({modelArtifactsInfo:Pn}),ir.onerror=Er=>{Kn=On.objectStore(cr);const gi=Kn.delete(this.modelPath);gi.onsuccess=()=>(zt.close(),gt(ir.error)),gi.onerror=So=>(zt.close(),gt(ir.error))}},Ln.onerror=vs=>(zt.close(),gt(Ln.error)),On.oncomplete=()=>{null==An?zt.close():An.oncomplete=()=>zt.close()}}},At.onerror=zt=>gt(At.error)})}}return re.URL_SCHEME="indexeddb://",re})();const aa=re=>(0,we.OB)().getBool("IS_BROWSER")&&!Array.isArray(re)&&re.startsWith(oa.URL_SCHEME)?function Po(re){return new oa(re)}(re.slice(oa.URL_SCHEME.length)):null;or.registerSaveRouter(aa),or.registerLoadRouter(aa);class za{constructor(){this.indexedDB=$r()}listModels(){var xe=this;return(0,Oe.Z)(function*(){return new Promise((ee,me)=>{const Fe=xe.indexedDB.open(Nn,1);Fe.onupgradeneeded=()=>eo(Fe),Fe.onsuccess=()=>{const gt=Fe.result,At=gt.transaction(cr,"readonly"),Pn=At.objectStore(cr).getAll();Pn.onsuccess=()=>{const On={};for(const Kn of Pn.result)On[Kn.modelPath]=Kn.modelArtifactsInfo;ee(On)},Pn.onerror=On=>(gt.close(),me(Pn.error)),At.oncomplete=()=>gt.close()},Fe.onerror=gt=>me(Fe.error)})})()}removeModel(xe){var ee=this;return(0,Oe.Z)(function*(){return xe=function xa(re){return re.startsWith(oa.URL_SCHEME)?re.slice(oa.URL_SCHEME.length):re}(xe),new Promise((me,Fe)=>{const gt=ee.indexedDB.open(Nn,1);gt.onupgradeneeded=()=>eo(gt),gt.onsuccess=()=>{const At=gt.result,zt=At.transaction(cr,"readwrite"),Pn=zt.objectStore(cr),On=Pn.get(xe);let Kn;On.onsuccess=()=>{if(null==On.result)return At.close(),Fe(new Error(`Cannot find model with path '${xe}' in IndexedDB.`));{const Ln=Pn.delete(xe),An=()=>{Kn=At.transaction(zs,"readwrite");const ir=Kn.objectStore(zs).delete(xe);ir.onsuccess=()=>me(On.result.modelArtifactsInfo),ir.onerror=Er=>Fe(On.error)};Ln.onsuccess=An,Ln.onerror=vs=>(An(),At.close(),Fe(On.error))}},On.onerror=Ln=>(At.close(),Fe(On.error)),zt.oncomplete=()=>{null==Kn?At.close():Kn.oncomplete=()=>At.close()}},gt.onerror=At=>Fe(gt.error)})})()}}const To="/",lo="tensorflowjs_models",Ao="info",Ho="model_topology",sl="weight_specs",ka="weight_data",to="model_metadata";function Wa(re){return{info:[lo,re,Ao].join(To),topology:[lo,re,Ho].join(To),weightSpecs:[lo,re,sl].join(To),weightData:[lo,re,ka].join(To),modelMetadata:[lo,re,to].join(To)}}function Fo(re){for(const xe of Object.values(re))window.localStorage.removeItem(xe)}function Ha(re){const xe=re.split(To);if(xe.length<3)throw new Error(`Invalid key format: ${re}`);return xe.slice(1,xe.length-1).join(To)}let jo=(()=>{class re{constructor(ee){if(!(0,we.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==ee||!ee)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=ee,this.keys=Wa(this.modelPath)}save(ee){var me=this;return(0,Oe.Z)(function*(){if(ee.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const Fe=JSON.stringify(ee.modelTopology),gt=JSON.stringify(ee.weightSpecs),At=Qn(ee);try{return me.LS.setItem(me.keys.info,JSON.stringify(At)),me.LS.setItem(me.keys.topology,Fe),me.LS.setItem(me.keys.weightSpecs,gt),me.LS.setItem(me.keys.weightData,function Ue(re){if(at)return Buffer.from(re).toString("base64");const xe=new Uint8Array(re);let ee="";for(let me=0,Fe=xe.length;me<Fe;me++)ee+=String.fromCharCode(xe[me]);return btoa(ee)}(ee.weightData)),me.LS.setItem(me.keys.modelMetadata,JSON.stringify({format:ee.format,generatedBy:ee.generatedBy,convertedBy:ee.convertedBy,signature:null!=ee.signature?ee.signature:void 0,userDefinedMetadata:null!=ee.userDefinedMetadata?ee.userDefinedMetadata:void 0,modelInitializer:null!=ee.modelInitializer?ee.modelInitializer:void 0,trainingConfig:null!=ee.trainingConfig?ee.trainingConfig:void 0})),{modelArtifactsInfo:At}}catch{throw Fo(me.keys),new Error(`Failed to save model '${me.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${At.modelTopologyBytes}, weightSpecsBytes=${At.weightSpecsBytes}, weightDataBytes=${At.weightDataBytes}.`)}}})()}load(){var ee=this;return(0,Oe.Z)(function*(){const me=JSON.parse(ee.LS.getItem(ee.keys.info));if(null==me)throw new Error(`In local storage, there is no model with name '${ee.modelPath}'`);if("JSON"!==me.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const Fe={},gt=JSON.parse(ee.LS.getItem(ee.keys.topology));if(null==gt)throw new Error(`In local storage, the topology of model '${ee.modelPath}' is missing.`);Fe.modelTopology=gt;const At=JSON.parse(ee.LS.getItem(ee.keys.weightSpecs));if(null==At)throw new Error(`In local storage, the weight specs of model '${ee.modelPath}' are missing.`);Fe.weightSpecs=At;const zt=ee.LS.getItem(ee.keys.modelMetadata);if(null!=zt){const On=JSON.parse(zt);Fe.format=On.format,Fe.generatedBy=On.generatedBy,Fe.convertedBy=On.convertedBy,null!=On.signature&&(Fe.signature=On.signature),null!=On.userDefinedMetadata&&(Fe.userDefinedMetadata=On.userDefinedMetadata),null!=On.modelInitializer&&(Fe.modelInitializer=On.modelInitializer),null!=On.trainingConfig&&(Fe.trainingConfig=On.trainingConfig)}const Pn=ee.LS.getItem(ee.keys.weightData);if(null==Pn)throw new Error(`In local storage, the binary weight values of model '${ee.modelPath}' are missing.`);return Fe.weightData=function pt(re){if(at){const me=Buffer.from(re,"base64");return me.buffer.slice(me.byteOffset,me.byteOffset+me.byteLength)}const xe=atob(re),ee=new Uint8Array(xe.length);for(let me=0;me<xe.length;++me)ee.set([xe.charCodeAt(me)],me);return ee.buffer}(Pn),Fe})()}}return re.URL_SCHEME="localstorage://",re})();const la=re=>(0,we.OB)().getBool("IS_BROWSER")&&!Array.isArray(re)&&re.startsWith(jo.URL_SCHEME)?function $s(re){return new jo(re)}(re.slice(jo.URL_SCHEME.length)):null;or.registerSaveRouter(la),or.registerLoadRouter(la);class co{constructor(){(0,De.hu)((0,we.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,De.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var xe=this;return(0,Oe.Z)(function*(){const ee={},me=lo+To,Fe=To+Ao;for(let gt=0;gt<xe.LS.length;++gt){const At=xe.LS.key(gt);At.startsWith(me)&&At.endsWith(Fe)&&(ee[Ha(At)]=JSON.parse(xe.LS.getItem(At)))}return ee})()}removeModel(xe){var ee=this;return(0,Oe.Z)(function*(){const me=Wa(xe=function qe(re){return re.startsWith(jo.URL_SCHEME)?re.slice(jo.URL_SCHEME.length):re}(xe));if(null==ee.LS.getItem(me.info))throw new Error(`Cannot find model at path '${xe}'`);const Fe=JSON.parse(ee.LS.getItem(me.info));return Fo(me),Fe})()}}var ui,ja,Go,Li,wa;const Ki="://";class Xi{constructor(){this.managers={}}static getInstance(){return null==Xi.instance&&(Xi.instance=new Xi),Xi.instance}static registerManager(xe,ee){(0,De.hu)(null!=xe,()=>"scheme must not be undefined or null."),xe.endsWith(Ki)&&(xe=xe.slice(0,xe.indexOf(Ki))),(0,De.hu)(xe.length>0,()=>"scheme must not be an empty string.");const me=Xi.getInstance();(0,De.hu)(null==me.managers[xe],()=>`A model store manager is already registered for scheme '${xe}'.`),me.managers[xe]=ee}static getManager(xe){const ee=Xi.getInstance().managers[xe];if(null==ee)throw new Error(`Cannot find model manager for scheme '${xe}'`);return ee}static getSchemes(){return Object.keys(Xi.getInstance().managers)}}function $i(re){if(-1===re.indexOf(Ki))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Xi.getSchemes().join(",")}`);return{scheme:re.split(Ki)[0],path:re.split(Ki)[1]}}function Bi(re,xe){return(ui=ui||(0,Oe.Z)(function*(ee,me,Fe=!1){(0,De.hu)(ee!==me,()=>`Old path and new path are the same: '${ee}'`);const gt=or.getLoadHandlers(ee);(0,De.hu)(gt.length>0,()=>`Copying failed because no load handler is found for source URL ${ee}.`),(0,De.hu)(gt.length<2,()=>`Copying failed because more than one (${gt.length}) load handlers for source URL ${ee}.`);const At=gt[0],zt=or.getSaveHandlers(me);(0,De.hu)(zt.length>0,()=>`Copying failed because no save handler is found for destination URL ${me}.`),(0,De.hu)(zt.length<2,()=>`Copying failed because more than one (${gt.length}) save handlers for destination URL ${me}.`);const Pn=zt[0],On=$i(ee).scheme,Kn=$i(ee).path,Ln=On===$i(ee).scheme,An=yield At.load();Fe&&Ln&&(yield Xi.getManager(On).removeModel(Kn));const vs=yield Pn.save(An);return Fe&&!Ln&&(yield Xi.getManager(On).removeModel(Kn)),vs.modelArtifactsInfo})).apply(this,arguments)}function hl(){return(ja=ja||(0,Oe.Z)(function*(){const re=Xi.getSchemes(),xe={};for(const ee of re){const me=yield Xi.getManager(ee).listModels();for(const Fe in me)xe[ee+Ki+Fe]=me[Fe]}return xe})).apply(this,arguments)}function Jr(re){return(Go=Go||(0,Oe.Z)(function*(xe){const ee=$i(xe);return Xi.getManager(ee.scheme).removeModel(ee.path)})).apply(this,arguments)}function Lo(re,xe){return(Li=Li||(0,Oe.Z)(function*(ee,me){return Bi(ee,me,!1)})).apply(this,arguments)}function dc(re,xe){return(wa=wa||(0,Oe.Z)(function*(ee,me){return Bi(ee,me,!0)})).apply(this,arguments)}class hc{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(xe,ee){return fetch(xe,ee)}now(){return performance.now()}encode(xe,ee){if("utf-8"!==ee&&"utf8"!==ee)throw new Error(`Browser's encoder only supports utf-8, but got ${ee}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(xe)}decode(xe,ee){return new TextDecoder(ee).decode(xe)}setTimeoutCustom(xe,ee){window&&(0,we.OB)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(xe),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},ee),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",me=>{me.source===window&&me.data.name===this.messageName&&(me.stopPropagation(),(0,this.functionRefs[me.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(xe,ee)}}if((0,we.OB)().get("IS_BROWSER")){(0,we.OB)().setPlatform("browser",new hc);try{Xi.registerManager(jo.URL_SCHEME,new co)}catch{}try{Xi.registerManager(oa.URL_SCHEME,new za)}catch{}}let Ko;(0,we.OB)().get("IS_NODE")&&!(0,we.OB)().get("IS_BROWSER")&&(0,we.OB)().setPlatform("node",new class fl{constructor(){this.util=h(2074),this.textEncoder=new this.util.TextEncoder}fetch(xe,ee){return null!=(0,we.OB)().global.fetch?(0,we.OB)().global.fetch(xe,ee):(null==Ko&&(Ko=h(9957)),Ko(xe,ee))}now(){const xe=process.hrtime();return 1e3*xe[0]+xe[1]/1e6}encode(xe,ee){if("utf-8"!==ee&&"utf8"!==ee)throw new Error(`Node built-in encoder only supports utf-8, but got ${ee}`);return this.textEncoder.encode(xe)}decode(xe,ee){return 0===xe.length?"":new this.util.TextDecoder(ee).decode(xe)}});var no=h(94),Ka=h(8622),so=h(1676),il=h(2202),Yi=h(9089);function Js(re){return new Promise(xe=>setTimeout(xe)).then(re)}(0,D.wv)(),(0,Yi.Vp)({buffer:no.f,cast:Ka.p,clone:so.d,print:il.S});let vi=(()=>{class re{constructor(ee){if(!(0,we.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");ee.startsWith(re.URL_SCHEME)&&(ee=ee.slice(re.URL_SCHEME.length)),(null==ee||0===ee.length)&&(ee="model"),this.modelJsonFileName=ee+".json",this.weightDataFileName=ee+".weights.bin"}save(ee){var me=this;return(0,Oe.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const Fe=window.URL.createObjectURL(new Blob([ee.weightData],{type:"application/octet-stream"}));if(ee.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const At=nn(ee,[{paths:["./"+me.weightDataFileName],weights:ee.weightSpecs}]),zt=window.URL.createObjectURL(new Blob([JSON.stringify(At)],{type:"application/json"})),Pn=null==me.modelJsonAnchor?document.createElement("a"):me.modelJsonAnchor;if(Pn.download=me.modelJsonFileName,Pn.href=zt,yield Js(()=>Pn.dispatchEvent(new MouseEvent("click"))),null!=ee.weightData){const On=null==me.weightDataAnchor?document.createElement("a"):me.weightDataAnchor;On.download=me.weightDataFileName,On.href=Fe,yield Js(()=>On.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Qn(ee)}}})()}}return re.URL_SCHEME="downloads://",re})();class $o{constructor(xe){if(null==xe||xe.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${xe}`);this.jsonFile=xe[0],this.weightsFiles=xe.slice(1)}load(){var xe=this;return(0,Oe.Z)(function*(){return new Promise((ee,me)=>{const Fe=new FileReader;Fe.onload=gt=>{const At=JSON.parse(gt.target.result),zt=At.modelTopology;if(null==zt)return void me(new Error(`modelTopology field is missing from file ${xe.jsonFile.name}`));if(null==At.weightsManifest)return void me(new Error(`weightManifest field is missing from file ${xe.jsonFile.name}`));if(0===xe.weightsFiles.length)return void ee({modelTopology:zt});const On=bn(At,Kn=>xe.loadWeights(Kn));ee(On)},Fe.onerror=gt=>me(`Failed to read model topology and weights manifest JSON from file '${xe.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),Fe.readAsText(xe.jsonFile)})})()}loadWeights(xe){const ee=[],me=[];for(const At of xe)ee.push(...At.weights),me.push(...At.paths);const Fe=this.checkManifestAndWeightFiles(xe),gt=me.map(At=>this.loadWeightsFile(At,Fe[At]));return Promise.all(gt).then(At=>[ee,Ct(At)])}loadWeightsFile(xe,ee){return new Promise((me,Fe)=>{const gt=new FileReader;gt.onload=At=>{me(At.target.result)},gt.onerror=At=>Fe(`Failed to weights data from file of path '${xe}'.`),gt.readAsArrayBuffer(ee)})}checkManifestAndWeightFiles(xe){const ee=[],me=this.weightsFiles.map(gt=>It(gt.name)),Fe={};for(const gt of xe)gt.paths.forEach(At=>{const zt=It(At);if(-1!==ee.indexOf(zt))throw new Error(`Duplicate file basename found in weights manifest: '${zt}'`);if(ee.push(zt),-1===me.indexOf(zt))throw new Error(`Weight file with basename '${zt}' is not provided.`);Fe[At]=this.weightsFiles[me.indexOf(zt)]});if(ee.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${ee.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return Fe}}function Al(re){return new $o(re)}function uo(re,xe,ee,me){(function At(Pn){(0,De.hu)(null!=Pn&&Array.isArray(Pn)&&Pn.length>0,()=>"promises must be a none empty array")})(re),function zt(Pn,On){(0,De.hu)(Pn>=0&&Pn<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${Pn}`),(0,De.hu)(On>=0&&On<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${On}`),(0,De.hu)(On>=Pn,()=>`startFraction must be no more than endFraction, but got startFraction ${Pn} and endFraction ${On}`)}(ee=ee??0,me=me??1);let Fe=0;return Promise.all(re.map(Pn=>(Pn.then(On=>{const Kn=ee+ ++Fe/re.length*(me-ee);return xe(Kn),On}),Pn)))}var Ra,Zi;function Oo(re,xe){return(Ra=Ra||(0,Oe.Z)(function*(ee,me){null==me&&(me={});const Fe=null==me.fetchFunc?(0,we.OB)().platform.fetch:me.fetchFunc,gt=ee.map(vs=>Fe(vs,me.requestInit,{isBinary:!0})),On=(null==me.onProgress?yield Promise.all(gt):yield uo(gt,me.onProgress,0,.5)).map(vs=>vs.arrayBuffer());return null==me.onProgress?yield Promise.all(On):yield uo(On,me.onProgress,.5,1)})).apply(this,arguments)}function Hi(re){return(Zi=Zi||(0,Oe.Z)(function*(xe,ee="",me,Fe){return ji(zt=>Oo(zt,{requestInit:Fe}))(xe,ee,me)})).apply(this,arguments)}function ji(re){var xe;return function(ee){return(xe=xe||(0,Oe.Z)(function*(me,Fe="",gt){const At=me.map(()=>!1),zt={},Pn=null!=gt?gt.map(()=>!1):[],On=[];if(me.forEach((Er,gi)=>{let So=0;Er.weights.forEach(vc=>{const Qo=te["quantization"in vc?vc.quantization.dtype:vc.dtype]*De.NA(vc.shape),Ci=()=>{At[gi]=!0,null==zt[gi]&&(zt[gi]=[]),zt[gi].push({manifestEntry:vc,groupOffset:So,sizeBytes:Qo})};null!=gt?gt.forEach((Rl,cl)=>{Rl===vc.name&&(Ci(),Pn[cl]=!0)}):Ci(),On.push(vc.name),So+=Qo})}),!Pn.every(Er=>Er)){const Er=gt.filter((gi,So)=>!Pn[So]);throw new Error(`Could not find weights in manifest with names: ${Er.join(", ")}. \nManifest JSON has weights with names: ${On.join(", ")}.`)}const Kn=At.reduce((Er,gi,So)=>(gi&&Er.push(So),Er),[]),Ln=[];Kn.forEach(Er=>{me[Er].paths.forEach(gi=>{const So=Fe+(Fe.endsWith("/")?"":"/")+gi;Ln.push(So)})});const An=yield re(Ln),vs={};let ir=0;return Kn.forEach(Er=>{const gi=me[Er].paths.length;let So=0;for(let Rl=0;Rl<gi;Rl++)So+=An[ir+Rl].byteLength;const vc=new ArrayBuffer(So),Nr=new Uint8Array(vc);let Qo=0;for(let Rl=0;Rl<gi;Rl++){const cl=new Uint8Array(An[ir+Rl]);Nr.set(cl,Qo),Qo+=cl.byteLength}zt[Er].forEach(Rl=>{const id=Te(vc.slice(Rl.groupOffset,Rl.groupOffset+Rl.sizeBytes),[Rl.manifestEntry]);for(const Dc in id)vs[Dc]=id[Dc]}),ir+=gi}),vs})).apply(this,arguments)}}or.registerSaveRouter(re=>(0,we.OB)().getBool("IS_BROWSER")&&!Array.isArray(re)&&re.startsWith(vi.URL_SCHEME)?function Oa(re="model"){return new vi(re)}(re.slice(vi.URL_SCHEME.length)):null);let ro=(()=>{class re{constructor(ee,me){if(this.DEFAULT_METHOD="POST",null==me&&(me={}),this.weightPathPrefix=me.weightPathPrefix,this.onProgress=me.onProgress,this.weightUrlConverter=me.weightUrlConverter,null!=me.fetchFunc?((0,De.hu)("function"==typeof me.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=me.fetchFunc):this.fetch=(0,we.OB)().platform.fetch,(0,De.hu)(null!=ee&&ee.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(ee)&&(0,De.hu)(2===ee.length,()=>`URL paths for http must have a length of 2, (actual length is ${ee.length}).`),this.path=ee,null!=me.requestInit&&null!=me.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=me.requestInit||{}}save(ee){var me=this;return(0,Oe.Z)(function*(){if(ee.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const Fe=Object.assign({method:me.DEFAULT_METHOD},me.requestInit);Fe.body=new FormData;const At=nn(ee,[{paths:["./model.weights.bin"],weights:ee.weightSpecs}]);Fe.body.append("model.json",new Blob([JSON.stringify(At)],{type:"application/json"}),"model.json"),null!=ee.weightData&&Fe.body.append("model.weights.bin",new Blob([ee.weightData],{type:"application/octet-stream"}),"model.weights.bin");const zt=yield me.fetch(me.path,Fe);if(zt.ok)return{modelArtifactsInfo:Qn(ee),responses:[zt]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${zt.status}.`)})()}load(){var ee=this;return(0,Oe.Z)(function*(){const me=yield ee.fetch(ee.path,ee.requestInit);if(!me.ok)throw new Error(`Request to ${ee.path} failed with status code ${me.status}. Please verify this URL points to the model JSON of the model to load.`);let Fe;try{Fe=yield me.json()}catch{let Pn=`Failed to parse model JSON of response from ${ee.path}.`;throw ee.path.endsWith(".pb")?Pn+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":Pn+=" Please make sure the server is serving valid JSON for this request.",new Error(Pn)}if(null==Fe.modelTopology&&null==Fe.weightsManifest)throw new Error(`The JSON from HTTP path ${ee.path} contains neither model topology or manifest for weights.`);return bn(Fe,zt=>ee.loadWeights(zt))})()}loadWeights(ee){var me=this;return(0,Oe.Z)(function*(){const Fe=Array.isArray(me.path)?me.path[1]:me.path,[gt,At]=function pa(re){const xe=re.lastIndexOf("/"),ee=re.lastIndexOf("?");return[re.substring(0,xe)+"/",ee>xe?re.substring(ee):""]}(Fe),zt=me.weightPathPrefix||gt,Pn=Dn(ee),On=[],Kn=[];for(const An of ee)for(const vs of An.paths)null!=me.weightUrlConverter?Kn.push(me.weightUrlConverter(vs)):On.push(zt+vs+At);return me.weightUrlConverter&&On.push(...yield Promise.all(Kn)),[Pn,Ct(yield Oo(On,{requestInit:me.requestInit,fetchFunc:me.fetch,onProgress:me.onProgress}))]})()}}return re.URL_SCHEME_REGEX=/^https?:\/\//,re})();function Qi(re){return null!=re.match(ro.URL_SCHEME_REGEX)}const al=(re,xe)=>{if(typeof fetch>"u"&&(null==xe||null==xe.fetchFunc))return null;{let ee=!0;if(ee=Array.isArray(re)?re.every(me=>Qi(me)):Qi(re),ee)return fa(re,xe)}return null};function fa(re,xe){return new ro(re,xe)}function di(re,xe){return fa(re,xe)}or.registerSaveRouter(al),or.registerLoadRouter(al);class ma{constructor(xe){this.modelArtifacts=xe}load(){return this.modelArtifacts}}class mo{constructor(xe){this.saveHandler=xe}save(xe){return this.saveHandler(xe)}}class mi{constructor(xe){xe.load&&(this.load=()=>Promise.resolve(xe.load())),xe.save&&(this.save=ee=>Promise.resolve(xe.save(ee)))}}function ic(re,xe,ee,me){return new mi(Br(...arguments))}function Br(re,xe,ee,me){return 1===arguments.length?null!=re.modelTopology||null!=re.weightSpecs?new ma(re):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ma({modelTopology:re})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ma({modelTopology:re,weightSpecs:xe,weightData:ee,trainingConfig:me}))}function dr(re){return new mo(re)}function Xo(re){return new mo(re)}var go=h(58),ml=h(5069),Na=h(7395),En=h(2267),ki=h(3886);const ar=(0,En.op)({confusionMatrix_:function wr(re,xe,ee){const me=(0,go._1)(re,"labels","confusionMatrix"),Fe=(0,go._1)(xe,"predictions","confusionMatrix");De.hu(null==ee||ee>0&&Number.isInteger(ee),()=>`If provided, numClasses must be a positive integer, but got ${ee}`),De.hu(1===me.rank,()=>`Expected the rank of labels to be 1, but got ${me.rank}`),De.hu(1===Fe.rank,()=>`Expected the rank of predictions to be 1, but got ${Fe.rank}`),De.hu(me.shape[0]===Fe.shape[0],()=>`Mismatch in the number of examples: ${me.shape[0]} vs. ${Fe.shape[0]}. Labels and predictions should have the same number of elements.`),De.hu(ee>0&&Number.isInteger(ee),()=>`numClasses is required to be a positive integer, but got ${ee}`);const gt=(0,Na.l)((0,Ka.p)(me,"int32"),ee),At=(0,Na.l)((0,Ka.p)(Fe,"int32"),ee),zt=(0,ki.p)(gt),Pn=(0,ml.O)(zt,At);return(0,Ka.p)(Pn,"int32")}});var _o,mc,Ma=h(9741),gn=h(351),qr=h(6096),Wl=h(815);let Ro;function ll(re,xe=3){if(xe>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==re)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let ee=!1,me=!1,Fe=!1,gt=!1,At=!1,zt=!1;if(re.data instanceof Uint8Array)ee=!0;else if(typeof ImageData<"u"&&re instanceof ImageData)me=!0;else if(typeof HTMLVideoElement<"u"&&re instanceof HTMLVideoElement)Fe=!0;else if(typeof HTMLImageElement<"u"&&re instanceof HTMLImageElement)gt=!0;else if(null!=re.getContext)At=!0;else{if(!(typeof ImageBitmap<"u"&&re instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${re.constructor.name}`);zt=!0}if(null!=(0,qr.pI)(gn.eBW,D.BV.backendName))return D.BV.runKernel(gn.eBW,{pixels:re},{numChannels:xe});const[On,Kn]=Fe?[re.videoWidth,re.videoHeight]:[re.width,re.height];let Ln,An;if(At)Ln=re.getContext("2d").getImageData(0,0,On,Kn).data;else if(me||ee)Ln=re.data;else if(gt||Fe||zt){if(null==Ro)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Ro=new OffscreenCanvas(1,1).getContext("2d")}else Ro=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ro.canvas.width=On,Ro.canvas.height=Kn,Ro.drawImage(re,0,0,On,Kn),Ln=Ro.getImageData(0,0,On,Kn).data}if(4===xe)An=new Int32Array(Ln);else{const ir=On*Kn;An=new Int32Array(ir*xe);for(let Er=0;Er<ir;Er++)for(let gi=0;gi<xe;++gi)An[Er*xe+gi]=Ln[4*Er+gi]}return(0,Wl.w)(An,[Kn,On,xe],"int32")}function gl(re){return(_o=_o||(0,Oe.Z)(function*(xe,ee=3){let me=null;if((0,we.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function Ea(re){return function Ca(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(re instanceof ImageBitmap)&&function Pa(re){return null!=re&&0!==re.width&&0!==re.height}(re)&&!function Si(re){return null!=re&&re.data instanceof Uint8Array}(re)}(xe)){let Fe;try{Fe=yield createImageBitmap(xe,{premultiplyAlpha:"none"})}catch{Fe=null}me=null!=Fe&&Fe.width===xe.width&&Fe.height===xe.height?Fe:xe}else me=xe;return ll(me,ee)})).apply(this,arguments)}function _l(re,xe){return(mc=mc||(0,Oe.Z)(function*(ee,me){let Fe=(0,go._1)(ee,"img","toPixels");if(!(ee instanceof Yi.es)){const Ln=Fe;Fe=(0,Ka.p)(Ln,"int32"),Ln.dispose()}if(2!==Fe.rank&&3!==Fe.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${Fe.rank}.`);const[gt,At]=Fe.shape.slice(0,2),zt=2===Fe.rank?1:Fe.shape[2];if(zt>4||2===zt)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${zt}`);if("float32"!==Fe.dtype&&"int32"!==Fe.dtype)throw new Error(`Unsupported type for toPixels: ${Fe.dtype}. Please use float32 or int32 tensors.`);const Pn=yield Fe.data(),On="float32"===Fe.dtype?255:1,Kn=new Uint8ClampedArray(At*gt*4);for(let Ln=0;Ln<gt*At;++Ln){const An=[0,0,0,255];for(let ir=0;ir<zt;ir++){const Er=Pn[Ln*zt+ir];if("float32"===Fe.dtype){if(Er<0||Er>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Er}.`)}else if("int32"===Fe.dtype&&(Er<0||Er>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Er}.`);1===zt?(An[0]=Er*On,An[1]=Er*On,An[2]=Er*On):An[ir]=Er*On}const vs=4*Ln;Kn[vs+0]=Math.round(An[0]),Kn[vs+1]=Math.round(An[1]),Kn[vs+2]=Math.round(An[2]),Kn[vs+3]=Math.round(An[3])}if(null!=me){me.width=At,me.height=gt;const Ln=me.getContext("2d"),An=new ImageData(Kn,At,gt);Ln.putImageData(An,0,0)}return Fe!==ee&&Fe.dispose(),Kn})).apply(this,arguments)}const q=(0,En.op)({fromPixels_:ll});function L(re,xe){const ee=re.shape.length,me=xe.shape.length;if(ee<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${ee}.`);if(me<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${me}.`);if("int32"!==xe.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${xe.dtype}.`);if(xe.shape[me-1]>ee)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${xe.shape[me-1]} vs. ${ee}`);if(0===(0,De.NA)(re.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${re.shape}.`);const Fe=xe.shape,gt=Fe[Fe.length-1];let At=1;for(let Ln=0;Ln<Fe.length-1;++Ln)At*=Fe[Ln];const zt=re.shape,Pn=Fe.slice();Pn.pop();let On=1;for(let Ln=gt;Ln<ee;++Ln)On*=zt[Ln],Pn.push(zt[Ln]);const Kn=[...(0,De.e3)(re.shape).map(Ln=>Ln/On),1].slice(0,gt);return[Pn,At,On,Kn]}var X=h(374);const Ae=-2,He=-1;function Ye(re,xe,ee){const me=re.shape.length;De.hu(me===xe.length,()=>`Error in slice${me}D: Length of begin ${xe} must match the rank of the array (${me}).`),De.hu(me===ee.length,()=>`Error in slice${me}D: Length of size ${ee} must match the rank of the array (${me}).`);for(let Fe=0;Fe<me;++Fe)De.hu(xe[Fe]+ee[Fe]<=re.shape[Fe],()=>`Error in slice${me}D: begin[${Fe}] + size[${Fe}] (${xe[Fe]+ee[Fe]}) would overflow input.shape[${Fe}] (${re.shape[Fe]})`)}function it(re){const xe=[];let ee=0;for(;re>0;)1&re&&xe.push(ee),re/=2,ee++;return xe}function _t(re,xe,ee){const me=[];for(let Fe=0;Fe<re.length;Fe++)me[Fe]=Math.ceil((xe[Fe]-re[Fe])/ee[Fe]);return me}function wt(re,xe,ee,me){const Fe=[...re];for(let gt=Fe.length;gt<me.length;gt++)Fe.push(1);for(let gt=0;gt<ee;gt++)0===gt?Fe[xe]=1:(Fe.splice(xe,0,1),Fe.pop());return Fe}function kn(re,xe,ee){return ee<=re?ee:ee-(xe-1)}function pn(re,xe){const ee=[];for(let me=0;me<re;me++)ee.push(xe+me);return ee}function qn(re,xe,ee,me,Fe,gt,At,zt,Pn){const On=re.length;let Kn=new Array(On),Ln=new Array(On),An=new Array(On);if(xe.length&&ee>0){const vs=xe[0],ir=ee+1;Kn=os(At,vs,ir,me,re),Ln=Ms(zt,vs,ir,Fe,re),An=wt(gt,vs,ir,re)}else for(let vs=0;vs<On;vs++)Kn[vs]=Cr(At,me,gt,re,vs,Pn),Ln[vs]=Is(zt,Fe,gt,re,vs,Pn),An[vs]=Tr(gt,vs,Pn);return{begin:Kn,end:Ln,strides:An}}function os(re,xe,ee,me,Fe){const gt=[...Fe],At=pn(ee,xe);for(let zt=0;zt<gt.length;zt++)if(At.indexOf(zt)>-1)gt[zt]=0;else{const Pn=kn(xe,ee,zt);let On=me[Pn];re&1<<Pn&&(On=0),gt[zt]=On}return gt}function Ms(re,xe,ee,me,Fe){const gt=[...Fe],At=pn(ee,xe);for(let zt=0;zt<gt.length;zt++)if(At.indexOf(zt)>-1)gt[zt]=Number.MAX_SAFE_INTEGER;else{const Pn=kn(xe,ee,zt);let On=me[Pn];re&1<<Pn&&(On=Number.MAX_SAFE_INTEGER),gt[zt]=On}for(let zt=0;zt<gt.length;zt++)gt[zt]<0&&(gt[zt]+=Fe[zt]),gt[zt]=De.uZ(0,gt[zt],Fe[zt]);return gt}function Tr(re,xe,ee){let me=re[xe];return(ee&1<<xe||null==me)&&(me=1),me}function Cr(re,xe,ee,me,Fe,gt){let At=xe[Fe];(re&1<<Fe||gt&1<<Fe||null==At)&&(At=(ee[Fe]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const Pn=me[Fe];return At<0&&(At+=Pn),At=De.uZ(0,At,Pn-1),At}function Is(re,xe,ee,me,Fe,gt){let At=xe[Fe];const zt=ee[Fe]||1;(re&1<<Fe||gt&1<<Fe||null==At)&&(At=zt>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const Pn=me[Fe];return At<0&&(At+=Pn),At=zt>0?De.uZ(0,At,Pn):De.uZ(-1,At,Pn-1),At}function lr(re,xe,ee){let me=ee.length;for(let Fe=0;Fe<ee.length;Fe++)if(ee[Fe]>1){me=Fe;break}for(let Fe=me+1;Fe<ee.length;Fe++)if(xe[Fe]>0||ee[Fe]!==re[Fe])return!1;return!0}function yo(re,xe){let ee=re.length>0?re[re.length-1]:1;for(let me=0;me<re.length-1;me++)ee+=re[me]*xe[me];return ee}function Da(re,xe,ee){let me;const Fe=re.shape.length;let gt;return me="number"==typeof xe?[xe,...new Array(Fe-1).fill(0)]:xe.length<Fe?xe.concat(new Array(Fe-xe.length).fill(0)):xe.slice(),me.forEach(At=>{De.hu(-1!==At,()=>"slice() does not support negative begin indexing.")}),gt=null==ee?new Array(Fe).fill(-1):"number"==typeof ee?[ee,...new Array(Fe-1).fill(-1)]:ee.length<Fe?ee.concat(new Array(Fe-ee.length).fill(-1)):ee,gt=gt.map((At,zt)=>At>=0?At:(De.hu(-1===At,()=>`Negative size values should be exactly -1 but got ${At} for the slice() size at index ${zt}.`),re.shape[zt]-me[zt])),[me,gt]}function Jt(re,xe,ee,me,Fe,gt,At,zt,Pn){let On;if(null==me?(On=new Array(xe.length),On.fill(1)):On=me,null!=At&&At&At-1)throw new Error("Multiple ellipses in slice is not allowed.");let Kn=!1;const Ln={dims:On.length,numAddAxisAfterEllipsis:0,begin:xe.slice(),end:ee.slice(),strides:On.slice(),beginMask:Fe,endMask:gt,ellipsisMask:At,newAxisMask:zt,shrinkAxisMask:Pn};for(let Nr=0;Nr<Ln.dims;Nr++)Kn&&1<<Nr&zt&&Ln.numAddAxisAfterEllipsis++,1<<Nr&At&&(Kn=!0);Kn||(Ln.ellipsisMask|=1<<Ln.dims,Ln.dims++);const An={dims:re.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function ai(re,xe){xe.beginMask=0,xe.endMask=0,xe.shrinkAxisMask=0;let ee=0;xe.beginValid=null!=re.begin,xe.endValid=null!=re.end,xe.begin=new Array(xe.dims),xe.end=new Array(xe.dims),xe.strides=new Array(xe.dims),xe.finalShapeGatherIndices=[],xe.finalShapeGatherIndicesSparse=[],xe.inputShapeGatherIndicesSparse=new Array(xe.dims);for(let me=0;me<re.dims;me++)if(1<<me&re.ellipsisMask){const Fe=Math.min(xe.dims-(re.dims-me)+1+re.numAddAxisAfterEllipsis,xe.dims);for(;ee<Fe;ee++)xe.begin[ee]=0,xe.end[ee]=0,xe.strides[ee]=1,xe.beginMask|=1<<ee,xe.endMask|=1<<ee,xe.finalShapeGatherIndices.push(ee),xe.finalShapeGatherIndicesSparse.push(-1),xe.inputShapeGatherIndicesSparse[ee]=me}else if(1<<me&re.newAxisMask)xe.finalShapeGatherIndices.push(Ae),xe.finalShapeGatherIndicesSparse.push(-1);else{if(ee===xe.begin.length)throw Error(`Index out of range using input dim ${ee}; input has only ${xe.dims} dims, ${xe.begin.length}.`);null!=re.begin&&(xe.begin[ee]=re.begin[me]),null!=re.end&&(xe.end[ee]=re.end[me]),xe.strides[ee]=re.strides[me],re.beginMask&1<<me&&(xe.beginMask|=1<<ee),re.endMask&1<<me&&(xe.endMask|=1<<ee),re.shrinkAxisMask&1<<me?(xe.finalShapeGatherIndices.push(He),xe.finalShapeGatherIndicesSparse.push(-1),xe.shrinkAxisMask|=1<<ee):(xe.finalShapeGatherIndices.push(ee),xe.finalShapeGatherIndicesSparse.push(me)),xe.inputShapeGatherIndicesSparse[ee]=me,ee++}}(Ln,An);let vs=!0,ir=!0,Er=!0;const gi=[],So=[];for(let Nr=0;Nr<re.length;++Nr){if(0===An.strides[Nr])throw Error(`strides[${Nr}] must be non-zero`);const Qo=!!(An.shrinkAxisMask&1<<Nr),Ci=re[Nr];if(-1===Ci){gi.push(Qo?1:-1);continue}const Rl=[An.beginMask&1<<Nr,An.endMask&1<<Nr],cl=[An.strides[Nr]>0?0:-1,An.strides[Nr]>0?Ci:Ci-1];if(Qo&&An.strides[Nr]<=0)throw Error("only stride 1 allowed on non-range indexing.");Er=Er&&1===An.strides[Nr];const id=!!(An.beginMask&1<<Nr&&An.endMask&1<<Nr);if(An.beginValid&&An.endValid){if(Qo){const Mh=An.begin[Nr]<0?Ci+An.begin[Nr]:An.begin[Nr];if(An.begin[Nr]=Mh,An.end[Nr]=An.begin[Nr]+1,Mh<0||Mh>=Ci)throw Error(`slice index ${An.begin[Nr]} of dimension ${Nr} out of bounds.`)}else An.begin[Nr]=oc(An.begin[Nr],0,An.strides[Nr],Ci,Rl,cl),An.end[Nr]=oc(An.end[Nr],1,An.strides[Nr],Ci,Rl,cl);const $c=1===An.strides[Nr]&&0===An.begin[Nr]&&An.end[Nr]===Ci;vs=vs&&$c,ir=ir&&(0===Nr&&1===An.strides[Nr]||$c)}else vs=vs&&1===An.strides[Nr]&&id,ir=ir&&(0===Nr&&1===An.strides[Nr]||id);let Dc,Ud=!1;if(An.beginValid&&An.endValid?(Dc=An.end[Nr]-An.begin[Nr],Ud=!0):Qo?(Dc=1,Ud=!0):id&&Ci>=0&&(Dc=An.strides[Nr]<0?-Ci:Ci,Ud=!0),Ud){let $c;$c=0===Dc||Dc<0!=An.strides[Nr]<0?0:Math.trunc(Dc/An.strides[Nr])+(Dc%An.strides[Nr]!=0?1:0),gi.push($c)}else gi.push(-1)}for(let Nr=0;Nr<An.finalShapeGatherIndices.length;++Nr){const Qo=An.finalShapeGatherIndices[Nr];Qo>=0?So.push(gi[Qo]):Qo===Ae&&So.push(1)}return{finalShapeSparse:So.filter((Nr,Qo)=>An.finalShapeGatherIndices[Qo]!==Ae),finalShape:So,isIdentity:vs,sliceDim0:ir,isSimpleSlice:Er,begin:An.begin,end:An.end,strides:An.strides}}function oc(re,xe,ee,me,Fe,gt){if(Fe[xe])return ee>0?gt[xe]:gt[xe+1&1];{const At=re<0?me+re:re;return At<gt[0]?gt[0]:At>gt[1]?gt[1]:At}}class wo{getClassName(){return this.constructor.className}static fromConfig(xe,ee){return new xe(ee)}}class Fa{constructor(){this.classNameMap={}}static getMap(){return null==Fa.instance&&(Fa.instance=new Fa),Fa.instance}static register(xe){Fa.getMap().classNameMap[xe.className]=[xe,xe.fromConfig]}}function yl(re){(0,De.hu)(null!=re.className,()=>"Class being registered does not have the static className property defined."),(0,De.hu)("string"==typeof re.className,()=>"className is required to be a string, but got type "+typeof re.className),(0,De.hu)(re.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Fa.register(re)}var Wu,Fi=h(1931),Yc=h(2775);const vl=.001,Hl=.1;function Zc(re,xe,ee){return null==ee&&(ee=Oc()),Fc(re,xe,(me,Fe)=>B(me,Fe,ee))}function Oc(){return 32===D.BV.backend.floatPrecision()?vl:Hl}function Fc(re,xe,ee){let me=!0;if(((0,De.fU)(re)||(0,De.fU)(xe))&&(me=!1),(0,De.fU)(re)&&(0,De.fU)(xe)&&(me=!0),me){const At=re.constructor.name,zt=xe.constructor.name;if(At!==zt)throw new Error(`Arrays are of different type. Actual: ${At}. Expected: ${zt}`)}if(Array.isArray(re)&&Array.isArray(xe)){const At=(0,go.C)(re),zt=(0,go.C)(xe);if(!(0,De.cO)(At,zt))throw new Error(`Arrays have different shapes. Actual: [${At}]. Expected: [${zt}]`)}const Fe=(0,De.fU)(re)?re:(0,De.xH)(re),gt=(0,De.fU)(xe)?xe:(0,De.xH)(xe);if(Fe.length!==gt.length)throw new Error(`Arrays have different lengths actual: ${Fe.length} vs expected: ${gt.length}.\nActual:   ${Fe}.\nExpected: ${gt}.`);for(let At=0;At<gt.length;++At){const zt=Fe[At],Pn=gt[At];if(!ee(zt,Pn))throw new Error(`Arrays differ: actual[${At}] = ${zt}, expected[${At}] = ${Pn}.\nActual:   ${Fe}.\nExpected: ${gt}.`)}typeof expect<"u"&&expect().nothing()}function Qc(re,xe){re().then(()=>xe.fail(),()=>xe()),typeof expect<"u"&&expect().nothing()}function Ai(re,xe){const ee="string"==typeof xe||"number"==typeof xe||"boolean"==typeof xe?[xe]:xe;return(0,De.HD)(re)||(0,De.HD)(re[0])||(0,De.HD)(xe)||(0,De.HD)(xe[0])?Fc(re,ee,(me,Fe)=>me==Fe):Fc(re,xe,(me,Fe)=>B(me,Fe,0))}function Iu(re,xe,ee){if(null==ee&&(ee=Oc()),!B(re,xe,ee))throw new Error(`Numbers differ: actual === ${re}, expected === ${xe}`);typeof expect<"u"&&expect().nothing()}function B(re,xe,ee){return!isFinite(re)&&!isFinite(xe)||!(isNaN(re)||isNaN(xe)||Math.abs(re-xe)>ee)}function ve(re,xe,ee){for(let me=0;me<re.length;me++)if(re[me]<xe||re[me]>ee)throw new Error(`Value out of range:${re[me]} low: ${xe}, high: ${ee}`)}function Be(re,xe){const ee=new Float32Array(re),me=new Float32Array(xe);if(ee.length!==me.length)throw new Error(`Expected ArrayBuffer to be of length ${me.length}, but it was ${ee.length}`);for(let Fe=0;Fe<me.length;Fe++)if(ee[Fe]!==me[Fe])throw new Error(`Expected ArrayBuffer value at ${Fe} to be ${me[Fe]} but got ${ee[Fe]} instead`)}function ot(re){for(let xe=0;xe<re.length;xe++){const ee=re[xe];Array.isArray(ee)?ot(ee):re[xe]=(0,Yc.encodeString)(ee)}return re}function st(re){const xe=document.createElement("video");return"playsInline"in xe&&(xe.playsInline=!0),xe.muted=!0,xe.loop=!0,xe.style.position="fixed",xe.style.left="0px",xe.style.top="0px",xe.preload="auto",xe.appendChild(re),new Promise(ee=>{xe.addEventListener("loadeddata",me=>ee(xe)),xe.load()})}function Xt(re){return(Wu=Wu||(0,Oe.Z)(function*(xe){yield xe.play(),"requestVideoFrameCallback"in xe&&(yield new Promise(ee=>{xe.requestVideoFrameCallback(ee)}))})).apply(this,arguments)}const jt="3.21.0";var Yt=h(1633),xn=h(2923),ss=h(9526),Jn=h(6008),_r=h(9949),Qs=h(1616),As=h(7804),cn=h(6541),Zr=h(9418);class jn extends wo{minimize(xe,ee=!1,me){const{value:Fe,grads:gt}=this.computeGradients(xe,me);if(null!=me){const At=me.map(zt=>({name:zt.name,tensor:gt[zt.name]}));this.applyGradients(At)}else this.applyGradients(gt);return(0,Yt.B9)(gt),ee?Fe:(Fe.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(xe,ee){return(0,cn.pn)(xe,ee)}dispose(){null!=this.iterations_&&(0,Yt.B9)(this.iterations_)}saveIterations(){var xe=this;return(0,Oe.Z)(function*(){return null==xe.iterations_&&(xe.iterations_=0),{name:"iter",tensor:(0,Zr.i)(xe.iterations_,"int32")}})()}getWeights(){return(0,Oe.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(xe){var ee=this;return(0,Oe.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${ee.getClassName()}`)})()}extractIterations(xe){var ee=this;return(0,Oe.Z)(function*(){return ee.iterations_=(yield xe[0].tensor.data())[0],xe.slice(1)})()}}Object.defineProperty(jn,Symbol.hasInstance,{value:re=>null!=re.minimize&&null!=re.computeGradients&&null!=re.applyGradients});let Oi=(()=>{class re extends jn{constructor(ee,me,Fe=null){super(),this.learningRate=ee,this.rho=me,this.epsilon=Fe,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==Fe&&(this.epsilon=D.BV.backend.epsilon())}applyGradients(ee){(Array.isArray(ee)?ee.map(Fe=>Fe.name):Object.keys(ee)).forEach((Fe,gt)=>{const At=D.BV.registeredVariables[Fe];null==this.accumulatedGrads[gt]&&(this.accumulatedGrads[gt]={originalName:`${Fe}/accum_grad`,variable:(0,Yt.lu)(()=>(0,As.P)(At).variable(!1))}),null==this.accumulatedUpdates[gt]&&(this.accumulatedUpdates[gt]={originalName:`${Fe}/accum_var`,variable:(0,Yt.lu)(()=>(0,As.P)(At).variable(!1))});const Pn=Array.isArray(ee)?ee[gt].tensor:ee[Fe];if(null==Pn)return;const On=this.accumulatedGrads[gt].variable,Kn=this.accumulatedUpdates[gt].variable;(0,Yt.lu)(()=>{const Ln=(0,xn.I)((0,Jn.d)(On,this.rho),(0,Jn.d)((0,Qs.h)(Pn),1-this.rho)),An=(0,Jn.d)((0,ss.h)((0,_r._)((0,xn.I)(Kn,this.epsilon)),(0,_r._)((0,xn.I)(On,this.epsilon))),Pn),vs=(0,xn.I)((0,Jn.d)(Kn,this.rho),(0,Jn.d)((0,Qs.h)(An),1-this.rho));On.assign(Ln),Kn.assign(vs);const ir=(0,xn.I)((0,Jn.d)(An,-this.learningRate),At);At.assign(ir)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,Yt.B9)(this.accumulatedGrads.map(ee=>ee.variable)),(0,Yt.B9)(this.accumulatedUpdates.map(ee=>ee.variable)))}getWeights(){var ee=this;return(0,Oe.Z)(function*(){const me=[...ee.accumulatedGrads,...ee.accumulatedUpdates];return[yield ee.saveIterations()].concat(me.map(Fe=>({name:Fe.originalName,tensor:Fe.variable})))})()}setWeights(ee){var me=this;return(0,Oe.Z)(function*(){const Fe=(ee=yield me.extractIterations(ee)).length/2;me.accumulatedGrads=ee.slice(0,Fe).map(At=>({originalName:At.name,variable:At.tensor.variable(!1)})),me.accumulatedUpdates=ee.slice(Fe,2*Fe).map(At=>({originalName:At.name,variable:At.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(ee,me){return new ee(me.learningRate,me.rho,me.epsilon)}}return re.className="Adadelta",re})();yl(Oi);var ca=h(3541);let Yo=(()=>{class re extends jn{constructor(ee,me=.1){super(),this.learningRate=ee,this.initialAccumulatorValue=me,this.accumulatedGrads=[]}applyGradients(ee){(Array.isArray(ee)?ee.map(Fe=>Fe.name):Object.keys(ee)).forEach((Fe,gt)=>{const At=D.BV.registeredVariables[Fe];null==this.accumulatedGrads[gt]&&(this.accumulatedGrads[gt]={originalName:`${Fe}/accumulator`,variable:(0,Yt.lu)(()=>(0,ca.h)(At.shape,this.initialAccumulatorValue).variable(!1))});const zt=Array.isArray(ee)?ee[gt].tensor:ee[Fe];if(null==zt)return;const Pn=this.accumulatedGrads[gt].variable;(0,Yt.lu)(()=>{const On=(0,xn.I)(Pn,(0,Qs.h)(zt));Pn.assign(On);const Kn=(0,xn.I)((0,Jn.d)((0,ss.h)(zt,(0,_r._)((0,xn.I)(On,D.BV.backend.epsilon()))),-this.learningRate),At);At.assign(Kn)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,Yt.B9)(this.accumulatedGrads.map(ee=>ee.variable))}getWeights(){var ee=this;return(0,Oe.Z)(function*(){return[yield ee.saveIterations()].concat(ee.accumulatedGrads.map(me=>({name:me.originalName,tensor:me.variable})))})()}setWeights(ee){var me=this;return(0,Oe.Z)(function*(){ee=yield me.extractIterations(ee),me.accumulatedGrads=ee.map(gt=>({originalName:gt.name,variable:gt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(ee,me){return new ee(me.learningRate,me.initialAccumulatorValue)}}return re.className="Adagrad",re})();yl(Yo);var La=h(1712),hi=h(8837);let ci=(()=>{class re extends jn{constructor(ee,me,Fe,gt=null){super(),this.learningRate=ee,this.beta1=me,this.beta2=Fe,this.epsilon=gt,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,Yt.lu)(()=>{this.accBeta1=(0,Zr.i)(me).variable(),this.accBeta2=(0,Zr.i)(Fe).variable()}),null==gt&&(this.epsilon=D.BV.backend.epsilon())}applyGradients(ee){const me=Array.isArray(ee)?ee.map(Fe=>Fe.name):Object.keys(ee);(0,Yt.lu)(()=>{const Fe=(0,hi.l)(1,this.accBeta1),gt=(0,hi.l)(1,this.accBeta2);me.forEach((At,zt)=>{const Pn=D.BV.registeredVariables[At];null==this.accumulatedFirstMoment[zt]&&(this.accumulatedFirstMoment[zt]={originalName:`${At}/m`,variable:(0,Yt.lu)(()=>(0,As.P)(Pn).variable(!1))}),null==this.accumulatedSecondMoment[zt]&&(this.accumulatedSecondMoment[zt]={originalName:`${At}/v`,variable:(0,Yt.lu)(()=>(0,As.P)(Pn).variable(!1))});const Kn=Array.isArray(ee)?ee[zt].tensor:ee[At];if(null==Kn)return;const Ln=this.accumulatedFirstMoment[zt].variable,An=this.accumulatedSecondMoment[zt].variable,vs=(0,xn.I)((0,Jn.d)(Ln,this.beta1),(0,Jn.d)(Kn,1-this.beta1)),ir=(0,xn.I)((0,Jn.d)(An,this.beta2),(0,Jn.d)((0,Qs.h)(Kn),1-this.beta2)),Er=(0,ss.h)(vs,Fe),gi=(0,ss.h)(ir,gt);Ln.assign(vs),An.assign(ir);const So=(0,xn.I)((0,Jn.d)((0,ss.h)(Er,(0,xn.I)((0,_r._)(gi),this.epsilon)),-this.learningRate),Pn);Pn.assign(So)}),this.accBeta1.assign((0,Jn.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,Jn.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,Yt.B9)(this.accumulatedFirstMoment.map(ee=>ee.variable)),null!=this.accumulatedSecondMoment&&(0,Yt.B9)(this.accumulatedSecondMoment.map(ee=>ee.variable))}getWeights(){var ee=this;return(0,Oe.Z)(function*(){const me=[...ee.accumulatedFirstMoment,...ee.accumulatedSecondMoment];return[yield ee.saveIterations()].concat(me.map(Fe=>({name:Fe.originalName,tensor:Fe.variable})))})()}setWeights(ee){var me=this;return(0,Oe.Z)(function*(){ee=yield me.extractIterations(ee),(0,Yt.lu)(()=>{me.accBeta1.assign((0,La.s)(me.beta1,me.iterations_+1)),me.accBeta2.assign((0,La.s)(me.beta2,me.iterations_+1))});const Fe=ee.length/2;me.accumulatedFirstMoment=ee.slice(0,Fe).map(At=>({originalName:At.name,variable:At.tensor.variable(!1)})),me.accumulatedSecondMoment=ee.slice(Fe,2*Fe).map(At=>({originalName:At.name,variable:At.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(ee,me){return new ee(me.learningRate,me.beta1,me.beta2,me.epsilon)}}return re.className="Adam",re})();yl(ci);var qt=h(1634),jl=h(685);let oo=(()=>{class re extends jn{constructor(ee,me,Fe,gt=null,At=0){super(),this.learningRate=ee,this.beta1=me,this.beta2=Fe,this.epsilon=gt,this.decay=At,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,Yt.lu)(()=>{this.iteration=(0,Zr.i)(0).variable(),this.accBeta1=(0,Zr.i)(me).variable()}),null==gt&&(this.epsilon=D.BV.backend.epsilon())}applyGradients(ee){const me=Array.isArray(ee)?ee.map(Fe=>Fe.name):Object.keys(ee);(0,Yt.lu)(()=>{const Fe=(0,hi.l)(1,this.accBeta1),gt=(0,ss.h)(-this.learningRate,(0,xn.I)((0,Jn.d)(this.iteration,this.decay),1));me.forEach((At,zt)=>{const Pn=D.BV.registeredVariables[At];null==this.accumulatedFirstMoment[zt]&&(this.accumulatedFirstMoment[zt]={originalName:`${At}/m`,variable:(0,As.P)(Pn).variable(!1)}),null==this.accumulatedWeightedInfNorm[zt]&&(this.accumulatedWeightedInfNorm[zt]={originalName:`${At}/v`,variable:(0,As.P)(Pn).variable(!1)});const Kn=Array.isArray(ee)?ee[zt].tensor:ee[At];if(null==Kn)return;const Ln=this.accumulatedFirstMoment[zt].variable,An=this.accumulatedWeightedInfNorm[zt].variable,vs=(0,xn.I)((0,Jn.d)(Ln,this.beta1),(0,Jn.d)(Kn,1-this.beta1)),ir=(0,Jn.d)(An,this.beta2),Er=(0,qt.W)(Kn),gi=(0,jl.g)(ir,Er);Ln.assign(vs),An.assign(gi);const So=(0,xn.I)((0,Jn.d)((0,ss.h)(gt,Fe),(0,ss.h)(vs,(0,xn.I)(gi,this.epsilon))),Pn);Pn.assign(So)}),this.iteration.assign((0,xn.I)(this.iteration,1)),this.accBeta1.assign((0,Jn.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,Yt.B9)(this.accumulatedFirstMoment.map(ee=>ee.variable)),null!=this.accumulatedWeightedInfNorm&&(0,Yt.B9)(this.accumulatedWeightedInfNorm.map(ee=>ee.variable))}getWeights(){return(0,Oe.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(ee){return(0,Oe.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(ee,me){return new ee(me.learningRate,me.beta1,me.beta2,me.epsilon,me.decay)}}return re.className="Adamax",re})();yl(oo);let Bo=(()=>{class re extends jn{constructor(ee){super(),this.learningRate=ee,this.setLearningRate(ee)}applyGradients(ee){(Array.isArray(ee)?ee.map(Fe=>Fe.name):Object.keys(ee)).forEach((Fe,gt)=>{const At=Array.isArray(ee)?ee[gt].tensor:ee[Fe];if(null==At)return;const zt=D.BV.registeredVariables[Fe];(0,Yt.lu)(()=>{const Pn=(0,xn.I)((0,Jn.d)(this.c,At),zt);zt.assign(Pn)})}),this.incrementIterations()}setLearningRate(ee){this.learningRate=ee,null!=this.c&&this.c.dispose(),this.c=(0,Yt.Cn)((0,Zr.i)(-ee))}dispose(){this.c.dispose()}getWeights(){var ee=this;return(0,Oe.Z)(function*(){return[yield ee.saveIterations()]})()}setWeights(ee){var me=this;return(0,Oe.Z)(function*(){if(0!==(ee=yield me.extractIterations(ee)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(ee,me){return new ee(me.learningRate)}}return re.className="SGD",re})();yl(Bo);let wi=(()=>{class re extends Bo{constructor(ee,me,Fe=!1){super(ee),this.learningRate=ee,this.momentum=me,this.useNesterov=Fe,this.accumulations=[],this.m=(0,Zr.i)(this.momentum)}applyGradients(ee){(Array.isArray(ee)?ee.map(Fe=>Fe.name):Object.keys(ee)).forEach((Fe,gt)=>{const At=D.BV.registeredVariables[Fe];null==this.accumulations[gt]&&(this.accumulations[gt]={originalName:`${Fe}/momentum`,variable:(0,Yt.lu)(()=>(0,As.P)(At).variable(!1))});const zt=this.accumulations[gt].variable,Pn=Array.isArray(ee)?ee[gt].tensor:ee[Fe];null!=Pn&&(0,Yt.lu)(()=>{let On;const Kn=(0,xn.I)((0,Jn.d)(this.m,zt),Pn);On=(0,xn.I)((0,Jn.d)(this.c,this.useNesterov?(0,xn.I)(Pn,(0,Jn.d)(Kn,this.m)):Kn),At),zt.assign(Kn),At.assign(On)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,Yt.B9)(this.accumulations.map(ee=>ee.variable))}setMomentum(ee){this.momentum=ee}getWeights(){var ee=this;return(0,Oe.Z)(function*(){return[yield ee.saveIterations()].concat(ee.accumulations.map(me=>({name:me.originalName,tensor:me.variable})))})()}setWeights(ee){var me=this;return(0,Oe.Z)(function*(){ee=yield me.extractIterations(ee),me.accumulations=ee.map(gt=>({originalName:gt.name,variable:gt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(ee,me){return new ee(me.learningRate,me.momentum,me.useNesterov)}}return re.className="Momentum",re})();yl(wi);let $a=(()=>{class re extends jn{constructor(ee,me=.9,Fe=0,gt=null,At=!1){if(super(),this.learningRate=ee,this.decay=me,this.momentum=Fe,this.epsilon=gt,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=At,null==gt&&(this.epsilon=D.BV.backend.epsilon()),null==ee)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(ee){(Array.isArray(ee)?ee.map(Fe=>Fe.name):Object.keys(ee)).forEach((Fe,gt)=>{const At=D.BV.registeredVariables[Fe];null==this.accumulatedMeanSquares[gt]&&(this.accumulatedMeanSquares[gt]={originalName:`${Fe}/rms`,variable:(0,Yt.lu)(()=>(0,As.P)(At).variable(!1))}),null==this.accumulatedMoments[gt]&&(this.accumulatedMoments[gt]={originalName:`${Fe}/momentum`,variable:(0,Yt.lu)(()=>(0,As.P)(At).variable(!1))}),null==this.accumulatedMeanGrads[gt]&&this.centered&&(this.accumulatedMeanGrads[gt]={originalName:`${Fe}/mg`,variable:(0,Yt.lu)(()=>(0,As.P)(At).variable(!1))});const Pn=Array.isArray(ee)?ee[gt].tensor:ee[Fe];if(null==Pn)return;const On=this.accumulatedMeanSquares[gt].variable,Kn=this.accumulatedMoments[gt].variable;(0,Yt.lu)(()=>{const Ln=(0,xn.I)((0,Jn.d)(On,this.decay),(0,Jn.d)((0,Qs.h)(Pn),1-this.decay));if(this.centered){const An=this.accumulatedMeanGrads[gt].variable,vs=(0,xn.I)((0,Jn.d)(An,this.decay),(0,Jn.d)(Pn,1-this.decay)),ir=(0,ss.h)((0,Jn.d)(Pn,this.learningRate),(0,_r._)((0,hi.l)(Ln,(0,xn.I)((0,Qs.h)(vs),this.epsilon)))),Er=(0,xn.I)((0,Jn.d)(Kn,this.momentum),ir);On.assign(Ln),An.assign(vs),Kn.assign(Er);const gi=(0,hi.l)(At,Er);At.assign(gi)}else{const An=(0,xn.I)((0,Jn.d)(On,this.decay),(0,Jn.d)((0,Qs.h)(Pn),1-this.decay)),vs=(0,xn.I)((0,Jn.d)(Kn,this.momentum),(0,ss.h)((0,Jn.d)(Pn,this.learningRate),(0,_r._)((0,xn.I)(An,this.epsilon))));On.assign(An),Kn.assign(vs);const ir=(0,hi.l)(At,vs);At.assign(ir)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,Yt.B9)(this.accumulatedMeanSquares.map(ee=>ee.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,Yt.B9)(this.accumulatedMeanGrads.map(ee=>ee.variable)),null!=this.accumulatedMoments&&(0,Yt.B9)(this.accumulatedMoments.map(ee=>ee.variable))}getWeights(){var ee=this;return(0,Oe.Z)(function*(){const me=[...ee.accumulatedMeanSquares,...ee.accumulatedMoments];return ee.centered&&me.push(...ee.accumulatedMeanGrads),[yield ee.saveIterations()].concat(me.map(Fe=>({name:Fe.originalName,tensor:Fe.variable})))})()}setWeights(ee){var me=this;return(0,Oe.Z)(function*(){ee=yield me.extractIterations(ee);const Fe=me.centered?ee.length/3:ee.length/2;me.accumulatedMeanSquares=ee.slice(0,Fe).map(At=>({originalName:At.name,variable:At.tensor.variable(!1)})),me.accumulatedMoments=ee.slice(Fe,2*Fe).map(At=>({originalName:At.name,variable:At.tensor.variable(!1)})),me.centered&&(me.accumulatedMeanGrads=ee.slice(2*Fe,3*Fe).map(At=>({originalName:At.name,variable:At.tensor.variable(!1)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(ee,me){return new ee(me.learningRate,me.decay,me.momentum,me.epsilon,me.centered)}}return re.className="RMSProp",re})();yl($a);class Gi{static sgd(xe){return new Bo(xe)}static momentum(xe,ee,me=!1){return new wi(xe,ee,me)}static rmsprop(xe,ee=.9,me=0,Fe=null,gt=!1){return new $a(xe,ee,me,Fe,gt)}static adam(xe=.001,ee=.9,me=.999,Fe=null){return new ci(xe,ee,me,Fe)}static adadelta(xe=.001,ee=.95,me=null){return new Oi(xe,ee,me)}static adamax(xe=.002,ee=.9,me=.999,Fe=null,gt=0){return new oo(xe,ee,me,Fe,gt)}static adagrad(xe,ee=.1){return new Yo(xe,ee)}}var uu=h(4207),an=h(2497),kl=h(2065);const Gl={sgd:Gi.sgd,momentum:Gi.momentum,adadelta:Gi.adadelta,adagrad:Gi.adagrad,rmsprop:Gi.rmsprop,adamax:Gi.adamax,adam:Gi.adam},Tu=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:re=>re();function sd(){return new Promise(re=>Tu(()=>re()))}var gc=h(4588);function rd(re,xe){const ee=re[0].length;re.forEach((Fe,gt)=>{De.hu(Fe.length===ee,()=>`Error in concat${ee}D: rank of tensors[${gt}] must be the same as the rank of the rest (${ee})`)}),De.hu(xe>=0&&xe<ee,()=>`Error in concat${ee}D: axis must be between 0 and ${ee-1}.`);const me=re[0];re.forEach((Fe,gt)=>{for(let At=0;At<ee;At++)De.hu(At===xe||Fe[At]===me[At],()=>`Error in concat${ee}D: Shape of tensors[${gt}] (${Fe}) does not match the shape of the rest (${me}) along the non-concatenated axis ${gt}.`)})}function Au(re,xe){const ee=re[0].slice();for(let me=1;me<re.length;me++)ee[xe]+=re[me][xe];return ee}var V=h(9992),O=h(9251),z=function(re){return re[re.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",re[re.VALUE_ROWIDS=1]="VALUE_ROWIDS",re[re.ROW_LENGTHS=2]="ROW_LENGTHS",re[re.ROW_SPLITS=3]="ROW_SPLITS",re[re.ROW_LIMITS=4]="ROW_LIMITS",re[re.ROW_STARTS=5]="ROW_STARTS",re}(z||{});function pe(re,xe,ee){let me=new Array;if(null==ee&&null==xe)return me;if(null==xe)for(;me.length<re+ee.length;)me.push(-1);else me=xe.slice();if(null==ee)return me;if(re+ee.length!==me.length)throw new Error(`rt input.shape and shape=${xe} are incompatible: rt input.rank = ${re+ee.length}, but shape.rank = ${me.length}`);for(let Fe=1;Fe<ee.length;++Fe){const gt=ee[Fe],At=me[me.length-ee.length+Fe],zt=me[At];if(gt>=0)if(zt>=0){if(zt!==gt)throw new Error(`rt input.shape and shape=${xe} are incompatible: rt input.shape[${Fe+re}] = ${gt} but shape[${Fe+re}] = ${zt}`)}else me[At]=gt}return me}function Pe(re){const xe={FIRST_DIM_SIZE:z.FIRST_DIM_SIZE,VALUE_ROWIDS:z.VALUE_ROWIDS,ROW_LENGTHS:z.ROW_LENGTHS,ROW_SPLITS:z.ROW_SPLITS,ROW_LIMITS:z.ROW_LIMITS,ROW_STARTS:z.ROW_STARTS},ee=[];for(const me of re){if(!(me in xe))break;ee.push(xe[me])}return ee}function Ve(re){return 0===re.length?0:re[0]===z.FIRST_DIM_SIZE?re.length-1:re.length}function et(re,xe){if(null==re||null==xe)return;const ee=re.length,me=xe.length;if(ee>=me)throw new Error(`defaultValue.shape=${re} and ragged tensor flatValues.shape=${xe}, are incompatible: defaultValue.rank = ${ee} must be less than ragged tensor input flatValues.rank = ${me})`);for(let Fe=0;Fe<Math.min(ee,me-1);++Fe){const gt=re[Fe],At=xe[Fe+1];if(gt>=0&&At>=0&&1!==gt&&gt!==At)throw new Error(`defaultValue.shape=${re}, and ragged tensor input flatValues.shape=${xe} are incompatible: defaultValue.shape[${Fe-re.length}] = ${gt} but ragged tensor input.flatValues.shape[${Fe-re.length}] = ${At}`)}}const mt=30;function Wt(re){return re<=mt?re:(0,De.jP)(re,Math.floor(Math.sqrt(re)))}function mn(re,xe,ee){return[ee*("number"==typeof re?re:re[0]),xe*("number"==typeof re?re:re[1])]}function rn(re,xe,ee,me=!0){let Fe=[];if(me)Fe=Fe.concat(xe.slice(0)),Fe.push(re[0]/ee),Fe=Fe.concat(re.slice(1));else{Fe=Fe.concat(re[0]);const gt=xe.length;for(let At=0;At<gt;++At)Fe=Fe.concat([re[At+1]/xe[At],xe[At]]);Fe=Fe.concat(re.slice(gt+1))}return Fe}function $n(re,xe,ee=!0){const me=[];if(ee){me.push(xe);for(let Fe=xe+1;Fe<re;++Fe)Fe<=2*xe?(me.push(Fe),me.push(Fe-(xe+1))):me.push(Fe)}else{const Fe=[],gt=[];for(let At=1;At<re;++At)At>=2*xe+1||At%2==1?gt.push(At):Fe.push(At);me.push(...Fe),me.push(0),me.push(...gt)}return me}function zn(re,xe,ee,me=!0){const Fe=[];Fe.push(me?re[0]/ee:re[0]*ee);for(let gt=1;gt<re.length;++gt)Fe.push(gt<=xe.length?me?xe[gt-1]*re[gt]:re[gt]/xe[gt-1]:re[gt]);return Fe}function Bs(re,xe){const ee=[0];for(let me=0;me<xe;++me)ee.push(re[me][0]);return ee}function ur(re,xe,ee){const me=re.slice(0,1);for(let Fe=0;Fe<ee;++Fe)me.push(re[Fe+1]-xe[Fe][0]-xe[Fe][1]);return me}const Rs=1.7580993408473768,Or=1.0507009873554805,zr=.3275911,sr=.254829592,No=-.284496736,ho=1.421413741,Rc=-1.453152027,Vr=1.061405429;var Ec=h(1590);function ku(re,xe){if(re.length!==xe.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${re.length}, imag: ${xe.length}.`);const ee=new Float32Array(2*re.length);for(let me=0;me<ee.length;me+=2)ee[me]=re[me/2],ee[me+1]=xe[me/2];return ee}function Gn(re){const xe=new Float32Array(re.length/2),ee=new Float32Array(re.length/2);for(let me=0;me<re.length;me+=2)xe[me/2]=re[me],ee[me/2]=re[me+1];return{real:xe,imag:ee}}function bl(re){const xe=Math.ceil(re.length/4),ee=new Float32Array(xe),me=new Float32Array(xe);for(let Fe=0;Fe<re.length;Fe+=4)ee[Math.floor(Fe/4)]=re[Fe],me[Math.floor(Fe/4)]=re[Fe+1];return{real:ee,imag:me}}function Vi(re){const xe=Math.floor(re.length/4),ee=new Float32Array(xe),me=new Float32Array(xe);for(let Fe=2;Fe<re.length;Fe+=4)ee[Math.floor(Fe/4)]=re[Fe],me[Math.floor(Fe/4)]=re[Fe+1];return{real:ee,imag:me}}function xl(re,xe){return{real:re[2*xe],imag:re[2*xe+1]}}function Kl(re,xe,ee,me){re[2*me]=xe,re[2*me+1]=ee}function bu(re,xe){const ee=new Float32Array(re/2),me=new Float32Array(re/2);for(let Fe=0;Fe<Math.ceil(re/2);Fe++){const gt=(xe?2:-2)*Math.PI*(Fe/re);ee[Fe]=Math.cos(gt),me[Fe]=Math.sin(gt)}return{real:ee,imag:me}}function _c(re,xe,ee){const me=(ee?2:-2)*Math.PI*(re/xe);return{real:Math.cos(me),imag:Math.sin(me)}}const Ou="->",xd=/->/g,yc=",",Lc="...";function Ru(re,xe){const ee=((re=re.replace(/\s/g,"")).length-re.replace(xd,"").length)/Ou.length;if(ee<1)throw new Error("Equations without an arrow are not supported.");if(ee>1)throw new Error(`Equation must contain exactly one arrow ("${Ou}").`);const[me,Fe]=re.split(Ou);(0,De.hu)(-1===me.indexOf(Lc),()=>`The ellipsis notation ("${Lc}") is not supported yet.`);const gt=me.split(yc),At=gt.length;if(xe!==At)throw new Error(`Expected ${At} input tensors, received ${xe}`);if(At>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const zt=[];for(let An=0;An<Fe.length;++An){const vs=Fe[An];if(!gt.some(ir=>-1!==ir.indexOf(vs)))throw new Error(`Output subscripts contain the label ${vs} not present in the input subscripts.`);-1===zt.indexOf(vs)&&zt.push(vs)}for(let An=0;An<me.length;++An){const vs=me[An];-1===zt.indexOf(vs)&&vs!==yc&&zt.push(vs)}const Pn=new Array(gt.length);for(let An=0;An<At;++An){if(new Set(gt[An].split("")).size!==gt[An].length)throw new Error(`Found duplicate axes in input component ${gt[An]}. Support for duplicate axes in input is not implemented yet.`);Pn[An]=[];for(let vs=0;vs<gt[An].length;++vs)Pn[An].push(zt.indexOf(gt[An][vs]))}const On=zt.length,Ln=[];for(let An=Fe.length;An<On;++An)Ln.push(An);return{allDims:zt,summedDims:Ln,idDims:Pn}}function Sa(re,xe){let ee=new Array(re);ee.fill(-1);for(let Fe=0;Fe<xe.length;++Fe)ee[xe[Fe]]=Fe;const me=[];for(let Fe=0;Fe<re;++Fe)-1===ee[Fe]&&me.push(Fe);return ee=ee.filter(Fe=>-1!==Fe),{permutationIndices:ee,expandDims:me}}function Ws(re,xe,ee){const me=new Array(re);for(let Fe=0;Fe<ee.length;++Fe){const gt=ee[Fe].shape;for(let At=0;At<xe[Fe].length;++At)void 0===me[xe[Fe][At]]?me[xe[Fe][At]]=gt[At]:(0,De.hu)(me[xe[Fe][At]]===gt[At],()=>`Expected dimension ${me[xe[Fe][At]]} at axis ${At} of input shaped ${JSON.stringify(gt)}, but got dimension ${gt[At]}`)}}function Wr(re,xe){const ee=re,me=[];let Fe=0;0===re.length&&ee.push(-1),Fe=re.length+1;for(let At=0;At<Fe;++At)me.push([]);const gt=[];for(let At=0;At<ee.length;++At){const Pn=Eo(xe,ee[At]);for(const On of Pn)-1===gt.indexOf(On)&&(me[At].push(On),gt.push(On))}return{path:ee,steps:me}}function Mo(re){return re.every((xe,ee)=>xe===ee)}function Eo(re,xe){const ee=[];for(let me=0;me<re.length;++me)(0===re[me].length||-1!==re[me].indexOf(xe)||-1===xe)&&ee.push(me);return ee}function Ol(re,xe,ee=0){let me=[];if("number"==typeof xe)(0,De.hu)(re.shape[ee]%xe==0,()=>"Number of splits must evenly divide the axis."),me=new Array(xe).fill(re.shape[ee]/xe);else{const Fe=xe.reduce((At,zt)=>(-1===zt&&(At+=1),At),0);(0,De.hu)(Fe<=1,()=>"There should be only one negative value in split array.");const gt=xe.indexOf(-1);if(-1!==gt){const At=xe.reduce((zt,Pn)=>Pn>0?zt+Pn:zt);xe[gt]=re.shape[ee]-At}(0,De.hu)(re.shape[ee]===xe.reduce((At,zt)=>At+zt),()=>"The sum of sizes must match the size of the axis dimension."),me=xe}return me}function ln(re){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${re}`}function ei(re,xe){return`indices(${re}, 0) is invalid: ${xe} < 0`}function ua(re,xe,ee){return`indices(${re}, 0) is invalid: ${xe} >= ${ee}`}function Nc(re,xe){return`only one output dimension may be -1, not both ${re} and ${xe}`}function Mc(re,xe){return`size ${re} must be non-negative, not ${xe}`}function Ur(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function wl(re,xe){return`Input to reshape is a SparseTensor with ${(0,De.NA)(re)}\n  dense values, but the requested shape requires a multiple of ${(0,De.NA)(xe)}. inputShape=${re} outputShape= ${xe}`}function wd(re,xe){return`Input to reshape is a tensor with ${(0,De.NA)(re)} dense values, but the requested shape has ${(0,De.NA)(xe)}. inputShape=${re} outputShape=${xe}`}function Do(){return"segment ids must be >= 0"}function ks(){return"segment ids are not increasing"}function Zo(re,xe){return`Segment id ${re} out of range [0, ${xe}), possibly because segmentIds input is not sorted.`}function Me(re,xe,ee){return`Bad: indices[${re}] == ${xe} out of range [0, ${ee})`}function ge(re,xe){let me,ee=!1;for(re<=mt?(me=re,ee=!0):me=(0,De.jP)(re,Math.floor(Math.sqrt(re)));!ee;)me>xe||me===re?ee=!0:me=(0,De.jP)(re,me+1);return me}function ke(re,xe,ee){const me=[],Fe=re.length;for(let gt=0;gt<Fe;gt++)me.push(gt!==xe?re[gt]:ee);return me}function Ke(re,xe,ee,me){const Fe=xe.shape.length,gt=re.shape.length;if(0!==me&&(me<-Fe||me>Fe))throw new Error(`Expect batchDims in the range of [-${Fe}, ${Fe}], but got ${me}`);if(me<0&&(me+=Fe),me>gt)throw new Error(`batchDims (${me}) must be less than rank(x) (\n    ${gt}).`);if(ee<me)throw new Error(`batchDims (${me}) must be less than or equal to axis (${ee}).`);for(let Ln=0;Ln<me;++Ln)if(re.shape[Ln]!==xe.shape[Ln])throw new Error(`x.shape[${Ln}]: ${re.shape[Ln]} should be equal to indices.shape[${Ln}]: ${xe.shape[Ln]}.`);const At=re.shape[ee],zt=[];let Pn=1,On=1,Kn=1;for(let Ln=0;Ln<me;++Ln)zt.push(re.shape[Ln]),Pn*=re.shape[Ln];for(let Ln=me;Ln<ee;Ln++)zt.push(re.shape[Ln]),On*=re.shape[Ln];for(let Ln=me;Ln<Fe;Ln++)zt.push(xe.shape[Ln]);for(let Ln=ee+1;Ln<gt;Ln++)zt.push(re.shape[Ln]),Kn*=re.shape[Ln];return{batchSize:Pn,sliceSize:Kn,outerSize:On,dimSize:At,outputShape:zt}}function dt(re){try{return re.map(xe=>(0,Yc.decodeString)(xe))}catch(xe){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${xe}`)}}function $t(re){return re.map(xe=>(0,Yc.encodeString)(xe))}var dn=h(501),Sn=h(2553),en=h(7437)},351:(Et,le,h)=>{"use strict";h.d(le,{$HU:()=>ji,$g6:()=>Qt,$w:()=>or,Acj:()=>sl,BMI:()=>Jr,BiW:()=>Zi,Byc:()=>Bt,CAk:()=>la,D2d:()=>ll,DlI:()=>uo,Eh3:()=>Te,FKq:()=>wr,G3Y:()=>it,GBy:()=>ar,Gcp:()=>qr,HEU:()=>Os,HZH:()=>Xs,Hhh:()=>Bi,Hmb:()=>pa,IKK:()=>W,IMb:()=>we,J$2:()=>qe,J_u:()=>rl,JhU:()=>K,Kgp:()=>Pr,L8s:()=>gn,Ly9:()=>Le,M2y:()=>M,MIZ:()=>X,MRv:()=>ki,MZg:()=>Li,NEP:()=>xr,NZg:()=>Ka,O3z:()=>Wl,OAf:()=>hc,OR:()=>xa,OU7:()=>Ga,OV7:()=>dc,Omj:()=>zs,Oyi:()=>G,PYm:()=>ja,PhF:()=>Br,QCc:()=>J,QRR:()=>Dn,Qg5:()=>to,QiL:()=>vi,Qvg:()=>kn,RFZ:()=>te,ROF:()=>_e,RQH:()=>go,RuY:()=>qn,SX0:()=>Nn,SYM:()=>U,SbG:()=>fa,SpW:()=>y,T0n:()=>ps,TQc:()=>Ma,TR1:()=>nn,ToN:()=>wt,Tr8:()=>q,Uyb:()=>Po,VGw:()=>Z,Vbg:()=>no,VcC:()=>Qn,VfG:()=>Go,Vn9:()=>Qe,W0H:()=>ol,XDQ:()=>pn,XLW:()=>We,XkS:()=>_l,Xze:()=>I,Y0y:()=>eo,YFo:()=>$r,YoZ:()=>hl,ZbH:()=>co,ZjV:()=>Ro,Zz9:()=>oe,_JP:()=>Ea,_V0:()=>Is,_Yw:()=>Qi,_k9:()=>Re,_tC:()=>Si,a5O:()=>En,aJk:()=>w,avt:()=>Wa,b9H:()=>Tr,bK0:()=>Ca,bV0:()=>mo,c17:()=>pl,cWu:()=>He,cie:()=>Es,cye:()=>zl,dDz:()=>Ra,deh:()=>aa,dpD:()=>ro,e07:()=>ma,e6w:()=>Oo,e7N:()=>$s,eBW:()=>Ms,eEB:()=>De,eZ0:()=>$i,ekb:()=>Ss,gJX:()=>de,h8e:()=>os,hdR:()=>cr,i5y:()=>Na,iHb:()=>bn,iJz:()=>ka,iWB:()=>Fo,iZT:()=>Ho,ik2:()=>Ct,jMg:()=>D,jQk:()=>Pa,jQs:()=>fl,jeX:()=>za,kU:()=>ui,kpP:()=>_t,kuV:()=>il,luS:()=>lr,lyA:()=>$o,mKl:()=>di,mTV:()=>Lo,mc4:()=>It,mhS:()=>v,mm_:()=>F,n9L:()=>Ae,nhH:()=>_o,nr8:()=>ic,o0g:()=>Al,o2y:()=>pt,oFR:()=>dr,oHH:()=>Lt,oT6:()=>N,p2w:()=>Xo,p4S:()=>Ir,pe_:()=>Oa,q1x:()=>Ao,q2K:()=>pc,q8u:()=>ko,qCd:()=>Ki,qIC:()=>Xi,qWM:()=>Xa,qi_:()=>lo,qkr:()=>Di,qw7:()=>T,r7n:()=>Ha,s1s:()=>gl,sEM:()=>L,sHE:()=>To,sJF:()=>l,sL$:()=>Xn,usg:()=>Cr,uv1:()=>fc,vFR:()=>Ko,vtC:()=>jo,vwp:()=>oa,w3H:()=>mc,w6g:()=>wa,wUP:()=>at,wYB:()=>ml,wYn:()=>so,we_:()=>Js,wm:()=>Xe,wx7:()=>Ye,x12:()=>Ue,xJR:()=>Hi,xQA:()=>mi,xnO:()=>P,y7R:()=>Ts,yQU:()=>Yi,yj2:()=>ye,zbQ:()=>al,zvY:()=>ie,zws:()=>Oe});const U="Abs",Z="Acos",y="Acosh",F="Add",I="AddN",N="All",W="Any",l="ArgMax",w="ArgMin",M="Asin",T="Asinh",D="Atan",G="Atanh",J="Atan2",K="AvgPool",_e="AvgPoolGrad",Re="AvgPool3D",we="AvgPool3DGrad",We="BatchMatMul",Oe="BatchToSpaceND",ie="Bincount",Le="BroadcastTo",De="BroadcastArgs",te="Cast",de="Ceil",P="ClipByValue",oe="Complex",ye="ComplexAbs",Te="Concat",v="Conv2D",at="Conv2DBackpropFilter",Xe="Conv2DBackpropInput",Ue="Conv3D",pt="Conv3DBackpropFilterV2",Ct="Conv3DBackpropInputV2",It="Cos",nn="Cosh",Bt="Cumprod",bn="Cumsum",Qn="CropAndResize",Dn="DenseBincount",ps="DepthToSpace",Es="DepthwiseConv2dNative",Xn="DepthwiseConv2dNativeBackpropFilter",Ts="DepthwiseConv2dNativeBackpropInput",or="Diag",Ir="Dilation2D",Ss="Dilation2DBackpropInput",Qe="Dilation2DBackpropFilter",Lt="RealDiv",Qt="Einsum",Nn="Elu",Os="EluGrad",zs="Erf",cr="Equal",xr="Exp",$r="ExpandDims",eo="Expm1",oa="FFT",aa="Fill",Po="FlipLeftRight",xa="Floor",za="FloorDiv",To="FusedBatchNorm",lo="GatherV2",Ao="GatherNd",Ho="Greater",sl="GreaterEqual",ka="Identity",to="IFFT",rl="Imag",Wa="IsFinite",Fo="IsInf",Ha="IsNan",qe="LeakyRelu",jo="Less",la="LessEqual",$s="LinSpace",co="Log",ui="Log1p",ja="LogicalAnd",Go="LogicalNot",Li="LogicalOr",wa="LogicalXor",Ki="LogSoftmax",Xi="LowerBound",$i="LRN",Bi="LRNGrad",hl="Max",Jr="Maximum",Lo="MaxPool",dc="MaxPoolGrad",hc="MaxPool3D",Ga="MaxPool3DGrad",Ko="MaxPoolWithArgmax",pc="Mean",pl="Min",ko="Minimum",fl="MirrorPad",no="Mod",Ka="Multinomial",so="Multiply",il="Neg",Yi="NotEqual",fc="NonMaxSuppressionV3",zl="NonMaxSuppressionV4",ol="NonMaxSuppressionV5",Xa="OnesLike",Js="OneHot",vi="Pack",$o="PadV2",Pr="Pool",Oa="Pow",Al="Prelu",uo="Prod",Ra="RaggedGather",Zi="RaggedTensorToTensor",Oo="Range",Hi="Real",ji="Reciprocal",Di="Relu",Xs="Reshape",ro="ResizeNearestNeighbor",pa="ResizeNearestNeighborGrad",Qi="ResizeBilinear",al="ResizeBilinearGrad",fa="Relu6",di="Reverse",ma="Round",mo="Rsqrt",mi="ScatterNd",ic="SearchSorted",Br="Select",dr="Selu",Xo="Slice",go="Sin",ml="Sinh",Na="Sign",En="Sigmoid",ki="Softplus",wr="Sqrt",ar="Sum",Ma="SpaceToBatchND",gn="SplitV",qr="Softmax",Wl="SparseFillEmptyRows",_o="SparseReshape",mc="SparseSegmentMean",Ro="SparseSegmentSum",ll="SparseToDense",Si="SquaredDifference",Ca="Square",Pa="StridedSlice",Ea="StringNGrams",gl="StringSplit",_l="StringToHashBucketFast",q="Sub",L="Tan",X="Tanh",Ae="Tile",He="TopK",Ye="Transform",it="Transpose",_t="Unique",wt="Unpack",kn="UnsortedSegmentSum",pn="UpperBound",qn="ZerosLike",os="Step",Ms="FromPixels",Tr="RotateWithOffset",Cr="_FusedMatMul",Is="FusedConv2D",lr="FusedDepthwiseConv2D"},6096:(Et,le,h)=>{"use strict";h.d(le,{Li:()=>M,T3:()=>G,bt:()=>D,nE:()=>T,pI:()=>N,tr:()=>l,uk:()=>W,wC:()=>w});var U=h(8514),Z=h(3565),y=h(1590);const F=(0,Z.R)("kernelRegistry",()=>new Map),I=(0,Z.R)("gradRegistry",()=>new Map);function N(K,_e){const Re=J(K,_e);return F.get(Re)}function W(K){return I.get(K)}function l(K){const _e=F.entries(),Re=[];for(;;){const{done:we,value:We}=_e.next();if(we)break;const[Oe,ie]=We,[Le]=Oe.split("_");Le===K&&Re.push(ie)}return Re}function w(K){const{kernelName:_e,backendName:Re}=K,we=J(_e,Re);F.has(we)&&y.Z(`The kernel '${_e}' for backend '${Re}' is already registered`),F.set(we,K)}function M(K){const{kernelName:_e}=K;I.has(_e)&&(0,U.OB)().getBool("DEBUG")&&y.Z(`Overriding the gradient for '${_e}'`),I.set(_e,K)}function T(K,_e){const Re=J(K,_e);if(!F.has(Re))throw new Error(`The kernel '${K}' for backend '${_e}' is not registered`);F.delete(Re)}function D(K){if(!I.has(K))throw new Error(`The gradient '${K}' for backend is not registered`);I.delete(K)}function G(K,_e){l(K).forEach(we=>{w(Object.assign({},we,{backendName:_e}))})}function J(K,_e){return`${_e}_${K}`}},1590:(Et,le,h)=>{"use strict";h.d(le,{Z:()=>Z,c:()=>y});var U=h(8514);function Z(...F){(0,U.OB)().getBool("IS_TEST")||(0,U.OB)().getBool("PROD")||console.warn(...F)}function y(...F){(0,U.OB)().getBool("IS_TEST")||(0,U.OB)().getBool("PROD")||console.log(...F)}},1634:(Et,le,h)=>{"use strict";h.d(le,{W:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({abs_:function I(W){const l=(0,y._1)(W,"x","abs");return U.BV.runKernel("complex64"===l.dtype?Z.yj2:Z.SYM,{x:l})}})},2923:(Et,le,h)=>{"use strict";h.d(le,{I:()=>W});var U=h(1379),Z=h(351),y=h(1931),F=h(58);const W=(0,h(2267).op)({add_:function N(l,w){let M=(0,F._1)(l,"a","add"),T=(0,F._1)(w,"b","add");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.mm_,{a:M,b:T})}})},4588:(Et,le,h)=>{"use strict";h.d(le,{LJ:()=>l,Q3:()=>W,Vh:()=>y,YB:()=>Z,kz:()=>F,lB:()=>N,rv:()=>I,sY:()=>w});var U=h(4944);function Z(M,T){for(let D=0;D<M.length;++D)if(M[M.length-D-1]!==T-1-D)return!1;return!0}function y(M,T,D){const G=M.length+T.length,J=[];let K=0,_e=0;for(let Re=0;Re<G;Re++)-1===D.indexOf(Re)?J.push(M[K++]):J.push(T[_e++]);return J}function F(M,T){const D=[],G=M.length;for(let K=0;K<G;K++)-1===T.indexOf(K)&&D.push(M[K]);return[D,T.map(K=>M[K])]}function I(M,T){return y(M,T.map(G=>1),T)}function N(M,T,D){U.hu(Z(T,D),()=>`${M} supports only inner-most axes for now. Got axes ${T} and rank-${D} input.`)}function W(M,T){if(Z(M,T))return null;const D=[];for(let G=0;G<T;++G)-1===M.indexOf(G)&&D.push(G);return M.forEach(G=>D.push(G)),D}function l(M){return M.map((T,D)=>[D,T]).sort((T,D)=>T[1]-D[1]).map(T=>T[0])}function w(M,T){const D=[];for(let G=T-M;G<T;++G)D.push(G);return D}},9741:(Et,le,h)=>{"use strict";function U(F,I){const N=F.length,W=[];for(let l=0;l<N;l++){const w=N-1-l;(I[I.length-1-l]||1)>1&&1===(F[w]||1)&&W.unshift(w)}return W}function Z(F,I){const N=[];for(let W=0;W<I.length;W++){const l=F[F.length-W-1],w=I.length-W-1;(null==l||1===l&&I[w]>1)&&N.unshift(w)}return N}function y(F,I){const N=[],W=Math.max(F.length,I.length);for(let l=0;l<W;l++){let w=F[F.length-l-1];null==w&&(w=1);let M=I[I.length-l-1];if(null==M&&(M=1),1===w)N.unshift(M);else if(1===M)N.unshift(w);else{if(w!==M)throw Error(`Operands could not be broadcast together with shapes ${F} and ${I}.`);N.unshift(w)}}return N}h.r(le),h.d(le,{assertAndGetBroadcastShape:()=>y,getBroadcastDims:()=>U,getReductionAxes:()=>Z})},94:(Et,le,h)=>{"use strict";h.d(le,{f:()=>y});var U=h(9089),Z=h(4944);function y(F,I="float32",N){return I=I||"float32",Z.Mu(F),new U.YD(F,I,N)}},8622:(Et,le,h)=>{"use strict";h.d(le,{p:()=>W});var U=h(1379),Z=h(351),y=h(58),F=h(4944);const W=(0,h(2267).op)({cast_:function N(l,w){const M=(0,y._1)(l,"x","cast");if(!F.LP(w))throw new Error(`Failed to cast to unknown dtype ${w}`);if("string"===w&&"string"!==M.dtype||"string"!==w&&"string"===M.dtype)throw new Error("Only strings can be casted to strings");return U.BV.runKernel(Z.RFZ,{x:M},{dtype:w})}})},1676:(Et,le,h)=>{"use strict";h.d(le,{d:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({clone_:function I(W){const w={x:(0,y._1)(W,"x","clone","string_or_numeric")};return U.BV.runKernel(Z.iJz,w)}})},7507:(Et,le,h)=>{"use strict";h.d(le,{P:()=>W});var U=h(1379),Z=h(351),y=h(58),F=h(4944);const W=(0,h(2267).op)({complex_:function N(l,w){const M=(0,y._1)(l,"real","complex"),T=(0,y._1)(w,"imag","complex");return F.k5(M.shape,T.shape,`real and imag shapes, ${M.shape} and ${T.shape}, must match in call to tf.complex().`),U.BV.runKernel(Z.Zz9,{real:M,imag:T})}})},9992:(Et,le,h)=>{"use strict";h.d(le,{I0:()=>_e,Ix:()=>I,Rf:()=>Z,Xw:()=>y,aO:()=>w,jT:()=>Re,jw:()=>N,m:()=>We,pl:()=>F,sl:()=>we});var U=h(4944);function Z(Oe,ie,Le,De,te="NHWC",de){return I(Oe,[...ie,Oe[3]],Le,de,De,null,null,we(te))}function y(Oe,ie,Le,De,te,de,P="channelsLast"){const[oe,ye]=M(ie);let Te;if("channelsLast"===P)Te=[oe,ye,Oe[3],Oe[3]];else{if("channelsFirst"!==P)throw new Error(`Unknown dataFormat ${P}`);Te=[oe,ye,Oe[1],Oe[1]]}return I(Oe,Te,Le,De,te,de,!1,P)}function F(Oe,ie,Le,De,te,de,P="NDHWC"){const[oe,ye,Te]=T(ie);let v,at;if("NDHWC"===P)at="channelsLast",v=[oe,ye,Te,Oe[4],Oe[4]];else{if("NCDHW"!==P)throw new Error(`Unknown dataFormat ${P}`);at="channelsFirst",v=[oe,ye,Te,Oe[1],Oe[1]]}return N(Oe,v,Le,De,te,!1,at,de)}function I(Oe,ie,Le,De,te,de,P=!1,oe="channelsLast"){let[ye,Te,v,at]=[-1,-1,-1,-1];if("channelsLast"===oe)[ye,Te,v,at]=Oe;else{if("channelsFirst"!==oe)throw new Error(`Unknown dataFormat ${oe}`);[ye,at,Te,v]=Oe}const[Xe,Ue,,pt]=ie,[Ct,It]=M(Le),[nn,Bt]=M(De),bn=D(Xe,nn),Qn=D(Ue,Bt),{padInfo:Dn,outHeight:ps,outWidth:Es}=function G(Oe,ie,Le,De,te,de,P,oe,ye){let Te,v,at;if("number"==typeof Oe){Te={top:Oe,bottom:Oe,left:Oe,right:Oe,type:0===Oe?"VALID":"NUMBER"};const Ue=function W(Oe,ie,Le,De,te){null==De&&(De=w(Oe,ie,Le));const P=Oe[1];return[K((Oe[0]-ie+2*De)/Le+1,te),K((P-ie+2*De)/Le+1,te)]}([ie,Le],de,De,Oe,oe);v=Ue[0],at=Ue[1]}else if("same"===Oe){v=Math.ceil(ie/De),at=Math.ceil(Le/te);const Xe=Math.max(0,(v-1)*De+de-ie),Ue=Math.max(0,(at-1)*te+P-Le),pt=Math.floor(Xe/2),Ct=Xe-pt,It=Math.floor(Ue/2);Te={top:pt,bottom:Ct,left:It,right:Ue-It,type:"SAME"}}else if("valid"===Oe)Te={top:0,bottom:0,left:0,right:0,type:"VALID"},v=Math.ceil((ie-de+1)/De),at=Math.ceil((Le-P+1)/te);else{if("object"!=typeof Oe)throw Error(`Unknown padding parameter: ${Oe}`);{const Xe="channelsLast"===ye?Oe[1][0]:Oe[2][0],Ue="channelsLast"===ye?Oe[1][1]:Oe[2][1],pt="channelsLast"===ye?Oe[2][0]:Oe[3][0],Ct="channelsLast"===ye?Oe[2][1]:Oe[3][1];Te={top:Xe,bottom:Ue,left:pt,right:Ct,type:0===Xe&&0===Ue&&0===pt&&0===Ct?"VALID":"EXPLICIT"},v=K((ie-de+Xe+Ue)/De+1,oe),at=K((Le-P+pt+Ct)/te+1,oe)}}return{padInfo:Te,outHeight:v,outWidth:at}}(te,Te,v,Ct,It,bn,Qn,de,oe),Xn=P?pt*at:pt;let Ts;return"channelsFirst"===oe?Ts=[ye,Xn,ps,Es]:"channelsLast"===oe&&(Ts=[ye,ps,Es,Xn]),{batchSize:ye,dataFormat:oe,inHeight:Te,inWidth:v,inChannels:at,outHeight:ps,outWidth:Es,outChannels:Xn,padInfo:Dn,strideHeight:Ct,strideWidth:It,filterHeight:Xe,filterWidth:Ue,effectiveFilterHeight:bn,effectiveFilterWidth:Qn,dilationHeight:nn,dilationWidth:Bt,inShape:Oe,outShape:Ts,filterShape:ie}}function N(Oe,ie,Le,De,te,de=!1,P="channelsLast",oe){let[ye,Te,v,at,Xe]=[-1,-1,-1,-1,-1];if("channelsLast"===P)[ye,Te,v,at,Xe]=Oe;else{if("channelsFirst"!==P)throw new Error(`Unknown dataFormat ${P}`);[ye,Xe,Te,v,at]=Oe}const[Ue,pt,Ct,,It]=ie,[nn,Bt,bn]=T(Le),[Qn,Dn,ps]=T(De),Es=D(Ue,Qn),Xn=D(pt,Dn),Ts=D(Ct,ps),{padInfo:or,outDepth:Ir,outHeight:Ss,outWidth:Qe}=function J(Oe,ie,Le,De,te,de,P,oe,ye,Te,v){let at,Xe,Ue,pt;if("number"==typeof Oe){at={top:Oe,bottom:Oe,left:Oe,right:Oe,front:Oe,back:Oe,type:0===Oe?"VALID":"NUMBER"};const It=function l(Oe,ie,Le,De,te,de){null==te&&(te=w(Oe,ie,De));const oe=Oe[1],ye=Oe[2];return[K((Oe[0]-ie+2*te)/De+1,de),K((oe-ie+2*te)/De+1,de),K((ye-ie+2*te)/De+1,de),Le]}([ie,Le,De,1],oe,1,te,Oe,v);Xe=It[0],Ue=It[1],pt=It[2]}else if("same"===Oe){Xe=Math.ceil(ie/te),Ue=Math.ceil(Le/de),pt=Math.ceil(De/P);const Ct=(Xe-1)*te+oe-ie,It=(Ue-1)*de+ye-Le,nn=(pt-1)*P+Te-De,Bt=Math.floor(Ct/2),bn=Ct-Bt,Qn=Math.floor(It/2),Dn=It-Qn,ps=Math.floor(nn/2);at={top:Qn,bottom:Dn,left:ps,right:nn-ps,front:Bt,back:bn,type:"SAME"}}else{if("valid"!==Oe)throw Error(`Unknown padding parameter: ${Oe}`);at={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},Xe=Math.ceil((ie-oe+1)/te),Ue=Math.ceil((Le-ye+1)/de),pt=Math.ceil((De-Te+1)/P)}return{padInfo:at,outDepth:Xe,outHeight:Ue,outWidth:pt}}(te,Te,v,at,nn,Bt,bn,Es,Xn,Ts,oe),Lt=de?It*Xe:It;let Qt;return"channelsFirst"===P?Qt=[ye,Lt,Ir,Ss,Qe]:"channelsLast"===P&&(Qt=[ye,Ir,Ss,Qe,Lt]),{batchSize:ye,dataFormat:P,inDepth:Te,inHeight:v,inWidth:at,inChannels:Xe,outDepth:Ir,outHeight:Ss,outWidth:Qe,outChannels:Lt,padInfo:or,strideDepth:nn,strideHeight:Bt,strideWidth:bn,filterDepth:Ue,filterHeight:pt,filterWidth:Ct,effectiveFilterDepth:Es,effectiveFilterHeight:Xn,effectiveFilterWidth:Ts,dilationDepth:Qn,dilationHeight:Dn,dilationWidth:ps,inShape:Oe,outShape:Qt,filterShape:ie}}function w(Oe,ie,Le,De=1){const te=D(ie,De);return Math.floor((Oe[0]*(Le-1)-Le+te)/2)}function M(Oe){return"number"==typeof Oe?[Oe,Oe,Oe]:2===Oe.length?[Oe[0],Oe[1],1]:Oe}function T(Oe){return"number"==typeof Oe?[Oe,Oe,Oe]:Oe}function D(Oe,ie){return ie<=1?Oe:Oe+(Oe-1)*(ie-1)}function K(Oe,ie){if(!ie)return Math.trunc(Oe);switch(ie){case"round":return Math.round(Oe);case"ceil":return Math.ceil(Oe);case"floor":return Math.floor(Oe);default:throw new Error(`Unknown roundingMode ${ie}`)}}function _e(Oe){const[ie,Le,De]=M(Oe);return 1===ie&&1===Le&&1===De}function Re(Oe,ie){return _e(Oe)||_e(ie)}function we(Oe){if("NHWC"===Oe)return"channelsLast";if("NCHW"===Oe)return"channelsFirst";throw new Error(`Unknown dataFormat ${Oe}`)}function We(Oe,ie,Le){if(null!=Le){if("string"==typeof ie)throw Error(`Error in ${Oe}: pad must be an integer when using dimRoundingMode ${Le} but got pad ${ie}.`);if("number"==typeof ie)U.hu(U.GN(ie),()=>`Error in ${Oe}: pad must be an integer when using dimRoundingMode ${Le} but got pad ${ie}.`);else{if("object"!=typeof ie)throw Error(`Error in ${Oe}: Unknown padding parameter: ${ie}`);ie.forEach(De=>{De.forEach(te=>{U.hu(U.GN(te),()=>`Error in ${Oe}: pad must be an integer when using dimRoundingMode ${Le} but got pad ${te}.`)})})}}}},9526:(Et,le,h)=>{"use strict";h.d(le,{h:()=>l});var U=h(1379),Z=h(351),y=h(1931),F=h(58),I=h(2266);const l=(0,h(2267).op)({div_:function W(w,M){let T=(0,F._1)(w,"a","div"),D=(0,F._1)(M,"b","div");return[T,D]=(0,y.makeTypesMatch)(T,D),"int32"===T.dtype&&"int32"===D.dtype?(0,I.q)(T,D):U.BV.runKernel(Z.oHH,{a:T,b:D},{})}})},7828:(Et,le,h)=>{"use strict";h.d(le,{p:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({elu_:function I(W){const w={x:(0,y._1)(W,"x","elu","float32")};return U.BV.runKernel(Z.SX0,w)}})},3541:(Et,le,h)=>{"use strict";h.d(le,{h:()=>y});var U=h(1379),Z=h(351);function y(F,I,N){return U.BV.runKernel(Z.deh,{},{shape:F,value:I,dtype:N})}},2266:(Et,le,h)=>{"use strict";h.d(le,{q:()=>W});var U=h(1379),Z=h(351),y=h(1931),F=h(58);const W=(0,h(2267).op)({floorDiv_:function N(l,w){let M=(0,F._1)(l,"a","floorDiv"),T=(0,F._1)(w,"b","floorDiv");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.jeX,{a:M,b:T})}})},9251:(Et,le,h)=>{"use strict";h.d(le,{Fr:()=>D,QH:()=>J,pf:()=>G,uy:()=>K});var U=h(9741),Z=h(7828),y=h(3183),F=h(6008),I=h(2620),N=h(2020),W=h(9098),l=h(1791),w=h(7690),M=h(6517),T=h(2149);function D(_e,Re,we){if(null==we||"linear"===we)return _e;if("relu"===we)return(0,F.d)(_e,(0,M.N)(Re));throw new Error(`Cannot compute gradient for fused activation ${we}.`)}function G(_e,Re){let we=Re;const We=U.getReductionAxes(_e.shape,Re.shape);return We.length>0&&(we=(0,T.S)(we,We)),(0,l.X)(we,_e.shape)}function J(_e,Re,we,We){if("linear"===Re)return _e;if("relu"===Re)return(0,N.U)(_e);if("elu"===Re)return(0,Z.p)(_e);if("relu6"===Re)return(0,W.b)(_e);if("prelu"===Re)return(0,I.A)(_e,we);if("leakyrelu"===Re)return(0,y.h)(_e,We);if("sigmoid"===Re)return(0,w.X)(_e);throw new Error(`Unknown fused activation ${Re}.`)}const K=(_e,Re)=>!(_e>0)||"linear"===Re},2556:(Et,le,h)=>{"use strict";h.d(le,{a:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({imag_:function I(W){const w={input:(0,y._1)(W,"input","imag")};return U.BV.runKernel(Z.J_u,w)}})},3183:(Et,le,h)=>{"use strict";h.d(le,{h:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({leakyRelu_:function I(W,l=.2){const M={x:(0,y._1)(W,"x","leakyRelu")};return U.BV.runKernel(Z.J$2,M,{alpha:l})}})},2065:(Et,le,h)=>{"use strict";h.d(le,{I:()=>U});var U=function(Z){return Z[Z.NONE=0]="NONE",Z[Z.MEAN=1]="MEAN",Z[Z.SUM=2]="SUM",Z[Z.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Z}(U||{})},5069:(Et,le,h)=>{"use strict";h.d(le,{O:()=>W});var U=h(1379),Z=h(351),y=h(1931),F=h(58);const W=(0,h(2267).op)({matMul_:function N(l,w,M=!1,T=!1){let D=(0,F._1)(l,"a","matMul"),G=(0,F._1)(w,"b","matMul");return[D,G]=(0,y.makeTypesMatch)(D,G),U.BV.runKernel(Z.XLW,{a:D,b:G},{transposeA:M,transposeB:T})}})},685:(Et,le,h)=>{"use strict";h.d(le,{g:()=>w});var U=h(1379),Z=h(351),y=h(1931),F=h(58),I=h(9741),N=h(8622);const w=(0,h(2267).op)({maximum_:function l(M,T){let D=(0,F._1)(M,"a","maximum"),G=(0,F._1)(T,"b","maximum");return[D,G]=(0,y.makeTypesMatch)(D,G),"bool"===D.dtype&&(D=(0,N.p)(D,"int32"),G=(0,N.p)(G,"int32")),(0,I.assertAndGetBroadcastShape)(D.shape,G.shape),U.BV.runKernel(Z.BMI,{a:D,b:G})}})},6008:(Et,le,h)=>{"use strict";h.d(le,{d:()=>W});var U=h(1379),Z=h(351),y=h(1931),F=h(58);const W=(0,h(2267).op)({mul_:function N(l,w){let M=(0,F._1)(l,"a","mul"),T=(0,F._1)(w,"b","mul");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.wYn,{a:M,b:T})}})},7939:(Et,le,h)=>{"use strict";h.d(le,{W:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({neg_:function I(W){const w={x:(0,y._1)(W,"x","neg")};return U.BV.runKernel(Z.kuV,w)}})},7395:(Et,le,h)=>{"use strict";h.d(le,{l:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({oneHot_:function I(W,l,w=1,M=0,T="int32"){if(l<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${l}`);const G={indices:(0,y._1)(W,"indices","oneHot","int32")};return U.BV.runKernel(Z.we_,G,{dtype:T,depth:l,onValue:w,offValue:M})}})},2267:(Et,le,h)=>{"use strict";h.d(le,{op:()=>F,z:()=>y});var U=h(1379),Z=h(4944);const y="__op";function F(I){const N=Object.keys(I);if(1!==N.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${N.length} keys.`);let W=N[0];const l=I[W];W.endsWith("_")&&(W=W.substring(0,W.length-1)),W+=y;const w=(...M)=>{U.BV.startScope(W);try{const T=l(...M);return(0,Z.tI)(T)&&console.error("Cannot return a Promise inside of tidy."),U.BV.endScope(T),T}catch(T){throw U.BV.endScope(null),T}};return Object.defineProperty(w,"name",{value:W,configurable:!0}),w}},2497:(Et,le,h)=>{"use strict";h.d(le,{zvA:()=>N.z,WnP:()=>Z.W,Khb:()=>l,__u:()=>M,IHx:()=>T.I,QBD:()=>J,$6P:()=>_e,YjB:()=>we,NqF:()=>Oe,vHJ:()=>Le,ZRM:()=>te,VfV:()=>P,z4N:()=>ye,fvJ:()=>at,C80:()=>Ue,wS1:()=>Bt,uR5:()=>Qn,zEQ:()=>Nn,tgs:()=>$r,Dxk:()=>oa,JY5:()=>Po,p3b:()=>za,E4h:()=>zs,yE8:()=>lo,anm:()=>rf,XsQ:()=>Ho,UFq:()=>ka,f3b:()=>to.f,pju:()=>pt.p,mDi:()=>Wa,iUl:()=>qe,d9v:()=>Dn.d,PYB:()=>jo.P,zoF:()=>Es,gME:()=>$s,Izb:()=>ui,MNy:()=>Go,ZaL:()=>wa,PAt:()=>Bi,Tek:()=>Xi,bc:()=>dc,pdZ:()=>Ga,$QV:()=>ko,mCk:()=>no,f9Y:()=>so,mew:()=>Vo,$Gn:()=>Yi,zbp:()=>zl,ppE:()=>Xa,nTT:()=>vi,B10:()=>Pr,Ka3:()=>Al,WmZ:()=>Ra,hiC:()=>Zi.h,NTj:()=>Qi,AKD:()=>fa,rvX:()=>Bh,WYO:()=>ma,pyx:()=>mo.p,GRh:()=>gh,DgJ:()=>ji,qNN:()=>ic,d2q:()=>_o,Qqt:()=>Ro,dt4:()=>Si,t$B:()=>Pa,iyy:()=>q,kp_:()=>Sc,hlL:()=>Fo.h,GWj:()=>X,qPi:()=>Ae.q,imm:()=>U,Iqj:()=>Ye,dbB:()=>mh,pjt:()=>_t,brS:()=>kn,Sxn:()=>Nu,asL:()=>pn.a,BHj:()=>sg,V3u:()=>Ic,wx0:()=>Hu,xVT:()=>os,UWc:()=>Tr,i2d:()=>Is,hi7:()=>lr.h,d9m:()=>Da,zN1:()=>ai,$r2:()=>S0,SX3:()=>oc,G9k:()=>Fa,cM7:()=>Fi,Krr:()=>Wu,e_t:()=>Qc,CmS:()=>B,l_t:()=>Be,HvI:()=>st,hJK:()=>jt,K5V:()=>xn,egP:()=>Jn,MB5:()=>Cu,eab:()=>cn,OI3:()=>Xn.O,Fp7:()=>Xo,_sB:()=>jn,YQQ:()=>ca,Ip$:()=>La,gWQ:()=>hi.g,J69:()=>qt,ry_:()=>wi,VV$:()=>ml,LTh:()=>Gi,VdP:()=>an,wQq:()=>Gl,Gi7:()=>sd,p_:()=>bp,dC7:()=>Ts.d,rq4:()=>rd,SJ_:()=>V,W76:()=>Hl.W,KOy:()=>qr,Quu:()=>z,lfX:()=>pe.l,iUs:()=>oo,JpU:()=>Ve,op:()=>N.op,N2O:()=>mt,vku:()=>mn,pNR:()=>$n,koy:()=>Bs,t1L:()=>Rs,lGY:()=>zr,d_R:()=>Ec,sQ3:()=>Na.s,AL3:()=>ku.A,S0v:()=>Gn.S,WVs:()=>Vi,$gW:()=>Kl,N89:()=>_c,TN_:()=>xd,wzB:()=>ua,nGf:()=>Mc,ruB:()=>wl,LGj:()=>Do,w6H:()=>ks,kwC:()=>Zo.k,M25:()=>ge,UYe:()=>ke.U,btT:()=>Ke.b,XLQ:()=>It.X,GYS:()=>$t,SDf:()=>Sn,diP:()=>re,sx7:()=>ee,mG2:()=>Fe,QEs:()=>Ya,NMM:()=>At,bp0:()=>Pn,iD$:()=>En.i,snQ:()=>Dd,zcT:()=>As,U8D:()=>Kn,U_I:()=>An,ODp:()=>gi,XD2:()=>or.X,Xxe:()=>vc,tdS:()=>ng,O$l:()=>Qo,R_K:()=>Rl,tPi:()=>Ss,jZU:()=>id,SmN:()=>Ud,CnO:()=>Mh,p0P:()=>Uf,XAC:()=>Ph,Wvh:()=>Oc,fBT:()=>No,rVs:()=>pf,ers:()=>lf,uN7:()=>D0,Vl2:()=>Fh,_b3:()=>ki._,h62:()=>wr.h,$i:()=>du,L9e:()=>hh,knu:()=>zd,Nbs:()=>Jp.N,NXj:()=>qc,Z_8:()=>ff,luU:()=>Ai.l,Smz:()=>ar.S,ORZ:()=>qp,AEp:()=>Lt,XeE:()=>Lh.X,RRF:()=>Nl,odF:()=>xu,wOQ:()=>ju.w,yXz:()=>$h,Bfx:()=>Hf,xZs:()=>ph,Gg6:()=>gl,hg7:()=>bc,p4s:()=>Vc.p,Xu6:()=>b_,Two:()=>Ed,pUJ:()=>fh,HHK:()=>ef,GaM:()=>jf,VD$:()=>yp,arb:()=>Xs,itS:()=>nf,lls:()=>jl,P84:()=>ro.P});var U={};h.r(U),h.d(U,{conv2d:()=>li,depthwiseConv2d:()=>Tt,matMul:()=>ht});var Z=h(1634),y=h(1379),F=h(351),I=h(58),N=h(2267);const l=(0,N.op)({acos_:function W(be){const se={x:(0,I._1)(be,"x","acos")};return y.BV.runKernel(F.VGw,se)}}),M=(0,N.op)({acosh_:function w(be){const se={x:(0,I._1)(be,"x","acosh")};return y.BV.runKernel(F.SpW,se)}});var T=h(2923),D=h(4944);const J=(0,N.op)({addN_:function G(be){D.hu(Array.isArray(be),()=>"The argument passed to tf.addN() must be a list of tensors"),D.hu(be.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${be.length}`);const he=be.map(($e,Ze)=>(0,I._1)($e,`tensors${Ze}`,"addN")),se=he[0];return he.forEach($e=>{if($e.dtype!==se.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),he.forEach($e=>{if(!D.cO($e.shape,se.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),y.BV.runKernel(F.Xze,he)}}),_e=(0,N.op)({all_:function K(be,he=null,se=!1){const $e={x:(0,I._1)(be,"x","all","bool")};return y.BV.runKernel(F.oT6,$e,{axis:he,keepDims:se})}}),we=(0,N.op)({any_:function Re(be,he=null,se=!1){const $e={x:(0,I._1)(be,"x","any","bool")};return y.BV.runKernel(F.IKK,$e,{axis:he,keepDims:se})}}),Oe=(0,N.op)({argMax_:function We(be,he=0){const Ie={x:(0,I._1)(be,"x","argMax")};return y.BV.runKernel(F.sJF,Ie,{axis:he})}}),Le=(0,N.op)({argMin_:function ie(be,he=0){const Ie={x:(0,I._1)(be,"x","argMin")};return y.BV.runKernel(F.aJk,Ie,{axis:he})}}),te=(0,N.op)({asin_:function De(be){const se={x:(0,I._1)(be,"x","asin")};return y.BV.runKernel(F.M2y,se)}}),P=(0,N.op)({asinh_:function de(be){const se={x:(0,I._1)(be,"x","asinh")};return y.BV.runKernel(F.qw7,se)}}),ye=(0,N.op)({atan_:function oe(be){const se={x:(0,I._1)(be,"x","atan")};return y.BV.runKernel(F.jMg,se)}});var Te=h(1931);const at=(0,N.op)({atan2_:function v(be,he){let se=(0,I._1)(be,"a","atan2"),Ie=(0,I._1)(he,"b","atan2");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),y.BV.runKernel(F.QCc,{a:se,b:Ie})}}),Ue=(0,N.op)({atanh_:function Xe(be){const se={x:(0,I._1)(be,"x","atanh")};return y.BV.runKernel(F.Oyi,se)}});var pt=h(8622),Ct=h(9992),It=h(1791);const Bt=(0,N.op)({avgPool_:function nn(be,he,se,Ie,$e){const Ze=(0,I._1)(be,"x","avgPool","float32");D.hu(Ct.jT(se,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${se} and dilations '1'`);let Dt=Ze,Ht=!1;3===Ze.rank&&(Ht=!0,Dt=(0,It.X)(Ze,[1,Ze.shape[0],Ze.shape[1],Ze.shape[2]])),D.hu(4===Dt.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${Dt.rank}.`),Ct.m("avgPool",Ie,$e);let wn=y.BV.runKernel(F.JhU,{x:Dt},{filterSize:he,strides:se,pad:Ie,dimRoundingMode:$e});return wn=(0,pt.p)(wn,Ze.dtype),Ht?(0,It.X)(wn,[wn.shape[1],wn.shape[2],wn.shape[3]]):wn}}),Qn=(0,N.op)({avgPool3d_:function bn(be,he,se,Ie,$e,Ze="NDHWC"){const ct=(0,I._1)(be,"x","avgPool3d","float32");let Dt=ct,Ht=!1;4===ct.rank&&(Ht=!0,Dt=(0,It.X)(ct,[1,ct.shape[0],ct.shape[1],ct.shape[2],ct.shape[3]])),D.hu(5===Dt.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${Dt.rank}.`),D.hu("NDHWC"===Ze,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${Ze}`),(0,Ct.m)("avgPool3d",Ie,$e);let wn=y.BV.runKernel(F._k9,{x:Dt},{filterSize:he,strides:se,pad:Ie,dimRoundingMode:$e,dataFormat:Ze});return wn=(0,pt.p)(wn,Dt.dtype),Ht?(0,It.X)(wn,[wn.shape[1],wn.shape[2],wn.shape[3],wn.shape[4]]):wn}});var Dn=h(1676);const Es=(0,N.op)({concat_:function ps(be,he=0){(0,D.hu)(be.length>=1,()=>"Pass at least one tensor to concat");const se=(0,I.sI)(be,"tensors","concat","string_or_numeric");return"complex64"===se[0].dtype&&se.forEach(Ze=>{if("complex64"!==Ze.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${Ze.dtype}. `)}),1===se.length?(0,Dn.d)(se[0]):y.BV.runKernel(F.Eh3,se,{axis:he})}});var Xn=h(5069),Ts=h(6008),or=h(7690);const Ss=(0,N.op)({slice_:function Ir(be,he,se){const Ie=(0,I._1)(be,"x","slice","string_or_numeric");if(0===Ie.rank)throw new Error("Slicing scalar is not possible");return y.BV.runKernel(F.p2w,{x:Ie},{begin:he,size:se})}}),Lt=(0,N.op)({tanh_:function Qe(be){const se={x:(0,I._1)(be,"x","tanh","float32")};return y.BV.runKernel(F.MIZ,se)}}),Nn=(0,N.op)({basicLSTMCell_:function Qt(be,he,se,Ie,$e,Ze){const ct=(0,I._1)(be,"forgetBias","basicLSTMCell"),Dt=(0,I._1)(he,"lstmKernel","basicLSTMCell"),Ht=(0,I._1)(se,"lstmBias","basicLSTMCell"),Gt=(0,I._1)(Ie,"data","basicLSTMCell"),vn=(0,I._1)($e,"c","basicLSTMCell"),wn=(0,I._1)(Ze,"h","basicLSTMCell"),cs=Es([Gt,wn],1),Hs=(0,Xn.O)(cs,Dt),fr=(0,T.I)(Hs,Ht),Dr=fr.shape[1]/4,mr=[fr.shape[0],Dr],_a=Ss(fr,[0,0],mr),Gr=Ss(fr,[0,Dr],mr),ul=Ss(fr,[0,2*Dr],mr),Jl=Ss(fr,[0,3*Dr],mr),Ji=(0,T.I)((0,Ts.d)((0,or.X)(_a),Lt(Gr)),(0,Ts.d)(vn,(0,or.X)((0,T.I)(ct,ul))));return[Ji,(0,Ts.d)(Lt(Ji),(0,or.X)(Jl))]}}),zs=(0,N.op)({batchToSpaceND_:function Os(be,he,se){const Ie=(0,I._1)(be,"x","batchToSpaceND"),$e=he.reduce((Dt,Ht)=>Dt*Ht);return D.hu(Ie.rank>=1+he.length,()=>`input rank is ${Ie.rank} but should be > than blockShape.length ${he.length}`),D.hu(se.length===he.length,()=>`crops.length is ${se.length} but should be equal to blockShape.length  ${he.length}`),D.hu(Ie.shape[0]%$e==0,()=>`input tensor batch is ${Ie.shape[0]} but is not divisible by the product of the elements of blockShape ${he.join(" * ")} === ${$e}`),y.BV.runKernel(F.zws,{x:Ie},{blockShape:he,crops:se})}});function cr(be){let he;return he=0===be.rank||1===be.rank?(0,It.X)(be,[1,1,1,be.size]):2===be.rank?(0,It.X)(be,[1,1,be.shape[0],be.shape[1]]):3===be.rank?(0,It.X)(be,[1,be.shape[0],be.shape[1],be.shape[2]]):be,he}const $r=(0,N.op)({batchNorm_:function xr(be,he,se,Ie,$e,Ze){null==Ze&&(Ze=.001);const ct=(0,I._1)(be,"x","batchNorm"),Dt=(0,I._1)(he,"mean","batchNorm"),Ht=(0,I._1)(se,"variance","batchNorm");let Gt,vn;null!=$e&&(Gt=(0,I._1)($e,"scale","batchNorm")),null!=Ie&&(vn=(0,I._1)(Ie,"offset","batchNorm")),D.hu(Dt.rank===Ht.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D.hu(null==vn||Dt.rank===vn.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D.hu(null==Gt||Dt.rank===Gt.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const cs={x:cr(ct),scale:Gt,offset:vn,mean:Dt,variance:Ht},fr=y.BV.runKernel(F.sHE,cs,{varianceEpsilon:Ze});return(0,It.X)(fr,ct.shape)}}),oa=(0,N.op)({batchNorm2d_:function eo(be,he,se,Ie,$e,Ze){const ct=(0,I._1)(be,"x","batchNorm"),Dt=(0,I._1)(he,"mean","batchNorm"),Ht=(0,I._1)(se,"variance","batchNorm");let Gt,vn;return null!=$e&&(Gt=(0,I._1)($e,"scale","batchNorm")),null!=Ie&&(vn=(0,I._1)(Ie,"offset","batchNorm")),D.hu(2===ct.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${ct.rank}.`),D.hu(2===Dt.rank||1===Dt.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${Dt.rank}.`),D.hu(2===Ht.rank||1===Ht.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${Ht.rank}.`),null!=Gt&&D.hu(2===Gt.rank||1===Gt.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${Gt.rank}.`),null!=vn&&D.hu(2===vn.rank||1===vn.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${vn.rank}.`),$r(ct,Dt,Ht,vn,Gt,Ze)}}),Po=(0,N.op)({batchNorm3d_:function aa(be,he,se,Ie,$e,Ze){const ct=(0,I._1)(be,"x","batchNorm"),Dt=(0,I._1)(he,"mean","batchNorm"),Ht=(0,I._1)(se,"variance","batchNorm");let Gt,vn;return null!=$e&&(Gt=(0,I._1)($e,"scale","batchNorm")),null!=Ie&&(vn=(0,I._1)(Ie,"offset","batchNorm")),D.hu(3===ct.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${ct.rank}.`),D.hu(3===Dt.rank||1===Dt.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${Dt.rank}.`),D.hu(3===Ht.rank||1===Ht.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${Ht.rank}.`),null!=Gt&&D.hu(3===Gt.rank||1===Gt.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${Gt.rank}.`),null!=vn&&D.hu(3===vn.rank||1===vn.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${vn.rank}.`),$r(ct,Dt,Ht,vn,Gt,Ze)}}),za=(0,N.op)({batchNorm4d_:function xa(be,he,se,Ie,$e,Ze){const ct=(0,I._1)(be,"x","batchNorm"),Dt=(0,I._1)(he,"mean","batchNorm"),Ht=(0,I._1)(se,"variance","batchNorm");let Gt,vn;return null!=$e&&(Gt=(0,I._1)($e,"scale","batchNorm")),null!=Ie&&(vn=(0,I._1)(Ie,"offset","batchNorm")),D.hu(4===ct.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${ct.rank}.`),D.hu(4===Dt.rank||1===Dt.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${Dt.rank}.`),D.hu(4===Ht.rank||1===Ht.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${Ht.rank}.`),null!=Gt&&D.hu(4===Gt.rank||1===Gt.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${Gt.rank}.`),null!=vn&&D.hu(4===vn.rank||1===vn.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${vn.rank}.`),$r(ct,Dt,Ht,vn,Gt,Ze)}}),lo=(0,N.op)({bincount_:function To(be,he,se){const Ie=(0,I._1)(be,"x","bincount"),$e=(0,I._1)(he,"weights","bincount");return D.hu("int32"===Ie.dtype,()=>`Error in bincount: input dtype must be int32, but got ${Ie.dtype}`),D.hu(se>=0,()=>`size must be non-negative, but got ${se}.`),D.hu($e.size===Ie.size||0===$e.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${Ie.shape}, weights shape: ${$e.shape}.`),y.BV.runKernel(F.zvY,{x:Ie,weights:$e},{size:se})}}),Ho=(0,N.op)({broadcastArgs_:function Ao(be,he){const se=(0,I._1)(be,"s0","broadcastArgs","int32"),Ie=(0,I._1)(he,"s1","broadcastArgs","int32");if(1!==se.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${se.rank}`);if(1!==Ie.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${Ie.rank}`);return y.BV.runKernel(F.eEB,{s0:se,s1:Ie})}}),ka=(0,N.op)({broadcastTo_:function sl(be,he){let se=(0,I._1)(be,"broadcastTo","x");const Ie=se.shape;if(he.some(Gt=>!(Gt>0)||Gt%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${he}].`);if(he.length<se.rank)throw new Error(`broadcastTo(): shape.length=${he.length} < input.rank=${se.rank}.`);if(he.length>se.rank){const Gt=se.shape.slice();for(;Gt.length<he.length;)Gt.unshift(1);se=(0,It.X)(se,Gt)}const $e=se.shape,Ze=Array.from(he);for(let Gt=he.length-1;Gt>=0;Gt--)if($e[Gt]===he[Gt])Ze[Gt]=1;else if(1!==se.shape[Gt])throw new Error(`broadcastTo(): [${Ie}] cannot be broadcast to [${he}].`);return 0===Ze.map((Gt,vn)=>Gt>1?vn:-1).filter(Gt=>Gt>=0).length?(0,Dn.d)(se):y.BV.runKernel(F.n9L,{x:se},{reps:Ze})}});var to=h(94);const Wa=(0,N.op)({ceil_:function rl(be){const se={x:(0,I._1)(be,"x","ceil","float32")};return y.BV.runKernel(F.gJX,se)}});var Fo=h(3541);const qe=(0,N.op)({clipByValue_:function Ha(be,he,se){const Ie=(0,I._1)(be,"x","clipByValue");return D.hu(he<=se,()=>`Error in clip: min (${he}) must be less than or equal to max (${se}).`),he===se?(0,Fo.h)(Ie.shape,he,Ie.dtype):y.BV.runKernel(F.xnO,{x:Ie},{clipValueMin:he,clipValueMax:se})}});var jo=h(7507);const $s=(0,N.op)({concat1d_:function la(be){return Es(be,0)}}),ui=(0,N.op)({concat2d_:function co(be,he){return Es(be,he)}}),Go=(0,N.op)({concat3d_:function ja(be,he){return Es(be,he)}}),wa=(0,N.op)({concat4d_:function Li(be,he){return Es(be,he)}}),Xi=(0,N.op)({conv2d_:function Ki(be,he,se,Ie,$e="NHWC",Ze=[1,1],ct){const Dt=(0,I._1)(be,"x","conv2d","float32"),Ht=(0,I._1)(he,"filter","conv2d","float32");let Gt=Dt,vn=!1;3===Dt.rank&&(vn=!0,Gt=(0,It.X)(Dt,[1,Dt.shape[0],Dt.shape[1],Dt.shape[2]])),D.hu(4===Gt.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${Gt.rank}.`),D.hu(4===Ht.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${Ht.rank}.`),Ct.m("conv2d",Ie,ct);const wn="NHWC"===$e?Gt.shape[3]:Gt.shape[1];D.hu(wn===Ht.shape[2],()=>`Error in conv2d: depth of input (${wn}) must match input depth for filter ${Ht.shape[2]}.`),D.hu(Ct.jT(se,Ze),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${se} and dilations '${Ze}'`);const fr=y.BV.runKernel(F.mhS,{x:Gt,filter:Ht},{strides:se,pad:Ie,dataFormat:$e,dilations:Ze,dimRoundingMode:ct});return vn?(0,It.X)(fr,[fr.shape[1],fr.shape[2],fr.shape[3]]):fr}}),Bi=(0,N.op)({conv1d_:function $i(be,he,se,Ie,$e="NWC",Ze=1,ct){const Dt=(0,I._1)(be,"x","conv1d"),Ht=(0,I._1)(he,"filter","conv1d");let Gt=Dt,vn=!1;2===Dt.rank&&(vn=!0,Gt=(0,It.X)(Dt,[1,Dt.shape[0],Dt.shape[1]])),D.hu(3===Gt.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${Gt.rank}.`),D.hu(3===Ht.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${Ht.rank}.`),Ct.m("conv1d",Ie,ct),D.hu(Gt.shape[2]===Ht.shape[1],()=>`Error in conv1d: depth of input (${Gt.shape[2]}) must match input depth for filter ${Ht.shape[1]}.`),D.hu(Ct.jT(se,Ze),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${se} and dilation '${Ze}'`),D.hu("NWC"===$e,()=>`Error in conv1d: got dataFormat of ${$e} but only NWC is currently supported.`);const wn=(0,It.X)(Ht,[1,Ht.shape[0],Ht.shape[1],Ht.shape[2]]),cs=(0,It.X)(Gt,[Gt.shape[0],1,Gt.shape[1],Gt.shape[2]]),Dr=Xi(cs,wn,[1,se],Ie,"NHWC",[1,Ze],ct);return(0,It.X)(Dr,vn?[Dr.shape[2],Dr.shape[3]]:[Dr.shape[0],Dr.shape[2],Dr.shape[3]])}}),Jr=(0,N.op)({conv2DBackpropInput_:function hl(be,he,se,Ie,$e,Ze="NHWC",ct){D.hu(be.length===he.rank,()=>`Length of inShape (${be.length}) and rank of dy (${he.rank}) must match`);let Dt=be,Ht=he,Gt=!1;3===he.rank&&(Gt=!0,Ht=(0,It.X)(he,[1,he.shape[0],he.shape[1],he.shape[2]]),Dt=[1,be[0],be[1],be[2]]),D.hu(4===Dt.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${Dt.length}.`),D.hu(4===Ht.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${Ht.rank}`),D.hu(4===se.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${se.rank}`);const vn="NHWC"===Ze?Dt[3]:Dt[1],wn="NHWC"===Ze?Ht.shape[3]:Ht.shape[1];D.hu(vn===se.shape[2],()=>`Error in conv2dDerInput: depth of input (${vn}) must match input depth for filter ${se.shape[2]}.`),D.hu(wn===se.shape[3],()=>`Error in conv2dDerInput: depth of output (${wn}) must match output depth for filter ${se.shape[3]}.`),Ct.m("conv2dDerInput",$e,ct);const fr=y.BV.runKernel(F.wm,{dy:Ht,filter:se},{strides:Ie,pad:$e,dataFormat:Ze,dimRoundingMode:ct,inputShape:Dt});return Gt?(0,It.X)(fr,[fr.shape[1],fr.shape[2],fr.shape[3]]):fr}}),dc=(0,N.op)({conv2dTranspose_:function Lo(be,he,se,Ie,$e,Ze){const ct=(0,I._1)(be,"x","conv2dTranspose"),Dt=(0,I._1)(he,"filter","conv2dTranspose");return Jr(se,ct,Dt,Ie,$e,"NHWC",Ze)}}),Ga=(0,N.op)({conv3d_:function hc(be,he,se,Ie,$e="NDHWC",Ze=[1,1,1]){const ct=(0,I._1)(be,"x","conv3d"),Dt=(0,I._1)(he,"filter","conv3d");let Ht=ct,Gt=!1;4===ct.rank&&(Gt=!0,Ht=(0,It.X)(ct,[1,ct.shape[0],ct.shape[1],ct.shape[2],ct.shape[3]])),D.hu(5===Ht.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${Ht.rank}.`),D.hu(5===Dt.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${Dt.rank}.`),D.hu(Ht.shape[4]===Dt.shape[3],()=>`Error in conv3d: depth of input (${Ht.shape[4]}) must match input depth for filter ${Dt.shape[3]}.`),D.hu((0,Ct.jT)(se,Ze),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${se} and dilations '${Ze}'`),D.hu("NDHWC"===$e,()=>`Error in conv3d: got dataFormat of ${$e} but only NDHWC is currently supported.`);const cs=y.BV.runKernel(F.x12,{x:Ht,filter:Dt},{strides:se,pad:Ie,dataFormat:$e,dilations:Ze});return Gt?(0,It.X)(cs,[cs.shape[1],cs.shape[2],cs.shape[3],cs.shape[4]]):cs}}),pc=(0,N.op)({conv3DBackpropInput_:function Ko(be,he,se,Ie,$e){D.hu(be.length===he.rank,()=>`Length of inShape (${be.length}) and rank of dy (${he.rank}) must match`);let Ze=be,ct=he,Dt=!1;4===he.rank&&(Dt=!0,ct=(0,It.X)(he,[1,he.shape[0],he.shape[1],he.shape[2],he.shape[3]]),Ze=[1,be[0],be[1],be[2],be[3]]);const Ht=Ze[4],Gt=ct.shape[4];D.hu(5===Ze.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${Ze.length}.`),D.hu(5===ct.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${ct.rank}`),D.hu(5===se.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${se.rank}`),D.hu(Ht===se.shape[3],()=>`Error in conv3dDerInput: depth of input (${Ht}) must match input depth for filter ${se.shape[3]}.`),D.hu(Gt===se.shape[4],()=>`Error in conv3dDerInput: depth of output (${Gt}) must match output depth for filter ${se.shape[4]}.`);const cs=y.BV.runKernel(F.ik2,{dy:ct,filter:se},{pad:$e,strides:Ie,inputShape:Ze});return Dt?(0,It.X)(cs,[cs.shape[1],cs.shape[2],cs.shape[3],cs.shape[4]]):cs}}),ko=(0,N.op)({conv3dTranspose_:function pl(be,he,se,Ie,$e){const Ze=(0,I._1)(be,"x","conv3dTranspose"),ct=(0,I._1)(he,"filter","conv3dTranspose");return pc(se,Ze,ct,Ie,$e)}}),no=(0,N.op)({cos_:function fl(be){const se={x:(0,I._1)(be,"x","cos","float32")};return y.BV.runKernel(F.mc4,se)}}),so=(0,N.op)({cosh_:function Ka(be){const se={x:(0,I._1)(be,"x","cosh","float32")};return y.BV.runKernel(F.TR1,se)}}),Yi=(0,N.op)({cumprod_:function il(be,he=0,se=!1,Ie=!1){const Ze={x:(0,I._1)(be,"x","cumprod")};return y.BV.runKernel(F.Byc,Ze,{axis:he,exclusive:se,reverse:Ie})}}),zl=(0,N.op)({cumsum_:function fc(be,he=0,se=!1,Ie=!1){const Ze={x:(0,I._1)(be,"x","cumsum")};return y.BV.runKernel(F.iHb,Ze,{axis:he,exclusive:se,reverse:Ie})}}),Xa=(0,N.op)({denseBincount_:function ol(be,he,se,Ie=!1){const $e=(0,I._1)(be,"x","denseBincount"),Ze=(0,I._1)(he,"weights","denseBincount");return D.hu("int32"===$e.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${$e.dtype}`),D.hu($e.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${$e.rank}.`),D.hu(se>=0,()=>`size must be non-negative, but got ${se}.`),D.hu(Ze.size===$e.size||0===Ze.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${$e.shape}, weights shape: ${Ze.shape}.`),y.BV.runKernel(F.QRR,{x:$e,weights:Ze},{size:se,binaryOutput:Ie})}}),vi=(0,N.op)({depthToSpace_:function Js(be,he,se="NHWC"){const Ie=(0,I._1)(be,"x","depthToSpace","float32"),$e="NHWC"===se?Ie.shape[1]:Ie.shape[2],Ze="NHWC"===se?Ie.shape[2]:Ie.shape[3],ct="NHWC"===se?Ie.shape[3]:Ie.shape[1];return D.hu(he>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${he}`),D.hu($e*he>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${$e} and ${he}  for depthToSpace with input shape\n    ${Ie.shape}`),D.hu(Ze*he>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${Ze} and ${he} for depthToSpace with input shape\n        ${Ie.shape}`),D.hu(ct%(he*he)==0,()=>`Dimension size must be evenly divisible by ${he*he} but is ${ct} for depthToSpace with input shape ${Ie.shape}`),y.BV.runKernel(F.T0n,{x:Ie},{blockSize:he,dataFormat:se})}}),Pr=(0,N.op)({depthwiseConv2d_:function $o(be,he,se,Ie,$e="NHWC",Ze=[1,1],ct){const Dt=(0,I._1)(be,"x","depthwiseConv2d","float32"),Ht=(0,I._1)(he,"filter","depthwiseConv2d","float32");let Gt=Dt,vn=!1;3===Dt.rank&&(vn=!0,Gt=(0,It.X)(Dt,[1,Dt.shape[0],Dt.shape[1],Dt.shape[2]])),D.hu(4===Gt.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${Gt.rank}.`),D.hu(4===Ht.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${Ht.rank}.`);const wn="NHWC"===$e?Gt.shape[3]:Gt.shape[1];D.hu(wn===Ht.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${wn}) must match the inChannels dimension in filter ${Ht.shape[2]}.`),Ct.m("depthwiseConv2d",Ie,ct);const fr=y.BV.runKernel(F.cie,{x:Gt,filter:Ht},{strides:se,pad:Ie,dataFormat:$e,dilations:Ze,dimRoundingMode:ct});return vn?(0,It.X)(fr,[fr.shape[1],fr.shape[2],fr.shape[3]]):fr}}),Al=(0,N.op)({diag_:function Oa(be){const se={x:(0,I._1)(be,"x","diag")};return y.BV.runKernel(F.$w,se)}}),Ra=(0,N.op)({dilation2d_:function uo(be,he,se,Ie,$e=[1,1],Ze="NHWC"){const ct=(0,I._1)(be,"x","dilation2d"),Dt=(0,I._1)(he,"filter","dilation2d");D.hu(3===ct.rank||4===ct.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${ct.rank}.`),D.hu(3===Dt.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${Dt.rank}.`),D.hu("NHWC"===Ze,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${Ze}`);let Ht=ct,Gt=!1;3===ct.rank&&(Ht=(0,It.X)(ct,[1,ct.shape[0],ct.shape[1],ct.shape[2]]),Gt=!0);const cs=y.BV.runKernel(F.p4S,{x:Ht,filter:Dt},{strides:se,pad:Ie,dilations:$e});return Gt?(0,It.X)(cs,[cs.shape[1],cs.shape[2],cs.shape[3]]):cs}});var Zi=h(9526),Oo=h(9741);const ji=(0,N.op)({equal_:function Hi(be,he){let se=(0,I._1)(be,"a","equal","string_or_numeric"),Ie=(0,I._1)(he,"b","equal","string_or_numeric");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.hdR,{a:se,b:Ie})}}),Xs=(0,N.op)({where_:function Di(be,he,se){const Ie=(0,I._1)(he,"a","where"),$e=(0,I._1)(se,"b","where"),Ze=(0,I._1)(be,"condition","where","bool"),ct=(0,Oo.assertAndGetBroadcastShape)((0,Oo.assertAndGetBroadcastShape)(Ze.shape,Ie.shape),$e.shape),Dt=ka(Ze,ct),Ht=ka(Ie,ct),Gt=ka($e,ct);return y.BV.runKernel(F.PhF,{condition:Dt,t:Ht,e:Gt})}});var ro=h(7804);const Qi=(0,N.op)({divNoNan_:function pa(be,he){let se=(0,I._1)(be,"a","div"),Ie=(0,I._1)(he,"b","div");[se,Ie]=(0,Te.makeTypesMatch)(se,Ie);const $e=(0,Zi.h)(se,Ie),Ze=(0,ro.P)($e),ct=ji(Ie,Ze);return Xs(ct,Ze,$e)}}),fa=(0,N.op)({dot_:function al(be,he){const se=(0,I._1)(be,"t1","dot"),Ie=(0,I._1)(he,"t2","dot");D.hu(!(1!==se.rank&&2!==se.rank||1!==Ie.rank&&2!==Ie.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${se.rank} and ${Ie.rank}.`);const $e=1===se.rank?se.size:se.shape[1],Ze=1===Ie.rank?Ie.size:Ie.shape[0];if(D.hu($e===Ze,()=>`Error in dot: inner dimensions of inputs must match, but got ${$e} and ${Ze}.`),1===se.rank&&1===Ie.rank){const ct=(0,It.X)(se,[1,-1]),Dt=(0,It.X)(Ie,[-1,1]),Ht=(0,Xn.O)(ct,Dt);return(0,It.X)(Ht,[])}if(1===se.rank&&2===Ie.rank){const ct=(0,It.X)(se,[1,-1]),Dt=(0,It.X)(Ie,[Ie.shape[0],Ie.shape[1]]),Ht=(0,Xn.O)(ct,Dt);return(0,It.X)(Ht,[Ht.size])}if(2===se.rank&&1===Ie.rank){const ct=(0,It.X)(Ie,[-1,1]),Dt=(0,Xn.O)(se,ct);return(0,It.X)(Dt,[Dt.size])}{const ct=(0,It.X)(Ie,[Ie.shape[0],Ie.shape[1]]);return(0,Xn.O)(se,ct)}}}),ma=(0,N.op)({einsum_:function di(be,...he){const se=he.map(($e,Ze)=>(0,I._1)($e,`tensors${Ze}`,"einsum"));return y.BV.runKernel(F.$g6,se,{equation:be})}});var mo=h(7828);const ic=(0,N.op)({erf_:function mi(be){let he=(0,I._1)(be,"x","erf");return D.hu("int32"===he.dtype||"float32"===he.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===he.dtype&&(he=(0,pt.p)(he,"float32")),y.BV.runKernel(F.Omj,{x:he})}});var Br=h(4588);const Xo=(0,N.op)({max_:function dr(be,he=null,se=!1){const $e={x:(0,I._1)(be,"x","max")};return y.BV.runKernel(F.YoZ,$e,{reductionIndices:he,keepDims:se})}}),ml=(0,N.op)({min_:function go(be,he=null,se=!1){const $e={x:(0,I._1)(be,"x","min")};return y.BV.runKernel(F.c17,$e,{axis:he,keepDims:se})}});var Na=h(1712),En=h(9418),ki=h(9949),wr=h(1616),ar=h(2149);function gn(be,he,se=null){if(0===be.rank)return(0,Z.W)(be);if(1!==be.rank&&null===se)return gn((0,It.X)(be,[-1]),he,se);if(1===be.rank||"number"==typeof se||Array.isArray(se)&&1===se.length){if(1===he)return(0,ar.S)((0,Z.W)(be),se);if(he===1/0)return Xo((0,Z.W)(be),se);if(he===-1/0)return ml((0,Z.W)(be),se);if("euclidean"===he||2===he)return(0,ki._)((0,ar.S)((0,Na.s)((0,Z.W)(be),(0,En.i)(2,"int32")),se));throw new Error(`Error in norm: invalid ord value: ${he}`)}if(Array.isArray(se)&&2===se.length){if(1===he)return Xo((0,ar.S)((0,Z.W)(be),se[0]),se[1]-1);if(he===1/0)return Xo((0,ar.S)((0,Z.W)(be),se[1]),se[0]);if(he===-1/0)return ml((0,ar.S)((0,Z.W)(be),se[1]),se[0]);if("fro"===he||"euclidean"===he)return(0,ki._)((0,ar.S)((0,wr.h)(be),se));throw new Error(`Error in norm: invalid ord value: ${he}`)}throw new Error(`Error in norm: invalid axis: ${se}`)}const qr=(0,N.op)({norm_:function Ma(be,he="euclidean",se=null,Ie=!1){const $e=gn(be=(0,I._1)(be,"x","norm"),he,se);let Ze=$e.shape;if(Ie){const ct=(0,D.EC)(se,be.shape);Ze=Br.rv($e.shape,ct)}return(0,It.X)($e,Ze)}}),_o=(0,N.op)({euclideanNorm_:function Wl(be,he=null,se=!1){return qr(be,"euclidean",he,se)}}),Ro=(0,N.op)({exp_:function mc(be){const se={x:(0,I._1)(be,"x","exp")};return y.BV.runKernel(F.NEP,se)}}),Si=(0,N.op)({expandDims_:function ll(be,he=0){const se=(0,I._1)(be,"x","expandDims","string_or_numeric");return D.hu(he<=se.rank,()=>"Axis must be <= rank of the tensor"),y.BV.runKernel(F.YFo,{input:se},{dim:he})}}),Pa=(0,N.op)({expm1_:function Ca(be){const se={x:(0,I._1)(be,"x","expm1")};return y.BV.runKernel(F.Y0y,se)}}),gl=(0,N.op)({tile_:function Ea(be,he){const se=(0,I._1)(be,"x","tile","string_or_numeric");return D.hu(se.rank===he.length,()=>`Error in transpose: rank of input ${se.rank} must match length of reps ${he}.`),y.BV.runKernel(F.n9L,{x:se},{reps:he})}}),q=(0,N.op)({eye_:function _l(be,he,se,Ie="float32"){null==he&&(he=be);const $e=(0,to.f)([be,he],Ie),Ze=be<=he?be:he;for(let Dt=0;Dt<Ze;++Dt)$e.set(1,Dt,Dt);const ct=(0,It.X)($e.toTensor(),[be,he]);if(null==se)return ct;if(1===se.length)return gl(Si(ct,0),[se[0],1,1]);if(2===se.length)return gl(Si(Si(ct,0),0),[se[0],se[1],1,1]);if(3===se.length)return gl(Si(Si(Si(ct,0),0),0),[se[0],se[1],se[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${se.length}D.`)}}),X=(0,N.op)({floor_:function L(be){const se={x:(0,I._1)(be,"x","floor","float32")};return y.BV.runKernel(F.OR,se)}});var Ae=h(2266);const Ye=(0,N.op)({gather_:function He(be,he,se=0,Ie=0){const $e=(0,I._1)(be,"x","gather"),Ze=(0,I._1)(he,"indices","gather","int32");return y.BV.runKernel(F.qi_,{x:$e,indices:Ze},{axis:se,batchDims:Ie})}}),_t=(0,N.op)({greater_:function it(be,he){let se=(0,I._1)(be,"a","greater","string_or_numeric"),Ie=(0,I._1)(he,"b","greater","string_or_numeric");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.iZT,{a:se,b:Ie})}}),kn=(0,N.op)({greaterEqual_:function wt(be,he){let se=(0,I._1)(be,"a","greaterEqual","string_or_numeric"),Ie=(0,I._1)(he,"b","greaterEqual","string_or_numeric");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.Acj,{a:se,b:Ie})}});var pn=h(2556);const os=(0,N.op)({isFinite_:function qn(be){const se={x:(0,I._1)(be,"x","isFinite")};return y.BV.runKernel(F.avt,se)}}),Tr=(0,N.op)({isInf_:function Ms(be){const se={x:(0,I._1)(be,"x","isInf")};return y.BV.runKernel(F.iWB,se)}}),Is=(0,N.op)({isNaN_:function Cr(be){const se={x:(0,I._1)(be,"x","isNaN")};return y.BV.runKernel(F.r7n,se)}});var lr=h(3183);const Da=(0,N.op)({less_:function yo(be,he){let se=(0,I._1)(be,"a","less","string_or_numeric"),Ie=(0,I._1)(he,"b","less","string_or_numeric");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.vtC,{a:se,b:Ie})}}),ai=(0,N.op)({lessEqual_:function Jt(be,he){let se=(0,I._1)(be,"a","lessEqual","string_or_numeric"),Ie=(0,I._1)(he,"b","lessEqual","string_or_numeric");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.CAk,{a:se,b:Ie})}});function oc(be,he,se){if(se<=0)throw new Error("The number of values should be positive.");return y.BV.runKernel(F.e7N,{},{start:be,stop:he,num:se})}const Fa=(0,N.op)({localResponseNormalization_:function wo(be,he=5,se=1,Ie=1,$e=.5){const Ze=(0,I._1)(be,"x","localResponseNormalization");D.hu(4===Ze.rank||3===Ze.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${Ze.rank}.`),D.hu(D.GN(he),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${he}.`);let ct=Ze,Dt=!1;3===Ze.rank&&(Dt=!0,ct=(0,It.X)(Ze,[1,Ze.shape[0],Ze.shape[1],Ze.shape[2]]));const vn=y.BV.runKernel(F.eZ0,{x:ct},{depthRadius:he,bias:se,alpha:Ie,beta:$e});return Dt?(0,It.X)(vn,[vn.shape[1],vn.shape[2],vn.shape[3]]):vn}}),Fi=(0,N.op)({log_:function yl(be){const se={x:(0,I._1)(be,"x","log","float32")};return y.BV.runKernel(F.ZbH,se)}}),Wu=(0,N.op)({log1p_:function Yc(be){const se={x:(0,I._1)(be,"x","log1p")};return y.BV.runKernel(F.kU,se)}});var vl=h(6541),Hl=h(7939);const Oc=(0,N.op)({softplus_:function Zc(be){const se={x:(0,I._1)(be,"x","softplus")};return y.BV.runKernel(F.MRv,se)}}),Qc=(0,N.op)({logSigmoid_:function Fc(be){const he=(0,I._1)(be,"x","logSigmoid");return(0,vl.cb)(Ie=>({value:(0,Hl.W)(Oc((0,Hl.W)(Ie))),gradFunc:ct=>(0,Ts.d)(ct,(0,or.X)((0,Hl.W)(Ie)))}))(he)}});var Ai=h(8837);const B=(0,N.op)({logSoftmax_:function Iu(be,he=-1){const se=(0,I._1)(be,"logits","logSoftmax");if(-1===he&&(he=se.rank-1),he!==se.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${se.rank} and axis was ${he}`);return(0,vl.cb)(($e,Ze)=>{const Dt=Xo($e,he,!0),Ht=(0,Ai.l)($e,Dt),Gt=(0,Ai.l)((0,pt.p)(Ht,"float32"),Fi((0,ar.S)(Ro(Ht),he,!0)));return Ze([Gt]),{value:Gt,gradFunc:(wn,cs)=>{const[Hs]=cs,Ii=Ro(Hs);return(0,Ai.l)(wn,(0,Ts.d)((0,ar.S)(wn,he,!0),Ii))}}})(se)}}),Be=(0,N.op)({logSumExp_:function ve(be,he=null,se=!1){const Ie=(0,I._1)(be,"x","logSumExp"),$e=(0,D.EC)(he,Ie.shape),Ze=Xo(Ie,$e,!0),ct=(0,Ai.l)(Ie,Ze),Dt=Ro(ct),Ht=(0,ar.S)(Dt,$e),Gt=Fi(Ht),vn=(0,T.I)((0,It.X)(Ze,Gt.shape),Gt);if(se){const wn=(0,Br.rv)(vn.shape,$e);return(0,It.X)(vn,wn)}return vn}}),st=(0,N.op)({logicalAnd_:function ot(be,he){const se=(0,I._1)(be,"a","logicalAnd","bool"),Ie=(0,I._1)(he,"b","logicalAnd","bool");return(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.PYm,{a:se,b:Ie})}}),jt=(0,N.op)({logicalNot_:function Xt(be){const se={x:(0,I._1)(be,"x","logicalNot","bool")};return y.BV.runKernel(F.VfG,se)}}),xn=(0,N.op)({logicalOr_:function Yt(be,he){const se=(0,I._1)(be,"a","logicalOr","bool"),Ie=(0,I._1)(he,"b","logicalOr","bool");return(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.MZg,{a:se,b:Ie})}}),Jn=(0,N.op)({logicalXor_:function ss(be,he){const se=(0,I._1)(be,"a","logicalXor","bool"),Ie=(0,I._1)(he,"b","logicalXor","bool");return(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),st(xn(be,he),jt(st(be,he)))}}),_r=2147483648,As=(0,N.op)({searchSorted_:function Qs(be,he,se="left"){const Ie=(0,I._1)(be,"sortedSequence","searchSorted"),$e=(0,I._1)(he,"values","searchSorted"),ct=$e.shape[$e.shape.length-1],Dt=(0,It.X)(Ie,[-1,Ie.shape[Ie.shape.length-1]]),Ht=(0,It.X)($e,[-1,ct]);if(Dt.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(Dt.shape[0]!==Ht.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,D.NA)(Ht.shape)>=_r)throw new Error(`values tensor size must less than ${_r}`);if(Dt.shape[1]>=_r)throw new Error(`trailing dim_size must less than ${_r} for int32 output type, was ${Dt.shape[1]}`);return y.BV.runKernel(F.nr8,{sortedSequence:Dt,values:Ht},{side:se})}});function cn(be,he){return As(be,he,"left")}const jn=(0,N.op)({maxPool_:function Zr(be,he,se,Ie,$e){const Ze=(0,I._1)(be,"x","maxPool");let Dt=Ze,Ht=!1;3===Ze.rank&&(Ht=!0,Dt=(0,It.X)(Ze,[1,Ze.shape[0],Ze.shape[1],Ze.shape[2]])),D.hu(4===Dt.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${Dt.rank}.`),D.hu(Ct.jT(se,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${se} and dilations '1'`),Ct.m("maxPool",Ie,$e);const wn=y.BV.runKernel(F.mTV,{x:Dt},{filterSize:he,strides:se,pad:Ie,dimRoundingMode:$e});return Ht?(0,It.X)(wn,[wn.shape[1],wn.shape[2],wn.shape[3]]):wn}}),ca=(0,N.op)({maxPool3d_:function Oi(be,he=[1,1,1],se,Ie,$e,Ze="NDHWC"){const ct=(0,I._1)(be,"x","maxPool3d");let Dt=ct,Ht=!1;4===ct.rank&&(Ht=!0,Dt=(0,It.X)(ct,[1,ct.shape[0],ct.shape[1],ct.shape[2],ct.shape[3]])),D.hu(5===Dt.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${Dt.rank}.`),D.hu("NDHWC"===Ze,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${Ze}`),(0,Ct.m)("maxPool3d",Ie,$e);const wn=y.BV.runKernel(F.OAf,{x:Dt},{filterSize:he,strides:se,pad:Ie,dimRoundingMode:$e,dataFormat:Ze});return Ht?(0,It.X)(wn,[wn.shape[1],wn.shape[2],wn.shape[3],wn.shape[4]]):wn}}),La=(0,N.op)({maxPoolWithArgmax_:function Yo(be,he,se,Ie,$e=!1){const ct={x:(0,I._1)(be,"x","maxPoolWithArgmax")},Ht=y.BV.runKernel(F.vFR,ct,{filterSize:he,strides:se,pad:Ie,includeBatchInIndex:$e});return{result:Ht[0],indexes:Ht[1]}}});var hi=h(685);const qt=(0,N.op)({mean_:function ci(be,he=null,se=!1){const $e={x:(0,I._1)(be,"x","mean")};return y.BV.runKernel(F.q2K,$e,{axis:he,keepDims:se})}});function jl(be,he="float32"){if("complex64"===he){const Ie=jl(be,"float32"),$e=jl(be,"float32");return(0,jo.P)(Ie,$e)}const se=(0,D.wT)((0,D.NA)(be),he);return y.BV.makeTensor(se,be,he)}function oo(be,he="float32"){if("complex64"===he){const Ie=oo(be,"float32"),$e=jl(be,"float32");return(0,jo.P)(Ie,$e)}const se=(0,D.p8)((0,D.NA)(be),he);return y.BV.makeTensor(se,be,he)}var Bo=h(9089);function wi(be,he,{indexing:se="xy"}={}){if("xy"!==se&&"ij"!==se)throw new TypeError(`${se} is not a valid third argument to meshgrid`);if(void 0===be)return[];let Ie=(0,I._1)(be,"x","meshgrid",be instanceof Bo.es?be.dtype:"float32");if(void 0===he)return[Ie];let $e=(0,I._1)(he,"y","meshgrid",he instanceof Bo.es?he.dtype:"float32");const Ze=(0,D.NA)(Ie.shape),ct=(0,D.NA)($e.shape);return"xy"===se?(Ie=(0,It.X)(Ie,[1,-1]),$e=(0,It.X)($e,[-1,1]),[(0,Xn.O)(oo([ct,1],Ie.dtype),Ie),(0,Xn.O)($e,oo([1,Ze],$e.dtype))]):(Ie=(0,It.X)(Ie,[-1,1]),$e=(0,It.X)($e,[1,-1]),[(0,Xn.O)(Ie,oo([1,ct],Ie.dtype)),(0,Xn.O)(oo([Ze,1],$e.dtype),$e)])}const Gi=(0,N.op)({minimum_:function $a(be,he){let se=(0,I._1)(be,"a","minimum"),Ie=(0,I._1)(he,"b","minimum");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),"bool"===se.dtype&&(se=(0,pt.p)(se,"int32"),Ie=(0,pt.p)(Ie,"int32")),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.q8u,{a:se,b:Ie})}}),an=(0,N.op)({mirrorPad_:function uu(be,he,se){D.hu("reflect"===se||"symmetric"===se,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${se}.`);const Ie=(0,I._1)(be,"x","mirrorPad");if(0===Ie.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D.hu(he.length===Ie.rank,()=>`Padding doesn't match input. Must be ${Ie.rank}. Got ${he.length}.`);const $e="reflect"===se?1:0;for(let Dt=0;Dt<Ie.rank;Dt++)D.hu(2===he[Dt].length,()=>"Invalid number of paddings. Must be length of 2 each."),D.hu(he[Dt][0]>=0&&he[Dt][0]<=Ie.shape[Dt]-$e&&he[Dt][1]>=0&&he[Dt][1]<=Ie.shape[Dt]-$e,()=>`Padding in dimension ${Dt} cannot be greater than or equal to ${Ie.shape[Dt]-$e} or less than 0 for input of shape ${Ie.shape}`);return y.BV.runKernel(F.jQs,{x:Ie},{paddings:he,mode:se})}}),Gl=(0,N.op)({mod_:function kl(be,he){let se=(0,I._1)(be,"a","mod"),Ie=(0,I._1)(he,"b","mod");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),y.BV.runKernel(F.Vbg,{a:se,b:Ie})}}),sd=(0,N.op)({moments_:function Tu(be,he=null,se=!1){be=(0,I._1)(be,"x","moments");const Ie=(0,D.EC)(he,be.shape),$e=qt(be,Ie,se);let Ze=$e.shape;se||(Ze=(0,Br.rv)($e.shape,Ie));const ct=(0,wr.h)((0,Ai.l)((0,pt.p)(be,"float32"),(0,It.X)($e,Ze)));return{mean:$e,variance:qt(ct,Ie,se)}}}),rd=(0,N.op)({multiRNNCell_:function gc(be,he,se,Ie){const $e=(0,I._1)(he,"data","multiRNNCell"),Ze=(0,I.sI)(se,"c","multiRNNCell"),ct=(0,I.sI)(Ie,"h","multiRNNCell");let Dt=$e;const Ht=[];for(let wn=0;wn<be.length;wn++){const cs=be[wn](Dt,Ze[wn],ct[wn]);Ht.push(cs[0]),Ht.push(cs[1]),Dt=cs[1]}const Gt=[],vn=[];for(let wn=0;wn<Ht.length;wn+=2)Gt.push(Ht[wn]),vn.push(Ht[wn+1]);return[Gt,vn]}}),V=(0,N.op)({multinomial_:function Au(be,he,se,Ie=!1){const $e=(0,I._1)(be,"logits","multinomial"),Ze=$e.size,ct=$e.rank;if(Ze<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${Ze}.`);if(ct>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${ct}`);se=se||Math.random();const Ht={logits:1===ct?(0,It.X)($e,[1,-1]):$e},vn=y.BV.runKernel(F.NZg,Ht,{numSamples:he,seed:se,normalized:Ie});return 1===ct?(0,It.X)(vn,[vn.size]):vn}}),z=(0,N.op)({notEqual_:function O(be,he){let se=(0,I._1)(be,"a","notEqual","string_or_numeric"),Ie=(0,I._1)(he,"b","notEqual","string_or_numeric");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F.yQU,{a:se,b:Ie})}});var pe=h(7395);const Ve=(0,N.op)({onesLike_:function Pe(be){const se={x:(0,I._1)(be,"x","onesLike")};return y.BV.runKernel(F.qWM,se)}}),mt=(0,N.op)({outerProduct_:function et(be,he){const se=(0,I._1)(be,"v1","outerProduct"),Ie=(0,I._1)(he,"v2","outerProduct");D.hu(1===se.rank&&1===Ie.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${se.rank} and ${Ie.rank}.`);const $e=(0,It.X)(se,[-1,1]),Ze=(0,It.X)(Ie,[1,-1]);return(0,Xn.O)($e,Ze)}}),mn=(0,N.op)({pad_:function Wt(be,he,se=0){const Ie=(0,I._1)(be,"x","pad");if(0===Ie.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return y.BV.runKernel(F.lyA,{x:Ie},{paddings:he,constantValue:se})}}),$n=(0,N.op)({pad1d_:function rn(be,he,se=0){return(0,D.hu)(2===he.length,()=>"Invalid number of paddings. Must be length of 2."),mn(be,[he],se)}}),Bs=(0,N.op)({pad2d_:function zn(be,he,se=0){return(0,D.hu)(2===he.length&&2===he[0].length&&2===he[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),mn(be,he,se)}}),Rs=(0,N.op)({pad3d_:function ur(be,he,se=0){return(0,D.hu)(3===he.length&&2===he[0].length&&2===he[1].length&&2===he[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),mn(be,he,se)}}),zr=(0,N.op)({pad4d_:function Or(be,he,se=0){return(0,D.hu)(4===he.length&&2===he[0].length&&2===he[1].length&&2===he[2].length&&2===he[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),mn(be,he,se)}}),No=(0,N.op)({spaceToBatchND_:function sr(be,he,se){const Ie=(0,I._1)(be,"x","spaceToBatchND");return D.hu(Ie.rank>=1+he.length,()=>`input rank ${Ie.rank} should be > than [blockShape] ${he.length}`),D.hu(se.length===he.length,()=>`paddings.shape[0] ${se.length} must be equal to [blockShape] ${he.length}`),D.hu(Ie.shape.reduce((ct,Dt,Ht)=>Ht>0&&Ht<=he.length?ct&&(Dt+se[Ht-1][0]+se[Ht-1][1])%he[Ht-1]==0:ct,!0),()=>`input spatial dimensions ${Ie.shape.slice(1)} with paddings ${se.toString()} must be divisible by blockShapes ${he.toString()}`),y.BV.runKernel(F.TQc,{x:Ie},{blockShape:he,paddings:se})}}),Ec=(0,N.op)({pool_:function ho(be,he,se,Ie,$e,Ze,ct){null==$e&&($e=[1,1]),null==Ze&&(Ze=1),0===Ie&&(Ie="valid");const Dt=(0,I._1)(be,"x","maxPool");let Ht=Dt,Gt=!1;3===Dt.rank&&(Gt=!0,Ht=(0,It.X)(Dt,[1,Dt.shape[0],Dt.shape[1],Dt.shape[2]])),D.hu(Ct.jT(Ze,$e),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${Ze} and dilations '${$e}'`);const vn=Ct.Xw(Ht.shape,he,Ze,$e,Ie),wn=[vn.dilationHeight,vn.dilationWidth];let cs;cs="same"===Ie?function Vr(be,he){const Ie=be.map((ct,Dt)=>ct+(ct-1)*(he[Dt]-1)).map(ct=>ct-1),$e=Ie.map(ct=>Math.floor(ct/2)),Ze=Ie.map((ct,Dt)=>ct-$e[Dt]);return Ie.map((ct,Dt)=>[$e[Dt],Ze[Dt]])}([vn.filterHeight,vn.filterWidth],wn):[[0,0],[0,0]];const Hs=1===wn[0]&&1===wn[1],[fr,Ii]=function Rc(be,he,se){const Ie=se.map(vn=>vn[0]),$e=se.map(vn=>vn[1]),Ze=be.concat(Ie,$e),ct=he.map((vn,wn)=>(vn-Ze[wn]%vn)%vn),Dt=$e.map((vn,wn)=>vn+ct[wn]),Ht=he.map((vn,wn)=>[Ie[wn],Dt[wn]]),Gt=he.map((vn,wn)=>[0,ct[wn]]);return[Ht,Gt]}([vn.inHeight,vn.inWidth],wn,cs),Dr=Hs?Ie:"valid",mr=Hs?Ht:No(Ht,wn,fr),Gr=("avg"===se?()=>Bt(mr,he,Ze,Dr,ct):()=>jn(mr,he,Ze,Dr,ct))(),ul=Hs?Gr:zs(Gr,wn,Ii);return Gt?(0,It.X)(ul,[ul.shape[1],ul.shape[2],ul.shape[3]]):ul}});var ku=h(2620),Gn=h(2202);const Vi=(0,N.op)({prod_:function bl(be,he=null,se=!1){let Ie=(0,I._1)(be,"x","prod");return"bool"===Ie.dtype&&(Ie=(0,pt.p)(Ie,"int32")),y.BV.runKernel(F.DlI,{x:Ie},{axis:he,keepDims:se})}}),Kl=(0,N.op)({raggedGather_:function xl(be,he,se,Ie){const $e=be.map((vn,wn)=>(0,I._1)(vn,`tensors${wn}`,"raggedGather","int32")),Ze=(0,I._1)(he,"paramsDenseValues","raggedGather"),ct=(0,I._1)(se,"indices","raggedGather","int32"),Gt=y.BV.runKernel(F.dDz,{paramsNestedSplits:$e,paramsDenseValues:Ze,indices:ct},{outputRaggedRank:Ie});return{outputNestedSplits:Gt.slice(0,Gt.length-1),outputDenseValues:Gt[Gt.length-1]}}}),_c=(0,N.op)({raggedTensorToTensor_:function bu(be,he,se,Ie,$e){const Ze=(0,I._1)(be,"shape","raggedTensorToTensor","int32"),ct=(0,I._1)(he,"values","raggedTensorToTensor"),Dt=(0,I._1)(se,"defaultValue","raggedTensorToTensor",ct.dtype),Ht=Ie.map((wn,cs)=>(0,I._1)(wn,`tensors${cs}`,"raggedTensorToTensor","int32"));return y.BV.runKernel(F.BiW,{shape:Ze,values:ct,defaultValue:Dt,rowPartitionTensors:Ht},{rowPartitionTypes:$e})}}),xd=(0,N.op)({rand_:function Ou(be,he,se){const Ie=(0,D.NA)(be);let $e=null;if(null==se||"float32"===se)$e=new Float32Array(Ie);else if("int32"===se)$e=new Int32Array(Ie);else{if("bool"!==se)throw new Error(`Unknown data type ${se}`);$e=new Uint8Array(Ie)}for(let Ze=0;Ze<Ie;Ze++)$e[Ze]=he();return y.BV.makeTensor($e,be,se)}});var yc=h(9128);class Lc{constructor(he,se,Ie,$e,Ze){this.mean=he,this.stdDev=se,this.dtype=Ie,this.nextVal=NaN,this.truncated=$e,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const ct=Ze||Math.random();this.random=yc.alea(ct.toString())}nextValue(){if(!isNaN(this.nextVal)){const $e=this.nextVal;return this.nextVal=NaN,$e}let he,se,Ie=!1;for(;!Ie;){let $e,Ze,ct;do{$e=2*this.random()-1,Ze=2*this.random()-1,ct=$e*$e+Ze*Ze}while(ct>=1||0===ct);const Dt=Math.sqrt(-2*Math.log(ct)/ct);he=this.mean+this.stdDev*$e*Dt,se=this.mean+this.stdDev*Ze*Dt,(!this.truncated||this.isValidTruncated(he))&&(Ie=!0)}return(!this.truncated||this.isValidTruncated(se))&&(this.nextVal=this.convertValue(se)),this.convertValue(he)}convertValue(he){return null==this.dtype||"float32"===this.dtype?he:Math.round(he)}isValidTruncated(he){return he<=this.upper&&he>=this.lower}}class Ru{constructor(he,se,Ie,$e){this.alpha=he,this.beta=1/se,this.dtype=Ie;const Ze=$e||Math.random();this.randu=yc.alea(Ze.toString()),this.randn=new Lc(0,1,Ie,!1,this.randu()),this.d=he<1?he+2/3:he-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let he,se,Ie,$e,Ze,ct;for(;;){do{$e=this.randn.nextValue(),ct=1+this.c*$e}while(ct<=0);if(ct*=ct*ct,he=$e*$e,se=1-.331*he*he,Ie=.5*he+this.d*(1-ct+Math.log(ct)),Ze=this.randu(),Ze<se||Math.log(Ze)<Ie)break}return ct*=1/this.beta*this.d,this.alpha<1&&(ct*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(ct)}convertValue(he){return"float32"===this.dtype?he:Math.round(he)}}class Sa{constructor(he=0,se=1,Ie,$e){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=he,this.range=se-he,this.dtype=Ie,null==$e&&($e=Math.random()),"number"==typeof $e&&($e=$e.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${he} - ${se} <= 1 and dtype is not float`);this.random=yc.alea($e)}convertValue(he){return this.canReturnFloat()?he:Math.round(he)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const ua=(0,N.op)({randomGamma_:function ei(be,he,se=1,Ie="float32",$e){if(null==se&&(se=1),null==Ie&&(Ie="float32"),"float32"!==Ie&&"int32"!==Ie)throw new Error(`Unsupported data type ${Ie}`);const Ze=new Ru(he,se,Ie,$e),ct=(0,to.f)(be,Ie);for(let Dt=0;Dt<ct.values.length;Dt++)ct.values[Dt]=Ze.nextValue();return ct.toTensor()}}),Mc=(0,N.op)({randomNormal_:function Nc(be,he=0,se=1,Ie,$e){if(null!=Ie&&"bool"===Ie)throw new Error(`Unsupported data type ${Ie}`);const Ze=new Lc(he,se,Ie,!1,$e),ct=(0,to.f)(be,Ie);for(let Dt=0;Dt<ct.values.length;Dt++)ct.values[Dt]=Ze.nextValue();return ct.toTensor()}}),wl=(0,N.op)({randomStandardNormal_:function Ur(be,he,se){if(null!=he&&"bool"===he)throw new Error(`Unsupported data type ${he}`);return Mc(be,0,1,he,se)}}),Do=(0,N.op)({randomUniform_:function wd(be,he=0,se=1,Ie="float32",$e){const Ze=(0,to.f)(be,Ie),ct=new Sa(he,se,null,$e);for(let Dt=0;Dt<Ze.values.length;Dt++)Ze.values[Dt]=ct.nextValue();return Ze.toTensor()}});function ks(be,he,se=1,Ie="float32"){if(0===se)throw new Error("Cannot have a step of zero");return y.BV.runKernel(F.e6w,{},{start:be,stop:he,step:se,dtype:Ie})}var Zo=h(3488);const ge=(0,N.op)({reciprocal_:function Me(be){const se={x:(0,I._1)(be,"x","reciprocal")};return y.BV.runKernel(F.$HU,se)}});var ke=h(2020),Ke=h(9098);const $t=(0,N.op)({reverse_:function dt(be,he){const Ie={x:(0,I._1)(be,"x","reverse")};return y.BV.runKernel(F.mKl,Ie,{dims:he})}}),Sn=(0,N.op)({reverse1d_:function dn(be){const he=(0,I._1)(be,"x","reverse");return D.hu(1===he.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${he.rank}.`),$t(he,0)}}),re=(0,N.op)({reverse2d_:function en(be,he){const se=(0,I._1)(be,"x","reverse");return D.hu(2===se.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${se.rank}.`),$t(se,he)}}),ee=(0,N.op)({reverse3d_:function xe(be,he){const se=(0,I._1)(be,"x","reverse");return D.hu(3===se.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${se.rank}.`),$t(se,he)}}),Fe=(0,N.op)({reverse4d_:function me(be,he){const se=(0,I._1)(be,"x","reverse");return D.hu(4===se.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${se.rank}.`),$t(se,he)}}),At=(0,N.op)({round_:function gt(be){const se={x:(0,I._1)(be,"x","round")};return y.BV.runKernel(F.e07,se)}}),Pn=(0,N.op)({rsqrt_:function zt(be){const se={x:(0,I._1)(be,"x","rsqrt","float32")};return y.BV.runKernel(F.bV0,se)}}),Kn=(0,N.op)({selu_:function On(be){const se={x:(0,I._1)(be,"x","selu")};return y.BV.runKernel(F.oFR,se)}}),An=(0,N.op)({separableConv2d_:function Ln(be,he,se,Ie,$e,Ze=[1,1],ct="NHWC"){const Dt=(0,I._1)(be,"x","separableConv2d"),Ht=(0,I._1)(he,"depthwiseFilter","separableConv2d"),Gt=(0,I._1)(se,"pointwiseFilter","separableConv2d");let vn=Dt,wn=!1;if(3===Dt.rank&&(wn=!0,vn=(0,It.X)(Dt,[1,Dt.shape[0],Dt.shape[1],Dt.shape[2]])),"NCHW"===ct)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D.hu(4===vn.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${vn.rank}.`),D.hu(4===Ht.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${Ht.rank}.`),D.hu(4===Gt.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${Ht.rank}.`),D.hu(1===Gt.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${Gt.shape[0]}.`),D.hu(1===Gt.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${Gt.shape[1]}.`);const cs=Ht.shape[2],Hs=Ht.shape[3];D.hu(Gt.shape[2]===cs*Hs,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${cs*Hs}, but got ${Gt.shape[2]}.`);const fr=Pr(vn,Ht,Ie,$e,ct,Ze),Dr=Xi(fr,Gt,1,"valid",ct);return wn?(0,It.X)(Dr,[Dr.shape[1],Dr.shape[2],Dr.shape[3]]):Dr}});var ir,vs=h(5861);const gi=function Er(be,he){return(ir=ir||(0,vs.Z)(function*(se,Ie){const $e=(0,I._1)(se,"x","setdiff1d"),Ze=(0,I._1)(Ie,"y","setdiff1d");D.hu($e.dtype===Ze.dtype,()=>`x and y should have the same dtype, but got x (${$e.dtype}) and y (${Ze.dtype}).`),D.hu(1===$e.rank,()=>`x should be 1D tensor, but got x (${$e.shape}).`),D.hu(1===Ze.rank,()=>`y should be 1D tensor, but got y (${Ze.shape}).`);const ct=yield $e.data(),Dt=yield Ze.data(),Ht=new Set(Dt);let Gt=0;for(let cs=0;cs<ct.length;cs++)Ht.has(ct[cs])||Gt++;const vn=new Bo.YD([Gt],$e.dtype),wn=new Bo.YD([Gt],"int32");for(let cs=0,Hs=0;cs<ct.length;cs++)Ht.has(ct[cs])||(vn.values[Hs]=ct[cs],wn.values[Hs]=cs,Hs++);return[vn.toTensor(),wn.toTensor()]})).apply(this,arguments)},vc=(0,N.op)({sign_:function So(be){const se={x:(0,I._1)(be,"x","sign")};return y.BV.runKernel(F.i5y,se)}}),Qo=(0,N.op)({sin_:function Nr(be){const se={x:(0,I._1)(be,"x","sin","float32")};return y.BV.runKernel(F.RQH,se)}}),Rl=(0,N.op)({sinh_:function Ci(be){const se={x:(0,I._1)(be,"x","sinh")};return y.BV.runKernel(F.wYB,se)}}),id=(0,N.op)({slice1d_:function cl(be,he,se){const Ie=(0,I._1)(be,"x","slice1d");return D.hu(1===Ie.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${Ie.rank} tensor`),Ss(Ie,[he],[se])}}),Ud=(0,N.op)({slice2d_:function Dc(be,he,se){const Ie=(0,I._1)(be,"x","slice2d");return D.hu(2===Ie.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${Ie.rank} tensor`),Ss(Ie,he,se)}}),Mh=(0,N.op)({slice3d_:function $c(be,he,se){const Ie=(0,I._1)(be,"x","slice3d");return D.hu(3===Ie.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${Ie.rank} tensor`),Ss(Ie,he,se)}}),Uf=(0,N.op)({slice4d_:function Vf(be,he,se){const Ie=(0,I._1)(be,"x","slice4d");return D.hu(4===Ie.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${Ie.rank} tensor`),Ss(Ie,he,se)}}),Ph=(0,N.op)({softmax_:function Km(be,he=-1){const se=(0,I._1)(be,"logits","softmax","float32");if(-1===he&&(he=se.rank-1),he!==se.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${se.rank} and dim was ${he}`);return y.BV.runKernel(F.Gcp,{logits:se},{dim:he})}}),Sc=(0,N.op)({fft_:function Zp(be){return(0,D.hu)("complex64"===be.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${be.dtype}.`),y.BV.runKernel(F.vwp,{input:be})}}),Nu=(0,N.op)({ifft_:function dh(be){return(0,D.hu)("complex64"===be.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${be.dtype}.`),y.BV.runKernel(F.Qg5,{input:be})}}),Hu=(0,N.op)({irfft_:function Qp(be){const he=be.shape[be.shape.length-1],se=be.size/he;let Ie;if(he<=2){const $e=(0,It.X)(be,[se,he]);Ie=Nu($e)}else{const $e=[se,2*(he-1)],Ze=(0,It.X)((0,Zo.k)(be),[se,he]),ct=(0,It.X)((0,pn.a)(be),[se,he]),Dt=$t(Ss(Ze,[0,1],[se,he-2]),1),Ht=(0,Ts.d)($t(Ss(ct,[0,1],[se,he-2]),1),(0,En.i)(-1)),Gt=Es([Ze,Dt],1),vn=Es([ct,Ht],1),wn=(0,It.X)((0,jo.P)(Gt,vn),[$e[0],$e[1]]);Ie=Nu(wn)}if(Ie=(0,Zo.k)(Ie),3===be.rank&&0!==be.shape[0]){const $e=Ie,Ze=be.shape[0];Ie=(0,It.X)(Ie,[Ze,Ie.shape[0]/Ze,Ie.shape[1]]),$e.dispose()}return Ie}}),Fh=(0,N.op)({split_:function Cd(be,he,se=0){const $e={x:(0,I._1)(be,"x","split")};return y.BV.runKernel(F.L8s,$e,{numOrSizeSplits:he,axis:se})}}),Ya=(0,N.op)({rfft_:function Jc(be,he){(0,D.hu)("float32"===be.dtype,()=>`The dtype for rfft() must be real value but got ${be.dtype}`);let se=be.shape[be.shape.length-1];const Ie=be.size/se;let $e;if(null!=he&&he<se){const fr=be.shape.map(Dr=>0),Ii=be.shape.map(Dr=>Dr);Ii[be.shape.length-1]=he,$e=Ss(be,fr,Ii),se=he}else if(null!=he&&he>se){const fr=be.shape.map(Ii=>Ii);fr[be.shape.length-1]=he-se,$e=Es([be,jl(fr)],be.shape.length-1),se=he}else $e=be;const Ze=(0,ro.P)($e),ct=(0,It.X)((0,jo.P)($e,Ze),[Ie,se]),Dt=Sc(ct),Ht=Math.floor(se/2)+1,Gt=(0,Zo.k)(Dt),vn=(0,pn.a)(Dt),wn=Fh(Gt,[Ht,se-Ht],Gt.shape.length-1),cs=Fh(vn,[Ht,se-Ht],vn.shape.length-1),Hs=$e.shape.slice();return Hs[$e.shape.length-1]=Ht,(0,It.X)((0,jo.P)(wn[0],cs[0]),Hs)}}),du=(0,N.op)({squaredDifference_:function Ba(be,he){let se=(0,I._1)(be,"a","squaredDifference"),Ie=(0,I._1)(he,"b","squaredDifference");return[se,Ie]=(0,Te.makeTypesMatch)(se,Ie),(0,Oo.assertAndGetBroadcastShape)(se.shape,Ie.shape),y.BV.runKernel(F._tC,{a:se,b:Ie},{})}}),hh=(0,N.op)({squeeze_:function Bc(be,he){const se=(0,I._1)(be,"x","squeeze","string_or_numeric");return(0,It.X)(se,(0,D.bp)(se.shape,he).newShape)}}),zd=(0,N.op)({stack_:function zf(be,he=0){const se=(0,I.sI)(be,"tensors","stack","string_or_numeric");return D.hu(se.length>=1,()=>"Pass at least one tensor to tf.stack"),se.length>0&&D.hu(he<=se[0].rank,()=>"Axis must be <= rank of the tensor"),y.BV.runKernel(F.QiL,se,{axis:he})}});var Jp=h(6517);const qc=(0,N.op)({stridedSlice_:function Wf(be,he,se,Ie,$e=0,Ze=0,ct=0,Dt=0,Ht=0){const vn={x:(0,I._1)(be,"x","stridedSlice","string_or_numeric")};return y.BV.runKernel(F.jQk,vn,{begin:he,end:se,strides:Ie,beginMask:$e,endMask:Ze,ellipsisMask:ct,newAxisMask:Dt,shrinkAxisMask:Ht})}}),qp=(0,N.op)({tan_:function od(be){const se={x:(0,I._1)(be,"x","tan","float32")};return y.BV.runKernel(F.sEM,se)}});var Lh=h(4712),Wd=h(987);function Nl(be,he){(0,D.Cq)(be);const se=(0,I.C)(be,he);if(1!==se.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,Wd.H)(be,null,se,he)}function xu(be,he,se){if((0,D.Cq)(be),null!=he&&2!==he.length)throw new Error("tensor2d() requires shape to have two numbers");const Ie=(0,I.C)(be,se);if(2!==Ie.length&&1!==Ie.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===Ie.length&&null==he)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Wd.H)(be,he,Ie,se)}var ju=h(815);function $h(be,he,se){if((0,D.Cq)(be),null!=he&&4!==he.length)throw new Error("tensor4d() requires shape to have four numbers");const Ie=(0,I.C)(be,se);if(4!==Ie.length&&1!==Ie.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===Ie.length&&null==he)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Wd.H)(be,he,Ie,se)}function Hf(be,he,se){if((0,D.Cq)(be),null!=he&&5!==he.length)throw new Error("tensor5d() requires shape to have five numbers");const Ie=(0,I.C)(be,se);if(5!==Ie.length&&1!==Ie.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===Ie.length&&null==he)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Wd.H)(be,he,Ie,se)}function ph(be,he,se){if((0,D.Cq)(be),null!=he&&6!==he.length)throw new Error("tensor6d() requires shape to have six numbers");const Ie=(0,I.C)(be,se);if(6!==Ie.length&&1!==Ie.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===Ie.length&&null==he)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return(0,Wd.H)(be,he=he||Ie,Ie,se)}const bc=(0,N.op)({topk_:function Hd(be,he=1,se=!0){const Ie=(0,I._1)(be,"x","topk");if(0===Ie.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const $e=Ie.shape[Ie.shape.length-1];if(he<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${he}`);if(he>$e)throw new Error(`'k' passed to topk() must be <= the last dimension (${$e}) but got ${he}`);const Ze={x:Ie},ct={k:he,sorted:se},[Dt,Ht]=y.BV.runKernel(F.cWu,Ze,ct);return{values:Dt,indices:Ht}}}),b_=(0,N.op)({truncatedNormal_:function _p(be,he=0,se=1,Ie,$e){if(null!=Ie&&"bool"===Ie)throw new Error("Unsupported data type $ { dtype }");const Ze=new Lc(he,se,Ie,!0,$e),ct=(0,to.f)(be,Ie);for(let Dt=0;Dt<ct.values.length;Dt++)ct.values[Dt]=Ze.nextValue();return ct.toTensor()}}),Ed=(0,N.op)({unique_:function Pc(be,he=0){const se=(0,I._1)(be,"x","unique","string_or_numeric");(0,D.hu)(se.rank>0,()=>"The input tensor must be at least 1D");const Ie={x:se},$e={axis:he},[Ze,ct]=y.BV.runKernel(F.kpP,Ie,$e);return{values:Ze,indices:ct}}}),fh=(0,N.op)({unsortedSegmentSum_:function ad(be,he,se){const Ie=(0,I._1)(be,"x","unsortedSegmentSum"),$e=(0,I._1)(he,"segmentIds","unsortedSegmentSum","int32");return(0,D.hu)((0,D.GN)(se),()=>"numSegments must be of dtype int"),y.BV.runKernel(F.Qvg,{x:Ie,segmentIds:$e},{numSegments:se})}}),ef=(0,N.op)({unstack_:function Mu(be,he=0){const se=(0,I._1)(be,"x","unstack","string_or_numeric");return D.hu(he>=-se.shape.length&&he<se.shape.length,()=>`Axis = ${he} is not in [-${se.shape.length}, ${se.shape.length})`),y.BV.runKernel(F.ToN,{value:se},{axis:he})}});function jf(be,he){return As(be,he,"right")}function yp(be,he=!0,se,Ie){return y.BV.makeVariable(be,he,se,Ie)}var jd,tf=h(2553);const nf=function Gf(be){return(jd=jd||(0,vs.Z)(function*(he){const se=(0,I._1)(he,"condition","whereAsync","bool"),Ie=yield se.data(),$e=(0,tf.Z)(se.shape,Ie);return he!==se&&se.dispose(),$e})).apply(this,arguments)};var sf;const rf=function Kf(be,he,se){return(sf=sf||(0,vs.Z)(function*(Ie,$e,Ze){const ct=(0,I._1)(Ie,"tensor","boolMask"),Dt=(0,I._1)($e,"mask","boolMask","bool"),Ht=Ze??0,Gt=Dt.rank,vn=ct.shape;D.hu(Gt>0,()=>"mask cannot be scalar"),D.k5(vn.slice(Ht,Ht+Gt),Dt.shape,"mask's shape must match the first K dimensions of tensor's shape,");let wn=1;for(let _a=Ht;_a<Ht+Gt;_a++)wn*=vn[_a];const cs=vn.slice(0,Ht).concat([wn],vn.slice(Ht+Gt)),Hs=(0,It.X)(ct,cs),fr=(0,It.X)(Dt,[-1]),Ii=yield nf(fr),Dr=hh(Ii,[1]),mr=Ye(Hs,Dr,Ht);return Ie!==ct&&ct.dispose(),$e!==Dt&&Dt.dispose(),Dr.dispose(),Hs.dispose(),fr.dispose(),Ii.dispose(),mr})).apply(this,arguments)};var Vc=h(3886);const bp=(0,N.op)({movingAverage_:function vp(be,he,se,Ie,$e=!0){const Ze=(0,I._1)(be,"v","movingAverage"),ct=(0,I._1)(he,"x","movingAverage"),Dt=(0,I._1)(se,"decay","movingAverage");(0,Te.assertTypesMatch)(Ze,ct),D.hu(D.cO(Ze.shape,ct.shape),()=>"Shape mismatch in v and x");const Ht=(0,En.i)(1),Gt=(0,Ai.l)(Ht,Dt);let vn=(0,Ts.d)((0,Ai.l)(ct,Ze),Gt);if($e){D.hu(null!=Ie,()=>"When using zeroDebias: true, step is required.");const wn=(0,I._1)(Ie,"step","movingAverage");vn=(0,Zi.h)(vn,(0,Ai.l)(Ht,(0,Na.s)(Dt,wn)))}return(0,T.I)(Ze,vn)}});var Ia=h(374);const Dd=(0,N.op)({scatterND_:function xp(be,he,se){const Ie=(0,I._1)(be,"indices","scatterND","int32"),$e=(0,I._1)(he,"updates","scatterND");return Ia.validateInput($e,Ie,se),y.BV.runKernel(F.xQA,{indices:Ie,updates:$e},{shape:se})}}),lf=(0,N.op)({sparseToDense_:function wp(be,he,se,Ie=0){const $e=(0,I._1)(be,"sparseIndices","sparseToDense","int32"),Ze=(0,I._1)(he,"sparseValues","sparseToDense","string_or_numeric"),ct=(0,I._1)(Ie,"defaultValue","sparseToDense",Ze.dtype);return function af(be,he,se,Ie){if("int32"!==be.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${be.dtype}.`);if(be.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${be.shape}.`);const $e=be.rank>0?be.shape[0]:1,Ze=be.rank>1?be.shape[1]:1;if(se.length!==Ze)throw new Error(`outputShape has incorrect number of elements:, ${se.length}, should be: ${Ze}.`);if(0!==he.rank&&(1!==he.rank||he.size!==$e))throw new Error(`sparseValues has incorrect shape ${he.shape}, should be [] or [${$e}]`);if(he.dtype!==Ie.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}($e,Ze,se,ct),y.BV.runKernel(F.D2d,{sparseIndices:$e,sparseValues:Ze,defaultValue:ct},{outputShape:se})}}),mh=(0,N.op)({gatherND_:function Uc(be,he){const se=(0,I._1)(he,"indices","gatherND","int32"),$e={params:(0,I._1)(be,"x","gatherND","string_or_numeric"),indices:se};return y.BV.runKernel(F.q1x,$e)}}),Bh=(0,N.op)({dropout_:function hu(be,he,se,Ie){const $e=(0,I._1)(be,"x","dropout");if(D.hu("float32"===$e.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${$e.dtype} tensor instead.`),D.hu(he>=0&&he<1,()=>`rate must be a float in the range [0, 1), but got ${he}.`),0===he)return be instanceof Bo.es?$e.clone():$e;const Ze=function Cp(be,he){if(null==he)return be.shape.slice();if(D.cO(be.shape,he))return he;if(be.shape.length===he.length){const se=[];for(let Ie=0;Ie<be.shape.length;Ie++)se.push(null==he[Ie]&&null!=be.shape[Ie]?be.shape[Ie]:he[Ie]);return se}return he}($e,se),ct=1-he,Dt=(0,Zi.h)(X((0,T.I)(Do(Ze,0,1,"float32",Ie),ct)),ct);return(0,Ts.d)($e,Dt)}});function gh(be){return Math.floor(Math.pow(2,Math.ceil(Math.log(be)/Math.log(2))))}function Vo(be,he,se){const Ie=1-be%2,$e=new Float32Array(be);for(let Ze=0;Ze<be;++Ze){const ct=2*Math.PI*Ze/(be+Ie-1);$e[Ze]=he-se*Math.cos(ct)}return Nl($e,"float32")}var _h;const Ic=function Vh(be,he){return(_h=_h||(0,vs.Z)(function*(se,Ie,$e=1){const Ze=(0,I._1)(se,"predictions","inTopK"),ct=(0,I._1)(Ie,"targets","inTopK");(0,D.hu)(Ze.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${Ze.rank}`),(0,D.hu)(Ze.rank-1===ct.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${Ze.rank} and targets rank ${ct.rank}`),(0,D.k5)(Ze.shape.slice(0,Ze.shape.length-1),ct.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const Dt=Ze.shape[Ze.shape.length-1];(0,D.hu)($e>0&&$e<=Dt,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${Dt}), but got ${$e}`);const Ht=yield Ze.data(),Gt=yield ct.data(),[vn,wn]=[Ht.length/Dt,Dt],cs=(0,D.WP)("bool",vn);for(let Hs=0;Hs<vn;Hs++){const fr=Hs*wn,Ii=Ht.subarray(fr,fr+wn),Dr=[];for(let mr=0;mr<Ii.length;mr++)Dr.push({value:Ii[mr],index:mr});Dr.sort((mr,_a)=>_a.value-mr.value),cs[Hs]=0;for(let mr=0;mr<$e;mr++)if(Dr[mr].index===Gt[Hs]){cs[Hs]=1;break}}return se!==Ze&&Ze.dispose(),Ie!==ct&&ct.dispose(),(0,Lh.X)(cs,ct.shape,"bool")})).apply(this,arguments)},Uo=(0,N.op)({conv2DBackpropFilter_:function Va(be,he,se,Ie,$e,Ze="NHWC",ct){let Dt=be;3===be.rank&&(Dt=(0,It.X)(be,[1,be.shape[0],be.shape[1],be.shape[2]]));let Ht=he;3===Ht.rank&&(Ht=(0,It.X)(he,[1,he.shape[0],he.shape[1],he.shape[2]])),D.hu(4===Dt.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${Dt.shape}.`),D.hu(4===Ht.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${Ht.shape}.`),D.hu(4===se.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${se}.`);const Gt="NHWC"===Ze?Dt.shape[3]:Dt.shape[1],vn="NHWC"===Ze?Ht.shape[3]:Ht.shape[1];return D.hu(Gt===se[2],()=>`Error in conv2dDerFilter: depth of input ${Gt}) must match input depth in filter (${se[2]}.`),D.hu(vn===se[3],()=>`Error in conv2dDerFilter: depth of dy (${vn}) must match output depth for filter (${se[3]}).`),Ct.m("conv2dDerFilter",$e,ct),y.BV.runKernel(F.wUP,{x:Dt,dy:Ht},{strides:Ie,pad:$e,dataFormat:Ze,dimRoundingMode:ct,filterShape:se})}});var Xl=h(9251);const li=(0,N.op)({fusedConv2d_:function Tc({x:be,filter:he,strides:se,pad:Ie,dataFormat:$e="NHWC",dilations:Ze=[1,1],dimRoundingMode:ct,bias:Dt,activation:Ht="linear",preluActivationWeights:Gt,leakyreluAlpha:vn}){if(!1===(0,Xl.uy)(y.BV.state.gradientDepth,Ht=Ht||"linear")){D.hu("NHWC"===$e,()=>`Error in fused conv2d: got dataFormat of ${$e} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Ji=Xi(be,he,se,Ie,$e,Ze,ct);return null!=Dt&&(Ji=(0,T.I)(Ji,Dt)),(0,Xl.QH)(Ji,Ht,Gt,vn)}const wn=(0,I._1)(be,"x","conv2d","float32"),cs=(0,I._1)(he,"filter","conv2d","float32");let Hs=wn,fr=!1;3===wn.rank&&(fr=!0,Hs=(0,It.X)(wn,[1,wn.shape[0],wn.shape[1],wn.shape[2]])),D.hu(4===Hs.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Hs.rank}.`),D.hu(4===cs.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${cs.rank}.`),Ct.m("fused conv2d",Ie,ct);const Ii="NHWC"===$e?Hs.shape[3]:Hs.shape[1];D.hu(cs.shape[2]===Ii,()=>`Error in conv2d: depth of input (${Ii}) must match input depth for filter ${cs.shape[2]}.`),D.hu(Ct.jT(se,Ze),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${se} and dilations '${Ze}'`);const Dr=Ct.Ix(Hs.shape,cs.shape,se,Ze,Ie,ct);let mr,_a;if(null!=Dt&&(mr=(0,I._1)(Dt,"bias","fused conv2d"),[mr]=(0,Te.makeTypesMatch)(mr,wn),"NHWC"===$e?Oo.assertAndGetBroadcastShape(Dr.outShape,mr.shape):(D.hu(mr.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${mr.shape.length}.`),D.hu(0===mr.shape.length||mr.shape[0]===Dr.outChannels||1===mr.shape[0],()=>`Error in fused conv2d: bias shape (${mr.shape}) is not compatible with the number of output channels (${Dr.outChannels})`))),null!=Gt){const Ji=Gt.shape;if(D.hu(Ji.length<=1||3===Ji.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Ji.length}.`),1===Ji.length)D.hu(1===Ji[0]||Ji[0]===Dr.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Ji}) is not compatible with the number of output channels (${Dr.outChannels}).`);else if(3===Ji.length)try{Oo.assertAndGetBroadcastShape(Ji,Dr.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Ji}) is not compatible with the output shape of the conv2d (${Dr.outShape}).`)}_a=(0,I._1)(Gt,"prelu weights","fused conv2d")}const Gr=(Ji,na)=>{D.hu("NHWC"===$e,()=>`Error in gradient of fused conv2D: got dataFormat of ${$e} but only NHWC is currently supported.`);const[ya,sa,va,Ml]=na,mu=(0,Xl.Fr)(Ji,va,Ht);D.hu(Ct.I0(Ze),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${Ze}'`);const eu=[Jr(sa.shape,mu,ya,se,Ie),Uo(sa,mu,ya.shape,se,Ie)];if(null!=Ml){const bh=(0,Xl.pf)(Ml,mu);eu.push(bh)}return eu},ul={x:Hs,filter:cs,bias:mr,preluActivationWeights:_a},Jl={strides:se,pad:Ie,dataFormat:$e,dilations:Ze,dimRoundingMode:ct,activation:Ht,leakyreluAlpha:vn};return null==Dt?(0,vl.cb)((na,ya,sa)=>{let va=y.BV.runKernel(F._V0,ul,Jl);return sa([ya,na,va]),fr&&(va=(0,It.X)(va,[va.shape[1],va.shape[2],va.shape[3]])),{value:va,gradFunc:Gr}})(Hs,cs):(0,vl.cb)((na,ya,sa,va)=>{let Ml=y.BV.runKernel(F._V0,ul,Jl);return va([ya,na,Ml,sa]),fr&&(Ml=(0,It.X)(Ml,[Ml.shape[1],Ml.shape[2],Ml.shape[3]])),{value:Ml,gradFunc:Gr}})(Hs,cs,mr)}}),Uh=(0,N.op)({depthwiseConv2dNativeBackpropFilter_:function ao(be,he,se,Ie,$e,Ze=[1,1],ct){let Dt=be;3===be.rank&&(Dt=(0,It.X)(be,[1,be.shape[0],be.shape[1],be.shape[2]]));let Ht=he;return 3===Ht.rank&&(Ht=(0,It.X)(he,[1,he.shape[0],he.shape[1],he.shape[2]])),y.BV.runKernel(F.sL$,{x:Dt,dy:Ht},{strides:Ie,pad:$e,dimRoundingMode:ct,dilations:Ze,filterShape:se})}}),pu=(0,N.op)({depthwiseConv2dNativeBackpropInput_:function Pu(be,he,se,Ie,$e,Ze=[1,1],ct){let Dt=he,Ht=!1;3===he.rank&&(Ht=!0,Dt=(0,It.X)(he,[1,he.shape[0],he.shape[1],he.shape[2]]));const wn=y.BV.runKernel(F.y7R,{dy:Dt,filter:se},{strides:Ie,pad:$e,dimRoundingMode:ct,dilations:Ze,inputShape:be});return Ht?(0,It.X)(wn,[wn.shape[1],wn.shape[2],wn.shape[3]]):wn}}),Tt=(0,N.op)({fusedDepthwiseConv2d_:function Xf({x:be,filter:he,strides:se,pad:Ie,dataFormat:$e="NHWC",dilations:Ze=[1,1],dimRoundingMode:ct,bias:Dt,activation:Ht="linear",preluActivationWeights:Gt,leakyreluAlpha:vn}){if(!1===(0,Xl.uy)(y.BV.state.gradientDepth,Ht)){let Jl=Pr(be,he,se,Ie,$e,Ze,ct);return null!=Dt&&(Jl=(0,T.I)(Jl,Dt)),(0,Xl.QH)(Jl,Ht,Gt,vn)}const wn=(0,I._1)(be,"x","depthwiseConv2d","float32"),cs=(0,I._1)(he,"filter","depthwiseConv2d","float32");let Hs=wn,fr=!1;3===wn.rank&&(fr=!0,Hs=(0,It.X)(wn,[1,wn.shape[0],wn.shape[1],wn.shape[2]])),D.hu(4===Hs.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${Hs.rank}.`),D.hu(4===cs.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${cs.rank}.`),D.hu(Hs.shape[3]===cs.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${Hs.shape[3]}) must match the inChannels dimension in filter ${cs.shape[2]}.`),null==Ze&&(Ze=[1,1]),D.hu(Ct.jT(se,Ze),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${se} and dilations '${Ze}'`),Ct.m("fused depthwiseConv2d",Ie,ct);const Ii=Ct.Ix(Hs.shape,cs.shape,se,Ze,Ie,ct,!0);let Dr,mr;null!=Dt&&(Dr=(0,I._1)(Dt,"bias","fused conv2d"),[Dr]=(0,Te.makeTypesMatch)(Dr,wn),Oo.assertAndGetBroadcastShape(Ii.outShape,Dr.shape)),null!=Gt&&(mr=(0,I._1)(Gt,"prelu weights","fused depthwiseConv2d"));const _a=(Jl,Ji)=>{D.hu(Ct.I0(Ze),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${Ze}'`);const[na,ya,sa,va]=Ji,Ml=(0,Xl.Fr)(Jl,sa,Ht),mu=pu(ya.shape,Ml,na,se,Ie,Ze,ct),Ac=Uh(ya,Ml,na.shape,se,Ie,Ze,ct);return null!=va?[mu,Ac,(0,Xl.pf)(Dr,Ml)]:[mu,Ac]},Gr={x:Hs,filter:cs,bias:Dr,preluActivationWeights:mr},ul={strides:se,pad:Ie,dataFormat:$e,dilations:Ze,dimRoundingMode:ct,activation:Ht,leakyreluAlpha:vn};return null==Dt?(0,vl.cb)((Ji,na,ya)=>{let sa=y.BV.runKernel(F.luS,Gr,ul);return ya([na,Ji,sa]),fr&&(sa=(0,It.X)(sa,[sa.shape[1],sa.shape[2],sa.shape[3]])),{value:sa,gradFunc:_a}})(Hs,cs):(0,vl.cb)((Ji,na,ya,sa)=>{let va=y.BV.runKernel(F.luS,Gr,ul);return sa([na,Ji,va,ya]),fr&&(va=(0,It.X)(va,[va.shape[1],va.shape[2],va.shape[3]])),{value:va,gradFunc:_a}})(Hs,cs,Dr)}}),ht=(0,N.op)({fusedMatMul_:function yt({a:be,b:he,transposeA:se=!1,transposeB:Ie=!1,bias:$e,activation:Ze="linear",preluActivationWeights:ct,leakyreluAlpha:Dt=.2}){if(!1===(0,Xl.uy)(y.BV.state.gradientDepth,Ze)){let Ml=(0,Xn.O)(be,he,se,Ie);return null!=$e&&(Ml=(0,T.I)(Ml,$e)),(0,Xl.QH)(Ml,Ze,ct,Dt)}let Ht=(0,I._1)(be,"a","fused matMul"),Gt=(0,I._1)(he,"b","fused matMul");[Ht,Gt]=(0,Te.makeTypesMatch)(Ht,Gt);const vn=se?Ht.shape[Ht.rank-2]:Ht.shape[Ht.rank-1],wn=Ie?Gt.shape[Gt.rank-1]:Gt.shape[Gt.rank-2],cs=se?Ht.shape[Ht.rank-1]:Ht.shape[Ht.rank-2],Hs=Ie?Gt.shape[Gt.rank-2]:Gt.shape[Gt.rank-1],fr=Ht.shape.slice(0,-2),Ii=Gt.shape.slice(0,-2),Dr=D.NA(fr),mr=D.NA(Ii);D.hu(vn===wn,()=>`Error in fused matMul: inner shapes (${vn}) and (${wn}) of Tensors with shapes ${Ht.shape} and ${Gt.shape} and transposeA=${se} and transposeB=${Ie} must match.`);const Gr=Oo.assertAndGetBroadcastShape(Ht.shape.slice(0,-2),Gt.shape.slice(0,-2)).concat([cs,Hs]),ul=(0,It.X)(Ht,se?[Dr,vn,cs]:[Dr,cs,vn]),Jl=(0,It.X)(Gt,Ie?[mr,Hs,wn]:[mr,wn,Hs]);let Ji,na;null!=$e&&(Ji=(0,I._1)($e,"bias","fused matMul"),[Ji]=(0,Te.makeTypesMatch)(Ji,Ht),Oo.assertAndGetBroadcastShape(Gr,Ji.shape)),null!=ct&&(na=(0,I._1)(ct,"prelu weights","fused matMul"));const ya=(Ml,mu)=>{const[Ac,Ku,eu,bh]=mu,Qd=(0,Xl.Fr)((0,It.X)(Ml,eu.shape),eu,Ze);let xh,Op;return se||Ie?!se&&Ie?(xh=(0,Xn.O)(Qd,Ku,!1,!1),Op=(0,Xn.O)(Qd,Ac,!0,!1)):se&&!Ie?(xh=(0,Xn.O)(Ku,Qd,!1,!0),Op=(0,Xn.O)(Ac,Qd,!1,!1)):(xh=(0,Xn.O)(Ku,Qd,!0,!0),Op=(0,Xn.O)(Qd,Ac,!0,!0)):(xh=(0,Xn.O)(Qd,Ku,!1,!0),Op=(0,Xn.O)(Ac,Qd,!0,!1)),null!=$e?[xh,Op,(0,Xl.pf)(bh,Qd)]:[xh,Op]},sa={a:ul,b:Jl,bias:Ji,preluActivationWeights:na},va={transposeA:se,transposeB:Ie,activation:Ze,leakyreluAlpha:Dt};return null==$e?(0,vl.cb)((mu,Ac,Ku)=>{const eu=y.BV.runKernel(F.usg,sa,va);return Ku([mu,Ac,eu]),{value:(0,It.X)(eu,Gr),gradFunc:ya}})(ul,Jl):(0,vl.cb)((mu,Ac,Ku,eu)=>{const bh=y.BV.runKernel(F.usg,sa,va);return eu([mu,Ac,bh,Ku]),{value:(0,It.X)(bh,Gr),gradFunc:ya}})(ul,Jl,Ji)}}),ut=(0,N.op)({hammingWindow_:function vt(be){return Vo(be,.54,.46)}}),Vt=(0,N.op)({hannWindow_:function Mt(be){return Vo(be,.5,.5)}}),Rn=(0,N.op)({frame_:function un(be,he,se,Ie=!1,$e=0){let Ze=0;const ct=[];for(;Ze+he<=be.size;)ct.push(Ss(be,Ze,he)),Ze+=se;if(Ie)for(;Ze<be.size;){const Dt=Ze+he-be.size,Ht=Es([Ss(be,Ze,he-Dt),(0,Fo.h)([Dt],$e)]);ct.push(Ht),Ze+=se}return 0===ct.length?xu([],[0,he]):(0,It.X)(Es(ct),[ct.length,he])}}),as=(0,N.op)({stft_:function Mn(be,he,se,Ie,$e=Vt){null==Ie&&(Ie=gh(he));const Ze=Rn(be,he,se),ct=(0,Ts.d)(Ze,$e(he));return Ya(ct,Ie)}}),js=(0,N.op)({cropAndResize_:function is(be,he,se,Ie,$e="bilinear",Ze=0){const ct=(0,I._1)(be,"image","cropAndResize"),Dt=(0,I._1)(he,"boxes","cropAndResize","float32"),Ht=(0,I._1)(se,"boxInd","cropAndResize","int32"),Gt=Dt.shape[0];return D.hu(4===ct.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${ct.rank}.`),D.hu(2===Dt.rank&&4===Dt.shape[1],()=>`Error in cropAndResize: boxes must be have size [${Gt},4] but had shape ${Dt.shape}.`),D.hu(1===Ht.rank&&Ht.shape[0]===Gt,()=>`Error in cropAndResize: boxInd must be have size [${Gt}] but had shape ${Dt.shape}.`),D.hu(2===Ie.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${Ie.length}.`),D.hu(Ie[0]>=1&&Ie[1]>=1,()=>`cropSize must be atleast [1,1], but was ${Ie}`),D.hu("bilinear"===$e||"nearest"===$e,()=>`method must be bilinear or nearest, but was ${$e}`),y.BV.runKernel(F.VcC,{image:ct,boxes:Dt,boxInd:Ht},{method:$e,extrapolationValue:Ze,cropSize:Ie})}}),Ri=(0,N.op)({flipLeftRight_:function pr(be){const he=(0,I._1)(be,"image","flipLeftRight","float32");return D.hu(4===he.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${he.rank}.`),y.BV.runKernel(F.Uyb,{image:he},{})}}),Xr=(0,N.op)({grayscaleToRGB_:function pi(be){const he=(0,I._1)(be,"image","grayscaleToRGB"),se=he.rank-1,Ie=he.shape[se];D.hu(he.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${he.rank}.`),D.hu(1===Ie,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${Ie}.`);const $e=new Array(he.rank);return $e.fill(1,0,se),$e[se]=3,gl(he,$e)}}),Fr=(0,N.op)({rotateWithOffset_:function Fn(be,he,se=0,Ie=.5){const $e=(0,I._1)(be,"image","rotateWithOffset","float32");return D.hu(4===$e.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${$e.rank}.`),y.BV.runKernel(F.b9H,{image:$e},{radians:he,fillValue:se,center:Ie})}});function hr(be,he,se,Ie,$e,Ze){null==Ie&&(Ie=.5),null==$e&&($e=Number.NEGATIVE_INFINITY),null==Ze&&(Ze=0);const ct=be.shape[0];return se=Math.min(se,ct),D.hu(0<=Ie&&Ie<=1,()=>`iouThreshold must be in [0, 1], but was '${Ie}'`),D.hu(2===be.rank,()=>`boxes must be a 2D tensor, but was of rank '${be.rank}'`),D.hu(4===be.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${be.shape[1]}`),D.hu(1===he.rank,()=>"scores must be a 1D tensor"),D.hu(he.shape[0]===ct,()=>`scores has incompatible shape with boxes. Expected ${ct}, but was ${he.shape[0]}`),D.hu(0<=Ze&&Ze<=1,()=>`softNmsSigma must be in [0, 1], but was '${Ze}'`),{maxOutputSize:se,iouThreshold:Ie,scoreThreshold:$e,softNmsSigma:Ze}}const Ui=(0,N.op)({nonMaxSuppression_:function gs(be,he,se,Ie=.5,$e=Number.NEGATIVE_INFINITY){const Ze=(0,I._1)(be,"boxes","nonMaxSuppression","float32"),ct=(0,I._1)(he,"scores","nonMaxSuppression","float32"),Dt=hr(Ze,ct,se,Ie,$e);return y.BV.runKernel(F.uv1,{boxes:Ze,scores:ct},{maxOutputSize:se=Dt.maxOutputSize,iouThreshold:Ie=Dt.iouThreshold,scoreThreshold:$e=Dt.scoreThreshold})}});var ta,Ni=h(501);const Za=(0,N.op)({nonMaxSuppressionWithScore_:function zo(be,he,se,Ie=.5,$e=Number.NEGATIVE_INFINITY,Ze=0){const ct=(0,I._1)(be,"boxes","nonMaxSuppression"),Dt=(0,I._1)(he,"scores","nonMaxSuppression"),Ht=hr(ct,Dt,se,Ie,$e,Ze),wn=y.BV.runKernel(F.W0H,{boxes:ct,scores:Dt},{maxOutputSize:se=Ht.maxOutputSize,iouThreshold:Ie=Ht.iouThreshold,scoreThreshold:$e=Ht.scoreThreshold,softNmsSigma:Ze=Ht.softNmsSigma});return{selectedIndices:wn[0],selectedScores:wn[1]}}});var fu;const Sd=(0,N.op)({nonMaxSuppressionPadded_:function El(be,he,se,Ie=.5,$e=Number.NEGATIVE_INFINITY,Ze=!1){const ct=(0,I._1)(be,"boxes","nonMaxSuppression"),Dt=(0,I._1)(he,"scores","nonMaxSuppression"),Ht=hr(ct,Dt,se,Ie,$e,null),fr=y.BV.runKernel(F.cye,{boxes:ct,scores:Dt},{maxOutputSize:Ht.maxOutputSize,iouThreshold:Ht.iouThreshold,scoreThreshold:Ht.scoreThreshold,padToMaxOutputSize:Ze});return{selectedIndices:fr[0],validOutputs:fr[1]}}});var Yl;const x_=(0,N.op)({resizeBilinear_:function Ep(be,he,se=!1,Ie=!1){const $e=(0,I._1)(be,"images","resizeBilinear");D.hu(3===$e.rank||4===$e.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$e.rank}.`),D.hu(2===he.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${he}.`),D.hu(!1===Ie||!1===se,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let Ze=$e,ct=!1;3===$e.rank&&(ct=!0,Ze=(0,It.X)($e,[1,$e.shape[0],$e.shape[1],$e.shape[2]]));const[]=he,Gt=y.BV.runKernel(F._Yw,{images:Ze},{alignCorners:se,halfPixelCenters:Ie,size:he});return ct?(0,It.X)(Gt,[Gt.shape[1],Gt.shape[2],Gt.shape[3]]):Gt}}),Dp=(0,N.op)({resizeNearestNeighbor_:function E0(be,he,se=!1,Ie=!1){const $e=(0,I._1)(be,"images","resizeNearestNeighbor");D.hu(3===$e.rank||4===$e.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$e.rank}.`),D.hu(2===he.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${he}.`),D.hu("float32"===$e.dtype||"int32"===$e.dtype,()=>"`images` must have `int32` or `float32` as dtype"),D.hu(!1===Ie||!1===se,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let Ze=$e,ct=!1;3===$e.rank&&(ct=!0,Ze=(0,It.X)($e,[1,$e.shape[0],$e.shape[1],$e.shape[2]]));const[]=he,Gt=y.BV.runKernel(F.dpD,{images:Ze},{alignCorners:se,halfPixelCenters:Ie,size:he});return ct?(0,It.X)(Gt,[Gt.shape[1],Gt.shape[2],Gt.shape[3]]):Gt}}),cf=(0,N.op)({threshold_:function yh(be,he="binary",se=!1,Ie=.5){const $e=(0,I._1)(be,"image","threshold"),Ht=$e.shape[0]*$e.shape[1];let vn,wn,cs,Hs,Gt=(0,Ts.d)(Nl([Ie]),255);if(D.hu(3===$e.rank,()=>`Error in threshold: image must be rank 3,but got rank ${$e.rank}.`),D.hu(3===$e.shape[2]||1===$e.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${$e.shape[2]}.`),D.hu("int32"===$e.dtype||"float32"===$e.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${$e.dtype}.`),D.hu("otsu"===he||"binary"===he,()=>`Method must be binary or otsu, but was ${he}`),3===$e.shape[2]){[vn,wn,cs]=Fh($e,[1,1,1],-1);const Dr=(0,Ts.d)(vn,.2989),mr=(0,Ts.d)(wn,.587),_a=(0,Ts.d)(cs,.114);Hs=(0,T.I)((0,T.I)(Dr,mr),_a)}else Hs=be;"otsu"===he&&(Gt=function Yf(be,he){let Ze,ct,Dt,Ht,Gt,vn,se=Nl([-1]),Ie=Nl([0]),$e=Nl([0]);for(let wn=0;wn<be.size-1;wn++){Ze=Ss(be,0,wn+1),ct=Ss(be,wn+1),Gt=(0,Zi.h)((0,ar.S)(Ze),he),vn=(0,Zi.h)((0,ar.S)(ct),he);const cs=(0,ar.S)((0,Ts.d)(Ze,ks(0,Ze.size)));Dt=(0,Zi.h)(cs,(0,ar.S)(Ze));const Hs=(0,Fo.h)(ct.shape,Ze.size),fr=(0,T.I)(ks(0,ct.size),Hs),Ii=(0,Ts.d)(ct,fr);Ht=(0,Zi.h)((0,ar.S)(Ii),(0,ar.S)(ct));const Dr=(0,Ai.l)(Dt,Ht),mr=(0,Ai.l)(Dt,Ht),_a=(0,Ts.d)(Gt,vn);$e=(0,Ts.d)((0,Ts.d)(_a,Dr),mr);const Gr=_t($e,Ie);Ie=Xs(Gr,$e,Ie),se=Xs(Gr,Nl([wn]),se)}return se}(lo((0,pt.p)(At(Hs),"int32"),(0,Lh.X)([]),256),Ht));const fr=se?ai(Hs,Gt):_t(Hs,Gt);return(0,pt.p)((0,Ts.d)(fr,255),"int32")}}),Zf=(0,N.op)({transform_:function Xm(be,he,se="nearest",Ie="constant",$e=0,Ze){const ct=(0,I._1)(be,"image","transform","float32"),Dt=(0,I._1)(he,"transforms","transform","float32");return D.hu(4===ct.rank,()=>`Error in transform: image must be rank 4,but got rank ${ct.rank}.`),D.hu(2===Dt.rank&&(Dt.shape[0]===ct.shape[0]||1===Dt.shape[0])&&8===Dt.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D.hu(null==Ze||2===Ze.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${Ze}.`),y.BV.runKernel(F.wx7,{image:ct,transforms:Dt},{interpolation:se,fillMode:Ie,fillValue:$e,outputShape:Ze})}}),Zl=(0,N.op)({bandPart_:function Qf(be,he,se){(0,D.hu)(he%1==0,()=>`bandPart(): numLower must be an integer, got ${he}.`),(0,D.hu)(se%1==0,()=>`bandPart(): numUpper must be an integer, got ${se}.`);const Ie=(0,I._1)(be,"a","bandPart");(0,D.hu)(Ie.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${Ie.rank}.`);const $e=Ie.shape,[Ze,ct]=Ie.shape.slice(-2);if(!(he<=Ze))throw new Error(`bandPart(): numLower (${he}) must not be greater than the number of rows (${Ze}).`);if(!(se<=ct))throw new Error(`bandPart(): numUpper (${se}) must not be greater than the number of columns (${ct}).`);he<0&&(he=Ze),se<0&&(se=ct);const Dt=(0,It.X)(ks(0,Ze,1,"int32"),[-1,1]),Ht=ks(0,ct,1,"int32"),Gt=(0,Ai.l)(Dt,Ht),vn=st(ai(Gt,(0,En.i)(+he,"int32")),kn(Gt,(0,En.i)(-se,"int32"))),wn=jl([Ze,ct],Ie.dtype);return(0,It.X)(zd(ef((0,It.X)(Ie,[-1,Ze,ct])).map(cs=>Xs(vn,cs,wn))),$e)}}),Ql=(0,N.op)({gramSchmidt_:function Jf(be){let he;if(Array.isArray(be)){he=!1,(0,D.hu)(null!=be&&be.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const $e=be[0].shape[0];for(let Ze=1;Ze<be.length;++Ze)(0,D.hu)(be[Ze].shape[0]===$e,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${be[Ze].shape[0]} vs. ${$e})`)}else he=!0,be=Fh(be,be.shape[0],0).map($e=>hh($e,[0]));(0,D.hu)(be.length<=be[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${be.length}) exceeds number of dimensions (${be[0].shape[0]}).`);const se=[],Ie=be;for(let $e=0;$e<be.length;++$e)se.push(y.BV.tidy(()=>{let Ze=Ie[$e];if($e>0)for(let ct=0;ct<$e;++ct){const Dt=(0,Ts.d)((0,ar.S)((0,Ts.d)(se[ct],Ze)),se[ct]);Ze=(0,Ai.l)(Ze,Dt)}return(0,Zi.h)(Ze,qr(Ze,"euclidean"))}));return he?zd(se,0):se}});var Ym=h(1633);function Sp(be,he=!1){return y.BV.tidy(()=>{(0,D.hu)(2===be.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${be.shape.length}D Tensor.`);const se=be.shape[0],Ie=be.shape[1];let $e=q(se),Ze=(0,Dn.d)(be);const ct=xu([[1]],[1,1]);let Dt=(0,Dn.d)(ct);const Ht=se>=Ie?Ie:se;for(let Gt=0;Gt<Ht;++Gt){const vn=Ze,wn=Dt,cs=$e;[Dt,Ze,$e]=y.BV.tidy(()=>{const Hs=Ss(Ze,[Gt,Gt],[se-Gt,1]),fr=qr(Hs),Ii=Ss(Ze,[Gt,Gt],[1,1]),Dr=Xs(_t(Ii,0),xu([[-1]]),xu([[1]])),mr=(0,Ai.l)(Ii,(0,Ts.d)(Dr,fr)),_a=(0,Zi.h)(Hs,mr);Dt=1===_a.shape[0]?(0,Dn.d)(ct):Es([ct,Ss(_a,[1,0],[_a.shape[0]-1,_a.shape[1]])],0);const Gr=(0,Hl.W)((0,Zi.h)((0,Xn.O)(Dr,mr),fr)),ul=Ss(Ze,[Gt,0],[se-Gt,Ie]),Jl=(0,Ts.d)(Gr,Dt),Ji=(0,Vc.p)(Dt);if(0===Gt)Ze=(0,Ai.l)(ul,(0,Xn.O)(Jl,(0,Xn.O)(Ji,ul)));else{const sa=(0,Ai.l)(ul,(0,Xn.O)(Jl,(0,Xn.O)(Ji,ul)));Ze=Es([Ss(Ze,[0,0],[Gt,Ie]),sa],0)}const na=(0,Vc.p)(Jl),ya=Ss($e,[0,Gt],[se,$e.shape[1]-Gt]);if(0===Gt)$e=(0,Ai.l)(ya,(0,Xn.O)((0,Xn.O)(ya,Dt),na));else{const sa=(0,Ai.l)(ya,(0,Xn.O)((0,Xn.O)(ya,Dt),na));$e=Es([Ss($e,[0,0],[se,Gt]),sa],1)}return[Dt,Ze,$e]}),(0,Ym.B9)([vn,wn,cs])}return!he&&se>Ie&&($e=Ss($e,[0,0],[se,Ie]),Ze=Ss(Ze,[0,0],[Ie,Ie])),[$e,Ze]})}const Zm=(0,N.op)({qr_:function qf(be,he=!1){if((0,D.hu)(be.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${be.rank}`),2===be.rank)return Sp(be,he);{const se=be.shape.slice(0,be.shape.length-2).reduce((Ht,Gt)=>Ht*Gt),Ie=ef((0,It.X)(be,[se,be.shape[be.shape.length-2],be.shape[be.shape.length-1]]),0),$e=[],Ze=[];return Ie.forEach(Ht=>{const[Gt,vn]=Sp(Ht,he);$e.push(Gt),Ze.push(vn)}),[(0,It.X)(zd($e,0),be.shape),(0,It.X)(zd(Ze,0),be.shape)]}}});var ga=h(2065);const Wo=(0,N.op)({computeWeightedLoss_:function Kd(be,he,se=ga.I.SUM_BY_NONZERO_WEIGHTS){const Ie=(0,I._1)(be,"losses","computeWeightedLoss");let $e=null;null!=he&&($e=(0,I._1)(he,"weights","computeWeightedLoss"));const Ze=null==$e?Ie:(0,Ts.d)(Ie,$e);if(se===ga.I.NONE)return Ze;if(se===ga.I.SUM)return(0,ar.S)(Ze);if(se===ga.I.MEAN){if(null==$e)return qt(Ze);{const ct=Ie.size/$e.size,Dt=(0,Zi.h)((0,ar.S)(Ze),(0,ar.S)($e));return ct>1?(0,Zi.h)(Dt,(0,En.i)(ct)):Dt}}if(se===ga.I.SUM_BY_NONZERO_WEIGHTS){if(null==$e)return(0,Zi.h)((0,ar.S)(Ze),(0,En.i)(Ie.size));{const ct=(0,Ts.d)($e,oo(Ie.shape)),Dt=(0,pt.p)((0,ar.S)(z(ct,(0,En.i)(0))),"float32");return(0,Zi.h)((0,ar.S)(Ze),Dt)}}throw Error(`Unknown reduction: ${se}`)}}),w_=(0,N.op)({absoluteDifference_:function Gu(be,he,se,Ie=ga.I.SUM_BY_NONZERO_WEIGHTS){const $e=(0,I._1)(be,"labels","absoluteDifference"),Ze=(0,I._1)(he,"predictions","absoluteDifference");let ct=null;null!=se&&(ct=(0,I._1)(se,"weights","absoluteDifference")),(0,D.k5)($e.shape,Ze.shape,"Error in absoluteDifference: ");const Dt=(0,Z.W)((0,Ai.l)($e,Ze));return Wo(Dt,ct,Ie)}}),C_=(0,N.op)({cosineDistance_:function Ip(be,he,se,Ie,$e=ga.I.SUM_BY_NONZERO_WEIGHTS){const Ze=(0,I._1)(be,"labels","cosineDistance"),ct=(0,I._1)(he,"predictions","cosineDistance");let Dt=null;null!=Ie&&(Dt=(0,I._1)(Ie,"weights","cosineDistance")),(0,D.k5)(Ze.shape,ct.shape,"Error in cosineDistance: ");const Ht=(0,En.i)(1),Gt=(0,Ai.l)(Ht,(0,ar.S)((0,Ts.d)(Ze,ct),se,!0));return Wo(Gt,Dt,$e)}}),Jm=(0,N.op)({hingeLoss_:function Qm(be,he,se,Ie=ga.I.SUM_BY_NONZERO_WEIGHTS){let $e=(0,I._1)(be,"labels","hingeLoss");const Ze=(0,I._1)(he,"predictions","hingeLoss");let ct=null;null!=se&&(ct=(0,I._1)(se,"weights","hingeLoss")),(0,D.k5)($e.shape,Ze.shape,"Error in hingeLoss: ");const Dt=(0,En.i)(1);$e=(0,Ai.l)((0,Ts.d)((0,En.i)(2),$e),Dt);const Ht=(0,ke.U)((0,Ai.l)(Dt,(0,Ts.d)($e,Ze)));return Wo(Ht,ct,Ie)}}),Xd=(0,N.op)({huberLoss_:function uf(be,he,se,Ie=1,$e=ga.I.SUM_BY_NONZERO_WEIGHTS){const Ze=(0,I._1)(be,"labels","huberLoss"),ct=(0,I._1)(he,"predictions","huberLoss");let Dt=null;null!=se&&(Dt=(0,I._1)(se,"weights","huberLoss")),(0,D.k5)(Ze.shape,ct.shape,"Error in huberLoss: ");const Ht=(0,En.i)(Ie),Gt=(0,Z.W)((0,Ai.l)(ct,Ze)),vn=Gi(Gt,Ht),wn=(0,Ai.l)(Gt,vn),cs=(0,T.I)((0,Ts.d)((0,En.i)(.5),(0,wr.h)(vn)),(0,Ts.d)(Ht,wn));return Wo(cs,Dt,$e)}}),Tp=(0,N.op)({logLoss_:function E_(be,he,se,Ie=1e-7,$e=ga.I.SUM_BY_NONZERO_WEIGHTS){const Ze=(0,I._1)(be,"labels","logLoss"),ct=(0,I._1)(he,"predictions","logLoss");let Dt=null;null!=se&&(Dt=(0,I._1)(se,"weights","logLoss")),(0,D.k5)(Ze.shape,ct.shape,"Error in logLoss: ");const Ht=(0,En.i)(1),Gt=(0,En.i)(Ie),vn=(0,Hl.W)((0,Ts.d)(Ze,Fi((0,T.I)(ct,Gt)))),wn=(0,Ts.d)((0,Ai.l)(Ht,Ze),Fi((0,T.I)((0,Ai.l)(Ht,ct),Gt))),cs=(0,Ai.l)(vn,wn);return Wo(cs,Dt,$e)}}),df=(0,N.op)({meanSquaredError_:function Ap(be,he,se,Ie=ga.I.SUM_BY_NONZERO_WEIGHTS){const $e=(0,I._1)(be,"labels","meanSquaredError"),Ze=(0,I._1)(he,"predictions","meanSquaredError");let ct=null;null!=se&&(ct=(0,I._1)(se,"weights","meanSquaredError")),(0,D.k5)($e.shape,Ze.shape,"Error in meanSquaredError: ");const Dt=du($e,Ze);return Wo(Dt,ct,Ie)}}),Id=(0,N.op)({sigmoidCrossEntropy_:function em(be,he,se,Ie=0,$e=ga.I.SUM_BY_NONZERO_WEIGHTS){let Ze=(0,I._1)(be,"multiClassLabels","sigmoidCrossEntropy");const ct=(0,I._1)(he,"logits","sigmoidCrossEntropy");let Dt=null;if(null!=se&&(Dt=(0,I._1)(se,"weights","sigmoidCrossEntropy")),(0,D.k5)(Ze.shape,ct.shape,"Error in sigmoidCrossEntropy: "),Ie>0){const Gt=(0,En.i)(Ie),vn=(0,En.i)(1),wn=(0,En.i)(.5);Ze=(0,T.I)((0,Ts.d)(Ze,(0,Ai.l)(vn,Gt)),(0,Ts.d)(wn,Gt))}const Ht=function ns(be,he){const se=(0,I._1)(be,"labels","sigmoidCrossEntropyWithLogits"),Ie=(0,I._1)(he,"logits","sigmoidCrossEntropyWithLogits");(0,D.k5)(se.shape,Ie.shape,"Error in sigmoidCrossEntropyWithLogits: ");const $e=(0,ke.U)(Ie),Ze=(0,Ts.d)(Ie,se),ct=Wu(Ro((0,Hl.W)((0,Z.W)(Ie))));return(0,T.I)((0,Ai.l)($e,Ze),ct)}(Ze,ct);return Wo(Ht,Dt,$e)}}),kp=(0,N.op)({softmaxCrossEntropy_:function zh(be,he,se,Ie=0,$e=ga.I.SUM_BY_NONZERO_WEIGHTS){let Ze=(0,I._1)(be,"onehotLabels","softmaxCrossEntropy");const ct=(0,I._1)(he,"logits","softmaxCrossEntropy");let Dt=null;if(null!=se&&(Dt=(0,I._1)(se,"weights","softmaxCrossEntropy")),(0,D.k5)(Ze.shape,ct.shape,"Error in softmaxCrossEntropy: "),Ie>0){const Gt=(0,En.i)(Ie),vn=(0,En.i)(1),wn=(0,En.i)(Ze.shape[1]);Ze=(0,T.I)((0,Ts.d)(Ze,(0,Ai.l)(vn,Gt)),(0,Zi.h)(Gt,wn))}const Ht=function qm(be,he,se=-1){if(-1===se&&(se=he.rank-1),se!==he.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${he.rank} and dim was ${se}`);return(0,vl.cb)(($e,Ze,ct)=>{const Ht=Be(Ze,[se],!0),Gt=(0,Ai.l)((0,pt.p)(Ze,"float32"),Ht);ct([$e,Gt]);const vn=(0,Hl.W)((0,Ts.d)(Gt,$e));return{value:(0,ar.S)(vn,[se]),gradFunc:(Hs,fr)=>{const[Ii,Dr]=fr,mr=(0,Br.rv)(Hs.shape,[se]);return[(0,Ts.d)((0,It.X)(Hs,mr),(0,Ai.l)((0,pt.p)(Ii,"float32"),Ro(Dr))),(0,Ts.d)((0,It.X)(Hs,mr),(0,Ai.l)(Ro(Dr),(0,pt.p)(Ii,"float32")))]}}})(be,he)}(Ze,ct);return Wo(Ht,Dt,$e)}}),D_=(0,N.op)({sparseFillEmptyRows_:function Wh(be,he,se,Ie){const $e=(0,I._1)(be,"indices","sparseFillEmptyRows","int32"),Ze=(0,I._1)(he,"values","sparseFillEmptyRows"),ct=(0,I._1)(se,"denseShape","sparseFillEmptyRows","int32"),Dt=(0,I._1)(Ie,"defaultValue","sparseFillEmptyRows",Ze.dtype);if(2!==$e.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${$e.shape}`);if(1!==Ze.rank)throw new Error(`Values should be Tensor1D but received shape ${Ze.shape}`);if(1!==ct.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${ct.shape}`);if(0!==Dt.rank)throw new Error(`Default value should be a scalar but received shape ${Dt.shape}`);const Gt=y.BV.runKernel(F.O3z,{indices:$e,values:Ze,denseShape:ct,defaultValue:Dt});return{outputIndices:Gt[0],outputValues:Gt[1],emptyRowIndicator:Gt[2],reverseIndexMap:Gt[3]}}}),S_=(0,N.op)({sparseReshape_:function tm(be,he,se){const Ie=(0,I._1)(be,"inputIndices","sparseReshape","int32"),$e=(0,I._1)(he,"inputShape","sparseReshape","int32"),Ze=(0,I._1)(se,"newShape","sparseReshape","int32");if(2!==Ie.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${Ie.shape}`);if(1!==$e.rank)throw new Error(`Input shape should be Tensor1D but received shape ${$e.shape}`);if(1!==Ze.rank)throw new Error(`New shape should be Tensor1D but received shape ${Ze.shape}`);const Dt=y.BV.runKernel(F.nhH,{inputIndices:Ie,inputShape:$e,newShape:Ze});return{outputIndices:Dt[0],outputShape:Dt[1]}}}),tg=(0,N.op)({sparseSegmentMean_:function eg(be,he,se){const Ie=(0,I._1)(be,"data","sparseSegmentMean"),$e=(0,I._1)(he,"indices","sparseSegmentMean","int32"),Ze=(0,I._1)(se,"segmentIds","sparseSegmentMean","int32");if(Ie.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==$e.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${$e.shape}`);if(1!==Ze.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${Ze.shape}`);return y.BV.runKernel(F.w3H,{data:Ie,indices:$e,segmentIds:Ze})}}),T_=(0,N.op)({sparseSegmentSum_:function I_(be,he,se){const Ie=(0,I._1)(be,"data","sparseSegmentSum"),$e=(0,I._1)(he,"indices","sparseSegmentSum","int32"),Ze=(0,I._1)(se,"segmentIds","sparseSegmentSum","int32");if(Ie.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==$e.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${$e.shape}`);if(1!==Ze.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${Ze.shape}`);return y.BV.runKernel(F.ZjV,{data:Ie,indices:$e,segmentIds:Ze})}}),vh=(0,N.op)({stringNGrams_:function wu(be,he,se,Ie,$e,Ze,ct,Dt){const Ht=(0,I._1)(be,"data","stringNGrams","string");if("string"!==Ht.dtype)throw new Error("Data must be of datatype string");if(1!==Ht.shape.length)throw new Error(`Data must be a vector, saw: ${Ht.shape}`);const Gt=(0,I._1)(he,"dataSplits","stringNGrams");if("int32"!==Gt.dtype)throw new Error("Data splits must be of datatype int32");const cs=y.BV.runKernel(F._JP,{data:Ht,dataSplits:Gt},{separator:se,nGramWidths:Ie,leftPad:$e,rightPad:Ze,padWidth:ct,preserveShortSequences:Dt});return{nGrams:cs[0],nGramsSplits:cs[1]}}}),Yd=(0,N.op)({stringSplit_:function Hh(be,he,se=!0){const Ie=(0,I._1)(be,"input","stringSplit","string"),$e=(0,I._1)(he,"delimiter","stringSplit","string");if(1!==Ie.rank)throw new Error(`Input should be Tensor1D but received shape ${Ie.shape}`);if(0!==$e.rank)throw new Error(`Delimiter should be a scalar but received shape ${$e.shape}`);const Dt=y.BV.runKernel(F.s1s,{input:Ie,delimiter:$e},{skipEmpty:se});return{indices:Dt[0],values:Dt[1],shape:Dt[2]}}}),hf=(0,N.op)({stringToHashBucketFast_:function Zd(be,he){const se=(0,I._1)(be,"input","stringToHashBucketFast","string"),Ie={numBuckets:he};if(he<=0)throw new Error("Number of buckets must be at least 1");return y.BV.runKernel(F.XkS,{input:se},Ie)}}),D0={fft:Sc,ifft:Nu,rfft:Ya,irfft:Hu},ng={hammingWindow:ut,hannWindow:Vt,frame:Rn,stft:as},sg={flipLeftRight:Ri,grayscaleToRGB:Xr,resizeNearestNeighbor:Dp,resizeBilinear:x_,rotateWithOffset:Fr,cropAndResize:js,nonMaxSuppression:Ui,nonMaxSuppressionAsync:function Io(be,he,se){return(ta=ta||(0,vs.Z)(function*(Ie,$e,Ze,ct=.5,Dt=Number.NEGATIVE_INFINITY){const Ht=(0,I._1)(Ie,"boxes","nonMaxSuppressionAsync"),Gt=(0,I._1)($e,"scores","nonMaxSuppressionAsync"),vn=hr(Ht,Gt,Ze,ct,Dt);Ze=vn.maxOutputSize,ct=vn.iouThreshold,Dt=vn.scoreThreshold;const wn=yield Promise.all([Ht.data(),Gt.data()]),cs=wn[0],Hs=wn[1],{selectedIndices:fr}=(0,Ni.GP)(cs,Hs,Ze,ct,Dt);return Ht!==Ie&&Ht.dispose(),Gt!==$e&&Gt.dispose(),Nl(fr,"int32")})).apply(this,arguments)},nonMaxSuppressionWithScore:Za,nonMaxSuppressionWithScoreAsync:function Cl(be,he,se){return(fu=fu||(0,vs.Z)(function*(Ie,$e,Ze,ct=.5,Dt=Number.NEGATIVE_INFINITY,Ht=0){const Gt=(0,I._1)(Ie,"boxes","nonMaxSuppressionAsync"),vn=(0,I._1)($e,"scores","nonMaxSuppressionAsync"),wn=hr(Gt,vn,Ze,ct,Dt,Ht);Ze=wn.maxOutputSize,ct=wn.iouThreshold,Dt=wn.scoreThreshold,Ht=wn.softNmsSigma;const cs=yield Promise.all([Gt.data(),vn.data()]),Hs=cs[0],fr=cs[1],{selectedIndices:Ii,selectedScores:Dr}=(0,Ni.pA)(Hs,fr,Ze,ct,Dt,Ht);return Gt!==Ie&&Gt.dispose(),vn!==$e&&vn.dispose(),{selectedIndices:Nl(Ii,"int32"),selectedScores:Nl(Dr)}})).apply(this,arguments)},nonMaxSuppressionPadded:Sd,nonMaxSuppressionPaddedAsync:function zc(be,he,se){return(Yl=Yl||(0,vs.Z)(function*(Ie,$e,Ze,ct=.5,Dt=Number.NEGATIVE_INFINITY,Ht=!1){const Gt=(0,I._1)(Ie,"boxes","nonMaxSuppressionAsync"),vn=(0,I._1)($e,"scores","nonMaxSuppressionAsync"),wn=hr(Gt,vn,Ze,ct,Dt,null),cs=wn.maxOutputSize,Hs=wn.iouThreshold,fr=wn.scoreThreshold,[Ii,Dr]=yield Promise.all([Gt.data(),vn.data()]),{selectedIndices:mr,validOutputs:_a}=(0,Ni.qP)(Ii,Dr,cs,Hs,fr,Ht);return Gt!==Ie&&Gt.dispose(),vn!==$e&&vn.dispose(),{selectedIndices:Nl(mr,"int32"),validOutputs:(0,En.i)(_a,"int32")}})).apply(this,arguments)},threshold:cf,transform:Zf},S0={bandPart:Zl,gramSchmidt:Ql,qr:Zm},Cu={absoluteDifference:w_,computeWeightedLoss:Wo,cosineDistance:C_,hingeLoss:Jm,huberLoss:Xd,logLoss:Tp,meanSquaredError:df,sigmoidCrossEntropy:Id,softmaxCrossEntropy:kp},pf={sparseFillEmptyRows:D_,sparseReshape:S_,sparseSegmentMean:tg,sparseSegmentSum:T_},ff={stringNGrams:vh,stringSplit:Yd,stringToHashBucketFast:hf}},1712:(Et,le,h)=>{"use strict";h.d(le,{s:()=>W});var U=h(1379),Z=h(351),y=h(1931),F=h(58);const W=(0,h(2267).op)({pow_:function N(l,w){let M=(0,F._1)(l,"base","pow"),T=(0,F._1)(w,"exp","pow");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.pe_,{a:M,b:T})}})},2620:(Et,le,h)=>{"use strict";h.d(le,{A:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({prelu_:function I(W,l){const w=(0,y._1)(W,"x","prelu"),M=(0,y._1)(l,"alpha","prelu");return U.BV.runKernel(Z.o0g,{x:w,alpha:M})}})},2202:(Et,le,h)=>{"use strict";function U(Z,y=!1){console.log(Z.toString(y))}h.d(le,{S:()=>U})},3488:(Et,le,h)=>{"use strict";h.d(le,{k:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({real_:function I(W){const w={input:(0,y._1)(W,"input","real")};return U.BV.runKernel(Z.xJR,w)}})},2020:(Et,le,h)=>{"use strict";h.d(le,{U:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({relu_:function I(W){const w={x:(0,y._1)(W,"x","relu")};return U.BV.runKernel(Z.qkr,w)}})},9098:(Et,le,h)=>{"use strict";h.d(le,{b:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({relu6_:function I(W){const w={x:(0,y._1)(W,"x","relu6")};return U.BV.runKernel(Z.SbG,w)}})},1791:(Et,le,h)=>{"use strict";h.d(le,{X:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({reshape_:function I(W,l){const M={x:(0,y._1)(W,"x","reshape","string_or_numeric")};return U.BV.runKernel(Z.HZH,M,{shape:l})}})},9418:(Et,le,h)=>{"use strict";h.d(le,{i:()=>y});var U=h(4944),Z=h(987);function y(F,I){if(((0,U.fU)(F)&&"string"!==I||Array.isArray(F))&&"complex64"!==I)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===I&&(0,U.fU)(F)&&!(F instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,Z.H)(F,[],[],I)}},374:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{calculateShapes:()=>F,validateInput:()=>y,validateUpdateShape:()=>Z});var U=h(4944);function Z(I,N,W){const l=N.rank>1?N.shape[N.rank-1]:1,w=N.rank>1?N.rank-1:1,M=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${W.shape}, indices.shape: ${N.shape}, shape: ${I}, sliceDim: ${l}, and batchDim: ${w}.`;if(W.rank<w)throw new Error(M+` update.rank < ${w}. `);if(I.length<l+(W.rank-w))throw new Error(M+` Output shape length < ${l+(W.rank-w)}`);if(W.rank!==w+I.length-l)throw new Error(M+" update.rank != "+(w+I.length-l));for(let T=0;T<w;++T)if(W.shape[T]!==N.shape[T])throw new Error(M+` updates.shape[${T}] (${W.shape[T]}) != indices.shape[${T}] (${N.shape[T]}).`);for(let T=0;T<W.rank-w;++T)if(W.shape[T+w]!==I[T+l])throw new Error(M+` updates.shape[${T+w}] (${W.shape[T+w]}) != shape[${T+w}] (${I[T+w]})`)}function y(I,N,W){if(N.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${N.rank}.`);if(I.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${I.rank}.`);if("int32"!==N.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${N.dtype}`);if(W.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${W}`);if(0===W.length){if(0===N.size)throw new Error(`Indices specified for empty output. indices shape: ${N.shape}`);if(0===I.size)throw new Error(`Updates specified for empty output. updates shape: ${I.shape}`)}Z(W,N,I)}function F(I,N,W){const l=N.shape.length,w=l>1?N.shape[l-1]:1,M=W.length;let T=1;for(let _e=w;_e<M;++_e)T*=W[_e];const D=w<1?1:w;return{sliceRank:w,numUpdates:(0,U.NA)(N.shape)/D,sliceSize:T,strides:[...(0,U.e3)(W.slice(0,w)),1],outputSize:(0,U.NA)(W)}}},7690:(Et,le,h)=>{"use strict";h.d(le,{X:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({sigmoid_:function I(W){const w={x:(0,y._1)(W,"x","sigmoid","float32")};return U.BV.runKernel(Z.a5O,w)}})},9949:(Et,le,h)=>{"use strict";h.d(le,{_:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({sqrt_:function I(W){const w={x:(0,y._1)(W,"x","sqrt","float32")};return U.BV.runKernel(Z.FKq,w)}})},1616:(Et,le,h)=>{"use strict";h.d(le,{h:()=>I});var U=h(1379),Z=h(58);const I=(0,h(2267).op)({square_:function F(N){const W=(0,Z._1)(N,"x","square");return U.BV.runKernel("Square",{x:W},{})}})},6517:(Et,le,h)=>{"use strict";h.d(le,{N:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({step_:function I(W,l=0){const M={x:(0,y._1)(W,"x","step")};return U.BV.runKernel(Z.h8e,M,{alpha:l})}})},8837:(Et,le,h)=>{"use strict";h.d(le,{l:()=>W});var U=h(1379),Z=h(351),y=h(1931),F=h(58);const W=(0,h(2267).op)({sub_:function N(l,w){let M=(0,F._1)(l,"a","sub"),T=(0,F._1)(w,"b","sub");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.Tr8,{a:M,b:T})}})},2149:(Et,le,h)=>{"use strict";h.d(le,{S:()=>W});var U=h(1379),Z=h(351),y=h(58),F=h(8622);const W=(0,h(2267).op)({sum_:function N(l,w=null,M=!1){let T=(0,y._1)(l,"x","sum");return"bool"===T.dtype&&(T=(0,F.p)(T,"int32")),U.BV.runKernel(Z.GBy,{x:T},{axis:w,keepDims:M})}})},4712:(Et,le,h)=>{"use strict";h.d(le,{X:()=>y});var U=h(58),Z=h(987);function y(F,I,N){const W=(0,U.C)(F,N);return(0,Z.H)(F,I,W,N)}},815:(Et,le,h)=>{"use strict";h.d(le,{w:()=>F});var U=h(58),Z=h(4944),y=h(987);function F(I,N,W){if((0,Z.Cq)(I),null!=N&&3!==N.length)throw new Error("tensor3d() requires shape to have three numbers");const l=(0,U.C)(I,W);if(3!==l.length&&1!==l.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===l.length&&null==N)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,y.H)(I,N,l,W)}},987:(Et,le,h)=>{"use strict";h.d(le,{H:()=>F});var U=h(1379),Z=h(4944),y=h(2775);function F(I,N,W,l){if(null==l&&(l=(0,Z.D2)(I)),"complex64"===l)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,Z.fU)(I)&&!Array.isArray(I)&&"number"!=typeof I&&"boolean"!=typeof I&&"string"!=typeof I)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=N){(0,Z.Mu)(N);const w=(0,Z.NA)(N),M=(0,Z.NA)(W);(0,Z.hu)(w===M,()=>`Based on the provided shape, [${N}], the tensor should have ${w} values but has ${M}`);for(let T=0;T<W.length;++T){const G=T!==W.length-1||W[T]!==(0,Z.NA)(N.slice(T));(0,Z.hu)(W[T]===N[T]||!G,()=>`Error creating a new Tensor. Inferred shape (${W}) does not match the provided shape (${N}). `)}}return!(0,Z.fU)(I)&&!Array.isArray(I)&&(I=[I]),N=N||W,I="string"!==l?(0,y.toTypedArray)(I,l):(0,Z.xH)(I,[],!0),U.BV.makeTensor(I,N,l)}},3886:(Et,le,h)=>{"use strict";h.d(le,{p:()=>D});var U=h(1379),Z=h(1633),y=h(351),F=h(58),I=h(4944),N=h(7507),W=h(2556),l=h(7939),w=h(2267),M=h(3488);const D=(0,w.op)({transpose_:function T(G,J,K){const _e=(0,F._1)(G,"x","transpose");if(null==J&&(J=_e.shape.map((We,Oe)=>Oe).reverse()),I.hu(_e.rank===J.length,()=>`Error in transpose: rank of input ${_e.rank} must match length of perm ${J}.`),J.forEach(We=>{I.hu(We>=0&&We<_e.rank,()=>`All entries in 'perm' must be between 0 and ${_e.rank-1} but got ${J}`)}),_e.rank<=1)return _e.clone();const Re={x:_e},we={perm:J};return"complex64"===_e.dtype?(0,Z.lu)(()=>{let We=(0,M.k)(_e),Oe=(0,W.a)(_e);return We=U.BV.runKernel(y.G3Y,{x:We},we),Oe=U.BV.runKernel(y.G3Y,{x:Oe},we),K&&(Oe=(0,l.W)(Oe)),(0,N.P)(We,Oe)}):U.BV.runKernel(y.G3Y,Re,we)}})},7804:(Et,le,h)=>{"use strict";h.d(le,{P:()=>N});var U=h(1379),Z=h(351),y=h(58);const N=(0,h(2267).op)({zerosLike_:function I(W){const w={x:(0,y._1)(W,"x","zerosLike")};return U.BV.runKernel(Z.RuY,w)}})},9089:(Et,le,h)=>{"use strict";h.d(le,{es:()=>ie,YD:()=>J,_w:()=>De,FZ:()=>Oe,Vp:()=>We,Vi:()=>we});var U=h(5861),Z=h(3565),y=h(4944);const F=20,I=3,N=7;function W(te,de,P,oe){const ye=(0,y.e3)(de),Te=function l(te,de,P,oe){const ye=(0,y.NA)(de),Te=oe[oe.length-1],v=new Array(Te).fill(0),at=de.length,Xe="complex64"===P?D(te):te;if(at>1)for(let Ue=0;Ue<ye/Te;Ue++){const pt=Ue*Te;for(let Ct=0;Ct<Te;Ct++)v[Ct]=Math.max(v[Ct],w(Xe[pt+Ct],0,P).length)}return v}(te,de,P,ye),v=de.length,at=T(te,de,P,ye,Te),Xe=["Tensor"];return oe&&(Xe.push(`  dtype: ${P}`),Xe.push(`  rank: ${v}`),Xe.push(`  shape: [${de}]`),Xe.push("  values:")),Xe.push(at.map(Ue=>"    "+Ue).join("\n")),Xe.join("\n")}function w(te,de,P){let oe;return oe=Array.isArray(te)?`${parseFloat(te[0].toFixed(N))} + ${parseFloat(te[1].toFixed(N))}j`:(0,y.HD)(te)?`'${te}'`:"bool"===P?M(te):parseFloat(te.toFixed(N)).toString(),(0,y.oj)(oe,de)}function M(te){return 0===te?"false":"true"}function T(te,de,P,oe,ye,Te=!0){const v="complex64"===P?2:1,at=de[0],Xe=de.length;if(0===Xe)return"complex64"===P?[w(D(te)[0],0,P)]:"bool"===P?[M(te[0])]:[te[0].toString()];if(1===Xe){if(at>F){let Dn=Array.from(te.slice(0,I*v)),ps=Array.from(te.slice((at-I)*v,at*v));return"complex64"===P&&(Dn=D(Dn),ps=D(ps)),["["+Dn.map((Es,Xn)=>w(Es,ye[Xn],P)).join(", ")+", ..., "+ps.map((Es,Xn)=>w(Es,ye[at-I+Xn],P)).join(", ")+"]"]}return["["+("complex64"===P?D(te):Array.from(te)).map((Qn,Dn)=>w(Qn,ye[Dn],P)).join(", ")+"]"]}const Ue=de.slice(1),pt=oe.slice(1),Ct=oe[0]*v,It=[];if(at>F){for(let bn=0;bn<I;bn++){const Qn=bn*Ct;It.push(...T(te.slice(Qn,Qn+Ct),Ue,P,pt,ye,!1))}It.push("...");for(let bn=at-I;bn<at;bn++){const Qn=bn*Ct;It.push(...T(te.slice(Qn,Qn+Ct),Ue,P,pt,ye,bn===at-1))}}else for(let bn=0;bn<at;bn++){const Qn=bn*Ct;It.push(...T(te.slice(Qn,Qn+Ct),Ue,P,pt,ye,bn===at-1))}const nn=2===Xe?",":"";It[0]="["+It[0]+nn;for(let bn=1;bn<It.length-1;bn++)It[bn]=" "+It[bn]+nn;let Bt=",\n";for(let bn=2;bn<Xe;bn++)Bt+="\n";return It[It.length-1]=" "+It[It.length-1]+"]"+(Te?"":Bt),It}function D(te){const de=[];for(let P=0;P<te.length;P+=2)de.push([te[P],te[P+1]]);return de}var G=h(2775);class J{constructor(de,P,oe){if(this.dtype=P,this.shape=de.slice(),this.size=y.NA(de),null!=oe){const ye=oe.length;y.hu(ye===this.size,()=>`Length of values '${ye}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===P)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=oe||y.rQ(P,this.size),this.strides=(0,y.e3)(de)}set(de,...P){0===P.length&&(P=[0]),y.hu(P.length===this.rank,()=>`The number of provided coordinates (${P.length}) must match the rank (${this.rank})`);const oe=this.locToIndex(P);this.values[oe]=de}get(...de){0===de.length&&(de=[0]);let P=0;for(const ye of de){if(ye<0||ye>=this.shape[P])throw new Error(`Requested out of range element at ${de}.   Buffer shape=${this.shape}`);P++}let oe=de[de.length-1];for(let ye=0;ye<de.length-1;++ye)oe+=this.strides[ye]*de[ye];return this.values[oe]}locToIndex(de){if(0===this.rank)return 0;if(1===this.rank)return de[0];let P=de[de.length-1];for(let oe=0;oe<de.length-1;++oe)P+=this.strides[oe]*de[oe];return P}indexToLoc(de){if(0===this.rank)return[];if(1===this.rank)return[de];const P=new Array(this.shape.length);for(let oe=0;oe<P.length-1;++oe)P[oe]=Math.floor(de/this.strides[oe]),de-=P[oe]*this.strides[oe];return P[P.length-1]=de,P}get rank(){return this.shape.length}toTensor(){return K().makeTensor(this.values,this.shape,this.dtype)}}let K=null,_e=null,Re=null;function we(te){K=te}function We(te){_e=te}function Oe(te){Re=te}class ie{constructor(de,P,oe,ye){this.kept=!1,this.isDisposedInternal=!1,this.shape=de.slice(),this.dtype=P||"float32",this.size=y.NA(de),this.strides=(0,y.e3)(de),this.dataId=oe,this.id=ye,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var de=this;return(0,U.Z)(function*(){const P=yield de.data();return _e.buffer(de.shape,de.dtype,P)})()}bufferSync(){return _e.buffer(this.shape,this.dtype,this.dataSync())}array(){var de=this;return(0,U.Z)(function*(){const P=yield de.data();return(0,y.GX)(de.shape,P,"complex64"===de.dtype)})()}arraySync(){return(0,y.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var de=this;return(0,U.Z)(function*(){de.throwIfDisposed();const P=K().read(de.dataId);if("string"===de.dtype){const oe=yield P;try{return oe.map(ye=>G.decodeString(ye))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return P})()}dataToGPU(de){return this.throwIfDisposed(),K().readToGPU(this.dataId,de)}dataSync(){this.throwIfDisposed();const de=K().readSync(this.dataId);if("string"===this.dtype)try{return de.map(P=>G.decodeString(P))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return de}bytes(){var de=this;return(0,U.Z)(function*(){de.throwIfDisposed();const P=yield K().read(de.dataId);return"string"===de.dtype?P:new Uint8Array(P.buffer)})()}dispose(){this.isDisposed||(K().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(de=!1){return _e.print(this,de)}clone(){return this.throwIfDisposed(),_e.clone(this)}toString(de=!1){return W(this.dataSync(),this.shape,this.dtype,de)}cast(de){return this.throwIfDisposed(),_e.cast(this,de)}variable(de=!0,P,oe){return this.throwIfDisposed(),K().makeVariable(this,de,P,oe)}}Object.defineProperty(ie,Symbol.hasInstance,{value:te=>!!te&&null!=te.data&&null!=te.dataSync&&null!=te.throwIfDisposed}),function Le(){(0,Z.R)("Tensor",()=>ie)}();class De extends ie{constructor(de,P,oe,ye){super(de.shape,de.dtype,de.dataId,ye),this.trainable=P,this.name=oe}assign(de){if(de.dtype!==this.dtype)throw new Error(`dtype of the new value (${de.dtype}) and previous value (${this.dtype}) must match`);if(!y.cO(de.shape,this.shape))throw new Error(`shape of the new value (${de.shape}) and previous value (${this.shape}) must match`);K().disposeTensor(this),this.dataId=de.dataId,K().incRef(this,null)}dispose(){K().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(De,Symbol.hasInstance,{value:te=>te instanceof ie&&null!=te.assign&&te.assign instanceof Function})},1931:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{assertTypesMatch:()=>I,getTensorsInContainer:()=>W,isTensorInList:()=>N,makeTypesMatch:()=>F});var U=h(9089),Z=h(4207),y=h(4944);function F(M,T){if(M.dtype===T.dtype)return[M,T];const D=(0,Z.x8)(M.dtype,T.dtype);return[M.cast(D),T.cast(D)]}function I(M,T){(0,y.hu)(M.dtype===T.dtype,()=>`The dtypes of the first(${M.dtype}) and second(${T.dtype}) input must match`)}function N(M,T){return T.some(D=>D.id===M.id)}function W(M){const T=[];return l(M,T,new Set),T}function l(M,T,D){if(null==M)return;if(M instanceof U.es)return void T.push(M);if(!function w(M){return Array.isArray(M)||"object"==typeof M}(M))return;const G=M;for(const J in G){const K=G[J];D.has(K)||(D.add(K),l(K,T,D))}}},58:(Et,le,h)=>{"use strict";h.d(le,{C:()=>N,_1:()=>w,sI:()=>M});var U=h(1379),Z=h(8514),y=h(9089),F=h(4944),I=h(2775);function N(T,D){let G=T;if((0,F.fU)(T))return"string"===D?[]:[T.length];if(!Array.isArray(T))return[];const J=[];for(;Array.isArray(G)||(0,F.fU)(G)&&"string"!==D;)J.push(G.length),G=G[0];return Array.isArray(T)&&(0,Z.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&W(T,J,[]),J}function W(T,D,G){if(G=G||[],!Array.isArray(T)&&!(0,F.fU)(T))return void(0,F.hu)(0===D.length,()=>`Element arr[${G.join("][")}] is a primitive, but should be an array/TypedArray of ${D[0]} elements`);(0,F.hu)(D.length>0,()=>`Element arr[${G.join("][")}] should be a primitive, but is an array of ${T.length} elements`),(0,F.hu)(T.length===D[0],()=>`Element arr[${G.join("][")}] should have ${D[0]} elements, but has ${T.length} elements`);const J=D.slice(1);for(let K=0;K<T.length;++K)W(T[K],J,G.concat(K))}function l(T,D,G,J){if("string_or_numeric"!==T){if(null==T)throw new Error("Expected dtype cannot be null.");if("numeric"!==T&&T!==D||"numeric"===T&&"string"===D)throw new Error(`Argument '${G}' passed to '${J}' must be ${T} tensor, but got ${D} tensor`)}}function w(T,D,G,J="numeric"){if(T instanceof y.es)return l(J,T.dtype,D,G),T;let K=(0,F.D2)(T);if("string"!==K&&["bool","int32","float32"].indexOf(J)>=0&&(K=J),l(J,K,D,G),null==T||!(0,F.fU)(T)&&!Array.isArray(T)&&"number"!=typeof T&&"boolean"!=typeof T&&"string"!=typeof T)throw new Error(`Argument '${D}' passed to '${G}' must be a Tensor or TensorLike, but got '${null==T?"null":T.constructor.name}'`);const _e=N(T,K);!(0,F.fU)(T)&&!Array.isArray(T)&&(T=[T]);const we="string"!==K?(0,I.toTypedArray)(T,K):(0,F.xH)(T,[],!0);return U.BV.makeTensor(we,_e,K)}function M(T,D,G,J="numeric"){if(!Array.isArray(T))throw new Error(`Argument ${D} passed to ${G} must be a \`Tensor[]\` or \`TensorLike[]\``);return T.map((_e,Re)=>w(_e,`${D}[${Re}]`,G,J))}},4207:(Et,le,h)=>{"use strict";h.d(le,{x8:()=>W,yw:()=>U,z4:()=>l});var U=function(w){return w.R0="R0",w.R1="R1",w.R2="R2",w.R3="R3",w.R4="R4",w.R5="R5",w.R6="R6",w}(U||{}),Z=function(w){return w.float32="float32",w.int32="int32",w.bool="int32",w.complex64="complex64",w}(Z||{}),y=function(w){return w.float32="float32",w.int32="int32",w.bool="bool",w.complex64="complex64",w}(y||{}),F=function(w){return w.float32="float32",w.int32="float32",w.bool="float32",w.complex64="complex64",w}(F||{}),I=function(w){return w.float32="complex64",w.int32="complex64",w.bool="complex64",w.complex64="complex64",w}(I||{});const N={float32:F,int32:Z,bool:y,complex64:I};function W(w,M){if("string"===w||"string"===M){if("string"===w&&"string"===M)return"string";throw new Error(`Can not upcast ${w} with ${M}`)}return N[w][M]}function l(w){return W(w,"int32")}},2775:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{arraysEqual:()=>Z.cO,assert:()=>Z.hu,assertNonNegativeIntegerDimensions:()=>Z.Mu,assertNonNull:()=>Z.Cq,assertShapesMatch:()=>Z.k5,bytesFromStringArray:()=>Z.Ub,bytesPerElement:()=>Z.bT,checkConversionForErrors:()=>Z.D5,clamp:()=>Z.uZ,computeStrides:()=>Z.e3,createScalarValue:()=>Le,createShuffledIndices:()=>Z.U$,decodeString:()=>ye,distSquared:()=>Z.E7,encodeString:()=>oe,fetch:()=>P,fingerPrint64:()=>ie,flatten:()=>Z.xH,getArrayFromDType:()=>Z.rQ,getTypedArrayFromDType:()=>Z.WP,hasEncodingLoss:()=>Z.QB,hexToLong:()=>N,indexToLoc:()=>Z.NE,inferDtype:()=>Z.D2,inferFromImplicitShape:()=>Z.JZ,isBoolean:()=>Z.jn,isFunction:()=>Z.mf,isInt:()=>Z.GN,isNumber:()=>Z.hj,isPromise:()=>Z.tI,isScalarShape:()=>Z.N9,isString:()=>Z.HD,isTypedArray:()=>Z.fU,isValidDtype:()=>Z.LP,locToIndex:()=>Z.qy,makeOnesTypedArray:()=>Z.p8,makeZerosNestedTypedArray:()=>Z.l6,makeZerosTypedArray:()=>Z.wT,nearestDivisor:()=>Z.jP,nearestLargerEven:()=>Z.nY,now:()=>de,parseAxisParam:()=>Z.EC,randUniform:()=>Z.bj,repeatedTry:()=>Z.WD,rightPad:()=>Z.oj,shuffle:()=>Z.TV,shuffleCombo:()=>Z.d7,sizeFromShape:()=>Z.NA,sizeToSquarishShape:()=>Z.YP,squeezeShape:()=>Z.bp,sum:()=>Z.Sm,swap:()=>Z.LF,tanh:()=>Z.AE,toNestedArray:()=>Z.GX,toTypedArray:()=>te});var U=h(8514),Z=h(4944),y=h(186);const I=h.n(y)()||y;function N(Te){return I.fromString(Te,!0,16)}const W=N("c3a5c85c97cb3127"),l=N("b492b66fbe98f273"),w=N("9ae16a3b2f90404f");function M(Te){return Te.xor(Te.shru(47))}function T(Te,v,at){const Xe=Te.slice(v,v+at);return I.fromBytes(Array.from(Xe),!0,!0)}function D(Te,v){return T(Te,v,8)}function G(Te,v){return T(Te,v,4)}function J(Te,v){return 0===v?Te:Te.shru(v).or(Te.shl(64-v))}function K(Te,v,at=N("9ddfea08eb382d69")){let Xe=Te.xor(v).mul(at);Xe=Xe.xor(Xe.shru(47));let Ue=v.xor(Xe).mul(at);return Ue=Ue.xor(Ue.shru(47)),Ue=Ue.mul(at),Ue}function Re(Te,v,at,Xe){return function _e(Te,v,at,Xe,Ue,pt){Ue=Ue.add(Te),pt=J(pt.add(Ue).add(Xe),21);const Ct=Ue;return Ue=(Ue=Ue.add(v)).add(at),pt=pt.add(J(Ue,44)),[Ue.add(Xe),pt.add(Ct)]}(D(Te,v),D(Te,v+8),D(Te,v+16),D(Te,v+24),at,Xe)}function ie(Te,v=Te.length){const at=I.fromNumber(81,!0);if(v<=32)return v<=16?function we(Te,v=Te.length){if(v>=8){const at=w.add(2*v),Xe=D(Te,0).add(w),Ue=D(Te,v-8);return K(J(Ue,37).mul(at).add(Xe),J(Xe,25).add(Ue).mul(at),at)}if(v>=4){const at=w.add(2*v);return K(G(Te,0).shl(3).add(v),G(Te,v-4),at)}if(v>0){const Ct=v+(Te[v-1]<<2);return M(w.mul(Te[0]+(Te[v>>1]<<8)).xor(W.mul(Ct))).mul(w)}return w}(Te,v):function We(Te,v=Te.length){const at=w.add(2*v),Xe=D(Te,0).mul(l),Ue=D(Te,8),pt=D(Te,v-8).mul(at),Ct=D(Te,v-16).mul(w);return K(J(Xe.add(Ue),43).add(J(pt,30)).add(Ct),Xe.add(J(Ue.add(w),18)).add(pt),at)}(Te,v);if(v<=64)return function Oe(Te,v=Te.length){const at=w.add(2*v),Xe=D(Te,0).mul(w),Ue=D(Te,8),pt=D(Te,v-8).mul(at),Ct=D(Te,v-16).mul(w),It=J(Xe.add(Ue),43).add(J(pt,30)).add(Ct),nn=K(It,Xe.add(J(Ue.add(w),18)).add(pt),at),Bt=D(Te,16).mul(at),bn=D(Te,24),Qn=It.add(D(Te,v-32)).mul(at),Dn=nn.add(D(Te,v-24)).mul(at);return K(J(Bt.add(bn),43).add(J(Qn,30)).add(Dn),Bt.add(J(bn.add(Xe),18)).add(Qn),at)}(Te,v);let Xe=at,Ue=at.mul(l).add(113),pt=M(Ue.mul(w).add(113)).mul(w),Ct=[I.UZERO,I.UZERO],It=[I.UZERO,I.UZERO];Xe=Xe.mul(w).add(D(Te,0));let nn=0;const Bt=64*(v-1>>6),bn=Bt+(v-1&63)-63;do{Xe=J(Xe.add(Ue).add(Ct[0]).add(D(Te,nn+8)),37).mul(l),Ue=J(Ue.add(Ct[1]).add(D(Te,nn+48)),42).mul(l),Xe=Xe.xor(It[1]),Ue=Ue.add(Ct[0]).add(D(Te,nn+40)),pt=J(pt.add(It[0]),33).mul(l),Ct=Re(Te,nn,Ct[1].mul(l),Xe.add(It[0])),It=Re(Te,nn+32,pt.add(It[1]),Ue.add(D(Te,nn+16))),[pt,Xe]=[Xe,pt],nn+=64}while(nn!==Bt);const Qn=l.add(pt.and(255).shl(1));return nn=bn,It[0]=It[0].add(v-1&63),Ct[0]=Ct[0].add(It[0]),It[0]=It[0].add(Ct[0]),Xe=J(Xe.add(Ue).add(Ct[0]).add(D(Te,nn+8)),37).mul(Qn),Ue=J(Ue.add(Ct[1]).add(D(Te,nn+48)),42).mul(Qn),Xe=Xe.xor(It[1].mul(9)),Ue=Ue.add(Ct[0].mul(9).add(D(Te,nn+40))),pt=J(pt.add(It[0]),33).mul(Qn),Ct=Re(Te,nn,Ct[1].mul(Qn),Xe.add(It[0])),It=Re(Te,nn+32,pt.add(It[1]),Ue.add(D(Te,nn+16))),[pt,Xe]=[Xe,pt],K(K(Ct[0],It[0],Qn).add(M(Ue).mul(W)).add(pt),K(Ct[1],It[1],Qn).add(Xe),Qn)}function Le(Te,v){return"string"===v?oe(Te):te([Te],v)}function te(Te,v){if("string"===v)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(Te)&&(Te=Z.xH(Te)),(0,U.OB)().getBool("DEBUG")&&Z.D5(Te,v),function De(Te,v){return Te instanceof Float32Array&&"float32"===v||Te instanceof Int32Array&&"int32"===v||Te instanceof Uint8Array&&"bool"===v}(Te,v))return Te;if(null==v||"float32"===v||"complex64"===v)return new Float32Array(Te);if("int32"===v)return new Int32Array(Te);if("bool"===v){const at=new Uint8Array(Te.length);for(let Xe=0;Xe<at.length;++Xe)0!==Math.round(Te[Xe])&&(at[Xe]=1);return at}throw new Error(`Unknown data type ${v}`)}function de(){return(0,U.OB)().platform.now()}function P(Te,v){return(0,U.OB)().platform.fetch(Te,v)}function oe(Te,v="utf-8"){return v=v||"utf-8",(0,U.OB)().platform.encode(Te,v)}function ye(Te,v="utf-8"){return v=v||"utf-8",(0,U.OB)().platform.decode(Te,v)}},4944:(Et,le,h)=>{"use strict";function U(Qe){let Lt=Qe.length,Qt=0;for(;Lt>0;)Qt=Math.random()*Lt|0,Lt--,I(Qe,Lt,Qt)}function Z(Qe,Lt){if(Qe.length!==Lt.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${Qe.length}Second array length was ${Lt.length}`);let Qt=Qe.length,Nn=0;for(;Qt>0;)Nn=Math.random()*Qt|0,Qt--,I(Qe,Qt,Nn),I(Lt,Qt,Nn)}function y(Qe,Lt,Qt){return Math.max(Qe,Math.min(Lt,Qt))}function F(Qe){return Qe%2==0?Qe:Qe+1}function I(Qe,Lt,Qt){const Nn=Qe[Lt];Qe[Lt]=Qe[Qt],Qe[Qt]=Nn}function N(Qe){let Lt=0;for(let Qt=0;Qt<Qe.length;Qt++)Lt+=Qe[Qt];return Lt}function W(Qe,Lt){const Qt=Math.random();return Lt*Qt+(1-Qt)*Qe}function l(Qe,Lt){let Qt=0;for(let Nn=0;Nn<Qe.length;Nn++){const Os=Number(Qe[Nn])-Number(Lt[Nn]);Qt+=Os*Os}return Qt}function w(Qe,Lt){if(!Qe)throw new Error("string"==typeof Lt?Lt:Lt())}function M(Qe,Lt,Qt=""){w(K(Qe,Lt),()=>Qt+` Shapes ${Qe} and ${Lt} must match`)}function T(Qe){w(null!=Qe,()=>"The input to the tensor constructor must be a non-null value.")}function D(Qe,Lt=[],Qt=!1){if(null==Lt&&(Lt=[]),Array.isArray(Qe)||v(Qe)&&!Qt)for(let Nn=0;Nn<Qe.length;++Nn)D(Qe[Nn],Lt,Qt);else Lt.push(Qe);return Lt}function G(Qe){if(0===Qe.length)return 1;let Lt=Qe[0];for(let Qt=1;Qt<Qe.length;Qt++)Lt*=Qe[Qt];return Lt}function J(Qe){return 0===Qe.length}function K(Qe,Lt){if(Qe===Lt)return!0;if(null==Qe||null==Lt||Qe.length!==Lt.length)return!1;for(let Qt=0;Qt<Qe.length;Qt++)if(Qe[Qt]!==Lt[Qt])return!1;return!0}function _e(Qe){return Qe%1==0}function Re(Qe){if(null!=Math.tanh)return Math.tanh(Qe);if(Qe===1/0)return 1;if(Qe===-1/0)return-1;{const Lt=Math.exp(2*Qe);return(Lt-1)/(Lt+1)}}function we(Qe){const Lt=Math.ceil(Math.sqrt(Qe));return[Lt,Math.ceil(Qe/Lt)]}function We(Qe){const Lt=new Uint32Array(Qe);for(let Qt=0;Qt<Qe;++Qt)Lt[Qt]=Qt;return U(Lt),Lt}function Oe(Qe,Lt){return Lt<=Qe.length?Qe:Qe+" ".repeat(Lt-Qe.length)}function ie(Qe,Lt=(Os=>0),Qt,Nn=setTimeout){return new Promise((Os,zs)=>{let cr=0;const xr=()=>{if(Qe())return void Os();cr++;const $r=Lt(cr);null!=Qt&&cr>=Qt?zs():Nn(xr,$r)};xr()})}function Le(Qe,Lt){let Qt=1,Nn=-1;for(let zs=0;zs<Qe.length;++zs)if(Qe[zs]>=0)Qt*=Qe[zs];else if(-1===Qe[zs]){if(-1!==Nn)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Nn} and dim ${zs}`);Nn=zs}else if(Qe[zs]<0)throw Error(`Shapes can not be < 0. Found ${Qe[zs]} at dim ${zs}`);if(-1===Nn){if(Lt>0&&Lt!==Qt)throw Error(`Size(${Lt}) must match the product of shape ${Qe}`);return Qe}if(0===Qt)throw Error(`Cannot infer the missing size in [${Qe}] when there are 0 elements`);if(Lt%Qt!=0)throw Error(`The implicit shape can't be a fractional number. Got ${Lt} / ${Qt}`);const Os=Qe.slice();return Os[Nn]=Lt/Qt,Os}function De(Qe,Lt){const Qt=Lt.length;return w((Qe=null==Qe?Lt.map((Nn,Os)=>Os):[].concat(Qe)).every(Nn=>Nn>=-Qt&&Nn<Qt),()=>`All values in axis param must be in range [-${Qt}, ${Qt}) but got axis ${Qe}`),w(Qe.every(Nn=>_e(Nn)),()=>`All values in axis param must be integers but got axis ${Qe}`),Qe.map(Nn=>Nn<0?Qt+Nn:Nn)}function te(Qe,Lt){const Qt=[],Nn=[],Os=null!=Lt&&Array.isArray(Lt)&&0===Lt.length,zs=null==Lt||Os?null:De(Lt,Qe).sort();let cr=0;for(let xr=0;xr<Qe.length;++xr){if(null!=zs){if(zs[cr]===xr&&1!==Qe[xr])throw new Error(`Can't squeeze axis ${xr} since its dim '${Qe[xr]}' is not 1`);(null==zs[cr]||zs[cr]>xr)&&1===Qe[xr]&&(Qt.push(Qe[xr]),Nn.push(xr)),zs[cr]<=xr&&cr++}1!==Qe[xr]&&(Qt.push(Qe[xr]),Nn.push(xr))}return{newShape:Qt,keptDims:Nn}}function de(Qe,Lt){let Qt=null;if(null==Qe||"float32"===Qe)Qt=new Float32Array(Lt);else if("int32"===Qe)Qt=new Int32Array(Lt);else{if("bool"!==Qe)throw new Error(`Unknown data type ${Qe}`);Qt=new Uint8Array(Lt)}return Qt}function P(Qe,Lt){let Qt=null;if(null==Qe||"float32"===Qe)Qt=new Float32Array(Lt);else if("int32"===Qe)Qt=new Int32Array(Lt);else if("bool"===Qe)Qt=new Uint8Array(Lt);else{if("string"!==Qe)throw new Error(`Unknown data type ${Qe}`);Qt=new Array(Lt)}return Qt}function oe(Qe,Lt){for(let Qt=0;Qt<Qe.length;Qt++){const Nn=Qe[Qt];if(isNaN(Nn)||!isFinite(Nn))throw Error(`A tensor of type ${Lt} being uploaded contains ${Nn}.`)}}function ye(Qe){return"bool"===Qe||"complex64"===Qe||"float32"===Qe||"int32"===Qe||"string"===Qe}function Te(Qe,Lt){return!("complex64"===Lt||"float32"===Lt&&"complex64"!==Qe||"int32"===Lt&&"float32"!==Qe&&"complex64"!==Qe||"bool"===Lt&&"bool"===Qe)}function v(Qe){return Qe instanceof Float32Array||Qe instanceof Int32Array||Qe instanceof Uint8Array||Qe instanceof Uint8ClampedArray}function at(Qe){if("float32"===Qe||"int32"===Qe)return 4;if("complex64"===Qe)return 8;if("bool"===Qe)return 1;throw new Error(`Unknown dtype ${Qe}`)}function Xe(Qe){if(null==Qe)return 0;let Lt=0;return Qe.forEach(Qt=>Lt+=Qt.length),Lt}function Ue(Qe){return"string"==typeof Qe||Qe instanceof String}function pt(Qe){return"boolean"==typeof Qe}function Ct(Qe){return"number"==typeof Qe}function It(Qe){return Array.isArray(Qe)?It(Qe[0]):Qe instanceof Float32Array?"float32":Qe instanceof Int32Array||Qe instanceof Uint8Array||Qe instanceof Uint8ClampedArray?"int32":Ct(Qe)?"float32":Ue(Qe)?"string":pt(Qe)?"bool":"float32"}function nn(Qe){return!!(Qe&&Qe.constructor&&Qe.call&&Qe.apply)}function Bt(Qe,Lt){for(let Qt=Lt;Qt<Qe;++Qt)if(Qe%Qt==0)return Qt;return Qe}function bn(Qe){const Lt=Qe.length;if(Lt<2)return[];const Qt=new Array(Lt-1);Qt[Lt-2]=Qe[Lt-1];for(let Nn=Lt-3;Nn>=0;--Nn)Qt[Nn]=Qt[Nn+1]*Qe[Nn+1];return Qt}function Qn(Qe,Lt,Qt,Nn=!1){const Os=new Array;if(1===Lt.length){const zs=Lt[0]*(Nn?2:1);for(let cr=0;cr<zs;cr++)Os[cr]=Qt[Qe+cr]}else{const zs=Lt[0],cr=Lt.slice(1),xr=cr.reduce(($r,eo)=>$r*eo)*(Nn?2:1);for(let $r=0;$r<zs;$r++)Os[$r]=Qn(Qe+$r*xr,cr,Qt,Nn)}return Os}function Dn(Qe,Lt,Qt=!1){if(0===Qe.length)return Lt[0];const Nn=Qe.reduce((Os,zs)=>Os*zs)*(Qt?2:1);if(0===Nn)return[];if(Nn!==Lt.length)throw new Error(`[${Qe}] does not match the input size ${Lt.length}${Qt?" for a complex tensor":""}.`);return Qn(0,Qe,Lt,Qt)}function ps(Qe,Lt){const Qt=Es(Qe,Lt);for(let Nn=0;Nn<Qt.length;Nn++)Qt[Nn]=1;return Qt}function Es(Qe,Lt){if(null==Lt||"float32"===Lt||"complex64"===Lt)return new Float32Array(Qe);if("int32"===Lt)return new Int32Array(Qe);if("bool"===Lt)return new Uint8Array(Qe);throw new Error(`Unknown data type ${Lt}`)}function Xn(Qe,Lt){const Qt=Qe.reduce((Nn,Os)=>Nn*Os,1);if(null==Lt||"float32"===Lt)return Dn(Qe,new Float32Array(Qt));if("int32"===Lt)return Dn(Qe,new Int32Array(Qt));if("bool"===Lt)return Dn(Qe,new Uint8Array(Qt));throw new Error(`Unknown data type ${Lt}`)}function Ts(Qe){Qe.forEach(Lt=>{w(Number.isInteger(Lt)&&Lt>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${Qe}].`)})}function or(Qe,Lt,Qt){if(0===Lt)return 0;if(1===Lt)return Qe[0];let Nn=Qe[Qe.length-1];for(let Os=0;Os<Qe.length-1;++Os)Nn+=Qt[Os]*Qe[Os];return Nn}function Ir(Qe,Lt,Qt){if(0===Lt)return[];if(1===Lt)return[Qe];const Nn=new Array(Lt);for(let Os=0;Os<Nn.length-1;++Os)Nn[Os]=Math.floor(Qe/Qt[Os]),Qe-=Nn[Os]*Qt[Os];return Nn[Nn.length-1]=Qe,Nn}function Ss(Qe){return Qe&&Qe.then&&"function"==typeof Qe.then}h.d(le,{AE:()=>Re,Cq:()=>T,D2:()=>It,D5:()=>oe,E7:()=>l,EC:()=>De,GN:()=>_e,GX:()=>Dn,HD:()=>Ue,JZ:()=>Le,LF:()=>I,LP:()=>ye,Mu:()=>Ts,N9:()=>J,NA:()=>G,NE:()=>Ir,QB:()=>Te,Sm:()=>N,TV:()=>U,U$:()=>We,Ub:()=>Xe,WD:()=>ie,WP:()=>de,YP:()=>we,bT:()=>at,bj:()=>W,bp:()=>te,cO:()=>K,d7:()=>Z,e3:()=>bn,fU:()=>v,hj:()=>Ct,hu:()=>w,jP:()=>Bt,jn:()=>pt,k5:()=>M,l6:()=>Xn,mf:()=>nn,nY:()=>F,oj:()=>Oe,p8:()=>ps,qy:()=>or,rQ:()=>P,tI:()=>Ss,uZ:()=>y,wT:()=>Es,xH:()=>D})},4050:(Et,le,h)=>{"use strict";h.d(le,{H:()=>Z});var U=h(9075);function Z(y,F){Array.isArray(y)||(y=[y]),y.forEach(I=>{null!=I&&U.D5U.assert("complex64"!==I.dtype,()=>`${F} does not support complex64 tensors in the CPU backend.`)})}},3777:(Et,le,h)=>{"use strict";h.d(le,{bk:()=>y,fC:()=>I});var U=h(9075),Z=h(4050);function y(N){const W=new Float32Array(N.length);for(let l=0;l<N.length;++l)W[l]=Math.abs(N[l]);return W}const I={kernelName:U.SYM,backendName:"cpu",kernelFunc:N=>{const{x:W}=N.inputs,l=N.backend;(0,Z.H)(W,"abs");let w=new Float32Array(U.D5U.sizeFromShape(W.shape));return w=y(l.data.get(W.dataId).values),l.makeOutput(w,W.shape,W.dtype)}}},6931:(Et,le,h)=>{"use strict";h.d(le,{EH:()=>F,IH:()=>N,j4:()=>W});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((l,w)=>l+w),I=(0,y.H)((l,w,M,T)=>({real:l+M,imag:w+T})),N=(0,y.j)(U.mm_,F,I),W={kernelName:U.mm_,backendName:"cpu",kernelFunc:N}},9569:(Et,le,h)=>{"use strict";h.d(le,{W:()=>Z,i:()=>y});var U=h(9075);function Z(F,I,N,W,l){const w=U.D5U.sizeFromShape(W),M=U.D5U.makeZerosTypedArray(l,N);for(let T=0;T<F.length;T++){const D=F[T];if(D<0)throw new Error("Input x must be non-negative!");D>=l||(M[D]+=w>0?I[T]:1)}return M}function y(F,I,N,W=!1){const l=F.shape[0],w=F.shape[1],M=(0,U.f3b)([l,N],I.dtype);for(let T=0;T<l;T++)for(let D=0;D<w;D++){const G=F.get(T,D);if(G<0)throw new Error("Input x must be non-negative!");G>=N||M.set(W?1:I.size>0?M.get(T,G)+I.get(T,D):M.get(T,G)+1,T,G)}return M}},8642:(Et,le,h)=>{"use strict";h.d(le,{T0:()=>N,nv:()=>F});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>W&l),I=(0,y.j)(U.hCO,F),N={kernelName:U.hCO,backendName:"cpu",kernelFunc:I}},1928:(Et,le,h)=>{"use strict";h.d(le,{Mq:()=>w,pj:()=>l,sJ:()=>W});var U=h(9075),Z=h(9450),y=h(3176),F=h(3392),I=h(6781),N=h(4353);function W(M,T,D,G){if("int32"===G)return[T,"int32",Int32Array.from(M)];if("bool"===G){const J=U.D5U.toTypedArray([0],D),[K,_e]=(0,Z.b)((Re,we)=>Re!==we?1:0)(T,[],M,J,"bool");return[_e,"bool",K]}throw new Error(`Error in Cast: failed to cast ${D} to ${G}`)}function l(M){const{inputs:T,backend:D,attrs:G}=M,{x:J}=T,{dtype:K}=G;if("complex64"===K){if("complex64"===J.dtype)return(0,I.y)({inputs:{x:J},backend:D});const Oe=(0,y.l)(D,J.shape,J.dtype),ie=l({inputs:{x:J},backend:D,attrs:{dtype:"float32"}}),Le=(0,F.P)({inputs:{real:ie,imag:Oe},backend:D});return D.disposeIntermediateTensorInfo(Oe),D.disposeIntermediateTensorInfo(ie),Le}if("complex64"===J.dtype){const Oe=(0,N.k)({inputs:{input:J},backend:D}),ie=l({inputs:{x:Oe},backend:D,attrs:{dtype:K}});return D.disposeIntermediateTensorInfo(Oe),ie}if(!U.D5U.hasEncodingLoss(J.dtype,K)){const Oe=(0,I.y)({inputs:{x:J},backend:D});return{dataId:Oe.dataId,shape:Oe.shape,dtype:K}}const _e=D.data.get(J.dataId).values,[Re,we,We]=W(_e,J.shape,J.dtype,K);return D.makeTensorInfo(Re,we,We)}const w={kernelName:U.RFZ,backendName:"cpu",kernelFunc:l}},5079:(Et,le,h)=>{"use strict";h.d(le,{__:()=>F,y2:()=>N});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>Math.ceil(W)),I=(0,y.O)(U.gJX,F),N={kernelName:U.gJX,backendName:"cpu",kernelFunc:I}},3392:(Et,le,h)=>{"use strict";function Z(F){const{inputs:I,backend:N}=F,{real:W,imag:l}=I,w=N.data.get(W.dataId).values,M=N.data.get(l.dataId).values,T=N.makeTensorInfo(W.shape,"complex64");return N.data.get(T.dataId).complexTensorInfos={real:N.makeTensorInfo(W.shape,"float32",w),imag:N.makeTensorInfo(l.shape,"float32",M)},T}h.d(le,{P:()=>Z,z:()=>y});const y={kernelName:h(9075).Zz9,backendName:"cpu",kernelFunc:Z}},9971:(Et,le,h)=>{"use strict";h.d(le,{j:()=>Z});var U=h(9075);function Z(y,F,I,N){const W=U.D5U.getArrayFromDType(I,U.D5U.sizeFromShape(F));if(N&&"string"!==I){let l=0;y.forEach(w=>{const M=U.D5U.sizeFromShape(w.shape);W.set(w.vals,l),l+=M})}else{let l=0;y.forEach(w=>{const M="string"===I?U.backend_util.fromUint8ToStringArray(w.vals):w.vals;let T=0;for(let D=0;D<w.shape[0];++D){const G=D*F[1]+l;for(let J=0;J<w.shape[1];++J)W[G+J]=M[T++]}l+=w.shape[1]})}return W}},5190:(Et,le,h)=>{"use strict";h.d(le,{Dg:()=>I,Kx:()=>N,tW:()=>F});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>W===l?1:0),I=(0,y.j)(U.hdR,F,null,"bool"),N={kernelName:U.hdR,backendName:"cpu",kernelFunc:I}},622:(Et,le,h)=>{"use strict";h.d(le,{Qq:()=>I,Ro:()=>F,SX:()=>N});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>Math.exp(W)),I=(0,y.O)(U.NEP,F,"float32"),N={kernelName:U.NEP,backendName:"cpu",kernelFunc:I}},7166:(Et,le,h)=>{"use strict";h.d(le,{OF:()=>F,Vu:()=>N});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>Math.expm1(W)),I=(0,y.O)(U.Y0y,F),N={kernelName:U.Y0y,backendName:"cpu",kernelFunc:I}},1471:(Et,le,h)=>{"use strict";h.d(le,{Ao:()=>N,r6:()=>F});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>Math.floor(W)),I=(0,y.O)(U.OR,F),N={kernelName:U.OR,backendName:"cpu",kernelFunc:I}},7846:(Et,le,h)=>{"use strict";h.d(le,{EE:()=>N,JP:()=>F});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>Math.floor(W/l)),I=(0,y.j)(U.jeX,F,null,"int32"),N={kernelName:U.jeX,backendName:"cpu",kernelFunc:I}},2465:(Et,le,h)=>{"use strict";h.d(le,{m:()=>Z});var U=h(9075);function Z(y,F,I,N,W,l,w,M,T){const D=(0,U.f3b)([N,l],I);for(let G=0;G<N;G++){const J=[];let K=0;for(let _e=0;_e<W;_e++){const Re=y[G*W+_e];K+=Re*w[_e],J.push(Re)}if(K<0||K>=T/l)throw new Error(`Invalid indices: ${J} does not index into ${M}`);for(let _e=0;_e<l;_e++)D.values[G*l+_e]=F.get(...F.indexToLoc(K*l+_e))}return D}},2697:(Et,le,h)=>{"use strict";h.d(le,{i:()=>Z});var U=h(9075);function Z(y,F,I){const N=(0,U.f3b)(I,y.dtype);for(let W=0;W<N.size;++W){const w=N.indexToLoc(W).slice(),D=F.locToIndex([w[0],w[2]]);w[2]=F.values[D];const G=y.locToIndex(w);0<=G&&G<y.values.length&&(N.values[W]=y.values[G])}return N}},4730:(Et,le,h)=>{"use strict";h.d(le,{Ce:()=>N,o:()=>F});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>W>l?1:0),I=(0,y.j)(U.iZT,F,null,"bool"),N={kernelName:U.iZT,backendName:"cpu",kernelFunc:I}},7310:(Et,le,h)=>{"use strict";h.d(le,{HL:()=>F,V:()=>N});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>W>=l?1:0),I=(0,y.j)(U.Acj,F,null,"bool"),N={kernelName:U.Acj,backendName:"cpu",kernelFunc:I}},6781:(Et,le,h)=>{"use strict";function Z(F){const{inputs:I,backend:N}=F,{x:W}=I;return N.incRef(W.dataId),{dataId:W.dataId,shape:W.shape,dtype:W.dtype}}h.d(le,{I:()=>y,y:()=>Z});const y={kernelName:h(9075).iJz,backendName:"cpu",kernelFunc:Z}},2339:(Et,le,h)=>{"use strict";h.d(le,{rO:()=>F,zh:()=>N});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>W<l?1:0),I=(0,y.j)(U.vtC,F,null,"bool"),N={kernelName:U.vtC,backendName:"cpu",kernelFunc:I}},33:(Et,le,h)=>{"use strict";h.d(le,{lx:()=>F,m3:()=>N});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>W<=l?1:0),I=(0,y.j)(U.CAk,F,null,"bool"),N={kernelName:U.CAk,backendName:"cpu",kernelFunc:I}},3373:(Et,le,h)=>{"use strict";h.d(le,{b:()=>Z});var U=h(9075);function Z(y,F,I){const N=(F-y)/(I-1),W=U.D5U.makeZerosTypedArray(I,"float32");W[0]=y;for(let l=1;l<W.length;l++)W[l]=W[l-1]+N;return W}},6723:(Et,le,h)=>{"use strict";h.d(le,{vX:()=>F,xM:()=>N});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>Math.log(W)),I=(0,y.O)(U.ZbH,F),N={kernelName:U.ZbH,backendName:"cpu",kernelFunc:I}},7727:(Et,le,h)=>{"use strict";h.d(le,{B:()=>Z});var U=h(9075);function Z(y,F,I,N){const W=U.D5U.getTypedArrayFromDType(N,U.D5U.sizeFromShape(I));for(let l=0;l<W.length;++l){const w=l*F;let M=y[w];for(let T=0;T<F;++T){const D=y[w+T];(Number.isNaN(D)||D>M)&&(M=D)}W[l]=M}return W}},6160:(Et,le,h)=>{"use strict";h.d(le,{eJ:()=>N,wS:()=>F});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>Math.max(W,l)),I=(0,y.j)(U.BMI,F),N={kernelName:U.BMI,backendName:"cpu",kernelFunc:I}},8170:(Et,le,h)=>{"use strict";h.d(le,{u0:()=>N,vP:()=>F});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>Math.min(W,l)),I=(0,y.j)(U.q8u,F),N={kernelName:U.q8u,backendName:"cpu",kernelFunc:I}},7985:(Et,le,h)=>{"use strict";h.d(le,{$3:()=>F,Jp:()=>N,f$:()=>W});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((l,w)=>l*w),I=(0,y.H)((l,w,M,T)=>({real:l*M-w*T,imag:l*T+w*M})),N=(0,y.j)(U.wYn,F,I),W={kernelName:U.wYn,backendName:"cpu",kernelFunc:N}},9994:(Et,le,h)=>{"use strict";h.d(le,{AF:()=>N,uC:()=>F});var U=h(9075),Z=h(4050),y=h(7985);function F(W,l,w){const M=U.D5U.createScalarValue(-1,w);return(0,y.$3)([],l,M,W,w)}const N={kernelName:U.kuV,backendName:"cpu",kernelFunc:function I(W){const{inputs:l,backend:w}=W,{x:M}=l;(0,Z.H)(M,"neg");const T=w.data.get(M.dataId).values,[D,G]=F(T,M.shape,M.dtype);return w.makeTensorInfo(G,M.dtype,D)}}},7555:(Et,le,h)=>{"use strict";h.d(le,{Gj:()=>F,nP:()=>N});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>W!==l?1:0),I=(0,y.j)(U.yQU,F,null,"bool"),N={kernelName:U.yQU,backendName:"cpu",kernelFunc:I}},2585:(Et,le,h)=>{"use strict";h.d(le,{Iz:()=>N,Qg:()=>F});var U=h(9075),Z=h(4050),y=h(1239);function F(W,l,w,M){const[T,D]=U.backend_util.computeOutAndReduceShapes(W,M),G=(0,U.x8V)(l,"int32"),J=U.D5U.makeZerosTypedArray(U.D5U.sizeFromShape(T),G),K=U.D5U.sizeFromShape(D);for(let _e=0;_e<J.length;++_e){const Re=_e*K;let we=1;for(let We=0;We<K;++We)we*=w[Re+We];J[_e]=we}return{outVals:J,outShape:T,outDtype:G}}const N={kernelName:U.DlI,backendName:"cpu",kernelFunc:function I(W){const{inputs:l,backend:w,attrs:M}=W,{x:T}=l,{axis:D,keepDims:G}=M;(0,Z.H)(T,"prod");const J=T.shape.length,K=U.D5U.parseAxisParam(D,T.shape),_e=U.backend_util.getAxesPermutation(K,J);let Re=K,we=T;const We=[];null!=_e&&(we=(0,y.p)({inputs:{x:T},backend:w,attrs:{perm:_e}}),We.push(we),Re=U.backend_util.getInnerMostAxes(Re.length,J));const Oe=w.data.get(we.dataId).values,{outVals:ie,outShape:Le,outDtype:De}=F(we.shape,we.dtype,Oe,Re);let te=Le;return G&&(te=U.backend_util.expandShapeToKeepDim(Le,K)),We.forEach(de=>w.disposeIntermediateTensorInfo(de)),w.makeTensorInfo(te,De,ie)}}},6134:(Et,le,h)=>{"use strict";h.d(le,{c:()=>w});var U=h(9075);function N(M,T){const D=M.slice(0,T);for(;D.length<T;)D.push(1);for(let G=T;G<M.length;G++)D[T-1]*=M[G];return D}function w(M,T,D,G,J,K,_e,Re){if(0===M.length)throw new Error("paramsNestedSplits must be non empty");if(0===T[0].length)throw new Error("Split tensors must not be scalars");if(function Z(M,T,D){M.forEach((G,J)=>{if(G<0||G>=D){const K=U.D5U.indexToLoc(J,T.length,U.D5U.computeStrides(T)).join(",");throw new Error(`indices[${K}] = ${G} is not in [0, ${D})`)}})}(K,_e,T[0][0]-1),0===G.length)throw new Error("params.rank must be nonzero");const We=G[0],{outSplits:Oe,valueSlices:ie,numValues:Le}=function F(M,T,D,G){const J=[];let K=0;const Re=new Array(T.length-1+D.length).fill(null).map(()=>[0]);!function y(M,T){for(let D=0;D<M.length;++D){const G=M[D],J=D===M.length-1?T:M[D+1].length;if(0===G.length)throw new Error("Ragged splits may not be empty");if(G[0]<0)throw new Error("Ragged splits must be non-negative");if(G[G.length-1]>J)throw new Error("Ragged splits must not point past values");for(let K=1;K<G.length;++K)if(G[K-1]>G[K])throw new Error("Ragged splits must be sorted in ascending order")}}(D,G);let we=1;for(let We=0;We<T.length-1;++We){we*=T[We];const Oe=T[We+1];for(let ie=1;ie<we+1;++ie)Re[We].push(ie*Oe)}for(let We=0;We<M.length;++We){let Oe=M[We],ie=M[We]+1;for(let Le=0;Le<D.length;++Le){const De=D[Le],te=Le+T.length-1;if(te>=0){const de=Re[te],P=de[de.length-1]-De[Oe];for(let oe=Oe;oe<ie;++oe)Re[te].push(De[oe+1]+P)}Oe=De[Oe],ie=De[ie]}ie!==Oe&&(J.push([Oe,ie]),K+=ie-Oe)}return{outSplits:Re,valueSlices:J,numValues:K}}(K,_e,M,We),De=function I(M){const T=[];for(let D=0;D<M.length;++D){const J=U.D5U.getArrayFromDType("int32",M[D].length);T.push(J),M[D].forEach((K,_e)=>J[_e]=K)}return T}(Oe),te=function l(M,T,D,G,J){const K=T.slice();K[0]=J;const _e=U.D5U.getArrayFromDType(D,U.D5U.sizeFromShape(K)),Re=M.length;return function W(M,T,D,G,J,K){const _e=N(T,2)[1],Re=N(K,2)[1];let we=0;for(const We of D)for(let Oe=We[0];Oe<We[1];++Oe){for(let ie=0;ie<G;++ie)J[we*Re+ie]=M[Oe*_e+ie];++we}}(M,T,G,0===Re?0:Re/T[0],_e,K),[_e,K]}(D,G,J,ie,Le);return[De,te[0],te[1]]}},832:(Et,le,h)=>{"use strict";h.d(le,{S:()=>y});var U=h(9075);const Z=2147483647;function y(F,I,N,W,l,w,M){if(I.length>1)throw new Error("starts must be a scalar or vector");if(l.length>1)throw new Error("limits must be a scalar or vector");if(M.length>1)throw new Error("deltas must be a scalar or vector");const T=0===I.length,D=0===l.length,G=0===M.length,J=[];T||J.push(I[0]),D||J.push(l[0]),G||J.push(M[0]);for(let Oe=1;Oe<J.length;++Oe)if(J[Oe]!==J[Oe-1])throw new Error("starts, limits, and deltas must have the same shape");const K=0===J.length?1:J[0],_e=U.D5U.getArrayFromDType("int32",K+1);_e[0]=0;for(let Oe=0;Oe<K;++Oe){const ie=T?F[0]:F[Oe],Le=D?W[0]:W[Oe],De=G?w[0]:w[Oe];if(0===De)throw new Error("Requires delta != 0");let te;if(De>0&&Le<ie||De<0&&Le>ie)te=0;else if(te=Math.ceil(Math.abs((Le-ie)/De)),te>Z)throw new Error(`Requires ((limit - start) / delta) <= ${Z}`);_e[Oe+1]=_e[Oe]+te}const we=U.D5U.getArrayFromDType(N,_e[K]);let We=0;for(let Oe=0;Oe<K;++Oe){const ie=_e[Oe+1]-_e[Oe];let Le=T?F[0]:F[Oe];const De=G?w[0]:w[Oe];for(let te=0;te<ie;++te)we[We++]=Le,Le+=De}return[_e,we]}},820:(Et,le,h)=>{"use strict";h.d(le,{p:()=>N});var U=h(9075),Z=U.backend_util.RowPartitionType;class y{constructor(l,w,M,T,D,G,J,K,_e,Re){this.shape=l,this.shapeShape=w,this.values=M,this.valuesShape=T,this.valuesDType=D,this.defaultValue=G,this.defaultValueShape=J,this.rowPartitionValues=K,this.rowPartitionValuesShapes=_e,this.rowPartitionTypes=U.backend_util.getRowPartitionTypesHelper(Re),this.raggedRank=U.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(l){return this.rowPartitionTypes[0]===Z.FIRST_DIM_SIZE?this.rowPartitionTypes[l+1]:this.rowPartitionTypes[l]}getRowPartitionTensor(l){return this.rowPartitionTypes[0]===Z.FIRST_DIM_SIZE?this.rowPartitionValues[l+1]:this.rowPartitionValues[l]}getMaxWidth(l){const w=this.getRowPartitionTensor(l-1);switch(this.getRowPartitionTypeByDimension(l-1)){case Z.VALUE_ROWIDS:return y.getMaxWidthValueRowID(w);case Z.ROW_SPLITS:return y.getMaxWidthRowSplit(w);default:throw new Error(`Cannot handle partition type ${Z[this.getRowPartitionTypeByDimension(l-1)]}`)}}static getMaxWidthRowSplit(l){const w=l.length;if(0===w||1===w)return 0;let M=0;for(let T=0;T<w-1;++T){const D=l[T+1]-l[T];D>M&&(M=D)}return M}static getMaxWidthValueRowID(l){const w=l.length;if(0===w)return 0;let M=0,T=l[0],D=0;for(let G=1;G<w;++G){const J=l[G];J!==T&&(T=J,D=Math.max(G-M,D),M=G)}return Math.max(w-M,D)}tensorShapeFromTensor(l,w,M=!0){if(0===w.length){if(-1===l[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return I(l,M)}calculateOutputSize(l){const w=this.valuesShape;U.backend_util.validateDefaultValueShape(this.defaultValueShape,w);const T=this.tensorShapeFromTensor(this.shape,this.shapeShape),G=U.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,T,w);G[0]<0&&(G[0]=l);for(let J=1;J<=this.raggedRank;++J)G[J]<0&&(G[J]=this.getMaxWidth(J));return G}calculateFirstParentOutputIndex(l,w,M){const T=Math.min(l,M),D=[];let G=0;for(let J=0;J<T;++J,G+=w)D.push(G);for(let J=T;J<l;++J)D.push(-1);return U.D5U.assert(D.length===l,()=>"Final length of result must be equal to firstDimension."),D}calculateOutputIndexRowSplit(l,w,M,T){const D=l.length,G=[];for(let J=0;J<D-1;++J){const K=l[J+1]-l[J];let _e=Math.min(T,K),Re=w[J];-1===Re&&(_e=0);for(let we=0;we<_e;++we)G.push(Re),Re+=M;for(let we=0;we<K-_e;++we)G.push(-1)}if(D>0&&G.length!==l[D-1])throw new Error("Invalid row split size.");return G}calculateOutputIndexValueRowID(l,w,M,T){const D=l.length,G=[];if(0===D)return[];let J=0,K=l[0];if(K>=w.length)throw new Error(`Got currentValueRowId=${K}, which is not less than ${w.length}`);let _e=w[K];G.push(_e);for(let Re=1;Re<D;++Re){const we=l[Re];if(we===K)_e>=0&&(++J,J<T?_e+=M:_e=-1);else{if(J=0,K=we,we>=w.length)throw new Error(`Got nextValueRowId=${we} which is not less than ${w.length}`);_e=w[we]}G.push(_e)}if(G.length!==l.length)throw new Error("Invalid row ids.");return G}calculateOutputIndex(l,w,M,T){const D=this.getRowPartitionTensor(l),G=this.getRowPartitionTypeByDimension(l);switch(G){case Z.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(D,w,M,T);case Z.ROW_SPLITS:if(D.length-1>w.length)throw new Error(`Row partition size is greater than output size: ${D.length-1} > ${w.length}`);return this.calculateOutputIndexRowSplit(D,w,M,T);default:throw new Error(`Unsupported partition type: ${Z[G]}`)}}getFirstDimensionSize(){const l=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const w=this.rowPartitionTypes[0];switch(w){case Z.FIRST_DIM_SIZE:return l[0];case Z.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Z.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Z[w]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const w=this.getFirstDimensionSize(),M=this.calculateOutputSize(w),T=new Array(this.raggedRank+1);T[T.length-1]=1;for(let K=T.length-2;K>=0;--K)T[K]=T[K+1]*M[K+1];const D=I(M,!1),G=U.D5U.getArrayFromDType(this.valuesDType,U.D5U.sizeFromShape(D));if(T[0]*M[0]>0){let K=this.calculateFirstParentOutputIndex(w,T[0],M[0]);for(let _e=1;_e<=this.raggedRank;++_e)K=this.calculateOutputIndex(_e-1,K,T[_e],M[_e]);this.setOutput(this.raggedRank,K,G,D)}return[D,G]}setOutput(l,w,M,T){if(0===M.length)return;const D=this.values,G=M;let J=T.slice();J=J.slice(l+1);const K=U.D5U.sizeFromShape(J),_e=w.length;let Re=this.defaultValue;if(Re.length!==K&&1!==Re.length){const ie=this.defaultValueShape;(0,U.lub)(()=>{const Le=(0,U.XLQ)(Re,ie);Re=(0,U.UFq)(Le,J).dataSync()})}let we=0,We=0,Oe=0;for(let ie=0;ie<=_e;++ie){let Le=ie<_e?w[ie]:-1;if(Le!==Oe){if(We<Oe){const De=D.subarray(we*K);F(G.subarray(We*K),De,(Oe-We)*K)}if(ie>=_e&&(Le=Math.floor(M.length/K)),Le>Oe)if(1===this.defaultValue.length)G.subarray(Oe*K,Le*K).fill(this.defaultValue[0]),Oe=Le;else for(;Le>Oe;)F(G.slice(Oe*K),Re,K),++Oe;Le<0?(we=ie+1,We=Oe):(we=ie,We=Oe,Oe=We+1)}else++Oe}}}function F(W,l,w){for(let M=0;M<w;M++)W[M]=l[M]}function I(W,l){const w=[];for(let M of W){if(M<0){if(!l)throw new Error(`Dimension ${M} must be >= 0`);if(M<-1)throw new Error(`Dimension ${M} must be >= -1`);M=-1}w.push(M)}return w}function N(W,l,w,M,T,D,G,J,K,_e){return new y(W,l,w,M,T,D,G,J,K,_e).compute()}},6229:(Et,le,h)=>{"use strict";h.d(le,{b:()=>Z});var U=h(9075);function Z(y,F,I,N){if(y===F||y<F&&I<0||F<y&&I>1)return U.D5U.makeZerosTypedArray(0,N);const M=Math.abs(Math.ceil((F-y)/I)),T=U.D5U.makeZerosTypedArray(M,N);F<y&&1===I&&(I=-1),T[0]=y;for(let D=1;D<T.length;D++)T[D]=T[D-1]+I;return T}},4353:(Et,le,h)=>{"use strict";function Z(F){const{inputs:I,backend:N}=F,{input:W}=I,l=N.data.get(W.dataId).complexTensorInfos.real,w=N.data.get(l.dataId).values;return N.makeTensorInfo(l.shape,l.dtype,w)}h.d(le,{O:()=>y,k:()=>Z});const y={kernelName:h(9075).xJR,backendName:"cpu",kernelFunc:Z}},1509:(Et,le,h)=>{"use strict";h.d(le,{FY:()=>N,zd:()=>F});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>1/Math.sqrt(W)),I=(0,y.O)(U.bV0,F),N={kernelName:U.bV0,backendName:"cpu",kernelFunc:I}},2529:(Et,le,h)=>{"use strict";h.d(le,{N:()=>Z});var U=h(9075);function Z(y,F,I,N,W,l,w,M,T,D){const G=[N/W,W],J=y.values,K=F.values;if(0===N)return(0,U.f3b)(I,F.dtype);const _e=T instanceof U.YDk?T:(0,U.f3b)(G,F.dtype);"string"==typeof T||"number"==typeof T?_e.values.fill(T):"boolean"==typeof T&&_e.values.fill(+T);for(let Re=0;Re<l;Re++){const we=[];let We=0;for(let Oe=0;Oe<w;Oe++){const ie=J[Re*w+Oe];we.push(ie),We+=ie*M[Oe]}if(We<0||We>=N/W)throw new Error(`Invalid indices: ${we} does not index into ${I}`);for(let Oe=0;Oe<W;Oe++)D?_e.values[We*W+Oe]+=K[Re*W+Oe]:_e.values[We*W+Oe]=0===F.rank?K[0]:K[Re*W+Oe]}return _e}},2250:(Et,le,h)=>{"use strict";h.d(le,{BP:()=>N,VY:()=>F,XD:()=>I});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>1/(1+Math.exp(-W))),I=(0,y.A)(U.a5O,W=>1/(1+Math.exp(-W))),N={kernelName:U.a5O,backendName:"cpu",kernelFunc:I}},5006:(Et,le,h)=>{"use strict";h.d(le,{C6:()=>I,rT:()=>y,tP:()=>F});var U=h(9075),Z=h(4050);function y(N,W,l,w,M){const T=U.kuN.isSliceContinous(w,W,l),D=U.D5U.sizeFromShape(l),G=U.D5U.computeStrides(w);if(T){const Re=U.kuN.computeFlatOffset(W,G);return"string"===M?N.slice(Re,Re+D):N.subarray(Re,Re+D)}const J="string"===M?U.backend_util.fromUint8ToStringArray(N):N,K=(0,U.f3b)(w,M,J),_e=(0,U.f3b)(l,M);for(let Re=0;Re<_e.size;++Re){const we=_e.indexToLoc(Re),We=we.map((Oe,ie)=>Oe+W[ie]);_e.set(K.get(...We),...we)}return"string"===M?U.backend_util.fromStringArrayToUint8(_e.values):_e.values}function F(N){const{inputs:W,backend:l,attrs:w}=N,{x:M}=W,{begin:T,size:D}=w;(0,Z.H)(M,"slice");const[G,J]=U.kuN.parseSliceParams(M,T,D);U.kuN.assertParamsValid(M,G,J);const _e=y(l.data.get(M.dataId).values,G,J,M.shape,M.dtype);return l.makeTensorInfo(J,M.dtype,_e)}const I={kernelName:U.p2w,backendName:"cpu",kernelFunc:F}},5483:(Et,le,h)=>{"use strict";h.d(le,{c:()=>Z});var U=h(9075);function Z(y,F,I,N,W,l,w){const M=F[0],T=l[0],D=new Array(T),G=new Array(M),J=F[1];if(0===T){if(0!==M)throw new Error(U.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(M));return[U.D5U.getArrayFromDType(I,0),[0,J],U.D5U.getArrayFromDType(W,0),D,G]}let K=!0,_e=0;const Re=new Array(T).fill(0);for(let We=0;We<M;++We){const Oe=y[We*J];if(Oe<0)throw new Error(U.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(We,Oe));if(Oe>=T)throw new Error(U.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(We,Oe,T));++Re[Oe],K=K&&Oe>=_e,_e=Oe}let we=!0;for(let We=0;We<T;++We){const Oe=0===Re[We];D[We]=Oe,we=we&&!Oe,Re[We]=Math.max(Re[We],1),We>0&&(Re[We]+=Re[We-1])}if(we&&K){const We=y,Oe=N;for(let ie=0;ie<M;++ie)G[ie]=ie;return[We,[M,J],Oe,D,G]}{const We=Re[T-1],Oe=U.D5U.getArrayFromDType(I,We*J),ie=U.D5U.getArrayFromDType(W,We),Le=new Array(T).fill(0);for(let De=0;De<M;++De){const te=y[De*J],P=(0===te?0:Re[te-1])+Le[te];Le[te]++;for(let oe=0;oe<J;++oe)Oe[P*J+oe]=y[De*J+oe];ie[P]=N[De],G[De]=P}for(let De=0;De<T;++De)if(0===Le[De]){const de=0===De?0:Re[De-1];Oe[de*J+0]=De;for(let P=1;P<J;++P)Oe[de*J+P]=0;ie[de]=w}return[Oe,[We,J],ie,D,G]}}},9912:(Et,le,h)=>{"use strict";h.d(le,{U:()=>Z});var U=h(9075);function Z(y,F,I,N,W){const l=U.D5U.sizeFromShape(N),w=F[0],M=W.length,T=[];let D=1,G=-1;for(let We=0;We<M;++We){const Oe=W[We];if(-1===Oe){if(-1!==G)throw new Error(U.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(G,We));G=We,T.push(1)}else{if(Oe<0)throw new Error(U.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(We,Oe));D*=Oe,T.push(Oe)}}if(-1!==G){if(D<=0)throw new Error(U.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const We=Math.trunc(l/D);if(D*We!==l)throw new Error(U.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(N,T));T[G]=We}if(U.D5U.sizeFromShape(T)!==l)throw new Error(U.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(N,T));const K=N.length,_e=[];if(K>0){_e[K-1]=1;for(let We=K-2;We>=0;--We)_e[We]=_e[We+1]*N[We+1]}const Re=[];if(M>0){Re[M-1]=1;for(let We=M-2;We>=0;--We)Re[We]=Re[We+1]*T[We+1]}const we=U.D5U.getArrayFromDType(I,w*M);for(let We=0;We<w;++We){let Oe=0;for(let ie=0;ie<K;++ie)Oe+=y[We*K+ie]*_e[ie];for(let ie=0;ie<M;++ie)we[We*M+ie]=Math.trunc(Oe/Re[ie]),Oe%=Re[ie]}return[we,[w,M],T]}},391:(Et,le,h)=>{"use strict";h.d(le,{V:()=>Z});var U=h(9075);function Z(y,F,I,N,W,l=!1,w=0){const M=N.length,T=[F[0],y.length/F[0]],D=T[1],J=M>0?W[M-1]+1:0;if(J<0)throw new Error(U.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const K=F.slice();K[0]=J;const _e=K.reduce((Le,De)=>Le*De,1),Re=U.D5U.getArrayFromDType(I,_e);if(0===M)return J>0&&Re.fill(w),[Re,K];if(J<=0)throw new Error(U.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let we=0,We=1,Oe=0,ie=W[we];for(;;){let Le=0;if(We<M){if(Le=W[We],ie===Le){++We;continue}if(ie>=Le)throw new Error(U.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(ie<0||ie>=J)throw new Error(U.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(ie,J));ie>Oe&&Re.fill(w,Oe*D,ie*D);for(let De=we;De<We;++De){const te=N[De];if(te<0||te>=T[0])throw new Error(U.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(De,N[De],T[0]));for(let de=0;de<D;de++)Re[ie*D+de]+=y[te*D+de]}if(l)for(let De=0;De<D;De++)Re[ie*D+De]/=We-we;if(we=We,++We,Oe=ie+1,ie=Le,We>M)break}return Oe<J&&Re.fill(w,Oe*D,J*D),[Re,K]}},6769:(Et,le,h)=>{"use strict";h.d(le,{cz:()=>N,zT:()=>F});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)(W=>Math.sqrt(W)),I=(0,y.A)(U.FKq,W=>Math.sqrt(W)),N={kernelName:U.FKq,backendName:"cpu",kernelFunc:I}},4376:(Et,le,h)=>{"use strict";h.d(le,{Hz:()=>F,MS:()=>N});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((W,l)=>{const w=W-l;return w*w}),I=(0,y.j)(U._tC,F),N={kernelName:U._tC,backendName:"cpu",kernelFunc:I}},6893:(Et,le,h)=>{"use strict";h.d(le,{P:()=>F,j:()=>N});var U=h(9075),Z=h(1623),y=h(1832);const F=(0,Z.a)((W,l)=>{const{pattern:w,replaceGlobal:M,rewrite:T}=l;return W.replace(new RegExp(w,M?"g":""),T)}),I=(0,y.O)(U.e0R,F),N={kernelName:U.e0R,backendName:"cpu",kernelFunc:I}},5549:(Et,le,h)=>{"use strict";h.d(le,{t:()=>Z});var U=h(9075);function Z(y,F,I,N){const W=(0,U.f3b)(y,F.dtype);for(let l=0;l<W.size;l++){const w=W.indexToLoc(l),M=new Array(w.length);for(let T=0;T<M.length;T++)M[T]=w[T]*I[T]+N[T];W.set(F.get(...M),...w)}return W}},3118:(Et,le,h)=>{"use strict";h.d(le,{A:()=>y});var U=h(9075);class Z{constructor(I,N,W,l,w,M){this.separator=U.D5U.encodeString(I),this.nGramWidths=N,this.leftPad=U.D5U.encodeString(W),this.rightPad=U.D5U.encodeString(l),this.padWidth=w,this.preserveShort=M}getPadWidth(I){return Math.min(this.padWidth<0?I-1:this.padWidth,I-1)}getNumNGrams(I,N){const W=this.getPadWidth(N);return Math.max(0,I+2*W-N+1)}createNGrams(I,N,W,l,w,M){for(let T=0;T<w;++T){const D=this.getPadWidth(M),G=Math.max(0,D-T),J=Math.max(0,D-(w-(T+1))),K=M-(G+J),_e=N+(G>0?0:T-D);let Re=0;Re+=G*this.leftPad.length;for(let Le=0;Le<K;++Le)Re+=I[_e+Le].length;Re+=J*this.rightPad.length,Re+=(G+J+K-1)*this.separator.length,W[l+T]=new Uint8Array(Re);const We=W[l+T];let Oe=0;const ie=Le=>Le.forEach(De=>We[Oe++]=De);for(let Le=0;Le<G;++Le)ie(this.leftPad),ie(this.separator);for(let Le=0;Le<K-1;++Le)ie(I[_e+Le]),ie(this.separator);if(K>0){ie(I[_e+K-1]);for(let Le=0;Le<J;++Le)ie(this.separator),ie(this.rightPad)}else{for(let Le=0;Le<J-1;++Le)ie(this.rightPad),ie(this.separator);ie(this.rightPad)}}}compute(I,N){const W=I.length,l=N.length;if(l>0){let D=N[0];if(0!==D)throw new Error(`First split value must be 0, got ${D}`);for(let G=1;G<l;++G){let J=N[G]>=D;if(J=J&&N[G]<=W,!J)throw new Error(`Invalid split value ${N[G]}, must be in [${D}, ${W}]`);D=N[G]}if(D!==W)throw new Error(`Last split value must be data size. Expected ${W}, got ${D}`)}const w=l-1,M=U.D5U.getArrayFromDType("int32",l);if(0===W||0===l){const D=new Array(W);for(let G=0;G<=w;++G)M[G]=0;return[D,M]}M[0]=0;for(let D=1;D<=w;++D){const G=N[D]-N[D-1];let J=0;this.nGramWidths.forEach(K=>{J+=this.getNumNGrams(G,K)}),this.preserveShort&&G>0&&0===J&&(J=1),M[D]=M[D-1]+J}const T=new Array(M[w]);for(let D=0;D<w;++D){const G=N[D];let J=M[D];if(this.nGramWidths.forEach(K=>{const Re=this.getNumNGrams(N[D+1]-N[D],K);this.createNGrams(I,G,T,J,Re,K),J+=Re}),this.preserveShort&&J===M[D]){const K=N[D+1]-N[D];if(0===K)continue;this.createNGrams(I,G,T,J,1,K+2*this.padWidth)}}return[T,M]}}function y(F,I,N,W,l,w,M,T){return new Z(N,W,l,w,M,T).compute(F,I)}},6482:(Et,le,h)=>{"use strict";h.d(le,{Q:()=>y});var U=h(9075);function Z(F,I,N,W){if(!F.length)return;if(0===I.length){for(let w=0;w<F.length;++w)W.push(F.subarray(w,w+1));return}if(1===I.length){const w=I[0];let M=F.indexOf(w);for(;-1!==M;){const T=F.subarray(0,M);(!N||0!==T.length)&&W.push(T),M=(F=F.subarray(M+1)).indexOf(w)}return void((!N||0!==F.length)&&W.push(F))}let l=0;for(let w=0;w<F.length+1;w++)if(w===F.length||-1!==I.indexOf(F[w])){const M=F.subarray(l,w);(!N||0!==M.length)&&W.push(M),l=w+1}}function y(F,I,N){const W=F.length,l=[];let w=0,M=0;const T=new Array(W);for(let _e=0;_e<W;++_e){const Re=l.length;Z(F[_e],I,N,l);const we=l.length-Re;T[_e]=we,w+=we,M=Math.max(M,we)}const D=U.D5U.getArrayFromDType("int32",2*w),G=new Array(w),J=[W,M];let K=0;for(let _e=0;_e<W;++_e)for(let Re=0;Re<T[_e];++Re)D[2*K]=_e,D[2*K+1]=Re,G[K]=l[K],++K;return[D,G,J]}},4105:(Et,le,h)=>{"use strict";h.d(le,{h:()=>Z});var U=h(9075);function Z(y,F){const I=U.D5U.getArrayFromDType("int32",y.length);for(let N=0;N<y.length;++N)I[N]=U.D5U.fingerPrint64(y[N]).modulo(F).getLowBitsUnsigned();return I}},1981:(Et,le,h)=>{"use strict";h.d(le,{GR:()=>W,VY:()=>F,lu:()=>N});var U=h(9075),Z=h(9450),y=h(9642);const F=(0,Z.b)((l,w)=>l-w),I=(0,y.H)((l,w,M,T)=>({real:l-M,imag:w-T})),N=(0,y.j)(U.Tr8,F,I),W={kernelName:U.Tr8,backendName:"cpu",kernelFunc:N}},1692:(Et,le,h)=>{"use strict";h.d(le,{R:()=>Z});var U=h(9075);function Z(y,F){const I=new Array(y.rank);for(let W=0;W<I.length;W++)I[W]=y.shape[W]*F[W];const N=(0,U.f3b)(I,y.dtype);for(let W=0;W<N.values.length;++W){const l=N.indexToLoc(W),w=new Array(y.rank);for(let T=0;T<w.length;T++)w[T]=l[T]%y.shape[T];const M=y.locToIndex(w);N.values[W]=y.values[M]}return N}},9942:(Et,le,h)=>{"use strict";h.d(le,{W:()=>F});var U=h(9075);const Z=(I,N)=>{const W=N.value-I.value;return 0===W?I.index-N.index:W};function y(I,N,W=0,l=I.length-1){for(;l>W;){if(l-W>600){const D=l-W+1,G=N-W+1,J=Math.log(D),K=.5*Math.exp(2*J/3),_e=.5*Math.sqrt(J*K*(D-K)/D)*Math.sign(G-D/2);y(I,N,Math.max(W,Math.floor(N-G*K/D+_e)),Math.min(l,Math.floor(N+(D-G)*K/D+_e)))}const w=I[N];let M=W,T=l;for(U.D5U.swap(I,W,N),Z(I[l],w)>0&&U.D5U.swap(I,W,l);M<T;){for(U.D5U.swap(I,M,T),M++,T--;Z(I[M],w)<0;)M+=1;for(;Z(I[T],w)>0;)T-=1}0===Z(I[W],w)?U.D5U.swap(I,W,T):(T+=1,U.D5U.swap(I,T,l)),T<=N&&(W=T+1),N<=T&&(l=T-1)}}function F(I,N,W,l,w){const M=N[N.length-1],[T,D]=[I.length/M,M],G=U.D5U.getTypedArrayFromDType(W,T*l),J=U.D5U.getTypedArrayFromDType("int32",T*l);for(let _e=0;_e<T;_e++){const Re=_e*D,we=I.subarray(Re,Re+D);let We=new Array(we.length);we.forEach((De,te)=>We[te]={value:De,index:te}),l<We.length&&(y(We,l),We=We.slice(0,l)),w&&We.sort(Z);const Oe=_e*l,ie=G.subarray(Oe,Oe+l),Le=J.subarray(Oe,Oe+l);for(let De=0;De<l;De++)ie[De]=We[De].value,Le[De]=We[De].index}const K=N.slice();return K[K.length-1]=l,[(0,U.f3b)(K,W,G),(0,U.f3b)(K,"int32",J)]}},1239:(Et,le,h)=>{"use strict";h.d(le,{b:()=>I,p:()=>F});var U=h(9075),Z=h(4050),y=h(8385);function F(N){const{inputs:W,attrs:l,backend:w}=N,{x:M}=W,{perm:T}=l;(0,Z.H)(M,"transpose");const G=new Array(M.shape.length);for(let Re=0;Re<G.length;Re++)G[Re]=M.shape[T[Re]];const J=w.data.get(M.dataId).values,K=(0,y.H)(J,M.shape,M.dtype,T,G);return{dataId:w.write(K,G,M.dtype),shape:G,dtype:M.dtype}}const I={kernelName:U.G3Y,backendName:"cpu",kernelFunc:F}},8385:(Et,le,h)=>{"use strict";h.d(le,{H:()=>Z});var U=h(9075);function Z(y,F,I,N,W){const l=F.length,w=U.D5U.sizeFromShape(F),M=U.D5U.computeStrides(F),T=U.D5U.computeStrides(W),D=U.D5U.getTypedArrayFromDType(I,U.D5U.sizeFromShape(W));for(let G=0;G<w;++G){const J=U.D5U.indexToLoc(G,l,M),K=new Array(J.length);for(let Re=0;Re<K.length;Re++)K[Re]=J[N[Re]];D[U.D5U.locToIndex(K,l,T)]=y[G]}return D}},705:(Et,le,h)=>{"use strict";h.d(le,{S:()=>Z});var U=h(9075);function Z(y,F,I,N){const W=U.D5U.parseAxisParam(F,I)[0],l=[1,I[0],1];for(let Re=0;Re<W;Re++)l[0]*=I[Re];l[1]=I[W];for(let Re=W+1;Re<I.length;Re++)l[2]*=I[Re];const w=new Map,M=new Int32Array(I[W]),T=new U.YDk(l,N,y),D=[],G=1===l[0]&&1===l[2];for(let Re=0;Re<I[W];Re++){let we;if(G)we=y[Re].toString();else{const Oe=[];for(let ie=0;ie<l[0];ie++)for(let Le=0;Le<l[2];Le++)Oe.push(T.get(ie,Re,Le));we=Oe.join(",")}const We=w.get(we);if(null!=We)M[Re]=We;else{const Oe=w.size;w.set(we,Oe),M[Re]=Oe,D.push(Re)}}const J=l.slice();J[1]=w.size;const K=new U.YDk(J,N);D.forEach((Re,we)=>{for(let We=0;We<l[0];We++)for(let Oe=0;Oe<l[2];Oe++)K.set(T.get(We,Re,Oe),We,we,Oe)});const _e=I.slice();return _e[W]=J[1],{outputValues:K.values,outputShape:_e,indices:M}}},8669:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{addImpl:()=>Z.EH,bincountImpl:()=>y.W,bincountReduceImpl:()=>y.i,bitwiseAndImpl:()=>F.nv,castImpl:()=>I.sJ,ceilImpl:()=>N.__,concatImpl:()=>W.j,equalImpl:()=>l.tW,expImpl:()=>w.Ro,expm1Impl:()=>M.OF,floorDivImpl:()=>D.JP,floorImpl:()=>T.r6,gatherNdImpl:()=>G.m,gatherV2Impl:()=>J.i,greaterEqualImpl:()=>_e.HL,greaterImpl:()=>K.o,lessEqualImpl:()=>we.lx,lessImpl:()=>Re.rO,linSpaceImpl:()=>We.b,logImpl:()=>Oe.vX,maxImpl:()=>ie.B,maximumImpl:()=>Le.wS,minimumImpl:()=>De.vP,multiplyImpl:()=>te.$3,negImpl:()=>de.uC,notEqualImpl:()=>P.Gj,prodImpl:()=>oe.Qg,raggedGatherImpl:()=>ye.c,raggedRangeImpl:()=>Te.S,raggedTensorToTensorImpl:()=>v.p,rangeImpl:()=>at.b,rsqrtImpl:()=>Xe.zd,scatterImpl:()=>Ue.N,sigmoidImpl:()=>pt.VY,simpleAbsImpl:()=>U.bk,sliceImpl:()=>Ct.rT,sparseFillEmptyRowsImpl:()=>It.c,sparseReshapeImpl:()=>nn.U,sparseSegmentReductionImpl:()=>Bt.V,sqrtImpl:()=>bn.zT,squaredDifferenceImpl:()=>Qn.Hz,staticRegexReplaceImpl:()=>Dn.P,stridedSliceImpl:()=>ps.t,stringNGramsImpl:()=>Es.A,stringSplitImpl:()=>Xn.Q,stringToHashBucketFastImpl:()=>Ts.h,subImpl:()=>or.VY,tileImpl:()=>Ir.R,topKImpl:()=>Ss.W,transposeImpl:()=>Qe.H,uniqueImpl:()=>Lt.S});var U=h(3777),Z=h(6931),y=h(9569),F=h(8642),I=h(1928),N=h(5079),W=h(9971),l=h(5190),w=h(622),M=h(7166),T=h(1471),D=h(7846),G=h(2465),J=h(2697),K=h(4730),_e=h(7310),Re=h(2339),we=h(33),We=h(3373),Oe=h(6723),ie=h(7727),Le=h(6160),De=h(8170),te=h(7985),de=h(9994),P=h(7555),oe=h(2585),ye=h(6134),Te=h(832),v=h(820),at=h(6229),Xe=h(1509),Ue=h(2529),pt=h(2250),Ct=h(5006),It=h(5483),nn=h(9912),Bt=h(391),bn=h(6769),Qn=h(4376),Dn=h(6893),ps=h(5549),Es=h(3118),Xn=h(6482),Ts=h(4105),or=h(1981),Ir=h(1692),Ss=h(9942),Qe=h(8385),Lt=h(705)},9450:(Et,le,h)=>{"use strict";h.d(le,{b:()=>Z});var U=h(9075);function Z(y){return(F,I,N,W,l)=>{const w=U.backend_util.assertAndGetBroadcastShape(F,I),M=w.length,T=U.D5U.computeStrides(w),D=U.D5U.sizeFromShape(w),G=U.D5U.getTypedArrayFromDType(l,D),J=F.length,K=I.length,_e=U.D5U.computeStrides(F),Re=U.D5U.computeStrides(I),we=U.backend_util.getBroadcastDims(F,w),We=U.backend_util.getBroadcastDims(I,w);if(we.length+We.length===0)for(let Oe=0;Oe<G.length;++Oe)G[Oe]=y(N[Oe%N.length],W[Oe%W.length]);else for(let Oe=0;Oe<G.length;++Oe){const ie=U.D5U.indexToLoc(Oe,M,T),Le=ie.slice(-J);we.forEach(P=>Le[P]=0);const De=U.D5U.locToIndex(Le,J,_e),te=ie.slice(-K);We.forEach(P=>te[P]=0);const de=U.D5U.locToIndex(te,K,Re);G[Oe]=y(N[De],W[de])}return[G,w]}}},9642:(Et,le,h)=>{"use strict";h.d(le,{H:()=>N,j:()=>I});var U=h(9075),Z=h(4050),y=h(1928),F=h(3392);function I(W,l,w,M){return null==w?({inputs:T,backend:D})=>{const{a:G,b:J}=T,K=D;(0,Z.H)([G,J],W);const _e=K.data.get(G.dataId).values,Re=K.data.get(J.dataId).values,we="string"===G.dtype?U.backend_util.fromUint8ToStringArray(_e):_e,We="string"===G.dtype?U.backend_util.fromUint8ToStringArray(Re):Re,Oe=M||G.dtype,[ie,Le]=l(G.shape,J.shape,we,We,Oe);return K.makeTensorInfo(Le,Oe,ie)}:({inputs:T,backend:D})=>{const{a:G,b:J}=T,K=D;if("complex64"===G.dtype||"complex64"===J.dtype){const _e=(0,y.pj)({inputs:{x:G},backend:K,attrs:{dtype:"complex64"}}),Re=K.data.get(_e.dataId),We=Re.complexTensorInfos.imag,Oe=K.data.get(Re.complexTensorInfos.real.dataId).values,ie=K.data.get(We.dataId).values,Le=(0,y.pj)({inputs:{x:J},backend:K,attrs:{dtype:"complex64"}}),De=K.data.get(Le.dataId),de=De.complexTensorInfos.imag,P=K.data.get(De.complexTensorInfos.real.dataId).values,oe=K.data.get(de.dataId).values,[ye,Te,v]=w(G.shape,J.shape,Oe,ie,P,oe),at=K.makeTensorInfo(v,"float32",ye),Xe=K.makeTensorInfo(v,"float32",Te),Ue=(0,F.P)({inputs:{real:at,imag:Xe},backend:K});return K.disposeIntermediateTensorInfo(_e),K.disposeIntermediateTensorInfo(Le),K.disposeIntermediateTensorInfo(at),K.disposeIntermediateTensorInfo(Xe),Ue}{const _e=K.data.get(G.dataId).values,Re=K.data.get(J.dataId).values,we=M||G.dtype,[We,Oe]=l(G.shape,J.shape,_e,Re,we);return K.makeTensorInfo(Oe,we,We)}}}function N(W){return(l,w,M,T,D,G)=>{const J=U.backend_util.assertAndGetBroadcastShape(l,w),K=U.D5U.sizeFromShape(J),_e=J.length,Re=U.D5U.computeStrides(J),we=U.D5U.getTypedArrayFromDType("float32",K),We=U.D5U.getTypedArrayFromDType("float32",K),Oe=U.backend_util.getBroadcastDims(l,J),ie=U.backend_util.getBroadcastDims(w,J),Le=U.backend_util.mergeRealAndImagArrays(M,T),De=U.backend_util.mergeRealAndImagArrays(D,G),te=l.length,de=U.D5U.computeStrides(l),P=w.length,oe=U.D5U.computeStrides(w);if(Oe.length+ie.length===0)for(let ye=0;ye<we.length;ye++){const Te=ye%Le.length,v=ye%De.length,at=W(Le[2*Te],Le[2*Te+1],De[2*v],De[2*v+1]);we[ye]=at.real,We[ye]=at.imag}else for(let ye=0;ye<we.length;ye++){const Te=U.D5U.indexToLoc(ye,_e,Re),v=Te.slice(-te);Oe.forEach(Ct=>v[Ct]=0);const at=U.D5U.locToIndex(v,te,de),Xe=Te.slice(-P);ie.forEach(Ct=>Xe[Ct]=0);const Ue=U.D5U.locToIndex(Xe,P,oe),pt=W(Le[2*at],Le[2*at+1],De[2*Ue],De[2*Ue+1]);we[ye]=pt.real,We[ye]=pt.imag}return[we,We,J]}}},1623:(Et,le,h)=>{"use strict";h.d(le,{a:()=>Z});var U=h(9075);function Z(y){return(F,I,N)=>{const W=U.D5U.getArrayFromDType(I,F.length);for(let l=0;l<F.length;++l)W[l]=y(F[l],N);return W}}},1832:(Et,le,h)=>{"use strict";h.d(le,{A:()=>F,O:()=>I});var U=h(9075),Z=h(4050),y=h(1623);function F(N,W,l){return I(N,(0,y.a)(W),l)}function I(N,W,l){return({inputs:w,attrs:M,backend:T})=>{const{x:D}=w;(0,Z.H)(D,N);const G=T,J=G.data.get(D.dataId).values;let K;if("string"===D.dtype){if(!Array.isArray(J))throw new Error("String tensor's value was not an instance of Array");K=U.backend_util.fromUint8ToStringArray(J)}else K=J;const _e=l||D.dtype,Re=W(K,_e,M);return G.makeTensorInfo(D.shape,_e,Re)}}},3176:(Et,le,h)=>{"use strict";h.d(le,{l:()=>y});var U=h(9075),Z=h(3392);function y(F,I,N="float32"){if("complex64"===N){const l=y(F,I,"float32"),w=y(F,I,"float32");return(0,Z.P)({inputs:{real:l,imag:w},backend:F})}const W=U.D5U.makeZerosTypedArray(U.D5U.sizeFromShape(I),N);return F.makeTensorInfo(I,N,W)}},3421:(Et,le,h)=>{"use strict";h.d(le,{Af:()=>Ms,QC:()=>Vi,kS:()=>bu,lz:()=>Z,nd:()=>l,ic:()=>Kl,yO:()=>_c,fZ:()=>U});var U={};h.r(U),h.d(U,{assertNotComplex:()=>la,bindCanvasToFramebuffer:()=>Lt,bindColorTextureToFramebuffer:()=>Qt,bindTextureToProgramUniformSampler:()=>Qe,bindTextureUnit:()=>Ts,bindVertexBufferToProgramAttribute:()=>Xn,callAndCheck:()=>te,canBeRepresented:()=>ye,createFragmentShader:()=>Xe,createFramebuffer:()=>Es,createProgram:()=>Ct,createStaticIndexBuffer:()=>bn,createStaticVertexBuffer:()=>Bt,createTexture:()=>Dn,createVertexShader:()=>at,getBatchDim:()=>$r,getExtensionOrThrow:()=>v,getFramebufferErrorMessage:()=>zs,getMaxTexturesInShader:()=>sl,getNumChannels:()=>Qn,getProgramUniformLocation:()=>Ss,getProgramUniformLocationOrThrow:()=>Ir,getRowsCols:()=>eo,getShapeAs3D:()=>oa,getTextureShapeFromLogicalShape:()=>aa,getWebGLDisjointQueryTimerVersion:()=>ka,getWebGLErrorMessage:()=>Te,getWebGLMaxTextureSize:()=>lo,hasExtension:()=>to,isCapableOfRenderingToFloatTexture:()=>Wa,isDownloadFloatTextureEnabled:()=>Fo,isReshapeFree:()=>xa,isWebGLFenceEnabled:()=>jo,isWebGLVersionEnabled:()=>rl,linkProgram:()=>It,logShaderSourceAndInfoLog:()=>pt,resetMaxTextureSize:()=>Ao,resetMaxTexturesInShader:()=>Ho,unbindColorTextureFromFramebuffer:()=>Nn,unbindTextureUnit:()=>or,validateFramebuffer:()=>Os,validateProgram:()=>nn,validateTextureSize:()=>ps});var Z={};h.r(Z),h.d(Z,{bindVertexProgramAttributeStreams:()=>Ye,createBufferFromOutputTexture:()=>wt,createFloat16MatrixTexture:()=>gl,createFloat16PackedMatrixTexture:()=>He,createFloat32MatrixTexture:()=>Pa,createIndexBuffer:()=>ll,createPackedMatrixTexture:()=>X,createUnsignedBytesMatrixTexture:()=>q,createVertexBuffer:()=>Ro,createVertexShader:()=>mc,downloadByteEncodedFloatMatrixFromOutputTexture:()=>pn,downloadFloat32MatrixFromBuffer:()=>kn,downloadMatrixFromPackedOutputTexture:()=>os,downloadPackedMatrixFromBuffer:()=>qn,getInternalFormatForFloat16MatrixTexture:()=>Ea,getInternalFormatForFloat16PackedMatrixTexture:()=>Ae,getInternalFormatForFloat32MatrixTexture:()=>Ca,getInternalFormatForPackedMatrixTexture:()=>L,getInternalFormatForUnsignedBytesMatrixTexture:()=>_l,uploadDenseMatrixToTexture:()=>it,uploadPixelDataToTexture:()=>_t});var y=h(9075),F=h(5861);const I={},N={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function l(C,b){I[C]=b}function w(C,b){if(!(C in I)||null!=b){const S=function T(C,b){if(1!==C&&2!==C)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const _=b??function M(C){if(!(0,y.OBj)().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===C)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(C);return _.addEventListener("webglcontextlost",S=>{S.preventDefault(),delete I[C]},!1),(0,y.OBj)().getBool("SOFTWARE_WEBGL_ENABLED")&&(N.failIfMajorPerformanceCaveat=!1),1===C?_.getContext("webgl",N)||_.getContext("experimental-webgl",N):_.getContext("webgl2",N)}(C,b);if(null===S)return console.log("Could not get context for WebGL version",C),null;I[C]=S}const _=I[C];return null==_||_.isContextLost()?(delete I[C],w(C)):(_.disable(_.DEPTH_TEST),_.disable(_.STENCIL_TEST),_.disable(_.BLEND),_.disable(_.DITHER),_.disable(_.POLYGON_OFFSET_FILL),_.disable(_.SAMPLE_COVERAGE),_.enable(_.SCISSOR_TEST),_.enable(_.CULL_FACE),_.cullFace(_.BACK),I[C])}var D=function(C){return C[C.DENSE=0]="DENSE",C[C.SHARED_BATCH=1]="SHARED_BATCH",C}(D||{}),G=function(C){return C[C.RENDER=0]="RENDER",C[C.UPLOAD=1]="UPLOAD",C[C.PIXELS=2]="PIXELS",C[C.DOWNLOAD=3]="DOWNLOAD",C}(G||{}),J=function(C){return C[C.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",C[C.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",C[C.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",C[C.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",C[C.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",C}(J||{});function K(C,b){return[b,C]}function we(C){const b=y.D5U.sizeFromShape(C),_=Math.ceil(b/4);return y.D5U.sizeToSquarishShape(_)}function ie(C,b){return[Math.max(1,Math.ceil(b/2)),Math.max(1,Math.ceil(C/2))]}function De(C,b){const _=C;let S,k,H,Q,ue,ae,Se,Ne,Je,rt;return 2===(0,y.OBj)().getNumber("WEBGL_VERSION")?(S=_.R32F,k=_.R16F,H=_.RGBA16F,Q=_.RGBA32F,ue=_.RED,Se=4,Ne=1,Je=_.HALF_FLOAT,rt=_.FLOAT,ae=_.RGBA8):(S=C.RGBA,k=C.RGBA,H=C.RGBA,Q=_.RGBA,ue=C.RGBA,Se=4,Ne=4,Je=null!=b?b.HALF_FLOAT_OES:null,rt=C.FLOAT,ae=C.RGBA),{internalFormatFloat:S,internalFormatHalfFloat:k,internalFormatPackedHalfFloat:H,internalFormatPackedFloat:Q,textureFormatFloat:ue,downloadTextureFormat:ae,downloadUnpackNumChannels:Se,defaultNumChannels:Ne,textureTypeHalfFloat:Je,textureTypeFloat:rt}}function te(C,b){const _=b();return(0,y.OBj)().getBool("DEBUG")&&function de(C){const b=C.getError();if(b!==C.NO_ERROR)throw new Error("WebGL Error: "+Te(C,b))}(C),_}const P=5.96e-8,oe=65504;function ye(C){return!!((0,y.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===C||P<Math.abs(C)&&Math.abs(C)<oe)}function Te(C,b){switch(b){case C.NO_ERROR:return"NO_ERROR";case C.INVALID_ENUM:return"INVALID_ENUM";case C.INVALID_VALUE:return"INVALID_VALUE";case C.INVALID_OPERATION:return"INVALID_OPERATION";case C.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case C.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case C.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${b}`}}function v(C,b){return cr(C,()=>C.getExtension(b),'Extension "'+b+'" not supported on this browser.')}function at(C,b){const _=cr(C,()=>C.createShader(C.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(te(C,()=>C.shaderSource(_,b)),te(C,()=>C.compileShader(_)),!1===C.getShaderParameter(_,C.COMPILE_STATUS))throw console.log(C.getShaderInfoLog(_)),new Error("Failed to compile vertex shader.");return _}function Xe(C,b){const _=cr(C,()=>C.createShader(C.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(te(C,()=>C.shaderSource(_,b)),te(C,()=>C.compileShader(_)),(0,y.OBj)().get("ENGINE_COMPILE_ONLY"))return _;if(!1===C.getShaderParameter(_,C.COMPILE_STATUS))throw pt(b,C.getShaderInfoLog(_)),new Error("Failed to compile fragment shader.");return _}const Ue=/ERROR: [0-9]+:([0-9]+):/g;function pt(C,b){const _=Ue.exec(b);if(null==_)return console.log(`Couldn't parse line number in error: ${b}`),void console.log(C);const S=+_[1],k=C.split("\n"),H=k.length.toString().length+2,Q=k.map((Je,rt)=>y.D5U.rightPad((rt+1).toString(),H)+Je);let ue=0;for(let Je=0;Je<Q.length;Je++)ue=Math.max(Q[Je].length,ue);const ae=Q.slice(0,S-1),Se=Q.slice(S-1,S),Ne=Q.slice(S);console.log(ae.join("\n")),console.log(b.split("\n")[0]),console.log(`%c ${y.D5U.rightPad(Se[0],ue)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(Ne.join("\n"))}function Ct(C){return cr(C,()=>C.createProgram(),"Unable to create WebGLProgram.")}function It(C,b){if(te(C,()=>C.linkProgram(b)),!(0,y.OBj)().get("ENGINE_COMPILE_ONLY")&&!1===C.getProgramParameter(b,C.LINK_STATUS))throw console.log(C.getProgramInfoLog(b)),new Error("Failed to link vertex and fragment shaders.")}function nn(C,b){if(te(C,()=>C.validateProgram(b)),!1===C.getProgramParameter(b,C.VALIDATE_STATUS))throw console.log(C.getProgramInfoLog(b)),new Error("Shader program validation failed.")}function Bt(C,b){const _=cr(C,()=>C.createBuffer(),"Unable to create WebGLBuffer");return te(C,()=>C.bindBuffer(C.ARRAY_BUFFER,_)),te(C,()=>C.bufferData(C.ARRAY_BUFFER,b,C.STATIC_DRAW)),_}function bn(C,b){const _=cr(C,()=>C.createBuffer(),"Unable to create WebGLBuffer");return te(C,()=>C.bindBuffer(C.ELEMENT_ARRAY_BUFFER,_)),te(C,()=>C.bufferData(C.ELEMENT_ARRAY_BUFFER,b,C.STATIC_DRAW)),_}function Qn(){return 2===(0,y.OBj)().getNumber("WEBGL_VERSION")?1:4}function Dn(C){return cr(C,()=>C.createTexture(),"Unable to create WebGLTexture.")}function ps(C,b){const _=(0,y.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(C<=0||b<=0)throw new Error(`Requested texture size [${C}x${b}] is invalid.`);if(C>_||b>_)throw new Error(`Requested texture size [${C}x${b}] greater than WebGL maximum on this browser / GPU [${_}x${_}].`)}function Es(C){return cr(C,()=>C.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Xn(C,b,_,S,k,H,Q){const ue=C.getAttribLocation(b,_);return-1!==ue&&(te(C,()=>C.bindBuffer(C.ARRAY_BUFFER,S)),te(C,()=>C.vertexAttribPointer(ue,k,C.FLOAT,!1,H,Q)),te(C,()=>C.enableVertexAttribArray(ue)),!0)}function Ts(C,b,_){xr(C,_),te(C,()=>C.activeTexture(C.TEXTURE0+_)),te(C,()=>C.bindTexture(C.TEXTURE_2D,b))}function or(C,b){xr(C,b),te(C,()=>C.activeTexture(C.TEXTURE0+b)),te(C,()=>C.bindTexture(C.TEXTURE_2D,null))}function Ir(C,b,_){return cr(C,()=>C.getUniformLocation(b,_),'uniform "'+_+'" not present in program.')}function Ss(C,b,_){return C.getUniformLocation(b,_)}function Qe(C,b,_,S){te(C,()=>Ts(C,b,S)),te(C,()=>C.uniform1i(_,S))}function Lt(C){te(C,()=>C.bindFramebuffer(C.FRAMEBUFFER,null)),te(C,()=>C.viewport(0,0,C.canvas.width,C.canvas.height)),te(C,()=>C.scissor(0,0,C.canvas.width,C.canvas.height))}function Qt(C,b,_){te(C,()=>C.bindFramebuffer(C.FRAMEBUFFER,_)),te(C,()=>C.framebufferTexture2D(C.FRAMEBUFFER,C.COLOR_ATTACHMENT0,C.TEXTURE_2D,b,0))}function Nn(C,b){te(C,()=>C.bindFramebuffer(C.FRAMEBUFFER,b)),te(C,()=>C.framebufferTexture2D(C.FRAMEBUFFER,C.COLOR_ATTACHMENT0,C.TEXTURE_2D,null,0))}function Os(C){const b=C.checkFramebufferStatus(C.FRAMEBUFFER);if(b!==C.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+zs(C,b))}function zs(C,b){switch(b){case C.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case C.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case C.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case C.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${b}`}}function cr(C,b,_){const S=te(C,()=>b());if(null==S)throw new Error(_);return S}function xr(C,b){const _=C.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,S=b+C.TEXTURE0;if(S<C.TEXTURE0||S>_)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${_}].`)}function $r(C,b=2){return y.D5U.sizeFromShape(C.slice(0,C.length-b))}function eo(C){if(0===C.length)throw Error("Cannot get rows and columns of an empty shape array.");return[C.length>1?C[C.length-2]:1,C[C.length-1]]}function oa(C){let b=[1,1,1];return 0===C.length||1===C.length&&1===C[0]||(b=[$r(C),...eo(C)]),b}function aa(C,b=!1){let _=(0,y.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),S=(0,y.OBj)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");S===1/0&&(0,y.OBj)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(S=_/2),b&&(_*=2,S*=2,1===(C=C.map((ue,ae)=>ae>=C.length-2?y.D5U.nearestLargerEven(C[ae]):C[ae])).length&&(C=[2,C[0]])),2!==C.length&&(C=y.D5U.squeezeShape(C).newShape);let k=y.D5U.sizeFromShape(C),H=null;C.length<=1&&k<=_?H=[1,k]:2===C.length&&C[0]<=_&&C[1]<=_?H=C:3===C.length&&C[0]*C[1]<=_&&C[2]<=_?H=[C[0]*C[1],C[2]]:3===C.length&&C[0]<=_&&C[1]*C[2]<=_?H=[C[0],C[1]*C[2]]:4===C.length&&C[0]*C[1]*C[2]<=_&&C[3]<=_?H=[C[0]*C[1]*C[2],C[3]]:4===C.length&&C[0]<=_&&C[1]*C[2]*C[3]<=_&&(H=[C[0],C[1]*C[2]*C[3]]);const Q=null!=H&&Math.max(...H)>S&&Math.min(...H)<=(b?2:1)&&Math.min(...H)>0;if(null==H||Q)if(b){const ue=$r(C);let ae=2,Se=2;C.length&&([ae,Se]=eo(C)),k=ue*(ae/2)*(Se/2),H=y.D5U.sizeToSquarishShape(k).map(Ne=>2*Ne)}else H=y.D5U.sizeToSquarishShape(k);return H}function Po(C){return C%2==0}function xa(C,b){if(C=C.slice(-2),b=b.slice(-2),y.D5U.arraysEqual(C,b)||!C.length||!b.length||0===C[0]||0===C[1]||0===b[0]||0===b[1])return!0;if(C.length!==b.length){const _=C[C.length-1],S=b[b.length-1];if(_===S||Po(_)&&Po(S)&&(1===C[0]||1===b[0]))return!0}return C[1]===b[1]&&Po(C[0])&&Po(b[0])}let za,To;function lo(C){if(null==za){const b=w(C);za=b.getParameter(b.MAX_TEXTURE_SIZE)}return za}function Ao(){za=null}function Ho(){To=null}function sl(C){if(null==To){const b=w(C);To=b.getParameter(b.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,To)}function ka(C){if(0===C)return 0;let b;const _=w(C);return b=to(_,"EXT_disjoint_timer_query_webgl2")&&2===C?2:to(_,"EXT_disjoint_timer_query")?1:0,b}function to(C,b){return null!=C.getExtension(b)}function rl(C){try{if(null!=w(C))return!0}catch(b){return console.log("Error when getting WebGL context: ",b),!1}return!1}function Wa(C){if(0===C)return!1;const b=w(C);if(1===C){if(!to(b,"OES_texture_float"))return!1}else if(!to(b,"EXT_color_buffer_float"))return!1;return Ha(b)}function Fo(C){if(0===C)return!1;const b=w(C);if(1!==C){if(to(b,"EXT_color_buffer_float"))return Ha(b);const S="EXT_color_buffer_half_float";if(to(b,S)){const k=b.getExtension(S);return function qe(C,b){const _=De(C,b),S=C.createTexture();C.bindTexture(C.TEXTURE_2D,S);C.texImage2D(C.TEXTURE_2D,0,_.internalFormatHalfFloat,1,1,0,_.textureFormatFloat,_.textureTypeHalfFloat,null);const Q=C.createFramebuffer();C.bindFramebuffer(C.FRAMEBUFFER,Q),C.framebufferTexture2D(C.FRAMEBUFFER,C.COLOR_ATTACHMENT0,C.TEXTURE_2D,S,0);const ue=C.checkFramebufferStatus(C.FRAMEBUFFER)===C.FRAMEBUFFER_COMPLETE;return C.bindTexture(C.TEXTURE_2D,null),C.bindFramebuffer(C.FRAMEBUFFER,null),C.deleteTexture(S),C.deleteFramebuffer(Q),ue}(b,k)}return!1}return!(!to(b,"OES_texture_float")||!to(b,"WEBGL_color_buffer_float"))&&Ha(b)}function Ha(C){const b=De(C),_=C.createTexture();C.bindTexture(C.TEXTURE_2D,_),C.texImage2D(C.TEXTURE_2D,0,b.internalFormatFloat,1,1,0,b.textureFormatFloat,b.textureTypeFloat,null);const H=C.createFramebuffer();C.bindFramebuffer(C.FRAMEBUFFER,H),C.framebufferTexture2D(C.FRAMEBUFFER,C.COLOR_ATTACHMENT0,C.TEXTURE_2D,_,0);const Q=C.checkFramebufferStatus(C.FRAMEBUFFER)===C.FRAMEBUFFER_COMPLETE;return C.bindTexture(C.TEXTURE_2D,null),C.bindFramebuffer(C.FRAMEBUFFER,null),C.deleteTexture(_),C.deleteFramebuffer(H),Q}function jo(C){return 2===C&&null!=w(C).fenceSync}function la(C,b){Array.isArray(C)||(C=[C]),C.forEach(_=>{null!=_&&y.D5U.assert("complex64"!==_.dtype,()=>`${b} does not support complex64 tensors in the WebGL backend.`)})}const $s=(0,y.OBj)();function co(){let C,b,_,S,k,H,Q,ue,ae,Se;return 2===(0,y.OBj)().getNumber("WEBGL_VERSION")?(C="#version 300 es",b="in",_="out",S="in",k="texture",H="outputColor",Q="out vec4 outputColor;",ue=(0,y.OBj)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",ae="",Se="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(C="",b="attribute",_="varying",S="varying",k="texture2D",H="gl_FragColor",Q="",ue="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",ae="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",Se="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:C,attribute:b,varyingVs:_,varyingFs:S,texture2D:k,output:H,defineOutput:Q,defineSpecialNaN:ue,defineSpecialInf:ae,defineRound:Se}}function ui(C,b,_="index"){const S=y.D5U.computeStrides(b);return S.map((k,H)=>`int ${C[H]} = ${_} / ${k}; ${H===S.length-1?`int ${C[H+1]} = ${_} - ${C[H]} * ${k}`:`index -= ${C[H]} * ${k}`};`).join("")}function ja(C,b,_="index"){const S=y.D5U.computeStrides(b);return S.map((k,H)=>`int ${C[H]} = ${_} / outShapeStrides[${H}]; ${H===S.length-1?`int ${C[H+1]} = ${_} - ${C[H]} * outShapeStrides[${H}]`:`index -= ${C[H]} * outShapeStrides[${H}]`};`).join("")}function Xi(C){const b=y.D5U.computeStrides(C).map(_=>_.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${b[0]} + coords.y * ${b[1]} + coords.z;\n  }\n`}$s.registerFlag("HAS_WEBGL",()=>$s.getNumber("WEBGL_VERSION")>0),$s.registerFlag("WEBGL_VERSION",()=>rl(2)?2:rl(1)?1:0),$s.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),$s.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===$s.get("WEBGL_VERSION")),$s.registerFlag("WEBGL_CPU_FORWARD",()=>!0),$s.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),$s.registerFlag("WEBGL_PACK",()=>$s.getBool("HAS_WEBGL")),$s.registerFlag("WEBGL_PACK_NORMALIZATION",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_CLIP",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_REDUCE",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_LAZILY_UNPACK",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_CONV_IM2COL",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>$s.getBool("WEBGL_PACK")),$s.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>lo($s.getNumber("WEBGL_VERSION"))),$s.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>sl($s.getNumber("WEBGL_VERSION"))),$s.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const C=$s.getNumber("WEBGL_VERSION");return 0===C?0:ka(C)}),$s.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>$s.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!y.C2$.isMobile()),$s.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Wa($s.getNumber("WEBGL_VERSION"))),$s.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!$s.getBool("WEBGL_FORCE_F16_TEXTURES")&&$s.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),$s.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Fo($s.getNumber("WEBGL_VERSION"))),$s.registerFlag("WEBGL_FENCE_API_ENABLED",()=>jo($s.getNumber("WEBGL_VERSION"))),$s.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>$s.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),$s.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,C=>{if("number"!=typeof C)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${C}.`);if(C<0&&-1!==C)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${C}.`)}),$s.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>y.C2$.isMobile()?1:-1,C=>{if("number"!=typeof C)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${C}.`);if(C<0&&-1!==C)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${C}.`)}),$s.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),$s.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),$s.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),$s.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),$s.registerFlag("WEBGL_EXP_CONV",()=>!1),$s.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>$s.getBool("IS_TEST")),$s.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),$s.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),$s.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),$s.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const Bi="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:hl}=y.backend_util;function Jr(C,b,_){const S=[];if(C.forEach(ft=>{const Ot=y.D5U.sizeFromShape(ft.shapeInfo.logicalShape);if(ft.shapeInfo.isUniform?S.push(`uniform float ${ft.name}${Ot>1?`[${Ot}]`:""};`):(S.push(`uniform sampler2D ${ft.name};`),S.push(`uniform int offset${ft.name};`)),_.enableShapeUniforms){const{uniformShape:Kt}=ic(_.packedInputs,ft.shapeInfo.logicalShape,ft.shapeInfo.texShape);switch(Kt.length){case 1:S.push(`uniform int ${ft.name}Shape;`);break;case 2:S.push(`uniform ivec2 ${ft.name}Shape;`);break;case 3:S.push(`uniform ivec3 ${ft.name}Shape;`);break;case 4:S.push(`uniform ivec4 ${ft.name}Shape;`)}S.push(`uniform ivec2 ${ft.name}TexShape;`)}}),_.enableShapeUniforms){switch(b.logicalShape.length){case 1:S.push("uniform int outShape;");break;case 2:S.push("uniform ivec2 outShape;"),S.push("uniform int outShapeStrides;");break;case 3:S.push("uniform ivec3 outShape;"),S.push("uniform ivec2 outShapeStrides;");break;case 4:S.push("uniform ivec4 outShape;"),S.push("uniform ivec3 outShapeStrides;")}S.push("uniform ivec2 outTexShape;")}_.customUniforms&&_.customUniforms.forEach(ft=>{S.push(`uniform ${ft.type} ${ft.name}${ft.arrayIndex?`[${ft.arrayIndex}]`:""};`)});const k=S.join("\n"),H=C.map(ft=>function hc(C,b,_=!1,S){let k="";k+=_?dc(C,S):Lo(C,S);return C.shapeInfo.logicalShape.length<=b.logicalShape.length&&(k+=_?function ma(C,b){const _=C.name,S=_.charAt(0).toUpperCase()+_.slice(1),k="get"+S+"AtOutCoords",H=C.shapeInfo.logicalShape.length,Q=b.logicalShape.length,ue=hl(C.shapeInfo.logicalShape,b.logicalShape),ae=mi(Q),Se=Q-H;let Ne;const Je=["x","y","z","w","u","v"];Ne=0===H?"":Q<2&&ue.length>=1?"coords = 0;":ue.map(hn=>`coords.${Je[hn+Se]} = 0;`).join("\n");let rt="";rt=Q<2&&H>0?"coords":C.shapeInfo.logicalShape.map((hn,ts)=>`coords.${Je[ts+Se]}`).join(", ");let ft="return outputValue;";const Kt=1===y.D5U.sizeFromShape(C.shapeInfo.logicalShape),Zt=1===y.D5U.sizeFromShape(b.logicalShape);if(1!==H||Kt||Zt){if(Kt&&!Zt)ft=1===Q?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(ue.length){const hn=H-2,ts=H-1;ue.indexOf(hn)>-1&&ue.indexOf(ts)>-1?ft="return vec4(outputValue.x);":ue.indexOf(hn)>-1?ft="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":ue.indexOf(ts)>-1&&(ft="return vec4(outputValue.xx, outputValue.zz);")}}else ft="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${k}() {\n      ${ae} coords = getOutputCoords();\n      ${Ne}\n      vec4 outputValue = get${S}(${rt});\n      ${ft}\n    }\n  `}(C,b):function mo(C,b){const _=C.name,S=_.charAt(0).toUpperCase()+_.slice(1),k="get"+S+"AtOutCoords",ue=C.shapeInfo.logicalShape.length,ae=b.logicalShape.length;if(!C.shapeInfo.isUniform&&ue===ae&&null==C.shapeInfo.flatOffset&&y.D5U.arraysEqual(C.shapeInfo.texShape,b.texShape))return`\n      float ${k}() {\n        return sampleTexture(${_}, resultUV);\n      }\n    `;const Se=mi(ae),Ne=hl(C.shapeInfo.logicalShape,b.logicalShape),Je=ae-ue;let rt;const ft=["x","y","z","w","u","v"];rt=0===ue?"":ae<2&&Ne.length>=1?"coords = 0;":Ne.map(Kt=>`coords.${ft[Kt+Je]} = 0;`).join("\n");let Ot="";return Ot=ae<2&&ue>0?"coords":C.shapeInfo.logicalShape.map((Kt,tn)=>`coords.${ft[tn+Je]}`).join(", "),`\n    float ${k}() {\n      ${Se} coords = getOutputCoords();\n      ${rt}\n      return get${S}(${Ot});\n    }\n  `}(C,b)),k}(ft,b,_.packedInputs,_.enableShapeUniforms)).join("\n"),Q=b.texShape,ue=co(),ae=function pc(C){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${C.texture2D}(textureSampler, uv).r;\n    }\n  `}(ue);let Se,Ne,Je=function fl(C){return`${C.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${C.varyingFs} vec2 resultUV;\n    ${C.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${C.defineSpecialNaN}\n    ${C.defineSpecialInf}\n    ${C.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${no}\n    ${Ka}\n    ${so}\n  `}(ue);return b.isPacked?(Se=function Ga(C,b,_){switch(C.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function fc(C,b,_){const S=[Math.ceil(b[0]/2),Math.ceil(b[1]/2)];return 1===S[0]?_?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${S[1]}.0);\n      }\n    `:1===S[1]?_?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${S[0]}.0);\n      }\n    `:_?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${S[0]}, ${S[1]}));\n      return 2 * (resTexRC.x * ${S[1]} + resTexRC.y);\n    }\n  `}(0,b,_);case 2:return function Oa(C,b,_){const S=[Math.ceil(b[0]/2),Math.ceil(b[1]/2)];if(y.D5U.arraysEqual(C,b))return _?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${S[0]}, ${S[1]}));\n      }\n    `;const k=Math.ceil(C[1]/2);return _?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${S[0]}, ${S[1]}));\n\n      int index = resTexRC.x * ${S[1]} + resTexRC.y;\n      int r = 2 * (index / ${k});\n      int c = imod(index, ${k}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(C,b,_);case 3:return function ol(C,b,_){if(_)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const S=[Math.ceil(b[0]/2),Math.ceil(b[1]/2)],k=Math.ceil(C[2]/2),H=k*Math.ceil(C[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${S[0]}, ${S[1]}));\n      int index = resTexRC.x * ${S[1]} + resTexRC.y;\n\n      int b = index / ${H};\n      index -= b * ${H};\n\n      int r = 2 * (index / ${k});\n      int c = imod(index, ${k}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(C,b,_);default:return function Js(C,b,_){if(_)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const S=[Math.ceil(b[0]/2),Math.ceil(b[1]/2)],k=Math.ceil(C[C.length-1]/2),H=k*Math.ceil(C[C.length-2]/2);let Q=H,ue="",ae="b, r, c";for(let Se=2;Se<C.length-1;Se++)Q*=C[C.length-Se-1],ue=`\n      int b${Se} = index / ${Q};\n      index -= b${Se} * ${Q};\n    `+ue,ae=`b${Se}, `+ae;return`\n    ivec${C.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${S[0]}, ${S[1]}));\n      int index = resTexRC.x * ${S[1]} + resTexRC.y;\n\n      ${ue}\n\n      int b = index / ${H};\n      index -= b * ${H};\n\n      int r = 2 * (index / ${k});\n      int c = imod(index, ${k}) * 2;\n\n      return ivec${C.length}(${ae});\n    }\n  `}(C,b,_)}}(b.logicalShape,Q,_.enableShapeUniforms),Ne=function ko(C){return`\n    void setOutput(vec4 val) {\n      ${C.output} = val;\n    }\n  `}(ue)):(Se=function Ko(C,b,_){switch(C.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function zl(C,b,_){return 1===b[0]?_?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${b[1]}.0);\n      }\n    `:1===b[1]?_?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${b[0]}.0);\n      }\n    `:_?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${b[0]}, ${b[1]}));\n      return resTexRC.x * ${b[1]} + resTexRC.y;\n    }\n  `}(0,b,_);case 2:return function Al(C,b,_){return y.D5U.arraysEqual(C,b)?_?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${b[0]}, ${b[1]}));\n      }\n    `:1===C[1]?_?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${b[0]}, ${b[1]}));\n        int index = resTexRC.x * ${b[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===C[0]?_?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${b[0]}, ${b[1]}));\n        int index = resTexRC.x * ${b[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:_?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${b[0]}, ${b[1]}));\n      int index = resTexRC.x * ${b[1]} + resTexRC.y;\n      int r = index / ${C[1]};\n      int c = index - r * ${C[1]};\n      return ivec2(r, c);\n    }\n  `}(C,b,_);case 3:return function Xa(C,b,_){if(_)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${ja(["r","c","d"],C)}\n    return ivec3(r, c, d);\n  }\n`;const S=ui(["r","c","d"],C);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${b[0]}, ${b[1]}));\n      int index = resTexRC.x * ${b[1]} + resTexRC.y;\n      ${S}\n      return ivec3(r, c, d);\n    }\n  `}(C,b,_);case 4:return function vi(C,b,_){if(_)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${ja(["r","c","d","d2"],C)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const S=ui(["r","c","d","d2"],C);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${b[0]}, ${b[1]}));\n      int index = resTexRC.x * ${b[1]} + resTexRC.y;\n      ${S}\n      return ivec4(r, c, d, d2);\n    }\n  `}(C,b,_);case 5:return function $o(C,b){const _=ui(["r","c","d","d2","d3"],C);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${b[0]},\n                             ${b[1]}));\n\n      int index = resTexRC.x * ${b[1]} + resTexRC.y;\n\n      ${_}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(C,b);case 6:return function Pr(C,b){const _=ui(["r","c","d","d2","d3","d4"],C);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${b[0]}, ${b[1]}));\n      int index = resTexRC.x * ${b[1]} + resTexRC.y;\n\n      ${_}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(C,b);default:throw new Error(`${C.length}-D output sampling is not yet supported`)}}(b.logicalShape,Q,_.enableShapeUniforms),Ne=function pl(C){return`\n    void setOutput(float val) {\n      ${C.output} = vec4(val, 0, 0, 0);\n    }\n  `}(ue)),_.packedInputs&&(Je+=il),[Je,ae,Ne,k,Se,H,_.userCode].join("\n")}function Lo(C,b=!1){const _=C.shapeInfo.logicalShape;switch(_.length){case 0:return function Zi(C,b){const _=C.name,S="get"+_.charAt(0).toUpperCase()+_.slice(1);if(C.shapeInfo.isUniform)return`float ${S}() {return ${_};}`;const[k,H]=C.shapeInfo.texShape;if(1===k&&1===H)return`\n      float ${S}() {\n        return sampleTexture(${_}, halfCR);\n      }\n    `;const Q=uo(_);if(b)return`\n    float ${S}() {\n      vec2 uv = uvFromFlat(${_}TexShape[0], ${_}TexShape[1], ${Q});\n      return sampleTexture(${_}, uv);\n    }\n  `;const[ue,ae]=C.shapeInfo.texShape;return`\n    float ${S}() {\n      vec2 uv = uvFromFlat(${ue}, ${ae}, ${Q});\n      return sampleTexture(${_}, uv);\n    }\n  `}(C,b);case 1:return function Hi(C,b){const _=C.name,S="get"+_.charAt(0).toUpperCase()+_.slice(1);if(C.shapeInfo.isUniform)return`\n      float ${S}(int index) {\n        ${di(C)}\n      }\n    `;const k=C.shapeInfo.texShape,H=k[0],Q=k[1];if(1===Q&&1===H)return`\n      float ${S}(int index) {\n        return sampleTexture(${_}, halfCR);\n      }\n    `;const ue=uo(_);return 1===Q?b?`\n      float ${S}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${ue}) + 0.5) / float(${_}TexShape[0]));\n        return sampleTexture(${_}, uv);\n      }\n    `:`\n      float ${S}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${ue}) + 0.5) / ${H}.0);\n        return sampleTexture(${_}, uv);\n      }\n    `:1===H?b?`\n      float ${S}(int index) {\n        vec2 uv = vec2((float(index + ${ue}) + 0.5) / float(${_}TexShape[1]), 0.5);\n        return sampleTexture(${_}, uv);\n      }\n    `:`\n      float ${S}(int index) {\n        vec2 uv = vec2((float(index + ${ue}) + 0.5) / ${Q}.0, 0.5);\n        return sampleTexture(${_}, uv);\n      }\n    `:b?`\n    float ${S}(int index) {\n      vec2 uv = uvFromFlat(${_}TexShape[0], ${_}TexShape[1], index + ${ue});\n      return sampleTexture(${_}, uv);\n    }\n  `:`\n    float ${S}(int index) {\n      vec2 uv = uvFromFlat(${H}, ${Q}, index + ${ue});\n      return sampleTexture(${_}, uv);\n    }\n  `}(C,b);case 2:return function Di(C,b){const _=C.shapeInfo.logicalShape,S=C.name,k="get"+S.charAt(0).toUpperCase()+S.slice(1),H=C.shapeInfo.texShape;if(null!=H&&y.D5U.arraysEqual(_,H))return b?`\n      float ${k}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${S}TexShape[1], ${S}TexShape[0]);\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n    float ${k}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${H[1]}.0, ${H[0]}.0);\n      return sampleTexture(${S}, uv);\n    }\n  `;const{newShape:Q,keptDims:ue}=y.D5U.squeezeShape(_);if(Q.length<_.length){const ft=["row","col"];return`\n      ${Lo(Br(C,Q),b)}\n      float ${k}(int row, int col) {\n        return ${k}(${dr(ft,ue)});\n      }\n    `}if(C.shapeInfo.isUniform)return`\n      float ${k}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${_[1]}, 1)));\n        ${di(C)}\n      }\n    `;const Se=H[0],Ne=H[1],Je=uo(S);return 1===Ne?b?`\n      float ${k}(int row, int col) {\n        float index = dot(vec3(row, col, ${Je}), vec3(${S}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${S}TexShape[0]));\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n    float ${k}(int row, int col) {\n      float index = dot(vec3(row, col, ${Je}), vec3(${_[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${Se}.0);\n      return sampleTexture(${S}, uv);\n    }\n  `:1===Se?b?`\n      float ${k}(int row, int col) {\n        float index = dot(vec3(row, col, ${Je}), vec3(${S}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${S}TexShape[1]), 0.5);\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n    float ${k}(int row, int col) {\n      float index = dot(vec3(row, col, ${Je}), vec3(${_[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${Ne}.0, 0.5);\n      return sampleTexture(${S}, uv);\n    }\n  `:b?`\n      float ${k}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${S}Shape[1] + col + ${Je};\n        vec2 uv = uvFromFlat(${S}TexShape[0], ${S}TexShape[1], index);\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n  float ${k}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${_[1]} + col + ${Je};\n    vec2 uv = uvFromFlat(${Se}, ${Ne}, index);\n    return sampleTexture(${S}, uv);\n  }\n`}(C,b);case 3:return function ro(C,b){const _=C.shapeInfo.logicalShape,S=C.name,k="get"+S.charAt(0).toUpperCase()+S.slice(1),H=_[1]*_[2],Q=_[2],{newShape:ue,keptDims:ae}=y.D5U.squeezeShape(_);if(ue.length<_.length){const tn=["row","col","depth"];return`\n        ${Lo(Br(C,ue),b)}\n        float ${k}(int row, int col, int depth) {\n          return ${k}(${dr(tn,ae)});\n        }\n      `}if(C.shapeInfo.isUniform)return`\n      float ${k}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${H}, ${Q}, 1)));\n        ${di(C)}\n      }\n    `;const Ne=C.shapeInfo.texShape,Je=Ne[0],rt=Ne[1],ft=C.shapeInfo.flatOffset;if(rt===H&&null==ft)return b?`\n      float ${k}(int row, int col, int depth) {\n        int stride1 = ${S}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${S}TexShape[1], ${S}TexShape[0]);\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n        float ${k}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${Q}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${rt}.0, ${Je}.0);\n          return sampleTexture(${S}, uv);\n        }\n      `;if(rt===Q&&null==ft)return b?`\n      float ${k}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${S}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${S}TexShape[1], ${S}TexShape[0]);\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n    float ${k}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${_[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${rt}.0, ${Je}.0);\n      return sampleTexture(${S}, uv);\n    }\n  `;const Ot=uo(S);return b?`\n    float ${k}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${S}Shape[1] * ${S}Shape[2];\n      int stride1 = ${S}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${Ot};\n      vec2 uv = uvFromFlat(${S}TexShape[0], ${S}TexShape[1], index);\n      return sampleTexture(${S}, uv);\n    }\n    `:`\n      float ${k}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${H} + col * ${Q} + depth + ${Ot};\n        vec2 uv = uvFromFlat(${Je}, ${rt}, index);\n        return sampleTexture(${S}, uv);\n      }\n  `}(C,b);case 4:return function Qi(C,b){const _=C.shapeInfo.logicalShape,S=C.name,k="get"+S.charAt(0).toUpperCase()+S.slice(1),H=_[3],Q=_[2]*H,ue=_[1]*Q,{newShape:ae,keptDims:Se}=y.D5U.squeezeShape(_);if(ae.length<_.length){const ts=["row","col","depth","depth2"];return`\n      ${Lo(Br(C,ae),b)}\n      float ${k}(int row, int col, int depth, int depth2) {\n        return ${k}(${dr(ts,Se)});\n      }\n    `}if(C.shapeInfo.isUniform)return`\n      float ${k}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${ue}, ${Q}, ${H}, 1)));\n        ${di(C)}\n      }\n    `;const Ne=C.shapeInfo.flatOffset,Je=C.shapeInfo.texShape,rt=Je[0],ft=Je[1],Ot=`int stride2 = ${S}Shape[3];`,Kt=`int stride1 = ${S}Shape[2] * stride2;`,tn=`int stride0 = ${S}Shape[1] * stride1;`;if(ft===ue&&null==Ne)return b?`\n      float ${k}(int row, int col, int depth, int depth2) {\n        ${Ot}\n        ${Kt}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${S}TexShape[1], ${S}TexShape[0]);\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n      float ${k}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${Q}, ${H}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${ft}.0, ${rt}.0);\n        return sampleTexture(${S}, uv);\n      }\n    `;if(ft===H&&null==Ne)return b?`\n      float ${k}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${S}Shape[1] * ${S}Shape[2], ${S}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${S}TexShape[1], ${S}TexShape[0]);\n        return sampleTexture(${S}, uv);\n      }\n    `:`\n      float ${k}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${_[1]*_[2]}, ${_[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${ft}.0, ${rt}.0);\n        return sampleTexture(${S}, uv);\n      }\n    `;const Zt=uo(S);return b?`\n    float ${k}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${Ot}\n      ${Kt}\n      ${tn}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${S}TexShape[0], ${S}TexShape[1], index + ${Zt});\n      return sampleTexture(${S}, uv);\n    }\n  `:`\n    float ${k}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${ue} + col * ${Q} +\n          depth * ${H} + depth2;\n      vec2 uv = uvFromFlat(${rt}, ${ft}, index + ${Zt});\n      return sampleTexture(${S}, uv);\n    }\n  `}(C,b);case 5:return function al(C){const b=C.shapeInfo.logicalShape,_=C.name,S="get"+_.charAt(0).toUpperCase()+_.slice(1),k=b[4],H=b[3]*k,Q=b[2]*H,ue=b[1]*Q,{newShape:ae,keptDims:Se}=y.D5U.squeezeShape(b);if(ae.length<b.length){const tn=["row","col","depth","depth2","depth3"];return`\n      ${Lo(Br(C,ae))}\n      float ${S}(int row, int col, int depth, int depth2, int depth3) {\n        return ${S}(${dr(tn,Se)});\n      }\n    `}if(C.shapeInfo.isUniform)return`\n      float ${S}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${ue}, ${Q}, ${H}, ${k})) +\n          depth3;\n        ${di(C)}\n      }\n    `;const Ne=C.shapeInfo.flatOffset,Je=C.shapeInfo.texShape,rt=Je[0],ft=Je[1];if(ft===ue&&null==Ne)return`\n      float ${S}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${Q}, ${H}, ${k}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${ft}.0, ${rt}.0);\n        return sampleTexture(${_}, uv);\n      }\n    `;if(ft===k&&null==Ne)return`\n      float ${S}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${b[1]*b[2]*b[3]},\n               ${b[2]*b[3]}, ${b[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${ft}.0, ${rt}.0);\n        return sampleTexture(${_}, uv);\n      }\n    `;return`\n    float ${S}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${ue} + col * ${Q} + depth * ${H} +\n          depth2 * ${k} + depth3 + ${uo(_)};\n      vec2 uv = uvFromFlat(${rt}, ${ft}, index);\n      return sampleTexture(${_}, uv);\n    }\n  `}(C);case 6:return function fa(C){const b=C.shapeInfo.logicalShape,_=C.name,S="get"+_.charAt(0).toUpperCase()+_.slice(1),{newShape:k,keptDims:H}=y.D5U.squeezeShape(b);if(k.length<b.length){const Zt=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Lo(Br(C,k))}\n      float ${S}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${S}(${dr(Zt,H)});\n      }\n    `}const Q=b[5],ue=b[4]*Q,ae=b[3]*ue,Se=b[2]*ae,Ne=b[1]*Se;if(C.shapeInfo.isUniform)return`\n      float ${S}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${Ne}, ${Se}, ${ae}, ${ue})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${Q}, 1)));\n        ${di(C)}\n      }\n    `;const Je=C.shapeInfo.flatOffset,rt=C.shapeInfo.texShape,ft=rt[0],Ot=rt[1];if(Ot===Ne&&null==Je)return`\n      float ${S}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${Se}, ${ae}, ${ue}, ${Q})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${Ot}.0, ${ft}.0);\n        return sampleTexture(${_}, uv);\n      }\n    `;if(Ot===Q&&null==Je)return`\n      float ${S}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${b[1]*b[2]*b[3]*b[4]},\n               ${b[2]*b[3]*b[4]},\n               ${b[3]*b[4]},\n               ${b[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${Ot}.0, ${ft}.0);\n        return sampleTexture(${_}, uv);\n      }\n    `;return`\n    float ${S}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${Ne} + col * ${Se} + depth * ${ae} +\n          depth2 * ${ue} + depth3 * ${Q} + depth4 + ${uo(_)};\n      vec2 uv = uvFromFlat(${ft}, ${Ot}, index);\n      return sampleTexture(${_}, uv);\n    }\n  `}(C);default:throw new Error(`${_.length}-D input sampling is not yet supported`)}}function dc(C,b){switch(C.shapeInfo.logicalShape.length){case 0:return function Ra(C){const b=C.name;return`\n    vec4 ${"get"+b.charAt(0).toUpperCase()+b.slice(1)}() {\n      return ${co().texture2D}(${b}, halfCR);\n    }\n  `}(C);case 1:return function Oo(C,b){const _=C.name,S="get"+_.charAt(0).toUpperCase()+_.slice(1),k=C.shapeInfo.texShape,H=co();if(b)return`\n    vec4 ${S}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${_}TexShape[0]) / 2.0), ceil(float(${_}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${H.texture2D}(${_}, uv);\n    }\n  `;const Q=[Math.ceil(k[0]/2),Math.ceil(k[1]/2)];return`\n    vec4 ${S}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${Q[0]}, ${Q[1]}, index);\n      return ${H.texture2D}(${_}, uv);\n    }\n  `}(C,b);case 2:return function ji(C,b){const _=C.shapeInfo.logicalShape,S=C.name,k="get"+S.charAt(0).toUpperCase()+S.slice(1),H=C.shapeInfo.texShape,Q=H[0],ue=H[1],ae=co();if(null!=H&&y.D5U.arraysEqual(_,H))return b?`\n      vec4 ${k}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${S}TexShape[1], ${S}TexShape[0]);\n\n        return ${ae.texture2D}(${S}, uv);\n      }\n    `:`\n      vec4 ${k}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${ue}.0, ${Q}.0);\n\n        return ${ae.texture2D}(${S}, uv);\n      }\n    `;if(b)return`\n    vec4 ${k}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${S}TexShape[0]) / 2.0), ceil(float(${S}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${S}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${ae.texture2D}(${S}, uv);\n    }\n  `;const Se=[Math.ceil(H[0]/2),Math.ceil(H[1]/2)];return`\n    vec4 ${k}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(_[1]/2)}, ${Se[0]}, ${Se[1]}, row, col);\n      return ${ae.texture2D}(${S}, uv);\n    }\n  `}(C,b);case 3:return function Xs(C,b){const _=C.shapeInfo.logicalShape,S=C.name,k="get"+S.charAt(0).toUpperCase()+S.slice(1),H=C.shapeInfo.texShape,Q=[Math.ceil(H[0]/2),Math.ceil(H[1]/2)];if(1===_[0]){const ft=[1,2],Kt=["b","row","col"];return`\n        ${dc(Br(C,_.slice(1)),b)}\n        vec4 ${k}(int b, int row, int col) {\n          return ${k}(${dr(Kt,ft)});\n        }\n      `}const ue=co();if(b)return`\n    vec4 ${k}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${S}TexShape[0]) / 2.0), ceil(float(${S}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${S}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${S}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${ue.texture2D}(${S}, uv);\n    }\n  `;const ae=Q[0],Se=Q[1],Ne=Math.ceil(_[2]/2);return`\n    vec4 ${k}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${ae}, ${Se}, ${Ne*Math.ceil(_[1]/2)}, ${Ne}, b, row, col);\n      return ${ue.texture2D}(${S}, uv);\n    }\n  `}(C,b);default:return function pa(C,b){const _=C.name,S="get"+_.charAt(0).toUpperCase()+_.slice(1),k=co();if(b)return`\n    vec4 ${S}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${_}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${_}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${_}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${_}TexShape[0]) / 2.0), ceil(float(${_}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${k.texture2D}(${_}, uv);\n    }\n  `;const H=C.shapeInfo.logicalShape,Q=H.length,ue=C.shapeInfo.texShape,ae=[Math.ceil(ue[0]/2),Math.ceil(ue[1]/2)],Se=ae[0],Ne=ae[1],Je=Math.ceil(H[Q-1]/2);let rt=Je*Math.ceil(H[Q-2]/2),ft="int b, int row, int col",Ot=`b * ${rt} + (row / 2) * ${Je} + (col / 2)`;for(let Kt=2;Kt<Q-1;Kt++)ft=`int b${Kt}, `+ft,rt*=H[Q-Kt-1],Ot=`b${Kt} * ${rt} + `+Ot;return`\n    vec4 ${S}(${ft}) {\n      int index = ${Ot};\n      int texR = index / ${Ne};\n      int texC = index - texR * ${Ne};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Ne}, ${Se});\n      return ${k.texture2D}(${_}, uv);\n    }\n  `}(C,b)}}const no="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ka="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",so="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",il="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function uo(C){return`offset${C}`}function di(C){const b=C.name,_=y.D5U.sizeFromShape(C.shapeInfo.logicalShape);return _<2?`return ${b};`:`\n    for (int i = 0; i < ${_}; i++) {\n      if (i == index) {\n        return ${b}[i];\n      }\n    }\n  `}function mi(C){if(C<=1)return"int";if(2===C)return"ivec2";if(3===C)return"ivec3";if(4===C)return"ivec4";if(5===C)return"ivec5";if(6===C)return"ivec6";throw Error(`GPU for rank ${C} is not yet supported`)}function ic(C,b,_){const{newShape:S,keptDims:k}=y.D5U.squeezeShape(b),H=b.length,Q=C&&3===H&&1===b[0],ue=Q?b.slice(1):S,ae=!C&&H>1&&!y.D5U.arraysEqual(b,_)&&S.length<H||Q;return{useSqueezeShape:ae,uniformShape:ae?ue:b,keptDims:k}}function Br(C,b){const _=JSON.parse(JSON.stringify(C));return _.shapeInfo.logicalShape=b,_}function dr(C,b){return b.map(_=>C[_]).join(", ")}function go(C,b,_){const S=[],k=[];let H,Q,ue,ae=null,Se=null;Se=C.getUniformLocation(_,"NAN",!1),1===(0,y.OBj)().getNumber("WEBGL_VERSION")&&(ae=C.getUniformLocation(_,"INFINITY",!1));const Ne=!1;for(const Je of b.variableNames){const rt={name:Je,uniform:C.getUniformLocation(_,Je,Ne),offset:C.getUniformLocation(_,`offset${Je}`,Ne)};b.enableShapeUniforms&&(rt.shape=C.getUniformLocation(_,`${Je}Shape`,Ne),rt.texShape=C.getUniformLocation(_,`${Je}TexShape`,Ne)),S.push(rt)}if(b.enableShapeUniforms&&(H=C.getUniformLocation(_,"outShape",Ne),ue=C.getUniformLocation(_,"outShapeStrides",Ne),Q=C.getUniformLocation(_,"outTexShape",Ne)),b.customUniforms)for(const Je of b.customUniforms)k.push(C.getUniformLocation(_,Je.name,Ne));return{variablesLocations:S,customUniformLocations:k,infLoc:ae,nanLoc:Se,outShapeLocation:H,outShapeStridesLocation:ue,outTexShapeLocation:Q}}function ml(C,b){if(C.length!==b.length)throw Error(`Binary was compiled with ${C.length} inputs, but was executed with ${b.length} inputs`);C.forEach((_,S)=>{const k=_.logicalShape,H=b[S],Q=H.shape;if(!y.D5U.arraysEqual(k,Q))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${k} and ${Q} must match`);if(_.isUniform&&H.isUniform)return;const ue=_.texShape,ae=H.isUniform?null:H.texData.texShape;if(!y.D5U.arraysEqual(ue,ae))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${ue} and ${ae} must match`)})}function ki(C){return(0,y.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&C<=4}class wr{constructor(b){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=D.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const _=co();this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ja(["r","c","d"],b):ui(["r","c","d"],b)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${_.output} = result;\n      }\n    `}}class ar{constructor(b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=D.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const _=co();this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ja(["r","c","d"],b):ui(["r","c","d"],b)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${_.output} = result;\n      }\n    `}}class Ma{constructor(b){this.variableNames=["A"],this.outTexUsage=G.DOWNLOAD;const _=co();this.outputShape=b,this.userCode=`\n      ${Bi}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${_.output} = encode_float(x);\n      }\n    `}}class gn{constructor(b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=G.DOWNLOAD;const _=co();this.outputShape=b,this.userCode=`\n      ${Bi}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${_.output} = encode_float(x);\n      }\n    `}}const qr={R:0,G:1,B:2,A:3};class Wl{constructor(b,_=!1,S="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const k=co();this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length);let H="result";_&&(H="floor(result * 255. + 0.5)");let Q="";for(let ue=0;ue<S.length;ue++)Q+=`\n          if(offset == ${ue}) {\n            result = values[${qr[S[ue]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Xi(b)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${S.length});\n\n        flatIndex = idiv(flatIndex, ${S.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${k.texture2D}(A, uv);\n          ${Q}\n        }\n        ${k.output} = vec4(${H}, 0., 0., 0.);\n      }\n    `}}class _o{constructor(b,_=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const S=co();this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length);let k="",H="result";_&&(H="floor(result * 255. + 0.5)");for(let Q=0;Q<=1;Q++)for(let ue=0;ue<=1;ue++){const ae=2*Q+ue;k+=`\n          localCoords = coords;\n          if(localCoords[2] + ${ue} < ${this.enableShapeUniforms?"outShape[2]":`${b[2]}`}) {\n          localCoords[2] += ${ue};\n          if (localCoords[1] + ${Q} < ${this.enableShapeUniforms?"outShape[1]":`${b[1]}`}) {\n            localCoords[1] += ${Q};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${S.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${ae}] = values[0];\n            } else if (offset == 1) {\n              result[${ae}] = values[1];\n            } else if (offset == 2) {\n              result[${ae}] = values[2];\n            } else {\n              result[${ae}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Xi(b)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${k}\n\n          ${S.output} = ${H};\n        }\n    `}}function mc(C){const b=co();return at(C,`${b.version}\n    precision highp float;\n    ${b.attribute} vec3 clipSpacePos;\n    ${b.attribute} vec2 uv;\n    ${b.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Ro(C){return Bt(C,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function ll(C){return bn(C,new Uint16Array([0,1,2,2,1,3]))}function Si(C,b,_,S,k,H){ps(b,_);const Q=Dn(C),ue=C.TEXTURE_2D;return te(C,()=>C.bindTexture(ue,Q)),te(C,()=>C.texParameteri(ue,C.TEXTURE_WRAP_S,C.CLAMP_TO_EDGE)),te(C,()=>C.texParameteri(ue,C.TEXTURE_WRAP_T,C.CLAMP_TO_EDGE)),te(C,()=>C.texParameteri(ue,C.TEXTURE_MIN_FILTER,C.NEAREST)),te(C,()=>C.texParameteri(ue,C.TEXTURE_MAG_FILTER,C.NEAREST)),1===(0,y.OBj)().getNumber("WEBGL_VERSION")?te(C,()=>C.texImage2D(ue,0,S,b,_,0,k,H,null)):te(C,()=>C.texStorage2D(ue,1,S,b,_)),te(C,()=>C.bindTexture(C.TEXTURE_2D,null)),{texture:Q,texShape:[_,b]}}function Ca(C){return C.internalFormatFloat}function Pa(C,b,_,S){const[k,H]=K(b,_);return Si(C,k,H,Ca(S),S.textureFormatFloat,C.FLOAT)}function Ea(C){return C.internalFormatHalfFloat}function gl(C,b,_,S){const[k,H]=K(b,_);return Si(C,k,H,Ea(S),S.textureFormatFloat,S.textureTypeHalfFloat)}function _l(C){return C.downloadTextureFormat}function q(C,b,_,S){const[k,H]=K(b,_);return Si(C,k,H,_l(S),C.RGBA,C.UNSIGNED_BYTE)}function L(C){return C.internalFormatPackedFloat}function X(C,b,_,S){const[k,H]=ie(b,_);return Si(C,k,H,L(S),C.RGBA,C.FLOAT)}function Ae(C){return C.internalFormatPackedHalfFloat}function He(C,b,_,S){const[k,H]=ie(b,_);return Si(C,k,H,Ae(S),C.RGBA,S.textureTypeHalfFloat)}function Ye(C,b,_){return te(C,()=>C.bindBuffer(C.ARRAY_BUFFER,_)),Xn(C,b,"clipSpacePos",_,3,20,0)&&Xn(C,b,"uv",_,2,20,12)}function it(C,b,_,S,k,H){let Q,ue,ae;te(C,()=>C.bindTexture(C.TEXTURE_2D,b)),k instanceof Uint8Array?(Q=new Uint8Array(_*S*4),ue=C.UNSIGNED_BYTE,ae=C.RGBA):(Q=new Float32Array(_*S*4),ue=C.FLOAT,ae=H.internalFormatPackedFloat),Q.set(k),2===(0,y.OBj)().getNumber("WEBGL_VERSION")?te(C,()=>C.texSubImage2D(C.TEXTURE_2D,0,0,0,_,S,C.RGBA,ue,Q)):te(C,()=>C.texImage2D(C.TEXTURE_2D,0,ae,_,S,0,C.RGBA,ue,Q)),te(C,()=>C.bindTexture(C.TEXTURE_2D,null))}function _t(C,b,_){te(C,()=>C.bindTexture(C.TEXTURE_2D,b)),_.data instanceof Uint8Array?2===(0,y.OBj)().getNumber("WEBGL_VERSION")?te(C,()=>C.texSubImage2D(C.TEXTURE_2D,0,0,0,_.width,_.height,C.RGBA,C.UNSIGNED_BYTE,_.data)):te(C,()=>C.texImage2D(C.TEXTURE_2D,0,C.RGBA,_.width,_.height,0,C.RGBA,C.UNSIGNED_BYTE,_.data)):2===(0,y.OBj)().getNumber("WEBGL_VERSION")?te(C,()=>C.texSubImage2D(C.TEXTURE_2D,0,0,0,C.RGBA,C.UNSIGNED_BYTE,_)):te(C,()=>C.texImage2D(C.TEXTURE_2D,0,C.RGBA,C.RGBA,C.UNSIGNED_BYTE,_)),te(C,()=>C.bindTexture(C.TEXTURE_2D,null))}function wt(C,b,_,S){const k=C.createBuffer();te(C,()=>C.bindBuffer(C.PIXEL_PACK_BUFFER,k));const ue=16*b*_;return te(C,()=>C.bufferData(C.PIXEL_PACK_BUFFER,ue,C.STREAM_READ)),te(C,()=>C.readPixels(0,0,_,b,C.RGBA,C.FLOAT,0)),te(C,()=>C.bindBuffer(C.PIXEL_PACK_BUFFER,null)),k}function kn(C,b,_){const S=C,k=new Float32Array(_);return S.bindBuffer(S.PIXEL_PACK_BUFFER,b),S.getBufferSubData(S.PIXEL_PACK_BUFFER,0,k),S.bindBuffer(S.PIXEL_PACK_BUFFER,null),k}function pn(C,b,_,S){const[k,H]=K(b,_),ue=new Uint8Array(function _e(C,b){return C*b}(b*_,4));return te(C,()=>C.readPixels(0,0,k,H,S.downloadTextureFormat,C.UNSIGNED_BYTE,ue)),new Float32Array(ue.buffer)}function qn(C,b,_,S,k,H,Q,ue){const ae=C,Se=new Float32Array(function Le(C,b){const[_,S]=ie(C,b);return _*S*4}(H,Q));return ae.bindBuffer(ae.PIXEL_PACK_BUFFER,b),ae.getBufferSubData(ae.PIXEL_PACK_BUFFER,0,Se),ae.bindBuffer(ae.PIXEL_PACK_BUFFER,null),Se}function os(C,b,_){const S=new Float32Array(b*_*4);return te(C,()=>C.readPixels(0,0,_,b,C.RGBA,C.FLOAT,S)),S}class Ms{constructor(b){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const _=(0,y.OBj)().getNumber("WEBGL_VERSION");if(null!=b?(this.gl=b,l(_,b)):this.gl=w(_),b=this.gl,2===(0,y.OBj)().getNumber("WEBGL_VERSION")){const H=b;this.createVertexArray=()=>te(H,()=>H.createVertexArray()),this.bindVertexArray=Q=>te(H,()=>H.bindVertexArray(Q)),this.deleteVertexArray=Q=>te(H,()=>H.deleteVertexArray(Q)),this.getVertexArray=()=>te(H,()=>H.getParameter(H.VERTEX_ARRAY_BINDING))}else if(null!=b){const H=b.getExtension("OES_vertex_array_object");if(null==H)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>te(b,()=>H.createVertexArrayOES()),this.bindVertexArray=Q=>te(b,()=>H.bindVertexArrayOES(Q)),this.deleteVertexArray=Q=>te(b,()=>H.deleteVertexArrayOES(Q)),this.getVertexArray=()=>te(b,()=>b.getParameter(H.VERTEX_ARRAY_BINDING_OES))}let S="WEBGL_color_buffer_float";const k="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,y.OBj)().getNumber("WEBGL_VERSION")){const Q="OES_texture_half_float";if(this.textureFloatExtension=v(this.gl,"OES_texture_float"),to(this.gl,Q))this.textureHalfFloatExtension=v(this.gl,Q);else if((0,y.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(S),to(this.gl,k))this.colorBufferHalfFloatExtension=v(this.gl,k);else if((0,y.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(S="EXT_color_buffer_float",to(this.gl,S))this.colorBufferFloatExtension=this.gl.getExtension(S);else{if(!to(this.gl,k))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(k)}this.vertexBuffer=Ro(this.gl),this.indexBuffer=ll(this.gl),this.framebuffer=Es(this.gl),this.textureConfig=De(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,y.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const b=this.gl;te(b,()=>b.finish()),te(b,()=>b.bindFramebuffer(b.FRAMEBUFFER,null)),te(b,()=>b.deleteFramebuffer(this.framebuffer)),te(b,()=>b.bindBuffer(b.ARRAY_BUFFER,null)),te(b,()=>b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,null)),te(b,()=>b.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(b,_){return this.throwIfDisposed(),Pa(this.gl,b,_,this.textureConfig)}createFloat16MatrixTexture(b,_){return this.throwIfDisposed(),gl(this.gl,b,_,this.textureConfig)}createUnsignedBytesMatrixTexture(b,_){return this.throwIfDisposed(),q(this.gl,b,_,this.textureConfig)}uploadPixelDataToTexture(b,_){this.throwIfDisposed(),_t(this.gl,b,_)}uploadDenseMatrixToTexture(b,_,S,k){this.throwIfDisposed(),it(this.gl,b,_,S,k,this.textureConfig)}createFloat16PackedMatrixTexture(b,_){return this.throwIfDisposed(),He(this.gl,b,_,this.textureConfig)}createPackedMatrixTexture(b,_){return this.throwIfDisposed(),X(this.gl,b,_,this.textureConfig)}deleteMatrixTexture(b){this.throwIfDisposed(),this.outputTexture===b&&(Nn(this.gl,this.framebuffer),this.outputTexture=null),te(this.gl,()=>this.gl.deleteTexture(b))}downloadByteEncodedFloatMatrixFromOutputTexture(b,_,S){return this.downloadMatrixDriver(b,()=>pn(this.gl,_,S,this.textureConfig))}downloadPackedMatrixFromBuffer(b,_,S,k,H,Q){return qn(this.gl,b,0,0,0,H,Q)}downloadFloat32MatrixFromBuffer(b,_){return kn(this.gl,b,_)}createBufferFromTexture(b,_,S){this.bindTextureToFrameBuffer(b);const k=wt(this.gl,_,S);return this.unbindTextureToFrameBuffer(),k}createAndWaitForFence(){const b=this.createFence(this.gl);return this.pollFence(b)}createFence(b){let _,S;if((0,y.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const k=b,H=k.fenceSync(k.SYNC_GPU_COMMANDS_COMPLETE,0);b.flush(),S=()=>{const Q=k.clientWaitSync(H,0,0);return Q===k.ALREADY_SIGNALED||Q===k.CONDITION_SATISFIED},_=H}else(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(_=this.beginQuery(),this.endQuery(),S=()=>this.isQueryAvailable(_,(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):S=()=>!0;return{query:_,isFencePassed:S}}downloadMatrixFromPackedTexture(b,_,S){return this.downloadMatrixDriver(b,()=>os(this.gl,_,S))}createProgram(b){this.throwIfDisposed();const _=this.gl;null==this.vertexShader&&(this.vertexShader=mc(_));const S=Ct(_);te(_,()=>_.attachShader(S,this.vertexShader)),te(_,()=>_.attachShader(S,b)),It(_,S);const k=Object.assign(S,{vao:this.createVertexArray()});return this.debug&&nn(_,k),k}buildVao(b){this.setProgram(b),this.bindVertexArray(b.vao);const _=this.gl;te(_,()=>_.bindBuffer(_.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Ye(_,b,this.vertexBuffer)}deleteProgram(b){this.throwIfDisposed(),b===this.program&&(this.program=null),null!=b&&(te(this.gl,()=>this.gl.deleteProgram(b)),this.deleteVertexArray(b.vao))}setProgram(b){this.throwIfDisposed(),this.program=b,null!=this.program&&this.debug&&nn(this.gl,this.program),te(this.gl,()=>this.gl.useProgram(b))}getUniformLocation(b,_,S=!0){return this.throwIfDisposed(),S?Ir(this.gl,b,_):Ss(this.gl,b,_)}getAttributeLocation(b,_){return this.throwIfDisposed(),te(this.gl,()=>this.gl.getAttribLocation(b,_))}getUniformLocationNoThrow(b,_){return this.throwIfDisposed(),this.gl.getUniformLocation(b,_)}setInputMatrixTexture(b,_,S){this.throwIfDisposed(),this.throwIfNoProgram(),Qe(this.gl,b,_,S)}setOutputMatrixTexture(b,_,S){this.setOutputMatrixTextureDriver(b,S,_)}setOutputPackedMatrixTexture(b,_,S){this.throwIfDisposed();const[k,H]=ie(_,S);this.setOutputMatrixTextureDriver(b,k,H)}setOutputMatrixWriteRegion(b,_,S,k){this.setOutputMatrixWriteRegionDriver(S,b,k,_)}setOutputPackedMatrixWriteRegion(b,_,S,k){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&nn(this.gl,this.program),Os(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const b=this.gl;if(this.debug){const _=this.getVertexArray();console.assert(_===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}te(b,()=>b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),te(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=v(this.gl,2===(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const S=this.gl,k=this.getQueryTimerExtensionWebGL2(),H=S.createQuery();return S.beginQuery(k.TIME_ELAPSED_EXT,H),H}const b=this.getQueryTimerExtensionWebGL1(),_=b.createQueryEXT();return b.beginQueryEXT(b.TIME_ELAPSED_EXT,_),_}endQuery(){if(2===(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const _=this.gl,S=this.getQueryTimerExtensionWebGL2();return void _.endQuery(S.TIME_ELAPSED_EXT)}const b=this.getQueryTimerExtensionWebGL1();b.endQueryEXT(b.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(b){var _=this;return(0,F.Z)(function*(){return yield y.D5U.repeatedTry(()=>_.disposed||_.isQueryAvailable(b,(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),_.getQueryTime(b,(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(b,_){if(0===_)return null;if(2===_){const S=this.gl;return S.getQueryParameter(b,S.QUERY_RESULT)/1e6}{const S=this.getQueryTimerExtensionWebGL1();return S.getQueryObjectEXT(b,S.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(b,_){if(0===_)return!0;if(2===_){const S=this.gl,k=this.getQueryTimerExtensionWebGL2(),H=S.getQueryParameter(b,S.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(k.GPU_DISJOINT_EXT)),H&&!this.disjoint}{const S=this.getQueryTimerExtensionWebGL1(),k=S.getQueryObjectEXT(b,S.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(S.GPU_DISJOINT_EXT)),k&&!this.disjoint}}pollFence(b){return new Promise(_=>{this.addItemToPoll(()=>b.isFencePassed(),()=>_())})}pollItems(){const b=function Tr(C){let b=0;for(;b<C.length&&C[b]();++b);return b-1}(this.itemsToPoll.map(_=>_.isDoneFn));for(let _=0;_<=b;++_){const{resolveFn:S}=this.itemsToPoll[_];S()}this.itemsToPoll=this.itemsToPoll.slice(b+1)}addItemToPoll(b,_){if(this.itemsToPoll.push({isDoneFn:b,resolveFn:_}),this.itemsToPoll.length>1)return;let S;"setTimeoutCustom"in(0,y.OBj)().platform&&(S=(0,y.OBj)().platform.setTimeoutCustom.bind((0,y.OBj)().platform)),y.D5U.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,S)}bindTextureToFrameBuffer(b){this.throwIfDisposed(),Qt(this.gl,b,this.framebuffer),this.debug&&Os(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Qt(this.gl,this.outputTexture,this.framebuffer),this.debug&&Os(this.gl)):Nn(this.gl,this.framebuffer)}downloadMatrixDriver(b,_){this.bindTextureToFrameBuffer(b);const S=_();return this.unbindTextureToFrameBuffer(),S}setOutputMatrixTextureDriver(b,_,S){this.throwIfDisposed();const k=this.gl;Qt(k,b,this.framebuffer),this.debug&&Os(k),this.outputTexture=b,te(k,()=>k.viewport(0,0,_,S)),te(k,()=>k.scissor(0,0,_,S))}setOutputMatrixWriteRegionDriver(b,_,S,k){this.throwIfDisposed(),te(this.gl,()=>this.gl.scissor(b,_,S,k))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}var Cr=h(8669);const{addImpl:Is,bincountImpl:lr,bincountReduceImpl:yo,bitwiseAndImpl:Da,castImpl:Jt,ceilImpl:ai,concatImpl:oc,equalImpl:wo,expImpl:Fa,expm1Impl:yl,floorImpl:Fi,gatherNdImpl:Yc,gatherV2Impl:Wu,greaterImpl:vl,greaterEqualImpl:Hl,lessImpl:Zc,lessEqualImpl:Oc,linSpaceImpl:Fc,logImpl:Qc,maxImpl:Ai,maximumImpl:Iu,minimumImpl:B,multiplyImpl:ve,negImpl:Be,notEqualImpl:ot,prodImpl:st,raggedGatherImpl:Xt,raggedRangeImpl:jt,raggedTensorToTensorImpl:Yt,rangeImpl:xn,rsqrtImpl:ss,scatterImpl:Jn,sigmoidImpl:_r,simpleAbsImpl:Qs,sliceImpl:As,sparseFillEmptyRowsImpl:cn,sparseReshapeImpl:Zr,sparseSegmentReductionImpl:jn,sqrtImpl:Oi,staticRegexReplaceImpl:ca,stridedSliceImpl:Yo,stringNGramsImpl:La,stringSplitImpl:hi,stringToHashBucketFastImpl:ci,subImpl:qt,tileImpl:jl,topKImpl:oo,transposeImpl:Bo,uniqueImpl:wi}=Cr;function $a(C,b){return["x","y","z","w","u","v"].slice(0,b).map(_=>`${C}.${_}`)}function Gi(C,b){return 1===b?[C]:$a(C,b)}class an{constructor(b){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=b,this.rank=b.length,this.enableShapeUniforms=ki(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const _=Gi("rc",this.rank),S=mi(this.rank),k=this.getOutOfBoundsCondition(_),H=this.getSetup(_),Q=this.getOutput(_);this.userCode=`\n        void main() {\n          ${S} rc = getOutputCoords();\n\n          if(${k}) {\n            setOutput(vec4(0));\n          } else {\n            ${H}\n\n            setOutput(vec4(${Q}));\n          }\n        }\n      `}}getSourceCoordsArr(b){const _=[];for(let S=0;S<=1;S++)for(let k=0;k<=1;k++){let H=`${0===S?"r":"rp1"}, ${0===k?"c":"cp1"}`;for(let Q=2;Q<this.rank;Q++)H=`${b[b.length-1-Q]},`+H;_.push(H)}return _}getOutOfBoundsCondition(b){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let _="";for(let S=this.rank-2;S<this.rank;S++)_+=`${b[S]} >= ${this.enableShapeUniforms?`outShape[${S}]`:this.outputShape[S]}`,S<this.rank-1&&(_+="||");return _}getSetup(b){if(1===this.rank)return"";const _=b.slice(-2);return`\n      int r = ${_[0]};\n      int c = ${_[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(b){const _=this.getSourceCoordsArr(b);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${_[0]}),\n            cEdge ? 0. : getA(${_[1]}),\n            rEdge ? 0. : getA(${_[2]}),\n            rEdge || cEdge ? 0. : getA(${_[3]})`}}class kl{constructor(b,_){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length);let S="";for(let k=0;k<4;k++){let H="thisRC = rc;";k%2==1&&(H+="thisRC.z += 1;"),k>1&&(H+="thisRC.y += 1;"),S+=`\n        ${H}\n        ${k>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${k}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${k>0?"}":""}\n      `}this.userCode=`\n      ${function Gl(C,b){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${b?function Li(C,b,_="index"){const k=function Go(C,b){const _=C.length,S=C.map(H=>`${b}[${H}]`),k=new Array(_-1);k[_-2]=S[_-1];for(let H=_-3;H>=0;--H)k[H]=`(${k[H+1]} * ${S[H+1]})`;return k}(C.map((H,Q)=>Q),b);return k.map((H,Q)=>`int ${C[Q]} = ${_} / ${k[Q]}; ${Q===k.length-1?`int ${C[Q+1]} = ${_} - ${C[Q]} * ${k[Q]}`:`index -= ${C[Q]} * ${k[Q]}`};`).join("")}(["r","c","d"],"inputShape"):ui(["r","c","d"],C)}\n      return ivec3(r, c, d);\n    }\n  `}(_,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Xi(b)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":b[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":b[2]};\n\n        ${S}\n\n        setOutput(result);\n      }\n    `}}class Tu{constructor(b){this.gpgpu=b,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(b,_,S){const k=V(_,S),H=O(b,k,S);H in this.freeTextures||(this.freeTextures[H]=[]),H in this.usedTextures||(this.usedTextures[H]=[]);const Q=gc(b,k,this.gpgpu.gl,this.gpgpu.textureConfig,S);if(this.freeTextures[H].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=Q,this.log();const ae=this.freeTextures[H].pop();return this.usedTextures[H].push(ae),ae}let ue;return k===J.PACKED_2X2_FLOAT32?ue=this.gpgpu.createPackedMatrixTexture(b[0],b[1]):k===J.PACKED_2X2_FLOAT16?ue=this.gpgpu.createFloat16PackedMatrixTexture(b[0],b[1]):k===J.UNPACKED_FLOAT32?ue=this.gpgpu.createFloat32MatrixTexture(b[0],b[1]):k===J.UNPACKED_FLOAT16?ue=this.gpgpu.createFloat16MatrixTexture(b[0],b[1]):k===J.PACKED_4X1_UNSIGNED_BYTE&&(ue=this.gpgpu.createUnsignedBytesMatrixTexture(b[0],b[1])),this.usedTextures[H].push(ue),this.numUsedTextures++,this._numBytesAllocated+=Q,this.log(),ue}releaseTexture(b,_,S,k){if(null==this.freeTextures)return;const H=V(S,k),Q=O(_,H,k);Q in this.freeTextures||(this.freeTextures[Q]=[]);const ue=gc(_,H,this.gpgpu.gl,this.gpgpu.textureConfig,k),ae=(0,y.OBj)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==ae&&this._numBytesAllocated>ae?(this.gpgpu.deleteMatrixTexture(b.texture),this._numBytesAllocated-=ue):(this.freeTextures[Q].push(b),this.numFreeTextures++,this._numBytesFree+=ue),this.numUsedTextures--;const Se=this.usedTextures[Q],Ne=Se&&Se.indexOf(b);if(null==Ne||Ne<0)throw new Error("Cannot release a texture that was never provided by this texture manager");Se[Ne]=Se[Se.length-1],Se.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const _=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*_)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const b in this.freeTextures)this.freeTextures[b].forEach(_=>{this.gpgpu.deleteMatrixTexture(_.texture)});for(const b in this.usedTextures)this.usedTextures[b].forEach(_=>{this.gpgpu.deleteMatrixTexture(_.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function gc(C,b,_,S,k){const H=function rd(C,b){switch(C){case J.PACKED_2X2_FLOAT32:return L(b);case J.PACKED_2X2_FLOAT16:return Ae(b);case J.UNPACKED_FLOAT32:return Ca(b);case J.UNPACKED_FLOAT16:return Ea(b);case J.PACKED_4X1_UNSIGNED_BYTE:return _l(b);default:throw new Error(`Unknown physical texture type ${C}`)}}(b,S);let Q;if(k){const[ae,Se]=ie(C[0],C[1]);Q=ae*Se}else{const[ae,Se]=K(C[0],C[1]);Q=ae*Se}const ue=function sd(C,b){if(b===C.R32F)return 4;if(b===C.R16F)return 2;if(b===C.RGBA32F)return 16;if(b===C.RGBA)return 16;if(b===C.RGBA16F)return 8;if(b===C.RGBA8)return 4;throw new Error(`Unknown internal format ${b}`)}(_,H);return Q*ue}function V(C,b){if(C===G.UPLOAD)return J.PACKED_2X2_FLOAT32;if(C===G.RENDER||null==C)return function Au(C){return(0,y.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?C?J.PACKED_2X2_FLOAT32:J.UNPACKED_FLOAT32:C?J.PACKED_2X2_FLOAT16:J.UNPACKED_FLOAT16}(b);if(C===G.DOWNLOAD||C===G.PIXELS)return J.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${C}`)}function O(C,b,_){return`${C[0]}_${C[1]}_${b}_${_}`}class z{constructor(b,_){this.variableNames=["A"],this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${_}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const pe="if (isnan(x)) return x;",Pe="return x;",Ve="return abs(x);",mt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Wt=pe+"\n  return (x < 0.0) ? 0.0 : x;\n",mn=pe+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",rn="return x;",$n="return 1.0 / (1.0 + exp(-1.0 * x));",zn="return x;",Bs="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",ur="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Rs="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Or="return 1.0 / (1.0 + exp(-1.0 * x));";class zr{constructor(b,_){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${_}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class sr{constructor(b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length);const _=b.length,S=Gi("rc",_),k=mi(_),H=function uu(C,b){if(1===C)return"rc";let _="";for(let S=0;S<C;S++)_+=b[S],S<C-1&&(_+=",");return _}(_,S),Q=S.slice(-2),ue=_<=1?"rc":`vec2(${Q.join(",")})`;this.userCode=`\n      void main() {\n        ${k} rc = getOutputCoords();\n        vec4 packedInput = getA(${H});\n\n        setOutput(getChannel(packedInput, ${ue}));\n      }\n    `}}const No=y.GDt.whereImpl,Vr={},ku=(0,y.OBj)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let Vi=(()=>{class C extends y.Zuw{nextDataId(){return C.nextDataId++}constructor(_){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,y.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let S;if(null!=_){if(_ instanceof Ms)S=_;else{const k=w((0,y.OBj)().getNumber("WEBGL_VERSION"),_);S=new Ms(k)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const k=w((0,y.OBj)().getNumber("WEBGL_VERSION"));S=new Ms(k),this.binaryCache=function Ec(C){return C in Vr||(Vr[C]={}),Vr[C]}((0,y.OBj)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=S,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Tu(this.gpgpu),this.numMBBeforeWarning=function bl(){return null==(0,y.OBj)().global.screen?1024:(0,y.OBj)().global.screen.height*(0,y.OBj)().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new y.JLz(this,(0,y.SRH)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(_,S,k,H,Q,ue){const ae=this.makeTensorInfo(S,k),Se=this.texData.get(ae.dataId);Se.isPacked=!1,Se.texture={texture:_,texShape:[H,Q]},Se.texShape=[H,Q];const Ne=oa(S),Je=new Wl(Ne,!1,ue),rt=this.runWebGLProgram(Je,[ae],k,[[H,Q]]);return rt.shape=S,Se.texture=null,this.disposeIntermediateTensorInfo(ae),rt.dataId}write(_,S,k){if(((0,y.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,y.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(_),"complex64"===k&&null!=_)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const H={id:this.nextDataId()};return this.texData.set(H,{shape:S,dtype:k,values:_,usage:G.UPLOAD,refCount:1}),H}refCount(_){return this.texData.has(_)?this.texData.get(_).refCount:0}incRef(_){this.texData.get(_).refCount++}decRef(_){this.texData.has(_)&&this.texData.get(_).refCount--}move(_,S,k,H,Q){if((0,y.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(S),"complex64"===H)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(_,{shape:k,dtype:H,values:S,usage:G.UPLOAD,refCount:Q})}disposeIntermediateTensorInfo(_){this.disposeData(_.dataId)}readSync(_){const S=this.texData.get(_),{values:k,dtype:H,complexTensorInfos:Q,slice:ue,shape:ae,isPacked:Se}=S;if(null!=ue){let ft;ft=Se?new zr(ae,rn):new z(ae,rn);const Ot=this.runWebGLProgram(ft,[{dataId:_,shape:ae,dtype:H}],H),Kt=this.readSync(Ot.dataId);return this.disposeIntermediateTensorInfo(Ot),Kt}if(null!=k)return this.convertAndCacheOnCPU(_);if("string"===H)return k;const Ne=null!=this.activeTimers;let Je,rt;if(Ne&&(Je=y.D5U.now()),"complex64"===H){const ft=this.readSync(Q.real.dataId),Ot=this.readSync(Q.imag.dataId);rt=y.backend_util.mergeRealAndImagArrays(ft,Ot)}else rt=this.getValuesFromTexture(_);return Ne&&(this.downloadWaitMs+=y.D5U.now()-Je),this.convertAndCacheOnCPU(_,rt)}read(_){var S=this;return(0,F.Z)(function*(){if(S.pendingRead.has(_)){const tn=S.pendingRead.get(_);return new Promise(Zt=>tn.push(Zt))}const k=S.texData.get(_),{values:H,shape:Q,slice:ue,dtype:ae,complexTensorInfos:Se,isPacked:Ne}=k;if(null!=ue){let tn;tn=Ne?new zr(Q,rn):new z(Q,rn);const Zt=S.runWebGLProgram(tn,[{dataId:_,shape:Q,dtype:ae}],ae),hn=S.read(Zt.dataId);return S.disposeIntermediateTensorInfo(Zt),hn}if(null!=H)return S.convertAndCacheOnCPU(_);if((0,y.OBj)().getBool("DEBUG")&&!(0,y.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,y.OBj)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let rt,ft,Je=null;if("complex64"!==ae&&(0,y.OBj)().get("WEBGL_BUFFER_SUPPORTED")){rt=S.decode(_);const tn=S.texData.get(rt.dataId);Je=S.gpgpu.createBufferFromTexture(tn.texture.texture,...we(Q))}if(S.pendingRead.set(_,[]),"complex64"!==ae&&(yield S.gpgpu.createAndWaitForFence()),"complex64"===ae){const tn=yield Promise.all([S.read(Se.real.dataId),S.read(Se.imag.dataId)]);ft=y.backend_util.mergeRealAndImagArrays(tn[0],tn[1])}else if(null==Je)ft=S.getValuesFromTexture(_);else{const tn=y.D5U.sizeFromShape(Q);ft=S.gpgpu.downloadFloat32MatrixFromBuffer(Je,tn)}if(null!=rt&&S.disposeIntermediateTensorInfo(rt),null!=Je){const tn=S.gpgpu.gl;te(tn,()=>tn.deleteBuffer(Je))}const Ot=S.convertAndCacheOnCPU(_,ft),Kt=S.pendingRead.get(_);return S.pendingRead.delete(_),Kt.forEach(tn=>tn(Ot)),S.pendingDisposal.has(_)&&(S.pendingDisposal.delete(_),S.disposeData(_)&&(0,y.SRH)().removeDataId(_,S),S.pendingDeletes--),Ot})()}readToGPU(_,S={}){const k=this.texData.get(_),{values:H,shape:Q,slice:ue,dtype:ae,isPacked:Se,texture:Ne}=k;if("complex64"===ae)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=ue){let Ot;Ot=Se?new zr(Q,rn):new z(Q,rn);const Kt=this.runWebGLProgram(Ot,[{dataId:_,shape:Q,dtype:ae}],ae),tn=this.readToGPU(Kt,S);return this.disposeIntermediateTensorInfo(Kt),tn}if(null==Ne)throw null!=H?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const Je=this.decode(_,S.customTexShape),rt=(0,y.SRH)().makeTensorFromTensorInfo(Je),ft=this.texData.get(Je.dataId);return Object.assign({tensorRef:rt},ft.texture)}bufferSync(_){const S=this.readSync(_.dataId);if("string"===_.dtype)try{const k=S.map(H=>y.D5U.decodeString(H));return(0,y.f3b)(_.shape,_.dtype,k)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,y.f3b)(_.shape,_.dtype,S)}checkNumericalProblems(_){if(null!=_)for(let S=0;S<_.length;S++){const k=_[S];if(!ye(k))throw(0,y.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${k} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${k} cannot be represented on this device.`)}}getValuesFromTexture(_){const{shape:S,dtype:k,isPacked:H}=this.texData.get(_),Q=y.D5U.sizeFromShape(S);if((0,y.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const ft=this.decode(_),Ot=this.texData.get(ft.dataId),Kt=this.gpgpu.downloadMatrixFromPackedTexture(Ot.texture.texture,...we(S)).subarray(0,Q);return this.disposeIntermediateTensorInfo(ft),Kt}const ue=(0,y.OBj)().getBool("WEBGL_PACK")&&!0===H,ae=ue?oa(S):S,Se=ue?new gn(ae):new Ma(ae),Ne=this.runWebGLProgram(Se,[{shape:ae,dtype:k,dataId:_}],"float32"),Je=this.texData.get(Ne.dataId),rt=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(Je.texture.texture,Je.texShape[0],Je.texShape[1]).subarray(0,Q);return this.disposeIntermediateTensorInfo(Ne),rt}timerAvailable(){return(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(_){var S=this;const k=this.activeTimers,H=[];let Q=!1;null==this.programTimersStack?(this.programTimersStack=H,Q=!0):this.activeTimers.push(H),this.activeTimers=H,_();const ue=y.D5U.flatten(this.activeTimers.map(Ne=>Ne.query)).filter(Ne=>null!=Ne),ae=y.D5U.flatten(this.activeTimers.map(Ne=>Ne.name)).filter(Ne=>null!=Ne);this.activeTimers=k,Q&&(this.programTimersStack=null);const Se={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,F.Z)(function*(){if((0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const Ne=yield Promise.all(ue);Se.kernelMs=y.D5U.sum(Ne),Se.getExtraProfileInfo=()=>Ne.map((Je,rt)=>({name:ae[rt],ms:Je})).map(Je=>`${Je.name}: ${Je.ms}`).join(", ")}else Se.kernelMs={error:"WebGL query timers are not supported in this environment."};return S.uploadWaitMs=0,S.downloadWaitMs=0,Se})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.D5U.now(),endMs:null}}endTimer(_){return(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),_):(_.endMs=y.D5U.now(),_)}getQueryTime(_){var S=this;return(0,F.Z)(function*(){return(0,y.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?S.gpgpu.waitForQueryAndGetTime(_):_.endMs-_.startMs})()}disposeData(_,S=!1){if(this.pendingDisposal.has(_))return!1;if(!this.texData.has(_))return!0;if(S?this.texData.get(_).refCount=0:this.texData.get(_).refCount--,!S&&this.texData.get(_).refCount>0)return!1;if(this.pendingRead.has(_))return this.pendingDisposal.add(_),this.pendingDeletes++,!1;this.releaseGPUData(_);const{complexTensorInfos:k}=this.texData.get(_);return null!=k&&(this.disposeData(k.real.dataId,S),this.disposeData(k.imag.dataId,S)),this.texData.delete(_),!0}releaseGPUData(_){const{texture:S,dtype:k,texShape:H,usage:Q,isPacked:ue,slice:ae}=this.texData.get(_),Se=ae&&ae.origDataId||_,Ne=this.dataRefCount.get(Se);Ne>1?this.dataRefCount.set(Se,Ne-1):(this.dataRefCount.delete(Se),null!=S&&(this.numBytesInGPU-=this.computeBytes(H,k),this.textureManager.releaseTexture(S,H,Q,ue)));const Je=this.texData.get(_);Je.texture=null,Je.texShape=null,Je.isPacked=!1,Je.slice=null}getTexture(_){return this.uploadToGPU(_),this.texData.get(_).texture.texture}getDataInfo(_){return this.texData.get(_)}shouldExecuteOnCPU(_,S=ku){return(0,y.OBj)().getBool("WEBGL_CPU_FORWARD")&&_.every(k=>null==this.texData.get(k.dataId).texture&&y.D5U.sizeFromShape(k.shape)<S)}getGPGPUContext(){return this.gpgpu}where(_){y.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const S=_.dataSync();return No(_.shape,S)}packedUnaryOp(_,S,k){const H=new zr(_.shape,S),Q=this.compileAndRun(H,[_],k);return(0,y.SRH)().makeTensorFromTensorInfo(Q)}abs(_){if(this.shouldExecuteOnCPU([_])&&"complex64"!==_.dtype){const H=Qs(this.texData.get(_.dataId).values);return this.makeOutput(_.shape,_.dtype,H)}if((0,y.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(_,Ve,_.dtype);const S=new z(_.shape,Ve),k=this.compileAndRun(S,[_]);return(0,y.SRH)().makeTensorFromTensorInfo(k)}makeTensorInfo(_,S,k){let H;if("string"===S&&null!=k&&k.length>0&&y.D5U.isString(k[0])){const Q=k.map(ue=>y.D5U.encodeString(ue));H=this.write(Q,_,S)}else H=this.write(k,_,S);return this.texData.get(H).usage=null,{dataId:H,shape:_,dtype:S}}makeOutput(_,S,k){return(0,y.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(_,S,k),this)}unpackTensor(_){const S=new sr(_.shape);return this.runWebGLProgram(S,[_],_.dtype)}packTensor(_){const S=new an(_.shape);return this.runWebGLProgram(S,[_],_.dtype,null,!0)}packedReshape(_,S){const k=[$r(_.shape),...eo(_.shape)],H={dtype:_.dtype,shape:k,dataId:_.dataId},Q=[$r(S),...eo(S)],ue=new kl(Q,k),Ne=this.runWebGLProgram(ue,[H],_.dtype,[k],!0);return{dataId:Ne.dataId,shape:S,dtype:Ne.dtype}}decode(_,S){const k=this.texData.get(_),{isPacked:H,shape:Q,dtype:ue}=k;if(null!=S){const ft=y.D5U.sizeFromShape(Q);y.D5U.assert(ft<=S[0]*S[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const ae=oa(Q);let Se;Se=H?new ar(ae):new wr(ae);const Je=[S??we(ae)];return{dtype:ue,shape:Q,dataId:this.runWebGLProgram(Se,[{shape:ae,dtype:ue,dataId:_}],ue,Je,!0,S).dataId}}runWebGLProgram(_,S,k,H,Q=!1,ue){const ae=this.makeTensorInfo(_.outputShape,k),Se=this.texData.get(ae.dataId);if(_.packedOutput&&(Se.isPacked=!0),_.outPackingScheme===D.DENSE){const hn=ue??we(_.outputShape);Se.texShape=hn.map(ts=>2*ts)}if(null!=_.outTexUsage&&(Se.usage=_.outTexUsage),0===y.D5U.sizeFromShape(ae.shape))return Se.values=y.D5U.getTypedArrayFromDType(ae.dtype,0),ae;const Ne=[],Je=S.map(hn=>{if("complex64"===hn.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let ts=this.texData.get(hn.dataId);if(null==ts.texture){if(!_.packedInputs&&y.D5U.sizeFromShape(hn.shape)<=(0,y.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:hn.shape,texData:null,isUniform:!0,uniformValues:ts.values};_.packedInputs&&(ts.isPacked=!0,ts.shape=hn.shape)}if(this.uploadToGPU(hn.dataId),!!ts.isPacked!=!!_.packedInputs)hn=ts.isPacked?this.unpackTensor(hn):this.packTensor(hn),Ne.push(hn),ts=this.texData.get(hn.dataId);else if(ts.isPacked&&!xa(ts.shape,hn.shape)){const us=hn,Us=hn.shape;hn.shape=ts.shape,hn=this.packedReshape(hn,Us),Ne.push(hn),ts=this.texData.get(hn.dataId),us.shape=Us}return{shape:hn.shape,texData:ts,isUniform:!1}});this.uploadToGPU(ae.dataId);const rt={shape:ae.shape,texData:Se,isUniform:!1},ft=function En(C,b,_){let S="";b.concat(_).forEach(Q=>{const ue=null!=Q.texData&&null!=Q.texData.slice&&Q.texData.slice.flatOffset>0;if(C.enableShapeUniforms&&!Q.isUniform){const ae=Q.texData.texShape,{useSqueezeShape:Se,uniformShape:Ne,keptDims:Je}=ic(C.packedInputs,Q.shape,ae);let rt="",ft="",Ot="";if(1===Ne.length&&C.packedInputs){const Us=[Math.ceil(ae[0]/2),Math.ceil(ae[1]/2)];rt=`${Us[0]>1}_${Us[1]>1}`}else if(2!==Ne.length||C.packedInputs){if(Ne.length>2&&!C.packedInputs){const Us=y.D5U.computeStrides(Ne);Ot=`${Us[0]===ae[1]}_${Us[Us.length-1]===ae[1]}`}}else ft=`${Ne[0]>1}_${Ne[1]>1}`;const Kt=Q.shape.length,tn=2===Ne.length&&y.D5U.arraysEqual(Q.shape,ae),Zt=1===y.D5U.sizeFromShape(Q.shape),hn=y.backend_util.getBroadcastDims(Q.shape,_.shape),ts=!C.packedInputs&&Kt===_.shape.length&&y.D5U.arraysEqual(ae,_.texData.texShape);S+=`${Kt}_${ts}_${Se?Je:""}_${Ne.length}_${Zt}_${hn}_${tn}_${rt}_${ft}_${Ot}_${C.packedInputs||Ne.length>2?"":`${ae[0]>1}_${ae[1]>1}`}_${ue}`}else S+=`${Q.shape}_${Q.isUniform?"uniform":Q.texData.texShape}_${ue}`});let H=C.constructor.name;return H+="_"+S+"_"+C.userCode+`${(0,y.OBj)().getNumber("WEBGL_VERSION")}`,H}(_,Je,rt),Ot=this.getAndSaveBinary(ft,()=>function Xo(C,b,_,S){const k=_.map((Ne,Je)=>{const rt={logicalShape:Ne.shape,texShape:Ne.isUniform?null:Ne.texData.texShape,isUniform:Ne.isUniform,isPacked:!Ne.isUniform&&Ne.texData.isPacked,flatOffset:null};return null!=Ne.texData&&null!=Ne.texData.slice&&Ne.texData.slice.flatOffset>0&&(rt.flatOffset=Ne.texData.slice.flatOffset),{name:b.variableNames[Je],shapeInfo:rt}}),H=k.map(Ne=>Ne.shapeInfo),Q={logicalShape:S.shape,texShape:S.texData.texShape,isUniform:!1,isPacked:S.texData.isPacked,flatOffset:null},ue=Jr(k,Q,b),ae=Xe(C.gl,ue),Se=C.createProgram(ae);return(0,y.OBj)().get("ENGINE_COMPILE_ONLY")?{program:b,fragmentShader:ae,source:ue,webGLProgram:Se,inShapeInfos:H,outShapeInfo:Q,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(C.buildVao(Se),Object.assign({program:b,fragmentShader:ae,source:ue,webGLProgram:Se,inShapeInfos:H,outShapeInfo:Q},go(C,b,Se)))}(this.gpgpu,_,Je,rt)),Kt=null!=this.activeTimers;let tn;Kt&&(tn=this.startTimer()),(0,y.OBj)().get("ENGINE_COMPILE_ONLY")||function Na(C,b,_,S,k){b.program.enableShapeUniforms||(ml(b.inShapeInfos,_),ml([b.outShapeInfo],[S]));const H=S.texData.texture,Q=S.texData.texShape;S.texData.isPacked?C.setOutputPackedMatrixTexture(H.texture,Q[0],Q[1]):C.setOutputMatrixTexture(H.texture,Q[0],Q[1]),C.setProgram(b.webGLProgram),C.bindVertexArray(b.webGLProgram.vao),1===(0,y.OBj)().getNumber("WEBGL_VERSION")&&null!==b.infLoc&&C.gl.uniform1f(b.infLoc,1/0),null!==b.nanLoc&&C.gl.uniform1f(b.nanLoc,NaN);for(let ae=0;ae<_.length;++ae){const Se=_[ae],{uniform:Ne,offset:Je,shape:rt,texShape:ft}=b.variablesLocations[ae];if(rt){const{uniformShape:Ot}=ic(b.program.packedInputs,Se.shape,Se.texData.texShape);switch(Ot.length){case 1:C.gl.uniform1iv(rt,new Int32Array(Ot));break;case 2:C.gl.uniform2iv(rt,new Int32Array(Ot));break;case 3:C.gl.uniform3iv(rt,new Int32Array(Ot));break;case 4:C.gl.uniform4iv(rt,new Int32Array(Ot))}}if(ft&&C.gl.uniform2i(ft,Se.texData.texShape[0],Se.texData.texShape[1]),null!=Ne){if(Se.isUniform){if(y.D5U.sizeFromShape(Se.shape)<2)C.gl.uniform1f(Ne,Se.uniformValues[0]);else{let Ot=Se.uniformValues;Ot instanceof Float32Array||(Ot=new Float32Array(Ot)),C.gl.uniform1fv(Ne,Ot)}continue}null!=Se.texData.slice&&null!=Je&&C.gl.uniform1i(Je,Se.texData.slice.flatOffset),C.setInputMatrixTexture(Se.texData.texture.texture,Ne,ae)}}const ue=b.outShapeLocation;if(ue)switch(S.shape.length){case 1:C.gl.uniform1iv(ue,new Int32Array(S.shape));break;case 2:C.gl.uniform2iv(ue,new Int32Array(S.shape));break;case 3:C.gl.uniform3iv(ue,new Int32Array(S.shape));break;case 4:C.gl.uniform4iv(ue,new Int32Array(S.shape))}if(b.outShapeStridesLocation){const ae=y.D5U.computeStrides(S.shape);switch(S.shape.length){case 2:C.gl.uniform1iv(b.outShapeStridesLocation,new Int32Array(ae));break;case 3:C.gl.uniform2iv(b.outShapeStridesLocation,new Int32Array(ae));break;case 4:C.gl.uniform3iv(b.outShapeStridesLocation,new Int32Array(ae))}}if(b.outTexShapeLocation&&C.gl.uniform2i(b.outTexShapeLocation,S.texData.texShape[0],S.texData.texShape[1]),b.program.customUniforms&&k)for(let ae=0;ae<b.program.customUniforms.length;++ae){const Se=b.program.customUniforms[ae],Ne=b.customUniformLocations[ae],Je=k[ae];if("float"===Se.type)C.gl.uniform1fv(Ne,Je);else if("vec2"===Se.type)C.gl.uniform2fv(Ne,Je);else if("vec3"===Se.type)C.gl.uniform3fv(Ne,Je);else if("vec4"===Se.type)C.gl.uniform4fv(Ne,Je);else if("int"===Se.type)C.gl.uniform1iv(Ne,Je);else if("ivec2"===Se.type)C.gl.uniform2iv(Ne,Je);else if("ivec3"===Se.type)C.gl.uniform3iv(Ne,Je);else{if("ivec4"!==Se.type)throw Error(`uniform type ${Se.type} is not supported yet.`);C.gl.uniform4iv(Ne,Je)}}C.executeProgram()}(this.gpgpu,Ot,Je,rt,H),Ne.forEach(hn=>this.disposeIntermediateTensorInfo(hn)),Kt&&(tn=this.endTimer(tn),this.activeTimers.push({name:_.constructor.name,query:this.getQueryTime(tn)}));const Zt=(0,y.OBj)().getNumber("WEBGL_FLUSH_THRESHOLD");if(Zt>0){const hn=y.D5U.now();hn-this.lastGlFlushTime>Zt&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=hn)}if(!(0,y.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&Se.isPacked&&!1===Q){const hn=this.unpackTensor(ae);return this.disposeIntermediateTensorInfo(ae),hn}return ae}compileAndRun(_,S,k,H,Q=!1){return this.runWebGLProgram(_,S,k=k||S[0].dtype,H,Q)}getAndSaveBinary(_,S){return _ in this.binaryCache||(this.binaryCache[_]=S()),this.binaryCache[_]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,y.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(S=>{this.gpgpu.deleteProgram(this.binaryCache[S].webGLProgram),delete this.binaryCache[S]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,y.lub)(()=>{if(!(0,y.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const _=(0,y.OBj)().getBool("DEBUG");(0,y.OBj)().set("DEBUG",!1);const S=this.abs((0,y.iD$)(1e-8)).dataSync()[0];if((0,y.OBj)().set("DEBUG",_),S>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(_){const S=this.texData.get(_),{shape:k,dtype:H,values:Q,texture:ue,usage:ae,isPacked:Se}=S;if(null!=ue)return;const Ne=null!=this.activeTimers;let Je;Ne&&(Je=y.D5U.now());let rt=S.texShape;if(null==rt&&(rt=aa(k,Se),S.texShape=rt),null!=Q){const ft=oa(k);let Ot,Kt=rt[1],tn=rt[0];const Zt=Q instanceof Uint8Array||Q instanceof Uint8ClampedArray;(Se||!Zt)&&([Kt,tn]=ie(rt[0],rt[1])),Ot=Se?new _o(ft,Zt):new Wl(ft,Zt);const hn=Zt?[tn,Kt]:rt,ts=this.makeTensorInfo(hn,H),us=this.texData.get(ts.dataId);us.usage=Zt?G.PIXELS:G.UPLOAD,us.texShape=hn,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(ts.dataId),Kt,tn,Q);const ii=this.runWebGLProgram(Ot,[ts],H,[[tn,Kt]],!0),Sr=this.texData.get(ii.dataId);S.texShape=Sr.texShape,S.isPacked=Sr.isPacked,S.usage=Sr.usage,(0,y.OBj)().get("ENGINE_COMPILE_ONLY")?this.disposeData(ii.dataId):(S.texture=Sr.texture,S.values=null,this.texData.delete(ii.dataId)),this.disposeIntermediateTensorInfo(ts),Ne&&(this.uploadWaitMs+=y.D5U.now()-Je)}else{const ft=this.acquireTexture(rt,ae,H,Se);S.texture=ft}}convertAndCacheOnCPU(_,S){const k=this.texData.get(_),{dtype:H}=k;return null!=S&&(k.values=function xl(C,b){if("float32"===b||"complex64"===b)return C;if("int32"===b||"bool"===b){const _="int32"===b?new Int32Array(C.length):new Uint8Array(C.length);for(let S=0;S<_.length;++S)_[S]=Math.round(C[S]);return _}throw new Error(`Unknown dtype ${b}`)}(S,H)),k.values}acquireTexture(_,S,k,H){if(this.numBytesInGPU+=this.computeBytes(_,k),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const Q=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${Q} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(_,S,H)}computeBytes(_,S){return _[0]*_[1]*y.D5U.bytesPerElement(S)}checkCompileCompletion(){for(const[,_]of Object.entries(this.binaryCache))this.checkCompletion_(_)}checkCompileCompletionAsync(){var _=this;return(0,F.Z)(function*(){const S=[];if(_.gpgpu.parallelCompilationExtension){for(const[,k]of Object.entries(_.binaryCache))S.push(_.checkCompletionAsync_(k));return Promise.all(S)}for(const[,k]of Object.entries(_.binaryCache)){const H=new Promise(Q=>{try{_.checkCompletion_(k),Q(!0)}catch(ue){throw ue}});S.push(H)}return Promise.all(S)})()}checkCompletionAsync_(_){var S=this;return(0,F.Z)(function*(){return S.gpgpu.gl.getProgramParameter(_.webGLProgram,S.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?S.checkCompletion_(_):(yield(0,y.glt)(),S.checkCompletionAsync_(_))})()}checkCompletion_(_){if(!1===this.gpgpu.gl.getProgramParameter(_.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(_.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(_.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(pt(_.source,this.gpgpu.gl.getShaderInfoLog(_.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const _ of Object.values(this.binaryCache)){this.gpgpu.buildVao(_.webGLProgram);const{variablesLocations:S,customUniformLocations:k,infLoc:H,nanLoc:Q,outShapeLocation:ue,outShapeStridesLocation:ae,outTexShapeLocation:Se}=go(this.gpgpu,_.program,_.webGLProgram);_.variablesLocations=S,_.customUniformLocations=k,_.infLoc=H,_.nanLoc=Q,_.outShapeLocation=ue,_.outShapeStridesLocation=ae,_.outTexShapeLocation=Se}}createTensorFromGPUData(_,S,k){_.channels=_.channels||"RGBA";const{texture:H,height:Q,width:ue,channels:ae}=_,Se=(0,y.SRH)().backend;if(!Se.gpgpu.gl.isTexture(H))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const Ne=Se.writeTexture(H,S,k,Q,ue,ae);return(0,y.SRH)().makeTensorFromDataId(Ne,S,k,Se)}}return C.nextDataId=0,C})();const Kl="4.11.0";function bu(){(0,y.OBj)().set("WEBGL_FORCE_F16_TEXTURES",!0)}y.C2$.isBrowser()&&(0,y.jqO)("webgl",()=>new Vi,2);const _c={forceHalfFloat:bu},Ou="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class yc{constructor(b,_,S){this.variableNames=["A","B"],this.outputShape=y.backend_util.assertAndGetBroadcastShape(_,S),this.enableShapeUniforms=ki(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${b}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Lc="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Ws{constructor(b,_,S,k=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=y.backend_util.assertAndGetBroadcastShape(_,S);const H=this.outputShape.length;this.enableShapeUniforms=ki(H);let Q="";if(k)if(0===H||1===y.D5U.sizeFromShape(this.outputShape))Q="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(Q=`\n          ${mi(H)} coords = getOutputCoords();\n        `,1===H)Q+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const ae=Gi("coords",H);Q+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${ae[H-2]} + 1) >= outShape[${H} - 2];\n            bool nextColOutOfBounds =\n              (${ae[H-1]} + 1) >= outShape[${H} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${ae[H-2]} + 1) >= ${this.outputShape[H-2]};\n            bool nextColOutOfBounds =\n              (${ae[H-1]} + 1) >= ${this.outputShape[H-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${b}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${Q}\n\n        setOutput(result);\n      }\n    `}}function Wr(C){const{inputs:b,backend:_}=C,{x:S}=b;return _.incRef(S.dataId),{dataId:S.dataId,shape:S.shape,dtype:S.dtype}}const Mo={kernelName:y.iJz,backendName:"webgl",kernelFunc:Wr};function Eo(C){const{inputs:b,backend:_}=C,{real:S,imag:k}=b,H=_.makeTensorInfo(S.shape,"complex64"),Q=_.texData.get(H.dataId),ue=Wr({inputs:{x:S},backend:_}),ae=Wr({inputs:{x:k},backend:_});return Q.complexTensorInfos={real:ue,imag:ae},H}const Ol={kernelName:y.Zz9,backendName:"webgl",kernelFunc:Eo},ln="return (a < 0.) ? b * a : a;",ei="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Nc={kernelName:y.J$2,backendName:"webgl",kernelFunc:function ua(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{alpha:H}=S,Q=_.makeTensorInfo([],"float32",y.D5U.createScalarValue(H,"float32")),ue=(0,y.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ws(ei,k.shape,Q.shape):new yc(ln,k.shape,Q.shape),ae=_.runWebGLProgram(ue,[k,Q],"float32");return _.disposeIntermediateTensorInfo(Q),ae}},Mc="return (a < 0.) ? b * a : a;",Ur="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",wd={kernelName:y.o0g,backendName:"webgl",kernelFunc:function wl(C){const{inputs:b,backend:_}=C,{x:S,alpha:k}=b,H=(0,y.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ws(Ur,S.shape,k.shape):new yc(Mc,S.shape,k.shape);return _.runWebGLProgram(H,[S,k],"float32")}},Do="if (isnan(x)) return x;";function ks({opSnippet:C,packedOpSnippet:b,cpuKernelImpl:_,dtype:S}){return({inputs:k,backend:H})=>{const{x:Q}=k,ue=H,ae=S||Q.dtype;if(ue.shouldExecuteOnCPU([Q])&&null!=_){const Je=ue.texData.get(Q.dataId),rt=_(Je.values,ae);return ue.makeTensorInfo(Q.shape,ae,rt)}let Ne;return Ne=(0,y.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=b?new zr(Q.shape,b):new z(Q.shape,C),ue.runWebGLProgram(Ne,[Q],ae)}}function Zo({opSnippet:C,packedOpSnippet:b,checkOutOfBounds:_=!1,supportsComplex:S=!1,cpuKernelImpl:k,dtype:H}){return({inputs:Q,backend:ue})=>{const{a:ae,b:Se}=Q,Ne=ue;if(S&&"complex64"===ae.dtype){const Ot=Ne.texData.get(ae.dataId),Kt=Ne.texData.get(Se.dataId),[tn,Zt]=[[Ot.complexTensorInfos.real,Kt.complexTensorInfos.real],[Ot.complexTensorInfos.imag,Kt.complexTensorInfos.imag]].map(ts=>{const[us,Us]=ts,_i={dataId:us.dataId,dtype:us.dtype,shape:ae.shape},ii={dataId:Us.dataId,dtype:Us.dtype,shape:Se.shape},Sr=new yc(C,ae.shape,Se.shape);return Ne.runWebGLProgram(Sr,[_i,ii],(0,y.x8V)(us.dtype,Us.dtype))}),hn=Eo({inputs:{real:tn,imag:Zt},backend:Ne});return Ne.disposeIntermediateTensorInfo(tn),Ne.disposeIntermediateTensorInfo(Zt),hn}const Je=H||(0,y.x8V)(ae.dtype,Se.dtype);if(("string"===ae.dtype||"string"===Se.dtype||Ne.shouldExecuteOnCPU([ae,Se]))&&null!=k){const Ot=Ne.texData.get(ae.dataId).values,Kt=Ne.texData.get(Se.dataId).values,tn="string"===ae.dtype?y.backend_util.fromUint8ToStringArray(Ot):Ot,Zt="string"===ae.dtype?y.backend_util.fromUint8ToStringArray(Kt):Kt,[hn,ts]=k(ae.shape,Se.shape,tn,Zt,Je),us=Ne.makeTensorInfo(ts,Je);return Ne.texData.get(us.dataId).values=hn,us}let ft;return ft=(0,y.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=b?new Ws(b,ae.shape,Se.shape,_):new yc(C,ae.shape,Se.shape),Ne.runWebGLProgram(ft,[ae,Se],Je)}}function Me(C,b=!1){if("linear"===C)return b?zn:Pe;if("relu"===C)return b?ur:Wt;if("elu"===C)return b?Bs:mt;if("relu6"===C)return b?Rs:mn;if("prelu"===C)return b?Ur:Mc;if("leakyrelu"===C)return b?ei:ln;if("sigmoid"===C)return b?Or:$n;throw new Error(`Activation ${C} has not been implemented for the WebGL backend.`)}class ge{constructor(b,_,S,k=!1,H=!1,Q=!1,ue=null,ae=!1,Se=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S,this.enableShapeUniforms=ki(this.outputShape.length);const Je=Math.ceil((k?b[1]:b[2])/2),rt=k?"i * 2, rc.y":"rc.y, i * 2",ft=H?"rc.z, i * 2":"i * 2, rc.z",Ot=k?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],Kt=H?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let tn="",Zt="";ue&&(tn=ae?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${ue}\n        }`:Se?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${ue}\n        }`:`vec4 activation(vec4 x) {\n          ${ue}\n        }`,Zt="result = activation(result);");const hn=Q?"result += getBiasAtOutCoords();":"";Q&&this.variableNames.push("bias"),ae&&this.variableNames.push("preluActivationWeights"),Se&&this.variableNames.push("leakyreluAlpha");let ts="rc.x",us="rc.x";b[0]<_[0]?ts=`imod(rc.x, ${b[0]})`:_[0]<b[0]&&(us=`imod(rc.x, ${_[0]})`),this.userCode=`\n      ${tn}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${Je}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${ts};\n        int batchB = ${us};\n        for (int i = 0; i < ${Je}; i++) {\n          vec4 a = getMatrixA(batchA, ${rt});\n          vec4 b = getMatrixB(batchB, ${ft});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${Ot[0]} * ${Kt[0]});\n          result += (${Ot[1]} * ${Kt[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${hn}\n\n        ${Zt}\n\n        setOutput(result);\n      }\n    `}}const ke={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Ke{constructor(b,_,S){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=y.backend_util.assertAndGetBroadcastShape(_,S),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${b}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const dt="return a * b;";function $t(C){const{inputs:b,backend:_}=C,{a:S,b:k}=b,H=y.backend_util.upcastType(S.dtype,k.dtype);if("complex64"===S.dtype){const ue=_.texData.get(S.dataId),ae=_.texData.get(k.dataId),Se=new Ke(ke.REAL,S.shape,k.shape),Ne=new Ke(ke.IMAG,S.shape,k.shape),Je=[{dataId:ue.complexTensorInfos.real.dataId,dtype:ue.complexTensorInfos.real.dtype,shape:S.shape},{dataId:ue.complexTensorInfos.imag.dataId,dtype:ue.complexTensorInfos.imag.dtype,shape:S.shape},{dataId:ae.complexTensorInfos.real.dataId,dtype:ae.complexTensorInfos.real.dtype,shape:k.shape},{dataId:ae.complexTensorInfos.imag.dataId,dtype:ae.complexTensorInfos.imag.dtype,shape:k.shape}],rt=_.runWebGLProgram(Se,Je,"float32"),ft=_.runWebGLProgram(Ne,Je,"float32"),Ot=Eo({inputs:{real:rt,imag:ft},backend:_});return _.disposeIntermediateTensorInfo(rt),_.disposeIntermediateTensorInfo(ft),Ot}if(_.shouldExecuteOnCPU([S,k])){const ue=_.texData.get(S.dataId),ae=_.texData.get(k.dataId),[Se,Ne]=ve(S.shape,k.shape,ue.values,ae.values,H),Je=_.makeTensorInfo(Ne,H);return _.texData.get(Je.dataId).values=Se,Je}let Q;return Q=(0,y.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ws(dt,S.shape,k.shape):new yc(dt,S.shape,k.shape),_.runWebGLProgram(Q,[S,k],H)}const dn={kernelName:y.wYn,backendName:"webgl",kernelFunc:$t};function en(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{shape:H}=S,Q=_,ue=y.D5U.sizeFromShape(k.shape),ae=y.D5U.inferFromImplicitShape(H,ue),Se=y.D5U.sizeFromShape(ae);y.D5U.assert(ue===Se,()=>`The new shape (${ae}) has ${Se} elements and the old shape (${k.shape}) has ${ue} elements. The new shape and old shape must have the same number of elements.`);const Ne=Q.texData.get(k.dataId);return!Ne.isPacked||xa(k.shape,ae)||null!==Ne.texture&&xa(Ne.shape,ae)?(Q.incRef(k.dataId),{dataId:k.dataId,shape:ae,dtype:k.dtype}):function Sn(C,b,_){const S=[$r(C.shape),...eo(C.shape)],k={dtype:C.dtype,shape:S,dataId:C.dataId},H=[$r(b),...eo(b)],Q=new kl(H,S),Se=_.runWebGLProgram(Q,[k],C.dtype,[S],!0);return{dataId:Se.dataId,shape:b,dtype:Se.dtype}}(k,ae,Q)}const re={kernelName:y.HZH,backendName:"webgl",kernelFunc:en};class xe{constructor(b,_){this.variableNames=["x"];const{windowSize:S,batchSize:k,inSize:H,outSize:Q}=b;this.outputShape=[k,Q];const ue=4*Math.floor(S/4),ae=S%4;let Se="sumValue += dot(values, ones);";if(null!=_){const Je=1/_;Se=`sumValue += dot(values * ${y.D5U.isInt(Je)?Je.toPrecision(2):Je}, ones);`}let Ne="";H%S>0&&(Ne=`\n        if (inIdx < 0 || inIdx >= ${H}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${Ne}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${S};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${ue}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${Se}\n        }\n\n        int inIdx = inOffset + ${ue};\n        if (${1===ae}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${Se}\n        } else if (${2===ae}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${Se}\n        } else if (${3===ae}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${Se}\n        }\n        setOutput(sumValue);\n      }\n    `}}class ee{constructor(b,_){this.variableNames=["x"];const{windowSize:S,batchSize:k,inSize:H,outSize:Q}=b;this.outputShape=[k,Q];let ue="0.0",ae="";"prod"===_?ue="1.0":"min"===_?(ue="1.0 / 1e-20",ae="min"):"max"===_&&(ue="-1.0 / 1e-20",ae="max");let Se=`${_}(${_}(${_}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===_?Se="sumValue":"prod"===_?Se="prodValue":"all"===_?Se="allValue":"any"===_&&(Se="anyValue");const Ne=4*Math.floor(S/4),Je=S%4;let rt=`\n      if (${"sum"===_}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===_}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${ae}(values, minMaxValue);\n        if (${"min"===_} || ${"max"===_}) {\n          minMaxValue = ${ae}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,ft="vec4";"all"===_?(ue="1.0",rt="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",ft="bvec4"):"any"===_&&(ue="0.0",rt="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",ft="bvec4");let Ot="";H%S>0&&(Ot=`\n        if (inIdx < 0 || inIdx >= ${H}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${ue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${Ot}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${S};\n\n        vec4 minMaxValue = vec4(${ue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${Ne}; i += 4) {\n          int inIdx = inOffset + i;\n          ${ft} values = ${ft}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${rt}\n        }\n\n        int inIdx = inOffset + ${Ne};\n        if (${1===Je}) {\n          ${ft} values = ${ft}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${rt}\n        } else if (${2===Je}) {\n          ${ft} values = ${ft}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${rt}\n        } else if (${3===Je}) {\n          ${ft} values = ${ft}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${rt}\n        }\n        setOutput(${Se});\n      }\n    `}}function Fe(C,b,_,S){const k=function me(C){const b=[];for(;0===b.length||1!==b[b.length-1].outSize;){const _=b.length?b[b.length-1].outSize:C[1],S=y.backend_util.computeOptimalWindowSize(_);b.push({inSize:_,windowSize:S,outSize:Math.ceil(_/S)})}return b}(C.shape);let H=C;for(let Q=0;Q<k.length;Q++){const{inSize:ue,windowSize:ae,outSize:Se}=k[Q];let Ne,Je;Ne="mean"===_?0===Q?new xe({windowSize:ae,inSize:ue,batchSize:C.shape[0],outSize:Se},ue):new xe({windowSize:ae,inSize:ue,batchSize:C.shape[0],outSize:Se}):new ee({windowSize:ae,inSize:ue,batchSize:C.shape[0],outSize:Se},_),Je=H,H=S.runWebGLProgram(Ne,[H],b),Je.dataId!==C.dataId&&S.disposeIntermediateTensorInfo(Je)}return H}class gt{constructor(b,_){this.variableNames=["A"];const S=new Array(b.length);for(let Q=0;Q<S.length;Q++)S[Q]=b[_[Q]];this.outputShape=S,this.rank=S.length;const k=mi(this.rank),H=function At(C){const b=C.length;if(b>6)throw Error(`Transpose for rank ${b} is not yet supported`);const _=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],S=new Array(b);for(let k=0;k<C.length;k++)S[C[k]]=_[k];return S.join()}(_);this.userCode=`\n    void main() {\n      ${k} resRC = getOutputCoords();\n      setOutput(getA(${H}));\n    }\n    `}}class zt{constructor(b,_){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const S=new Array(b.length);for(let Ne=0;Ne<S.length;Ne++)S[Ne]=b[_[Ne]];if(this.outputShape=S,this.rank=S.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const k=mi(this.rank),H=$a("rc",this.rank),Q=new Array(this.rank);for(let Ne=0;Ne<_.length;Ne++)Q[_[Ne]]=H[Ne];const ue=`vec2(${Q.slice(-2).join()})`,ae=`++${H[this.rank-1]} < ${S[this.rank-1]}`,Se=`getChannel(getA(${Q.join()}), ${ue})`;this.userCode=`\n    void main() {\n      ${k} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${Se};\n      if(${ae}) {\n        result[1] = ${Se};\n      }\n      --${H[this.rank-1]};\n      if(++${H[this.rank-2]} < ${S[this.rank-2]}) {\n        result[2] = ${Se};\n        if(${ae}) {\n          result[3] = ${Se};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Pn(C,b,_){const S=(0,y.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zt(C.shape,b):new gt(C.shape,b);return _.runWebGLProgram(S,[C],C.dtype)}function Kn(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H,keepDims:Q}=S;return function On(C,b,_,S){const H=C.shape.length,Q=y.D5U.parseAxisParam(b,C.shape);let ue=Q;const ae=y.backend_util.getAxesPermutation(ue,H),Se=null!=ae;let Ne=C;Se&&(Ne=Pn(C,ae,S),ue=y.backend_util.getInnerMostAxes(ue.length,H)),y.backend_util.assertAxesAreInnerMostDims("sum",ue,H);const[Je,rt]=y.backend_util.computeOutAndReduceShapes(Ne.shape,ue);let ft=Je;_&&(ft=y.backend_util.expandShapeToKeepDim(Je,Q));const Ot=y.D5U.sizeFromShape(rt),Zt=en({inputs:{x:Ne},attrs:{shape:[y.D5U.sizeFromShape(C.shape)/Ot,Ot]},backend:S}),ts=Fe(Zt,(0,y.z4k)(C.dtype),"sum",S),us=en({inputs:{x:ts},attrs:{shape:ft},backend:S});return S.disposeIntermediateTensorInfo(Zt),S.disposeIntermediateTensorInfo(ts),Se&&S.disposeIntermediateTensorInfo(Ne),us}(k,H,Q,_)}const Ln={kernelName:y.GBy,backendName:"webgl",kernelFunc:Kn};function An(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{perm:H}=S,Q=_,ae=new Array(k.shape.length);for(let Ne=0;Ne<ae.length;Ne++)ae[Ne]=k.shape[H[Ne]];let Se;if(Q.shouldExecuteOnCPU([k])){const Je=Q.texData.get(k.dataId).values,rt=Bo(Je,k.shape,k.dtype,H,ae);Se=Q.makeTensorInfo(ae,k.dtype),Q.texData.get(Se.dataId).values=rt}else Se=Pn(k,H,Q);return Se}const vs={kernelName:y.G3Y,backendName:"webgl",kernelFunc:An},ir=1e3;function Er({a:C,b,transposeA:_,transposeB:S,backend:k,bias:H=null,preluActivationWeights:Q=null,leakyreluAlpha:ue=0,activation:ae=null}){const Se=C.shape.length,Ne=b.shape.length,Je=_?C.shape[Se-2]:C.shape[Se-1],rt=S?b.shape[Ne-1]:b.shape[Ne-2],ft=_?C.shape[Se-1]:C.shape[Se-2],Ot=S?b.shape[Ne-2]:b.shape[Ne-1],Kt=C.shape.slice(0,-2),tn=b.shape.slice(0,-2),Zt=y.D5U.sizeFromShape(Kt),hn=y.D5U.sizeFromShape(tn),us=y.Jyw.assertAndGetBroadcastShape(C.shape.slice(0,-2),b.shape.slice(0,-2)).concat([ft,Ot]);y.D5U.assert(Je===rt,()=>`Error in matMul: inner shapes (${Je}) and (${rt}) of Tensors with shapes ${C.shape} and ${b.shape} and transposeA=${_} and transposeB=${S} must match.`);const Us=_?[Zt,Je,ft]:[Zt,ft,Je],_i=S?[hn,Ot,rt]:[hn,rt,Ot],ii=en({inputs:{x:C},backend:k,attrs:{shape:Us}}),Sr=en({inputs:{x:b},backend:k,attrs:{shape:_i}}),vo=[ii,Sr],Ti=Math.max(Zt,hn),Aa=_?ii.shape[1]:ii.shape[2],ql=null!=H,cd=null!=Q,$u="leakyrelu"===ae,Bu=null!=ae?Me(ae,!0):null;let Zu;if((1===ft||1===Ot)&&Aa>ir&&!1===(ql||cd||$u||null!=Bu)){let ep=ii,Vu=Sr;_&&(ep=An({inputs:{x:ii},backend:k,attrs:{perm:[0,2,1]}}),vo.push(ep)),S&&(Vu=An({inputs:{x:Sr},backend:k,attrs:{perm:[0,2,1]}}),vo.push(Vu));const xm=1===Ot;let tp=ep;1!==Ot&&(tp=en({inputs:{x:ep},backend:k,attrs:{shape:[Ti,Aa,1]}}),vo.push(tp));const th=1===Ot?2:1;let np=Vu;xm&&(np=en({inputs:{x:Vu},backend:k,attrs:{shape:[Ti,1,Aa]}}),vo.push(np));const Sv=$t({inputs:{a:tp,b:np},backend:k});Zu=Kn({inputs:{x:Sv},backend:k,attrs:{axis:th,keepDims:!0}}),vo.push(Sv)}else{const ep=(0,y.x8V)(C.dtype,b.dtype),Vu=new ge(Us,_i,[Ti,ft,Ot],_,S,ql,Bu,cd,$u),yr=[ii,Sr];if(null!=H&&yr.push(H),cd&&yr.push(Q),$u){const xm=k.makeTensorInfo([],"float32",y.D5U.createScalarValue(ue,"float32"));yr.push(xm),vo.push(xm)}Zu=k.runWebGLProgram(Vu,yr,ep)}const lc=en({inputs:{x:Zu},backend:k,attrs:{shape:us}});vo.push(Zu);for(const ep of vo)k.disposeIntermediateTensorInfo(ep);return lc}const So={kernelName:y.usg,backendName:"webgl",kernelFunc:function gi(C){const{inputs:b,backend:_,attrs:S}=C,{a:k,b:H,bias:Q,preluActivationWeights:ue}=b,{transposeA:ae,transposeB:Se,activation:Ne,leakyreluAlpha:Je}=S;return Er({a:k,b:H,transposeA:ae,transposeB:Se,backend:_,bias:Q,preluActivationWeights:ue,leakyreluAlpha:Je,activation:Ne})}},vc="return abs(x);",Qo={kernelName:y.SYM,backendName:"webgl",kernelFunc:function Nr(C){const{inputs:b,backend:_}=C,{x:S}=b;if(_.shouldExecuteOnCPU([S])&&"complex64"!==S.dtype){const H=_.texData.get(S.dataId),Q=Qs(H.values);return _.makeTensorInfo(S.shape,S.dtype,Q)}let k;return k=(0,y.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new zr(S.shape,vc):new z(S.shape,vc),_.runWebGLProgram(k,[S],S.dtype)}},Rl=ks({opSnippet:pe+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),cl={kernelName:y.VGw,backendName:"webgl",kernelFunc:Rl},Dc=ks({opSnippet:pe+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Ud={kernelName:y.SpW,backendName:"webgl",kernelFunc:Dc},$c="return a + b;",Mh=Zo({opSnippet:$c,packedOpSnippet:$c,supportsComplex:!0,cpuKernelImpl:Is}),Vf={kernelName:y.mm_,backendName:"webgl",kernelFunc:Mh};class Uf{constructor(b,_){this.outputShape=[],this.outputShape=b,this.variableNames=_.map((H,Q)=>`T${Q}`);const S=[];this.variableNames.forEach(H=>{S.push(`float v${H} = get${H}AtOutCoords();`)});const k=this.variableNames.map(H=>`v${H}`).join(" + ");this.userCode=`\n      void main() {\n        ${S.join("\n        ")}\n\n        float result = ${k};\n        setOutput(result);\n      }\n    `}}class Km{constructor(b,_){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=b,this.variableNames=_.map((H,Q)=>`T${Q}`);const S=[];this.variableNames.forEach(H=>{S.push(`vec4 v${H} = get${H}AtOutCoords();`)});const k=this.variableNames.map(H=>`v${H}`).join(" + ");this.userCode=`\n      void main() {\n        ${S.join("\n        ")}\n\n        vec4 result = ${k};\n        setOutput(result);\n      }\n    `}}const Zp={kernelName:y.Xze,backendName:"webgl",kernelFunc:function Ph(C){const{inputs:b,backend:_}=C,S=b;if(1===S.length)return Wr({inputs:{x:S[0]},backend:_});if(S.length>(0,y.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const ae=Math.floor(S.length/2),Se=Ph({inputs:S.slice(0,ae),backend:_}),Ne=Ph({inputs:S.slice(ae),backend:_});return Ph({inputs:[Se,Ne],backend:_})}const k=S.map(ae=>ae.dtype).reduce((ae,Se)=>(0,y.x8V)(ae,Se)),H=S.map(ae=>ae.shape),ue=(0,y.OBj)().getBool("WEBGL_PACK")?new Km(S[0].shape,H):new Uf(S[0].shape,H);return _.runWebGLProgram(ue,S,k)}},dh={kernelName:y.oT6,backendName:"webgl",kernelFunc:function Sc(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H,keepDims:Q}=S,ue=k.shape.length,ae=y.D5U.parseAxisParam(H,k.shape);let Se=ae;const Ne=y.backend_util.getAxesPermutation(Se,ue);let Je=k;null!=Ne&&(Je=An({inputs:{x:k},backend:_,attrs:{perm:Ne}}),Se=y.backend_util.getInnerMostAxes(Se.length,ue)),y.backend_util.assertAxesAreInnerMostDims("all",Se,ue);const[rt,ft]=y.backend_util.computeOutAndReduceShapes(Je.shape,Se),Kt=en({inputs:{x:Je},backend:_,attrs:{shape:[-1,y.D5U.sizeFromShape(ft)]}}),tn=Fe(Kt,Kt.dtype,"all",_);let Zt;return Zt=en(Q?{inputs:{x:tn},backend:_,attrs:{shape:y.backend_util.expandShapeToKeepDim(rt,ae)}}:{inputs:{x:tn},backend:_,attrs:{shape:rt}}),_.disposeIntermediateTensorInfo(Kt),_.disposeIntermediateTensorInfo(tn),null!=Ne&&_.disposeIntermediateTensorInfo(Je),Zt}},Qp={kernelName:y.IKK,backendName:"webgl",kernelFunc:function Nu(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H,keepDims:Q}=S,ue=k.shape.length,ae=y.D5U.parseAxisParam(H,k.shape);let Se=ae;const Ne=y.backend_util.getAxesPermutation(Se,ue);let Je=k;null!=Ne&&(Je=An({inputs:{x:k},backend:_,attrs:{perm:Ne}}),Se=y.backend_util.getInnerMostAxes(Se.length,ue)),y.backend_util.assertAxesAreInnerMostDims("any",Se,ue);const[rt,ft]=y.backend_util.computeOutAndReduceShapes(Je.shape,Se),Kt=en({inputs:{x:Je},backend:_,attrs:{shape:[-1,y.D5U.sizeFromShape(ft)]}}),tn=Fe(Kt,Kt.dtype,"any",_);let Zt;return Zt=en(Q?{inputs:{x:tn},backend:_,attrs:{shape:y.backend_util.expandShapeToKeepDim(rt,ae)}}:{inputs:{x:tn},backend:_,attrs:{shape:rt}}),_.disposeIntermediateTensorInfo(Kt),_.disposeIntermediateTensorInfo(tn),null!=Ne&&_.disposeIntermediateTensorInfo(Je),Zt}};class Hu{constructor(b,_,S){this.variableNames=["A"];const{windowSize:k,batchSize:H,outSize:Q}=b;S||this.variableNames.push("bestIndicesA"),this.outputShape=[H,Q],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${k};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${k}; i++) {\n          int inIdx = ${S?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===_?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Cd{constructor(b,_,S,k){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y.D5U.assert(b.length>2,()=>`Packed arg${S.charAt(0).toUpperCase()+S.slice(1)} supports only inputs with rank above 2.`);const Q=Math.ceil(b[b.length-1]/_);this.outputShape=b.slice(0,-1),Q>1&&this.outputShape.push(Q),k||this.variableNames.push("bestIndicesA");const ue=this.outputShape,ae=ue.length,Se=mi(ae),Ne=Gi("coords",ae);let Je,rt;if(1===Q){rt=ae+1;const Sr=mi(rt);Je=`\n        ${Sr} sourceLocR = ${Sr}(${Ne.join()}, 0);\n        ++${Ne[ae-1]};\n        ${Sr} sourceLocG = ${Sr}(${Ne.join()}, 0);\n        ++${Ne[ae-2]};\n        ${Sr} sourceLocA = ${Sr}(${Ne.join()}, 0);\n        --${Ne[ae-1]};\n        ${Sr} sourceLocB = ${Sr}(${Ne.join()}, 0);\n        --${Ne[ae-2]};`}else rt=ae,Je=`\n        ${Se} sourceLocR = coords;\n        ++${Ne[ae-1]};\n        ${Se} sourceLocG = coords;\n        ++${Ne[ae-2]};\n        ${Se} sourceLocA = coords;\n        --${Ne[ae-1]};\n        ${Se} sourceLocB = coords;\n        --${Ne[ae-2]};`;const ft=["x","y","z","w","u","v"].slice(0,rt),Ot="."+ft[rt-1],Kt=ft.map(Sr=>"int "+Sr),tn=Gi("sourceLocR",rt-1).concat("inIdx.r"),Zt=Gi("sourceLocG",rt-1).concat("inIdx.g"),hn=Gi("sourceLocB",rt-1).concat("inIdx.b"),ts=Gi("sourceLocA",rt-1).concat("inIdx.a"),us="max"===S?"greaterThan":"lessThan",Us=k?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${tn.join()}),\n                             getBestIndicesAChannel(${Zt.join()}),\n                             getBestIndicesAChannel(${hn.join()}),\n                             getBestIndicesAChannel(${ts.join()})));`,_i=`vec4(\n            getAChannel(${tn.join()}),\n            hasNextCol ? getAChannel(${Zt.join()}) : 0.,\n            hasNextRow ? getAChannel(${hn.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${ts.join()}) : 0.)`,ii=k?"":`\n      float getBestIndicesAChannel(${Kt.join()}) {\n        return getChannel(getBestIndicesA(${ft.join()}),\n                                          vec2(${ft.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${Kt.join()}) {\n        return getChannel(getA(${ft.join()}),\n                               vec2(${ft.slice(-2).join()}));\n      }\n      ${ii}\n      void main() {\n        ${Se} coords = getOutputCoords();\n        bool hasNextCol = ${Ne[ae-1]} < ${ue[ae-1]-1};\n        bool hasNextRow = ${Ne[ae-2]} < ${ue[ae-2]-1};\n        ${Je}\n        ivec4 srcIdx = ivec4(sourceLocR${Ot}, sourceLocG${Ot},\n          sourceLocB${Ot}, sourceLocA${Ot}) * ${_};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${_i};\n\n        for (int i = 0; i < ${_}; i++) {\n          inIdx = srcIdx;\n          ${Us}\n          vec4 candidate = ${_i};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${us}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Fh(C,b,_,S=null){let k=b.shape[0],H=b.shape[1];null!=S&&(k=S.shape[0],H=S.shape[1]);const Q=y.backend_util.computeOptimalWindowSize(H),ue={windowSize:Q,inSize:H,batchSize:k,outSize:Math.ceil(H/Q)},ae=new Hu(ue,_,null==S),Se=[b];null!=S&&Se.push(S);const Ne=C.runWebGLProgram(ae,Se,"int32");if(1===Ne.shape[1])return Ne;const Je=Fh(C,b,_,Ne);return C.disposeIntermediateTensorInfo(Ne),Je}function Jc(C,b,_,S=null){const k=null!=S?S.shape:b.shape,Q=y.backend_util.computeOptimalWindowSize(k[k.length-1]),ue=new Cd(k,Q,_,null==S),Se=C.runWebGLProgram(ue,null==S?[b]:[b,S],"int32");if(Se.shape.length===b.shape.length){const Ne=Jc(C,b,_,Se);return C.disposeIntermediateTensorInfo(Se),Ne}return Se}function Ya(C,b,_,S){const k=[_];if(y.backend_util.assertAxesAreInnerMostDims("arg"+S.charAt(0).toUpperCase()+S.slice(1),k,b.shape.length),!(0,y.OBj)().getBool("WEBGL_PACK_REDUCE")||b.shape.length<=2){const H=[],Q=C.texData.get(b.dataId);let ae=b;null!==Q&&Q.isPacked&&(ae=C.unpackTensor(b),H.push(ae));const[Se,Ne]=y.backend_util.computeOutAndReduceShapes(ae.shape,k),Je=y.D5U.sizeFromShape(Ne),rt=en({inputs:{x:ae},backend:C,attrs:{shape:[-1,Je]}});H.push(rt);const ft=Fh(C,rt,S);H.push(ft);const Ot=en({inputs:{x:ft},backend:C,attrs:{shape:Se}});return H.forEach(Kt=>C.disposeIntermediateTensorInfo(Kt)),Ot}return Jc(C,b,S)}const du={kernelName:y.sJF,backendName:"webgl",kernelFunc:function Ba(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H}=S;let Q=y.D5U.parseAxisParam(H,k.shape);const ue=y.backend_util.getAxesPermutation(Q,k.shape.length);let ae=k;const Se=[];null!=ue&&(ae=An({inputs:{x:k},backend:_,attrs:{perm:ue}}),Se.push(ae),Q=y.backend_util.getInnerMostAxes(Q.length,ae.shape.length)),y.backend_util.assertAxesAreInnerMostDims("argMax",[Q[0]],ae.shape.length);const Ne=Ya(_,ae,Q[0],"max");return Se.forEach(Je=>_.disposeIntermediateTensorInfo(Je)),Ne}},hh={kernelName:y.aJk,backendName:"webgl",kernelFunc:function Bc(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H}=S;let Q=y.D5U.parseAxisParam(H,k.shape);const ue=y.backend_util.getAxesPermutation(Q,k.shape.length);let ae=k;const Se=[];null!=ue&&(ae=An({inputs:{x:k},backend:_,attrs:{perm:ue}}),Se.push(ae),Q=y.backend_util.getInnerMostAxes(Q.length,ae.shape.length)),y.backend_util.assertAxesAreInnerMostDims("argMin",[Q[0]],ae.shape.length);const Ne=Ya(_,ae,Q[0],"min");return Se.forEach(Je=>_.disposeIntermediateTensorInfo(Je)),Ne}},zd=ks({opSnippet:pe+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Jp={kernelName:y.M2y,backendName:"webgl",kernelFunc:zd},qc=ks({opSnippet:pe+"return log(x + sqrt(x * x + 1.0));"}),od={kernelName:y.qw7,backendName:"webgl",kernelFunc:qc},Lh=ks({opSnippet:pe+"\n  return atan(x);\n"}),Wd={kernelName:y.jMg,backendName:"webgl",kernelFunc:Lh},ju=Zo({opSnippet:Ou+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Lc+"\n  return result;\n"}),$h={kernelName:y.QCc,backendName:"webgl",kernelFunc:ju},ph=ks({opSnippet:pe+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Hd={kernelName:y.Oyi,backendName:"webgl",kernelFunc:ph};class bc{constructor(b,_,S,k=!1,H=!1){if(this.variableNames=["x"],"avg"===_&&S)throw new Error("Cannot compute positions for average pool.");const Q=b.filterWidth,ue=b.strideHeight,ae=b.strideWidth,Se=b.dilationHeight,Ne=b.dilationWidth,Je=b.effectiveFilterHeight,rt=b.effectiveFilterWidth,ft=b.padInfo.top,Ot=b.padInfo.left;this.outputShape=b.outShape;const Kt="avg"===_;let hn="0.0";if(Kt||(hn="-1.0 / 1e-20"),S)return void(this.userCode=`\n        const ivec2 strides = ivec2(${ue}, ${ae});\n        const ivec2 pads = ivec2(${ft}, ${Ot});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${Je};\n              wR += ${Se}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${b.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${rt};\n                wC += ${Ne}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${b.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${k?H?`((batch  * ${b.inHeight} + xR) * ${b.inWidth} + xC) * ${b.inChannels} + d`:`(xR * ${b.inWidth} + xC) * ${b.inChannels} + d`:`wR * ${rt} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let us=`${_}(${_}(${_}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===_&&(us="avgValue / max(count, 1.0)");const Us=4*Math.floor(Q/4),_i=Q%4,ii=`\n      if (${Kt}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${ue}, ${ae});\n      const ivec2 pads = ivec2(${ft}, ${Ot});\n      const float initializationValue = ${hn};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${b.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${hn});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${Je};\n            wR += ${Se}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${b.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${Us}; wC += 4) {\n            int xC = xCCorner + wC * ${Ne};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${Ne}, d),\n              getValue(batch, xR, xC + 2 * ${Ne}, d),\n              getValue(batch, xR, xC + 3 * ${Ne}, d)\n            );\n\n            ${ii}\n          }\n\n          int xC = xCCorner + ${Us};\n          if (${1===_i}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${ii}\n          } else if (${2===_i}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${Ne}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${ii}\n          } else if (${3===_i}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${Ne}, d),\n              getValue(batch, xR, xC + 2 * ${Ne}, d),\n              initializationValue\n            );\n\n            ${ii}\n          }\n        }\n        setOutput(${us});\n      }\n    `}}class _p{constructor(b,_,S,k=!1,H=!1){if(this.variableNames=["x"],"avg"===_&&S)throw new Error("Cannot compute positions for average pool.");const Q=b.filterWidth,ue=b.strideDepth,ae=b.strideHeight,Se=b.strideWidth,Ne=b.dilationDepth,Je=b.dilationHeight,rt=b.dilationWidth,ft=b.effectiveFilterDepth,Ot=b.effectiveFilterHeight,Kt=b.effectiveFilterWidth,tn=b.padInfo.front,Zt=b.padInfo.top,hn=b.padInfo.left;this.outputShape=b.outShape;const ts="avg"===_;let us="0.0";if(ts||(us="-1.0 / 1e-20"),S)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${ue}, ${ae}, ${Se});\n        const ivec3 pads = ivec3(${tn}, ${Zt}, ${hn});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${ft};\n              wD += ${Ne}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${b.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${Ot};\n                wR += ${Je}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${b.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${Kt};\n                  wC += ${rt}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${b.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${k?H?`(((batch * ${b.inDepth} + xD) * ${b.inHeight} + xR) * ${b.inWidth} + xC) * ${b.inChannels} + ch`:`((xD * ${b.inHeight} + xR) * ${b.inWidth} + xC) * ${b.inChannels} + ch`:`wD * ${Ot} * ${Kt} +\n                      wR * ${Kt} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let _i=`${_}(${_}(${_}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===_&&(_i="avgValue / max(count, 1.0)");const ii=4*Math.floor(Q/4),Sr=Q%4,vo=`\n      if (${ts}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${ue}, ${ae}, ${Se});\n      const ivec3 pads = ivec3(${tn}, ${Zt}, ${hn});\n      const float initializationValue = ${us};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${b.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${us});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${ft};\n            wD += ${Ne}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${b.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${Ot};\n            wR += ${Je}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${b.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${ii}; wC += 4) {\n              int xC = xCCorner + wC * ${rt};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${rt}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${rt}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${rt}, ch)\n              );\n\n              ${vo}\n            }\n\n            int xC = xCCorner + ${ii};\n            if (${1===Sr}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${vo}\n            } else if (${2===Sr}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${rt}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${vo}\n            } else if (${3===Sr}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${rt}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${rt}, ch),\n                initializationValue\n              );\n\n              ${vo}\n            }\n          }\n        }\n        setOutput(${_i});\n      }\n    `}}const Pc={kernelName:y.JhU,backendName:"webgl",kernelFunc:function b_(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b;la(k,"avgPool");const{filterSize:H,strides:Q,pad:ue,dimRoundingMode:ae}=S;y.D5U.assert(y.backend_util.eitherStridesOrDilationsAreOne(Q,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${Q} and dilations '1'`);const Ne=y.backend_util.computePool2DInfo(k.shape,H,Q,1,ue,ae);if(1===Ne.filterWidth&&1===Ne.filterHeight&&y.D5U.arraysEqual(Ne.inShape,Ne.outShape))return Wr({inputs:{x:k},backend:_});const Je=new bc(Ne,"avg",!1);return _.runWebGLProgram(Je,[k],"float32")}},ad={kernelName:y._k9,backendName:"webgl",kernelFunc:function Ed(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{filterSize:H,strides:Q,pad:ue,dimRoundingMode:ae,dataFormat:Se}=S,Je=y.backend_util.computePool3DInfo(k.shape,H,Q,[1,1,1],ue,ae,Se),rt=new _p(Je,"avg",!1);return _.runWebGLProgram(rt,[k],"float32")}};class fh{constructor(b){this.variableNames=["dy"],this.outputShape=b.inShape;const ae=b.effectiveFilterHeight,Se=b.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${ae-1-b.padInfo.top}, ${Se-1-b.padInfo.left});\n      const float avgMultiplier = float(${1/(b.filterHeight*b.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${ae};\n            wR += ${b.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${b.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${b.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${Se};\n            wC+= ${b.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${b.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${b.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Mu{constructor(b){this.variableNames=["dy"],this.outputShape=b.inShape;const Je=b.effectiveFilterDepth,rt=b.effectiveFilterHeight,ft=b.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${Je-1-b.padInfo.front}, ${rt-1-b.padInfo.top}, ${ft-1-b.padInfo.left});\n      const float avgMultiplier = float(${1/(b.filterDepth*b.filterHeight*b.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${Je};\n            wD += ${b.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${b.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${b.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${rt};\n              wR += ${b.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${b.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${b.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${ft};\n                wC += ${b.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${b.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${b.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const jf={kernelName:y.IMb,backendName:"webgl",kernelFunc:function ef(C){const{inputs:b,backend:_,attrs:S}=C,{dy:k,input:H}=b,Q=H,{filterSize:ue,strides:ae,pad:Se,dimRoundingMode:Ne}=S,rt=y.backend_util.computePool3DInfo(Q.shape,ue,ae,[1,1,1],Se,Ne),ft=new Mu(rt);return _.runWebGLProgram(ft,[k],Q.dtype)}},tf={kernelName:y.ROF,backendName:"webgl",kernelFunc:function yp(C){const{inputs:b,backend:_,attrs:S}=C,{dy:k,input:H}=b,Q=H;la([k,H],"avgPoolGrad");const{filterSize:ue,strides:ae,pad:Se}=S,Ne=y.backend_util.computePool2DInfo(Q.shape,ue,ae,1,Se),Je=new fh(Ne);return _.runWebGLProgram(Je,[k],Q.dtype)}},Gf={kernelName:y.XLW,backendName:"webgl",kernelFunc:function jd(C){const{inputs:b,backend:_,attrs:S}=C,{a:k,b:H}=b,{transposeA:Q,transposeB:ue}=S;return Er({a:k,b:H,transposeA:Q,transposeB:ue,backend:_})}};class nf{constructor(b,_,S,k,H,Q){this.outputShape=[],this.variableNames=["x","mean","variance"],y.backend_util.assertAndGetBroadcastShape(b,_),y.backend_util.assertAndGetBroadcastShape(b,S);let ue="0.0";null!=k&&(y.backend_util.assertAndGetBroadcastShape(b,k),this.variableNames.push("offset"),ue="getOffsetAtOutCoords()");let ae="1.0";null!=H&&(y.backend_util.assertAndGetBroadcastShape(b,H),this.variableNames.push("scale"),ae="getScaleAtOutCoords()"),this.outputShape=b,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${ue};\n        float scale = ${ae};\n        float inv = scale * inversesqrt(variance + float(${Q}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class sf{constructor(b,_,S,k,H,Q){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],y.backend_util.assertAndGetBroadcastShape(b,_),y.backend_util.assertAndGetBroadcastShape(b,S);let ue="vec4(0.0)";null!=k&&(y.backend_util.assertAndGetBroadcastShape(b,k),this.variableNames.push("offset"),ue="getOffsetAtOutCoords()");let ae="vec4(1.0)";null!=H&&(y.backend_util.assertAndGetBroadcastShape(b,H),this.variableNames.push("scale"),ae="getScaleAtOutCoords()"),this.outputShape=b,this.userCode=`\n      void main() {\n        vec4 offset = ${ue};\n        vec4 scale = ${ae};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${Q}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const rf={kernelName:y.sHE,backendName:"webgl",kernelFunc:({inputs:C,backend:b,attrs:_})=>{const{x:S,mean:k,variance:H,offset:Q,scale:ue}=C;y.D5U.assert(k.shape.length===H.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.D5U.assert(null==Q||k.shape.length===Q.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.D5U.assert(null==ue||k.shape.length===ue.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:ae}=_;null==ae&&(ae=.001);const Se=[S,k,H];let Ne=null;null!=Q&&(Ne=Q.shape,Se.push(Q));let Je=null;null!=ue&&(Je=ue.shape,Se.push(ue));const rt=(0,y.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new sf(S.shape,k.shape,H.shape,Ne,Je,ae):new nf(S.shape,k.shape,H.shape,Ne,Je,ae);return b.runWebGLProgram(rt,Se,Se[0].dtype)}};class Vc{constructor(b){this.variableNames=["source"],this.outputShape=b,this.rank=b.length;const _=mi(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const S=function bp(C){if(1===C)return"sourceLoc";if(C<=6)return vp.slice(0,C).map(b=>"sourceLoc."+b).join(",");throw Error(`Slicing for rank ${C} is not yet supported`)}(this.rank);let k;k=`\n        ${_} sourceLoc;\n        ${_} coords = getOutputCoords();\n        ${b.map((Q,ue)=>`sourceLoc.${vp[ue]} = start[${ue}] + coords.${vp[ue]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${k}\n        setOutput(getSource(${S}));\n      }\n    `}}const vp=["x","y","z","w","u","v"];class Ia{constructor(b){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=b,this.rank=b.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const _=mi(this.rank),S=Gi("coords",this.rank),k=Gi("sourceLoc",this.rank),H=1===this.rank?"sourceLoc":`vec2(${k.slice(-2).join()})`,Q=`getChannel(getSource(${k.join()}), ${H})`,ue=`\n      result.x = ${Q};\n      if (++${S[this.rank-1]} < ${b[this.rank-1]}) {\n        ++${k[this.rank-1]};\n        result.y = ${Q};\n        --${k[this.rank-1]};\n      }\n    `,ae=1===this.rank?"":`\n      --${S[this.rank-1]};\n      if (++${S[this.rank-2]} < ${b[this.rank-2]}) {\n        ++${k[this.rank-2]};\n        result.z = ${Q};\n        if (++${S[this.rank-1]} < ${b[this.rank-1]}) {\n          ++${k[this.rank-1]};\n          result.w = ${Q};\n        }\n      }\n    `,Se=this.rank<=4?`sourceLoc = coords +\n            ${_}(${b.map((Ne,Je)=>`start[${Je}]`).join()});`:b.map((Ne,Je)=>`${k[Je]} = ${S[Je]} + start[${Je}];`).join("\n");this.userCode=`\n      void main() {\n        ${_} coords = getOutputCoords();\n        ${_} sourceLoc;\n        ${Se}\n        vec4 result = vec4(0.);\n        ${ue}\n        ${ae}\n        setOutput(result);\n      }\n    `}}function Dd(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{begin:H,size:Q}=S,[ue,ae]=y.kuN.parseSliceParams(k,H,Q);if(y.kuN.assertParamsValid(k,ue,ae),0===y.D5U.sizeFromShape(ae))return _.makeTensorInfo(ae,k.dtype,[]);if(_.shouldExecuteOnCPU([k])||"string"===k.dtype){const Je=_.texData.get(k.dataId),rt=As(Je.values,ue,ae,k.shape,k.dtype);return _.makeTensorInfo(ae,k.dtype,rt)}const{isPacked:Se}=_.texData.get(k.dataId),Ne=y.kuN.isSliceContinous(k.shape,ue,ae);if(Se||!Ne){const Je=(0,y.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ia(ae):new Vc(ae);return _.runWebGLProgram(Je,[k],k.dtype,[ue])}return _.uploadToGPU(k.dataId),function xp(C,b,_,S){const k=S.texData.get(C.dataId),H=S.makeTensorInfo(_,C.dtype),Q=S.texData.get(H.dataId);Object.assign(Q,k),Q.refCount=1,Q.shape=_,Q.dtype=C.dtype;let ue=y.kuN.computeFlatOffset(b,y.D5U.computeStrides(C.shape));k.slice&&(ue+=k.slice.flatOffset),Q.slice={flatOffset:ue,origDataId:k.slice&&k.slice.origDataId||C.dataId};const ae=S.dataRefCount.get(Q.slice.origDataId)||1;return S.dataRefCount.set(Q.slice.origDataId,ae+1),H}(k,ue,ae,_)}const af={kernelName:y.p2w,backendName:"webgl",kernelFunc:Dd},lf={kernelName:y.zws,backendName:"webgl",kernelFunc:C=>{const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{blockShape:H,crops:Q}=S;y.D5U.assert(k.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const ue=H.reduce((hn,ts)=>hn*ts),ae=y.backend_util.getReshaped(k.shape,H,ue),Se=y.backend_util.getPermuted(ae.length,H.length),Ne=y.backend_util.getReshapedPermuted(k.shape,H,ue),Je=y.backend_util.getSliceBeginCoords(Q,H.length),rt=y.backend_util.getSliceSize(Ne,Q,H.length),ft=[],Ot=en({inputs:{x:k},backend:_,attrs:{shape:ae}}),Kt=An({inputs:{x:Ot},backend:_,attrs:{perm:Se}}),tn=en({inputs:{x:Kt},backend:_,attrs:{shape:Ne}}),Zt=Dd({inputs:{x:tn},backend:_,attrs:{begin:Je,size:rt}});return ft.push(Ot),ft.push(Kt),ft.push(tn),ft.forEach(hn=>_.disposeIntermediateTensorInfo(hn)),Zt}},mh={kernelName:y.zvY,backendName:"webgl",kernelFunc:function Uc(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,weights:H}=b,{size:Q}=S,ue=_.readSync(k.dataId),ae=_.readSync(H.dataId),Se=lr(ue,ae,H.dtype,H.shape,Q);return _.makeTensorInfo([Q],H.dtype,Se)}},gh={kernelName:y.hCO,backendName:"webgl",kernelFunc:function Bh(C){const{inputs:b,backend:_}=C,{a:S,b:k}=b,H=(0,y.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),Q=(0,y.OBj)().getNumber("WEBGL_VERSION");if(_.shouldExecuteOnCPU([S,k])||1===Q){const ae=_.texData.get(S.dataId).values,Se=_.texData.get(k.dataId).values,[Ne,Je]=Da(S.shape,k.shape,ae,Se,S.dtype),rt=_.makeTensorInfo(Je,S.dtype);return _.texData.get(rt.dataId).values=Ne,rt}let ue;return ue=H?new Ws("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",S.shape,k.shape,!1):new yc("\n  return float(int(a.r) & int(b.r));\n",S.shape,k.shape),_.runWebGLProgram(ue,[S,k],S.dtype)}},_h={kernelName:y.eEB,backendName:"webgl",kernelFunc:function Vo(C){const{inputs:b,backend:_}=C,{s0:S,s1:k}=b,H=_.readSync(S.dataId),Q=_.readSync(k.dataId),ue=y.backend_util.assertAndGetBroadcastShape(Array.from(H),Array.from(Q));return _.makeTensorInfo([ue.length],"int32",Int32Array.from(ue))}},Ic=Zo({opSnippet:"return float(a != b);",cpuKernelImpl:ot,dtype:"bool"}),Va={kernelName:y.yQU,backendName:"webgl",kernelFunc:Ic};function Uo(C){const{inputs:b,backend:_}=C,{input:S}=b;return Wr({inputs:{x:_.texData.get(S.dataId).complexTensorInfos.real},backend:_})}const Xl={kernelName:y.xJR,backendName:"webgl",kernelFunc:Uo},Uh={kernelName:y.RFZ,backendName:"webgl",kernelFunc:function ao(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{dtype:H}=S;if("complex64"===H){if("complex64"===k.dtype)return Wr({inputs:{x:k},backend:_});const Q=y.lls(k.shape),ue=ao({inputs:{x:k},backend:_,attrs:{dtype:"float32"}}),ae=Eo({inputs:{real:ue,imag:Q},backend:_});return Q.dispose(),_.disposeIntermediateTensorInfo(ue),ae}if("complex64"===k.dtype){const Q=Uo({inputs:{input:k},backend:_}),ue=ao({inputs:{x:Q},backend:_,attrs:{dtype:H}});return _.disposeIntermediateTensorInfo(Q),ue}if(!y.D5U.hasEncodingLoss(k.dtype,H)){const Q=Wr({inputs:{x:k},backend:_});return{dataId:Q.dataId,shape:Q.shape,dtype:H}}if(_.shouldExecuteOnCPU([k])){const Q=_.texData.get(k.dataId).values,[ue,ae,Se]=Jt(Q,k.shape,k.dtype,H);return _.makeTensorInfo(ue,ae,Se)}if("int32"===H)return function li(C,b){const _=new z(C.shape,"return float(int(x));"),S=b.runWebGLProgram(_,[C],"int32");return{dataId:S.dataId,shape:S.shape,dtype:S.dtype}}(k,_);if("bool"===H){const Q=_.makeTensorInfo([],"bool",y.D5U.getTypedArrayFromDType("bool",1)),ae=Ic({inputs:{a:k,b:Q},backend:_});return _.disposeIntermediateTensorInfo(Q),ae}throw new Error(`Error in Cast: failed to cast ${k.dtype} to ${H}`)}},Pu="return ceil(x);",pu=ks({opSnippet:Pu,packedOpSnippet:Pu,cpuKernelImpl:ai}),Xf={kernelName:y.gJX,backendName:"webgl",kernelFunc:pu};class Tt{constructor(b){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=b,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class yt{constructor(b){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=b,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const vt={kernelName:y.xnO,backendName:"webgl",kernelFunc:function ht(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{clipValueMin:H,clipValueMax:Q}=S;let ue;return ue=(0,y.OBj)().getBool("WEBGL_PACK_CLIP")?new yt(k.shape):new Tt(k.shape),_.runWebGLProgram(ue,[k],k.dtype,[[H],[Q]])}};class ut{constructor(b){this.variableNames=["real","imag"],this.outputShape=b,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Mt(C,b){return{dataId:b.dataId,dtype:b.dtype,shape:C.shape}}const un={kernelName:y.yj2,backendName:"webgl",kernelFunc:function Vt(C){const{inputs:b,backend:_}=C,{x:S}=b,k=_.texData.get(S.dataId),H=new ut(S.shape),Q=[Mt(S,k.complexTensorInfos.real),Mt(S,k.complexTensorInfos.imag)];return _.runWebGLProgram(H,Q,Q[0].dtype)}};class Rn{constructor(b){this.outputShape=[],this.outputShape=y.backend_util.computeOutShape(b,1),this.variableNames=b.map((Q,ue)=>`T${ue}`);const _=new Array(b.length-1);_[0]=b[0][1];for(let Q=1;Q<_.length;Q++)_[Q]=_[Q-1]+b[Q][1];const S=[`if (yC < ${_[0]}) setOutput(getT0(yR, yC));`];for(let Q=1;Q<_.length;Q++)S.push(`else if (yC < ${_[Q]}) setOutput(getT${Q}(yR, yC-${_[Q-1]}));`);S.push(`else setOutput(getT${_.length}(yR, yC-${_[_.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${S.join("\n        ")}\n      }\n    `}}class Mn{constructor(b,_){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=y.backend_util.computeOutShape(b,_);const S=this.outputShape,k=S.length,H=mi(k),Q=Gi("coords",k),ue=["x","y","z","w","u","v"].slice(0,k);this.variableNames=b.map((Kt,tn)=>`T${tn}`);const ae=new Array(b.length-1);ae[0]=b[0][_];for(let Kt=1;Kt<ae.length;Kt++)ae[Kt]=ae[Kt-1]+b[Kt][_];const Se=ue[_],Ne=ue.slice(-2),Je=ue.join();let rt=`if (${Se} < ${ae[0]}) {\n        return getChannel(\n            getT0(${Je}), vec2(${Ne.join()}));\n        }`;for(let Kt=1;Kt<ae.length;Kt++){const tn=ae[Kt-1];rt+=`\n        if (${Se} < ${ae[Kt]}  && ${Se} >= ${ae[Kt-1]}) {\n          return getChannel(\n            getT${Kt}(${as(ue,Se,tn)}),\n            vec2(${as(Ne,Se,tn)}));\n        }`}const Ot=ae[ae.length-1];rt+=`\n        return getChannel(\n          getT${ae.length}(${as(ue,Se,Ot)}),\n          vec2(${as(Ne,Se,Ot)}));`,this.userCode=`\n      float getValue(${ue.map(Kt=>"int "+Kt)}) {\n        ${rt}\n      }\n\n      void main() {\n        ${H} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${Q}), 0., 0., 0.);\n\n        ${Q[k-1]} = ${Q[k-1]} + 1;\n        if (${Q[k-1]} < ${S[k-1]}) {\n          result.g = getValue(${Q});\n        }\n\n        ${Q[k-2]} = ${Q[k-2]} + 1;\n        if (${Q[k-2]} < ${S[k-2]}) {\n          result.a = getValue(${Q});\n        }\n\n        ${Q[k-1]} = ${Q[k-1]} - 1;\n        if (${Q[k-2]} < ${S[k-2]} &&\n            ${Q[k-1]} < ${S[k-1]}) {\n          result.b = getValue(${Q});\n        }\n        setOutput(result);\n      }\n    `}}function as(C,b,_){const S=C.indexOf(b);return C.map((H,Q)=>Q===S?`${H} - ${_}`:H).join()}function is(C){const{inputs:b,backend:_}=C,{input:S}=b;return Wr({inputs:{x:_.texData.get(S.dataId).complexTensorInfos.imag},backend:_})}const js={kernelName:y.J_u,backendName:"webgl",kernelFunc:is};function pr(C,b,_){const S=C[0].dtype;if("complex64"===S){const ft=C.map(hn=>Uo({inputs:{input:hn},backend:_})),Ot=C.map(hn=>is({inputs:{input:hn},backend:_})),Kt=pr(ft,b,_),tn=pr(Ot,b,_),Zt=Eo({inputs:{real:Kt,imag:tn},backend:_});return ft.forEach(hn=>_.disposeIntermediateTensorInfo(hn)),Ot.forEach(hn=>_.disposeIntermediateTensorInfo(hn)),_.disposeIntermediateTensorInfo(Kt),_.disposeIntermediateTensorInfo(tn),Zt}let k=_.shouldExecuteOnCPU(C);if("string"===S&&(k=!0),k){const ft=C.map(us=>{const _i=[-1,y.D5U.sizeFromShape(us.shape.slice(b))];return en({inputs:{x:us},backend:_,attrs:{shape:_i}})}),Ot=ft.map(us=>({vals:_.readSync(us.dataId),shape:us.shape})),Kt=y.backend_util.computeOutShape(ft.map(us=>us.shape),1),Zt=oc(Ot,Kt,S,1===ft[0].shape[0]),hn=y.backend_util.computeOutShape(C.map(us=>us.shape),b),ts=_.makeTensorInfo(hn,S,Zt);return ft.forEach(us=>_.disposeIntermediateTensorInfo(us)),ts}const H=C.filter(ft=>y.D5U.sizeFromShape(ft.shape)>0),Q=(0,y.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&H[0].shape.length>1;if(1===H.length){const ft=Q?new z(C[0].shape,rn):new zr(C[0].shape,rn);return _.runWebGLProgram(ft,C,S)}const ue=(0,y.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(H.length>ue){const ft=[];for(let Kt=0;Kt<H.length;Kt+=ue){const tn=H.slice(Kt,Kt+ue);ft.push(pr(tn,b,_))}const Ot=pr(ft,b,_);for(const Kt of ft)_.disposeIntermediateTensorInfo(Kt);return Ot}if(Q){const ft=new Mn(H.map(Ot=>Ot.shape),b);return _.runWebGLProgram(ft,H,S)}const{tensors2D:ae,outShape:Se}=function Ri(C,b,_){const S=y.backend_util.computeOutShape(C.map(H=>H.shape),b);return{tensors2D:C.map(H=>en({inputs:{x:H},attrs:{shape:[-1,y.D5U.sizeFromShape(H.shape.slice(b))]},backend:_})),outShape:S}}(H,b,_),Ne=new Rn(ae.map(ft=>ft.shape)),Je=_.runWebGLProgram(Ne,ae,S);ae.forEach(ft=>_.disposeIntermediateTensorInfo(ft));const rt=en({inputs:{x:Je},attrs:{shape:Se},backend:_});return _.disposeIntermediateTensorInfo(Je),rt}function pi(C){const{inputs:b,backend:_,attrs:S}=C,{axis:k}=S,H=y.D5U.parseAxisParam(k,b[0].shape)[0],Q=b.map(Se=>Se.shape);y.backend_util.assertParamsConsistent(Q,H);const ue=y.backend_util.computeOutShape(b.map(Se=>Se.shape),H);if(0===y.D5U.sizeFromShape(ue))return _.makeTensorInfo(ue,b[0].dtype,[]);const ae=b.filter(Se=>y.D5U.sizeFromShape(Se.shape)>0);return 1===ae.length?Wr({inputs:{x:ae[0]},backend:_}):pr(ae,H,_)}const Xr={kernelName:y.Eh3,backendName:"webgl",kernelFunc:pi};class Fn{constructor(b,_=!1,S=null,k=!1,H=!1){this.variableNames=["x","W"],this.outputShape=b.outShape;const Q=b.padInfo.top,ue=b.padInfo.left,ae=b.strideHeight,Se=b.strideWidth,Ne=b.dilationHeight,Je=b.dilationWidth,rt=b.filterHeight,ft=b.filterWidth,Ot=4*Math.floor(b.inChannels/4),Kt=b.inChannels%4,tn="channelsLast"===b.dataFormat,Zt=tn?1:2,hn=tn?2:3,ts=tn?3:1;let us="",Us="";S&&(us=k?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${S}\n        }`:H?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${S}\n        }`:`\n          float activation(float x) {\n            ${S}\n          }\n        `,Us="result = activation(result);");const _i=_?"result += getBiasAtOutCoords();":"";_&&this.variableNames.push("bias"),k&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${us}\n\n      const ivec2 strides = ivec2(${ae}, ${Se});\n      const ivec2 pads = ivec2(${Q}, ${ue});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${ts}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${Zt}], coords[${hn}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${rt}; wR++) {\n          int xR = xRCorner + wR * ${Ne};\n\n          if (xR < 0 || xR >= ${b.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${ft}; wC++) {\n            int xC = xCCorner + wC * ${Je};\n\n            if (xC < 0 || xC >= ${b.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${Ot}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${tn}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===Kt}) {\n\n              if (${tn}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${Ot}) *\n                    getW(wR, wC, ${Ot}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${Ot}, xR, xC) *\n                    getW(wR, wC, ${Ot}, d2);\n              }\n\n            } else if (${2===Kt}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${Ot}, d2),\n                getW(wR, wC, ${Ot} + 1, d2)\n              );\n\n              if (${tn}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${Ot}),\n                  getX(batch, xR, xC, ${Ot} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${Ot}, xR, xC),\n                  getX(batch, ${Ot} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===Kt}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${Ot}, d2),\n                getW(wR, wC, ${Ot} + 1, d2),\n                getW(wR, wC, ${Ot} + 2, d2)\n              );\n\n              if (${tn}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${Ot}),\n                  getX(batch, xR, xC, ${Ot} + 1),\n                  getX(batch, xR, xC, ${Ot} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${Ot}, xR, xC),\n                  getX(batch, ${Ot} + 1, xR, xC),\n                  getX(batch, ${Ot} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${_i}\n        ${Us}\n        setOutput(result);\n      }\n    `}}class Fr{constructor(b){this.variableNames=["x","W"],this.outputShape=b.outShape;const _=b.padInfo.front,S=b.padInfo.top,k=b.padInfo.left,H=b.strideDepth,Q=b.strideHeight,ue=b.strideWidth,ae=b.dilationDepth,Se=b.dilationHeight,Ne=b.dilationWidth,Je=b.filterDepth,rt=b.filterHeight,ft=b.filterWidth,Ot=4*Math.floor(b.inChannels/4),Kt=b.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${H}, ${Q}, ${ue});\n      const ivec3 pads = ivec3(${_}, ${S}, ${k});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${Je}; wF++) {\n          int xF = xFCorner + wF * ${ae};\n\n          if (xF < 0 || xF >= ${b.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${rt}; wR++) {\n            int xR = xRCorner + wR * ${Se};\n\n            if (xR < 0 || xR >= ${b.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${ft}; wC++) {\n              int xC = xCCorner + wC * ${Ne};\n\n              if (xC < 0 || xC >= ${b.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${Ot}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===Kt}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${Ot}) *\n                  getW(wF, wR, wC, ${Ot}, d2);\n              } else if (${2===Kt}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${Ot}),\n                  getX(batch, xF, xR, xC, ${Ot} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${Ot}, d2),\n                  getW(wF, wR, wC, ${Ot} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===Kt}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${Ot}),\n                  getX(batch, xF, xR, xC, ${Ot} + 1),\n                  getX(batch, xF, xR, xC, ${Ot} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${Ot}, d2),\n                  getW(wF, wR, wC, ${Ot} + 1, d2),\n                  getW(wF, wR, wC, ${Ot} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class hr{constructor(b,_=!1,S=null,k=!1,H=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=b.outShape,this.enableShapeUniforms=ki(this.outputShape.length);const Q=b.padInfo.left,ue=b.strideWidth,ae=b.dilationWidth,Se=b.filterHeight,Ne=b.filterWidth,Je=Ne;let rt="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let tn=0;tn<Ne;tn++)rt+=`\n           vec4 xTexelC${2*tn};\n           int xTexelC${2*tn}Ready;\n           vec4 xTexelC${2*tn+1};\n           int xTexelC${2*tn+1}Ready;\n           vec4 xC${tn};`;rt+=`\n     for (int r = 0; r < ${Se}; r++) {\n      for (int d1 = 0; d1 < ${b.inChannels}; d1 += 2) {\n       `;for(let tn=0;tn<Ne;tn++)rt+=`\n           xTexelC${2*tn} = vec4(0.0);\n           xTexelC${2*tn}Ready = 0;\n           xTexelC${2*tn+1} = vec4(0.0);\n           xTexelC${2*tn+1}Ready = 0;\n           xC${tn} = vec4(0.0);`;rt+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let tn=0;tn<(Je+1)/2;tn++){const Zt=2*tn;if(rt+=`\n           xC = xCCorner + ${Zt*ae};\n           `,1===ue){if(Zt<Ne&&(Q%2==1?(rt+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Zt}Ready == 0) {\n                   xTexelC${Zt} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${Zt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Zt}Ready = 1;\n                 }\n               `,rt+=1===ae&&Zt>0?`\n                 xC${Zt} = vec4(xTexelC${Zt-2}.zw, xTexelC${Zt}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${Zt} = vec4(previous.zw, xTexelC${Zt}.xy);\n                   } else {\n                     xC${Zt} = vec4(0.0, 0.0, xTexelC${Zt}.xy);\n                   }\n                   `):rt+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${Zt}Ready == 0) {\n                   xTexelC${Zt} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${Zt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Zt}Ready = 1;\n                 }\n\n                 xC${Zt} = xTexelC${Zt};\n                 `,Zt+1<Ne)){const hn=Q%2==0?y.D5U.nearestLargerEven(ae):ae;ae%2==0&&Q%2==1||ae%2!=0&&Q%2!=1?(rt+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${hn};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Zt+1}Ready == 0) {\n                     xTexelC${Zt+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${Zt+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${Zt+1}Ready = 1;\n                   }\n                   `,rt+=ae>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${Zt+1} = vec4(previous.zw, xTexelC${Zt+1}.xy);\n                     } else {\n                      xC${Zt+1} = vec4(0.0, 0.0, xTexelC${Zt+1}.xy);\n                     }\n                     `:`\n                     xC${Zt+1} = vec4(xTexelC${Zt}.zw, xTexelC${Zt+1}.xy);\n                     `):rt+=1===hn?`\n                     xC${Zt+1} = xTexelC${Zt};\n                     `:`\n                     xCOffset = xC + ${hn};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Zt+1}Ready == 0) {\n                       xTexelC${Zt+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${Zt+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${Zt+1}Ready = 1;\n                     }\n\n                     xC${Zt+1} = xTexelC${Zt+1};\n                     `}}else Zt<Ne&&(Q%2==1?(rt+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Zt}Ready == 0) {\n                   xTexelC${Zt} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${Zt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Zt}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Zt+1}Ready == 0) {\n                   xTexelC${Zt+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${Zt+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${Zt+1}Ready = 1;\n                 }\n\n                 xC${Zt} = vec4(xTexelC${Zt}.zw, xTexelC${Zt+1}.zw);\n               `,Zt+1<Ne&&(rt+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${Zt+1} = vec4(xTexelC${Zt+1}.xy, final.xy);\n                 `)):(rt+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${Zt}Ready == 0) {\n                   xTexelC${Zt} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${Zt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Zt}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Zt+1}Ready == 0) {\n                   xTexelC${Zt+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${Zt+1}.zw = vec2(0.);\n                   }\n                   xTexelC${Zt+1}Ready = 1;\n                 }\n\n                 xC${Zt} = vec4(\n                   xTexelC${Zt}.xy, xTexelC${Zt+1}.xy);\n               `,Zt+1<Ne&&(rt+=`\n                   xC${Zt+1} = vec4(xTexelC${Zt}.zw, xTexelC${Zt+1}.zw);\n                 `)));Zt<Ne&&(rt+=`\n             wTexel = getW(r, ${Zt}, d1, d2);\n             dotProd += xC${Zt}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${b.inChannels}) {\n               dotProd += xC${Zt}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,Zt+1<Ne&&(rt+=`\n               wTexel = getW(r, ${Zt+1}, d1, d2);\n               dotProd += xC${Zt+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${b.inChannels}) {\n                 dotProd += xC${Zt+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}rt+="\n     }\n   ",rt+="\n     }\n   ",rt+="\n     }\n   ";let ft="",Ot="";S&&(ft=k?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${S}\n         }`:H?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${S}\n         }`:`vec4 activation(vec4 x) {\n           ${S}\n         }`,Ot="result = activation(result);");const Kt=_?"result += getBiasAtOutCoords();":"";_&&this.variableNames.push("bias"),k&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${ft}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${rt}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${Kt}\n         ${Ot}\n         setOutput(result);\n       }\n     `}}class gs{constructor(b,_){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=b,this.enableShapeUniforms=ki(this.outputShape.length);const{dataFormat:S}=_,k=co(),H="channelsLast"===S,Q=H?1:2,ue=H?2:3,ae=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${b[2]} && pos < ${b[1]}) {`;let Se="";for(let Ne=0;Ne<=1;Ne++)for(let Je=0;Je<=1;Je++)Se+=`\n          blockIndex = rc.z + ${Je};\n          pos = rc.y + ${Ne};\n\n          ${ae}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${Q}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${ue}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${H}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*Ne+Je}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*Ne+Je}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${Se}\n\n        ${k.output} = result;\n      }\n    `}}function Ui(C,b){const _=C.length;return _>=3?b?[...C.slice(0,-3),C[_-3]*C[_-2],C[_-1]]:[...C.slice(0,-3),C[_-3],C[_-2]*C[_-1]]:!b&&1===_&&C[0]>1?[C[0],1]:null}function Ni({x:C,filter:b,convInfo:_,backend:S,bias:k=null,preluActivationWeights:H=null,leakyreluAlpha:Q=0,activation:ue=null}){const ae=C.shape,Se=S.texData.get(C.dataId),Ne=_.inChannels,Je=ae[0]*ae[1]*ae[2],rt=_.outChannels,ft="channelsLast"===_.dataFormat;let tn;const Zt=[];if(null!=H){const us=Ui(H.shape,ft);null!=us&&(H=en({inputs:{x:H},backend:S,attrs:{shape:us}}),Zt.push(H))}if(null!=k){const us=Ui(k.shape,ft);null!=us&&(k=en({inputs:{x:k},backend:S,attrs:{shape:us}}),Zt.push(k))}if((1!==Je&&1!==rt||!(Ne>ir))&&Se.isPacked&&ft&&null!=Se.texture&&ae[2]%2!=0&&y.D5U.arraysEqual(Se.shape.slice(-3),ae.slice(-3))){const Us={dataId:C.dataId,shape:[1,ae[0]*ae[1]*(ae[2]+1),_.inChannels],dtype:C.dtype},_i=Se.shape;Se.shape=Se.shape.slice(),Se.shape[Se.shape.length-2]++,y.D5U.assert(xa(Se.shape,Us.shape),()=>`packed reshape ${Se.shape} to ${Us.shape} isn't free`);const ii=en({inputs:{x:b},backend:S,attrs:{shape:[1,_.inChannels,_.outChannels]}});Zt.push(ii);const Sr=Er({a:Us,b:ii,backend:S,transposeA:!1,transposeB:!1,bias:k,activation:ue,preluActivationWeights:H,leakyreluAlpha:Q}),vo=S.texData.get(Sr.dataId);y.D5U.assert(vo.isPacked,()=>"batchMatMul result is expected to be packed"),Se.shape=_i,vo.shape=_.outShape,tn=Wr({inputs:{x:Sr},backend:S}),tn.shape=_.outShape,Zt.push(Sr)}else{const us=_.outHeight*_.outWidth,Us=en({inputs:{x:C},backend:S,attrs:{shape:ft?[_.batchSize,us,_.inChannels]:[_.batchSize,_.inChannels,us]}}),_i=en({inputs:{x:b},backend:S,attrs:{shape:[1,_.inChannels,_.outChannels]}}),ii=Er({a:ft?Us:_i,b:ft?_i:Us,transposeA:!ft,transposeB:!1,backend:S,bias:k,activation:ue,preluActivationWeights:H,leakyreluAlpha:Q});tn=en({inputs:{x:ii},backend:S,attrs:{shape:_.outShape}}),Zt.push(Us),Zt.push(_i),Zt.push(ii)}for(const us of Zt)S.disposeIntermediateTensorInfo(us);return tn}function ta({x:C,filter:b,convInfo:_,backend:S,bias:k=null,preluActivationWeights:H=null,leakyreluAlpha:Q=0,activation:ue=null}){const{filterWidth:ae,filterHeight:Se,inChannels:Ne,outWidth:Je,outHeight:rt,dataFormat:ft}=_,Ot="channelsLast"===ft,Kt=ae*Se*Ne,tn=rt*Je,Zt=[_.batchSize,Kt,tn],us=[];if(null!=H){const lc=Ui(H.shape,Ot);null!=lc&&(H=en({inputs:{x:H},backend:S,attrs:{shape:lc}}),us.push(H))}if(null!=k){const lc=Ui(k.shape,Ot);null!=lc&&(k=en({inputs:{x:k},backend:S,attrs:{shape:lc}}),us.push(k))}const Us=en({inputs:{x:b},backend:S,attrs:{shape:[1,Kt,y.D5U.sizeFromShape(b.shape)/Kt]}});us.push(Us);const _i=new gs(Zt,_),Sr=S.runWebGLProgram(_i,[C],"float32",[C.shape,[_.padInfo.top,_.padInfo.left],[_.strideHeight,_.strideWidth],[_.dilationHeight,_.dilationWidth],[_.inChannels],[_.filterWidth*_.inChannels],[_.outWidth]]),vo=en({inputs:{x:Sr},backend:S,attrs:{shape:Zt}});us.push(Sr),us.push(vo);const Ti=null!=k,Aa=null!=H,ql="leakyrelu"===ue,cd=ue?Me(ue,!0):null,$u=new ge(Ot?vo.shape:Us.shape,Ot?Us.shape:vo.shape,Ot?[_.batchSize,tn,_.outChannels]:[_.batchSize,_.outChannels,tn],!0,!1,Ti,cd,Aa,ql),Bu=Ot?[vo,Us]:[Us,vo];if(k&&Bu.push(k),Aa&&Bu.push(H),ql){const lc=S.makeTensorInfo([],"float32",y.D5U.createScalarValue(Q,"float32"));Bu.push(lc),us.push(lc)}const su=S.runWebGLProgram($u,Bu,"float32"),Zu=en({inputs:{x:su},backend:S,attrs:{shape:_.outShape}});us.push(su);for(const lc of us)S.disposeIntermediateTensorInfo(lc);return Zu}const da={kernelName:y.mhS,backendName:"webgl",kernelFunc:function Io(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,filter:H}=b,{strides:Q,pad:ue,dataFormat:ae,dilations:Se,dimRoundingMode:Ne}=S,Je=y.backend_util.convertConv2DDataFormat(ae),rt=y.backend_util.computeConv2DInfo(k.shape,H.shape,Q,Se,ue,Ne,!1,Je);let ft;if(1!==rt.filterHeight||1!==rt.filterWidth||1!==rt.dilationHeight||1!==rt.dilationWidth||1!==rt.strideHeight||1!==rt.strideWidth||"SAME"!==rt.padInfo.type&&"VALID"!==rt.padInfo.type)if(rt.strideWidth<=2&&"channelsLast"===Je&&(0,y.OBj)().getBool("WEBGL_EXP_CONV")){const Kt=new hr(rt);ft=_.runWebGLProgram(Kt,[k,H],"float32",[[rt.padInfo.top,rt.padInfo.left],[rt.strideHeight,rt.strideWidth],[rt.dilationHeight,rt.dilationWidth],[rt.inHeight,rt.inWidth]])}else if((0,y.OBj)().getBool("WEBGL_CONV_IM2COL"))ft=ta({x:k,filter:H,convInfo:rt,backend:_});else{const Kt=new Fn(rt);ft=_.runWebGLProgram(Kt,[k,H],"float32")}else ft=Ni({x:k,filter:H,convInfo:rt,backend:_});const Ot=en({inputs:{x:ft},backend:_,attrs:{shape:rt.outShape}});return _.disposeIntermediateTensorInfo(ft),Ot}};class zo{constructor(b){this.variableNames=["x","dy"],this.outputShape=b.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${b.batchSize}; b++) {\n          for (int yR = 0; yR < ${b.outHeight}; yR++) {\n            int xR = wR + yR * ${b.strideHeight} - ${b.padInfo.top};\n\n            if (xR < 0 || xR >= ${b.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${b.outWidth}; yC++) {\n              int xC = wC + yC * ${b.strideWidth} - ${b.padInfo.left};\n\n              if (xC < 0 || xC >= ${b.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===b.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Za{constructor(b){this.variableNames=["dy","W"],this.outputShape=b.inShape;const _=b.filterHeight,S=b.filterWidth,Q="channelsLast"===b.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${_-1-b.padInfo.top}, ${S-1-b.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${Q?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${Q?1:2}], coords[${Q?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${_}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${b.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${b.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${_} - 1 - wR;\n\n          for (int wC = 0; wC < ${S}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${b.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${b.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${S} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${b.outChannels}; d2++) {\n\n              if (${Q}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fu{constructor(b){this.variableNames=["x","dy"],this.outputShape=b.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${b.batchSize}; b++) {\n          for (int yF = 0; yF < ${b.outDepth}; yF++) {\n            int xF = wF + yF * ${b.strideDepth} - ${b.padInfo.front};\n\n            if (xF < 0 || xF >= ${b.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${b.outHeight}; yR++) {\n              int xR = wR + yR * ${b.strideHeight} - ${b.padInfo.top};\n\n              if (xR < 0 || xR >= ${b.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${b.outWidth}; yC++) {\n                int xC = wC + yC * ${b.strideWidth} - ${b.padInfo.left};\n\n                if (xC < 0 || xC >= ${b.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Cl{constructor(b){this.variableNames=["dy","W"],this.outputShape=b.inShape;const _=b.filterDepth,S=b.filterHeight,k=b.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${_-1-b.padInfo.front}, ${S-1-b.padInfo.top}, ${k-1-b.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${_}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${b.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${b.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${_} - 1 - wF;\n\n          for (int wR = 0; wR < ${S}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${b.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${b.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${S} - 1 - wR;\n\n            for (int wC = 0; wC < ${k}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${b.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${b.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${k} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${b.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const El={kernelName:y.wUP,backendName:"webgl",kernelFunc:function Jo(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,dy:H}=b,{strides:Q,pad:ue,dataFormat:ae,dimRoundingMode:Se,filterShape:Ne}=S,Je=y.backend_util.convertConv2DDataFormat(ae),rt=y.backend_util.computeConv2DInfo(k.shape,Ne,Q,1,ue,Se,!1,Je),ft=new zo(rt);return _.runWebGLProgram(ft,[k,H],"float32")}};class Sd{constructor(b){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=b.inShape,this.enableShapeUniforms=ki(this.outputShape.length);const _=b.filterHeight,S=b.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${_-1-b.padInfo.top}, ${S-1-b.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${_}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${b.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${_} - 1 - wR;\n\n          for (int wC = 0; wC < ${S}; wC++) {\n            int wCPerm = ${S} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${b.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${b.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${b.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${b.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${b.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const zc={kernelName:y.wm,backendName:"webgl",kernelFunc:function Yl(C){const{inputs:b,backend:_,attrs:S}=C,{dy:k,filter:H}=b,{inputShape:Q,strides:ue,pad:ae,dataFormat:Se,dimRoundingMode:Ne}=S,Je=y.backend_util.convertConv2DDataFormat(Se),rt=y.backend_util.computeConv2DInfo(Q,H.shape,ue,1,ae,Ne,!1,Je);if((0,y.OBj)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===Je){const ft=[[rt.strideHeight,rt.strideWidth]],Ot=new Sd(rt);return _.runWebGLProgram(Ot,[k,H],"float32",ft)}{const ft=new Za(rt);return _.runWebGLProgram(ft,[k,H],"float32")}}},Ep={kernelName:y.x12,backendName:"webgl",kernelFunc:function Gd(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,filter:H}=b,{strides:Q,pad:ue,dilations:ae}=S,Se=y.backend_util.computeConv3DInfo(k.shape,H.shape,Q,ae,ue),Ne=new Fr(Se);return _.runWebGLProgram(Ne,[k,H],"float32")}},E0={kernelName:y.o2y,backendName:"webgl",kernelFunc:function x_(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,dy:H}=b,{strides:Q,pad:ue,filterShape:ae}=S,Se=y.backend_util.computeConv3DInfo(k.shape,ae,Q,1,ue),Ne=new fu(Se);return _.runWebGLProgram(Ne,[k,H],"float32")}},yh={kernelName:y.ik2,backendName:"webgl",kernelFunc:function Dp(C){const{inputs:b,backend:_,attrs:S}=C,{dy:k,filter:H}=b,{pad:Q,strides:ue,inputShape:ae}=S,Se=y.backend_util.computeConv3DInfo(ae,H.shape,ue,1,Q),Ne=new Cl(Se);return _.runWebGLProgram(Ne,[k,H],"float32")}},Xm=ks({opSnippet:Do+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Lc}\n  return result;\n`}),Zf={kernelName:y.mc4,backendName:"webgl",kernelFunc:Xm},Zl=ks({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Jf={kernelName:y.TR1,backendName:"webgl",kernelFunc:Zl};class Ql{constructor(b,_,S,k,H){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[Q,ue,ae,Se]=b,[Ne]=_,[Je,rt]=S;this.outputShape=[Ne,Je,rt,Se];const ft="bilinear"===k?1:0,[Ot,Kt]=[ue-1+".0",ae-1+".0"],[tn,Zt,hn]=Je>1?[""+(ue-1)/(Je-1),"(y2-y1) * height_ratio",`y1*${Ot} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${Ot}`],[ts,us,Us]=rt>1?[""+(ae-1)/(rt-1),"(x2-x1) * width_ratio",`x1*${Kt} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${Kt}`];this.userCode=`\n      const float height_ratio = float(${tn});\n      const float width_ratio = float(${ts});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${Q}) {\n          return;\n        }\n\n        float height_scale = ${Zt};\n        float width_scale = ${us};\n\n        float in_y = ${hn};\n        if( in_y < 0.0 || in_y > ${Ot} ) {\n          setOutput(float(${H}));\n          return;\n        }\n        float in_x = ${Us};\n        if( in_x < 0.0 || in_x > ${Kt} ) {\n          setOutput(float(${H}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${ft} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const qf={kernelName:y.VcC,backendName:"webgl",kernelFunc:C=>{const{inputs:b,backend:_,attrs:S}=C,{image:k,boxes:H,boxInd:Q}=b,{cropSize:ue,method:ae,extrapolationValue:Se}=S,Ne=new Ql(k.shape,H.shape,ue,ae,Se);return _.runWebGLProgram(Ne,[k,H,Q],"float32")}};var Sp=function(C){return C.Prod="*",C.Sum="+",C}(Sp||{});class Zm{constructor(b,_,S,k){this.op=b,this.outputShape=_,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const H=this.outputShape.length,ue=S?this.op===Sp.Prod?"1.0":"0.0":`getX(${ga(H,"coords",this.op)})`,ae=this.outputShape[this.outputShape.length-1];let Se="",Ne="";S?(Se=k?"end != "+(ae-1):"end != 0",Ne=k?"end + 1":"end - 1"):(Se=k?`end + pow2 < ${ae}`:"end >= pow2",Ne=k?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${mi(H)} coords = getOutputCoords();\n        int end = ${Kd(H,"coords",this.op)};\n        float val = ${ue};\n        int pow2 = int(pow(2.0, index));\n        if (${Se}) {\n          int idx = ${Ne};\n          ${Kd(H,"coords",this.op)} = idx;\n          val ${this.op}= getX(${ga(H,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function ga(C,b,_){if(1===C)return`${b}`;if(2===C)return`${b}.x, ${b}.y`;if(3===C)return`${b}.x, ${b}.y, ${b}.z`;if(4===C)return`${b}.x, ${b}.y, ${b}.z, ${b}.w`;throw new Error(`Cumulative ${_} for rank ${C} is not yet supported`)}function Kd(C,b,_){if(1===C)return`${b}`;if(2===C)return`${b}.y`;if(3===C)return`${b}.z`;if(4===C)return`${b}.w`;throw new Error(`Cumulative ${_} for rank ${C} is not yet supported`)}function Wo(C,b,_,S,k,H){const Q=b.shape.length,ue=y.backend_util.getAxesPermutation([S],Q);let ae=b;null!=ue&&(ae=An({inputs:{x:b},backend:_,attrs:{perm:ue}}));const Se=y.backend_util.getInnerMostAxes(1,Q)[0];if(Se!==Q-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${b.shape.length-1} but got axis=${S}`);const Ne=ae.shape[Se];let Je=Wr({inputs:{x:ae},backend:_});for(let rt=0;rt<=Math.ceil(Math.log2(Ne))-1;rt++){const ft=new Zm(C,ae.shape,!1,H),Kt=Je;Je=_.runWebGLProgram(ft,[Je],Je.dtype,[[rt]]),_.disposeIntermediateTensorInfo(Kt)}if(k){const rt=new Zm(C,ae.shape,k,H),ft=Je;Je=_.runWebGLProgram(rt,[Je],Je.dtype),_.disposeIntermediateTensorInfo(ft)}if(null!=ue){const ft=An({inputs:{x:Je},backend:_,attrs:{perm:y.backend_util.getUndoAxesPermutation(ue)}});return _.disposeIntermediateTensorInfo(Je),_.disposeIntermediateTensorInfo(ae),ft}return Je}const w_={kernelName:y.Byc,backendName:"webgl",kernelFunc:function Gu(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H,exclusive:Q,reverse:ue}=S;return Wo(Sp.Prod,k,_,H,Q,ue)}},C_={kernelName:y.iHb,backendName:"webgl",kernelFunc:function Ip(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H,exclusive:Q,reverse:ue}=S;return Wo(Sp.Sum,k,_,H,Q,ue)}},Jm={kernelName:y.QRR,backendName:"webgl",kernelFunc:function Qm(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,weights:H}=b,{size:Q,binaryOutput:ue}=S;if(1===k.shape.length){const ae=_.readSync(k.dataId),Se=_.readSync(H.dataId),Ne=lr(ae,Se,H.dtype,H.shape,Q);return _.makeTensorInfo([Q],H.dtype,Ne)}if(2===k.shape.length){const ae=_.bufferSync(k),Se=_.bufferSync(H),Ne=yo(ae,Se,Q,ue);return _.makeTensorInfo(Ne.shape,H.dtype,Ne.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${k.shape.length}.`)}};class uf{constructor(b,_,S){this.variableNames=["x"],this.outputShape=[],this.outputShape=b,this.blockSize=_,this.dataFormat=S,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${_};\n      int offset_h = imod(h, ${_});\n      int in_w = w / ${_};\n      int offset_w = imod(w, ${_});\n      int offset_d = (offset_h * ${_} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const E_={kernelName:y.T0n,backendName:"webgl",kernelFunc:function Xd(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{blockSize:H,dataFormat:Q}=S,ue=k.shape[0],Je=("NHWC"===Q?k.shape[1]:k.shape[2])*H,rt=("NHWC"===Q?k.shape[2]:k.shape[3])*H,ft=("NHWC"===Q?k.shape[3]:k.shape[1])/(H*H),Kt=new uf("NHWC"===Q?[ue,Je,rt,ft]:[ue,ft,Je,rt],H,Q);return _.runWebGLProgram(Kt,[k],k.dtype)}};class Tp{constructor(b,_=!1,S=null,k=!1,H=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=b.outShape,this.enableShapeUniforms=ki(this.outputShape.length);const Q=b.filterHeight,ue=b.filterWidth,ae=b.outChannels/b.inChannels;let Se="",Ne="";S&&(Se=k?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${S}\n        }`:H?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${S}\n        }`:`\n          float activation(float x) {\n            ${S}\n          }\n        `,Ne="result = activation(result);");const Je=_?"result += getBiasAtOutCoords();":"";_&&this.variableNames.push("bias"),k&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${Se}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${ae};\n        int q = d2 - d1 * ${ae};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${Q}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${ue}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${Je}\n        ${Ne}\n        setOutput(result);\n      }\n    `}}class Ap{constructor(b,_=!1,S=null,k=!1,H=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=b.outShape,this.enableShapeUniforms=ki(this.outputShape.length);const Q=b.outChannels/b.inChannels,ue=b.padInfo.left,ae=b.strideWidth,Se=b.dilationWidth,Ne=b.filterHeight,Je=b.filterWidth,rt=Je;let ft="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let Zt=0;Zt<Je;Zt++)ft+=`\n          vec4 xTexelC${2*Zt};\n          int xTexelC${2*Zt}Ready;\n          vec4 xTexelC${2*Zt+1};\n          int xTexelC${2*Zt+1}Ready;\n          vec4 xC${Zt};`;ft+=`\n    for (int r = 0; r < ${Ne}; r++) {\n      `;for(let Zt=0;Zt<Je;Zt++)ft+=`\n          xTexelC${2*Zt} = vec4(0.0);\n          xTexelC${2*Zt}Ready = 0;\n          xTexelC${2*Zt+1} = vec4(0.0);\n          xTexelC${2*Zt+1}Ready = 0;\n          xC${Zt} = vec4(0.0);`;ft+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let Zt=0;Zt<(rt+1)/2;Zt++){const hn=2*Zt;if(ft+=`\n          xC = xCCorner + ${hn*Se};\n          `,1===ae){if(hn<Je&&(ue%2==1?(ft+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${hn}Ready == 0) {\n                  xTexelC${hn} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${hn}.zw = vec2(0.0);\n                  }\n                  xTexelC${hn}Ready = 1;\n                }\n              `,ft+=1===Se&&hn>0?`\n                xC${hn} = vec4(xTexelC${hn-2}.zw, xTexelC${hn}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${hn} = vec4(previous.zw, xTexelC${hn}.xy);\n                  } else {\n                    xC${hn} = vec4(0.0, 0.0, xTexelC${hn}.xy);\n                  }\n                  `):ft+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${hn}Ready == 0) {\n                  xTexelC${hn} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${hn}.zw = vec2(0.0);\n                  }\n                  xTexelC${hn}Ready = 1;\n                }\n\n                xC${hn} = xTexelC${hn};\n                `,hn+1<Je)){const ts=ue%2==0?y.D5U.nearestLargerEven(Se):Se;Se%2==0&&ue%2==1||Se%2!=0&&ue%2!=1?(ft+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${ts};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${hn+1}Ready == 0) {\n                    xTexelC${hn+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${hn+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${hn+1}Ready = 1;\n                  }\n                  `,ft+=Se>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${hn+1} = vec4(previous.zw, xTexelC${hn+1}.xy);\n                    } else {\n                     xC${hn+1} = vec4(0.0, 0.0, xTexelC${hn+1}.xy);\n                    }\n                    `:`\n                    xC${hn+1} = vec4(xTexelC${hn}.zw, xTexelC${hn+1}.xy);\n                    `):ft+=1===ts?`\n                    xC${hn+1} = xTexelC${hn};\n                    `:`\n                    xCOffset = xC + ${ts};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${hn+1}Ready == 0) {\n                      xTexelC${hn+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${hn+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${hn+1}Ready = 1;\n                    }\n\n                    xC${hn+1} = xTexelC${hn+1};\n                    `}}else hn<Je&&(ue%2==1?(ft+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${hn}Ready == 0) {\n                  xTexelC${hn} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${hn}.zw = vec2(0.0);\n                  }\n                  xTexelC${hn}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${hn+1}Ready == 0) {\n                  xTexelC${hn+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${hn+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${hn+1}Ready = 1;\n                }\n\n                xC${hn} = vec4(xTexelC${hn}.zw, xTexelC${hn+1}.zw);\n              `,hn+1<Je&&(ft+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${hn+1} = vec4(xTexelC${hn+1}.xy, final.xy);\n                `)):(ft+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${hn}Ready == 0) {\n                  xTexelC${hn} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${hn}.zw = vec2(0.0);\n                  }\n                  xTexelC${hn}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${hn+1}Ready == 0) {\n                  xTexelC${hn+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${hn+1}.zw = vec2(0.);\n                  }\n                  xTexelC${hn+1}Ready = 1;\n                }\n\n                xC${hn} = vec4(\n                  xTexelC${hn}.xy, xTexelC${hn+1}.xy);\n              `,hn+1<Je&&(ft+=`\n                  xC${hn+1} = vec4(xTexelC${hn}.zw, xTexelC${hn+1}.zw);\n                `)));hn<Je&&(ft+=`\n            wTexel = getW(r, ${hn}, d1, q);\n            dotProd += xC${hn} * vec4(wTexel.xz, wTexel.xz);\n          `,hn+1<Je&&(ft+=`\n              wTexel = getW(r, ${hn+1}, d1, q);\n              dotProd += xC${hn+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}ft+="\n    }\n  ",ft+="\n      }\n    ";let Ot="",Kt="";S&&(Ot=k?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${S}\n        }`:H?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${S}\n        }`:`vec4 activation(vec4 x) {\n          ${S}\n        }`,Kt="result = activation(result);");const tn=_?"result += getBiasAtOutCoords();":"";_&&this.variableNames.push("bias"),k&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${Ot}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${Q};\n        int q = d2 - d1 * ${Q};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${ft}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${tn}\n        ${Kt}\n        setOutput(result);\n      }\n    `}}const ns={kernelName:y.cie,backendName:"webgl",kernelFunc:function df(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,filter:H}=b,{strides:Q,pad:ue,dilations:ae,dimRoundingMode:Se}=S;let Ne=ae;null==Ne&&(Ne=[1,1]),y.D5U.assert(y.backend_util.eitherStridesOrDilationsAreOne(Q,Ne),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${Q} and dilations '${Ne}'`);const Je=y.backend_util.computeConv2DInfo(k.shape,H.shape,Q,Ne,ue,Se,!0);let rt;return rt=(0,y.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&Je.strideWidth<=2&&Je.outChannels/Je.inChannels==1?new Ap(Je):new Tp(Je),_.runWebGLProgram(rt,[k,H],"float32",[[Je.padInfo.top,Je.padInfo.left],[Je.strideHeight,Je.strideWidth],[Je.dilationHeight,Je.dilationWidth],[Je.inHeight,Je.inWidth]])}};class em{constructor(b){this.variableNames=["x","dy"],this.outputShape=b.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${b.outChannels/b.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${b.batchSize}; b++) {\n          for (int yR = 0; yR < ${b.outHeight}; yR++) {\n            int xR = wR + yR * ${b.strideHeight} - ${b.padInfo.top};\n\n            if (xR < 0 || xR >= ${b.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${b.outWidth}; yC++) {\n              int xC = wC + yC * ${b.strideWidth} - ${b.padInfo.left};\n\n              if (xC < 0 || xC >= ${b.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Id{constructor(b){this.variableNames=["dy","W"],this.outputShape=b.inShape;const _=b.filterHeight,S=b.filterWidth,ae=b.outChannels/b.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${_-1-b.padInfo.top}, ${S-1-b.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${_}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${b.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${b.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${_} - 1 - wR;\n\n          for (int wC = 0; wC < ${S}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${b.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${b.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${S} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${ae}; dm++) {\n              int d2 = d1 * ${ae} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const zh={kernelName:y.sL$,backendName:"webgl",kernelFunc:function qm(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,dy:H}=b,{strides:Q,dilations:ue,pad:ae,dimRoundingMode:Se,filterShape:Ne}=S,Je=y.backend_util.computeConv2DInfo(k.shape,Ne,Q,ue,ae,Se,!0),rt=new em(Je);return _.runWebGLProgram(rt,[k,H],"float32")}},Wh={kernelName:y.y7R,backendName:"webgl",kernelFunc:function kp(C){const{inputs:b,backend:_,attrs:S}=C,{dy:k,filter:H}=b,{strides:Q,dilations:ue,pad:ae,dimRoundingMode:Se,inputShape:Ne}=S,Je=y.backend_util.computeConv2DInfo(Ne,H.shape,Q,ue,ae,Se,!0),rt=new Id(Je);return _.runWebGLProgram(rt,[k,H],"float32")}};class D_{constructor(b){this.variableNames=["X"],this.outputShape=[b,b],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const S_={kernelName:y.$w,backendName:"webgl",kernelFunc:function tm(C){const{inputs:b,backend:_}=C,{x:S}=b,k=[...S.shape,...S.shape],H=y.D5U.sizeFromShape(S.shape),Q=en({inputs:{x:S},backend:_,attrs:{shape:[H]}}),ue=new D_(H),ae=_.runWebGLProgram(ue,[Q],Q.dtype),Se=en({inputs:{x:ae},backend:_,attrs:{shape:k}});return _.disposeIntermediateTensorInfo(Q),_.disposeIntermediateTensorInfo(ae),Se}};class eg{constructor(b){this.variableNames=["x","W"],this.outputShape=b.outShape;const{inHeight:_,inWidth:S,padInfo:k,strideHeight:H,strideWidth:Q,filterHeight:ue,filterWidth:ae,dilationHeight:Se,dilationWidth:Ne}=b,{top:Je,left:rt}=k;this.userCode=`\n      const ivec2 strides = ivec2(${H}, ${Q});\n      const ivec2 pads = ivec2(${Je}, ${rt});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${ue}; h++) {\n          int hIn = hBeg + h * ${Se};\n\n          if (hIn >= 0 && hIn < ${_}) {\n            for (int w = 0; w < ${ae}; w++) {\n              int wIn = wBeg + w * ${Ne};\n\n              if (wIn >= 0 && wIn < ${S}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const I_={kernelName:y.p4S,backendName:"webgl",kernelFunc:function tg(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,filter:H}=b,{strides:Q,pad:ue,dilations:ae}=S,Se=y.backend_util.computeDilation2DInfo(k.shape,H.shape,Q,ue,"NHWC",ae);let Ne;const Je=new eg(Se);Ne=_.runWebGLProgram(Je,[k,H],"float32");const rt=en({inputs:{x:Ne},backend:_,attrs:{shape:Se.outShape}});return _.disposeIntermediateTensorInfo(Ne),rt}},wu={kernelName:y.$g6,backendName:"webgl",kernelFunc:function T_(C){const{inputs:b,backend:_,attrs:S}=C,{equation:k}=S,H=b,{allDims:Q,summedDims:ue,idDims:ae}=y.backend_util.decodeEinsumEquation(k,H.length);y.backend_util.checkEinsumDimSizes(Q.length,ae,H);const{path:Se,steps:Ne}=y.backend_util.getEinsumComputePath(ue,ae),Je=Ne.length;let rt=null,ft=Q.length;const Ot=[];for(let Kt=0;Kt<Je;++Kt){for(const tn of Ne[Kt]){const{permutationIndices:Zt,expandDims:hn}=y.backend_util.getEinsumPermutation(ft,ae[tn]);let ts;y.backend_util.isIdentityPermutation(Zt)?ts=H[tn]:(ts=An({inputs:{x:H[tn]},backend:_,attrs:{perm:Zt}}),Ot.push(ts));const us=ts.shape.slice();for(let Us=0;Us<hn.length;++Us)us.splice(hn[Us],0,1);y.D5U.arraysEqual(ts.shape,us)||(ts=en({inputs:{x:ts},backend:_,attrs:{shape:us}}),Ot.push(ts)),null===rt?rt=ts:(rt=$t({inputs:{a:ts,b:rt},backend:_}),Ot.push(rt))}Kt<Je-1&&(Se[Kt]>=0&&(rt=Kn({inputs:{x:rt},backend:_,attrs:{axis:Se[Kt]-(Q.length-ft),keepDims:!1}}),Ot.push(rt)),ft--)}for(const Kt of Ot)Kt!==rt&&_.disposeIntermediateTensorInfo(Kt);return rt}},Yd=ks({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Zd={kernelName:y.SX0,backendName:"webgl",kernelFunc:Yd},sg={kernelName:y.HEU,backendName:"webgl",kernelFunc:C=>{const{inputs:b,backend:_}=C,{dy:S,y:k}=b,H=(0,y.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ws("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",S.shape,k.shape):new yc("return (b >= 0.0) ? a : a * (b + 1.0);",S.shape,k.shape);return _.runWebGLProgram(H,[S,k],S.dtype)}},pf=Zo({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:wo}),ff={kernelName:y.hdR,backendName:"webgl",kernelFunc:pf},he=ks({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${y.backend_util.ERF_P};\n  float a1 = ${y.backend_util.ERF_A1};\n  float a2 = ${y.backend_util.ERF_A2};\n  float a3 = ${y.backend_util.ERF_A3};\n  float a4 = ${y.backend_util.ERF_A4};\n  float a5 = ${y.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),se={kernelName:y.Omj,backendName:"webgl",kernelFunc:he},Ze=ks({opSnippet:Do+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Fa,dtype:"float32"}),ct={kernelName:y.NEP,backendName:"webgl",kernelFunc:Ze};function Dt(C){const{inputs:b,attrs:_,backend:S}=C,{dim:k}=_,{input:H}=b,Q=H.shape.length,ue=H.shape.slice();let ae=k;return k<0&&(y.D5U.assert(-(Q+1)<=k,()=>`Axis must be in the interval [${-(Q+1)}, ${Q}]`),ae=Q+k+1),ue.splice(ae,0,1),en({inputs:{x:H},backend:S,attrs:{shape:ue}})}const Ht={kernelName:y.YFo,backendName:"webgl",kernelFunc:Dt},Gt="return exp(x) - 1.0;",vn=ks({opSnippet:Gt,packedOpSnippet:Gt,cpuKernelImpl:yl}),wn={kernelName:y.Y0y,backendName:"webgl",kernelFunc:vn};class cs{constructor(b,_,S){this.variableNames=["real","imag"];const k=_[1];this.outputShape=_;const H=S?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,Q=S?`${k}.0`:"1.0";let ue;if("real"===b)ue="return real * expR - imag * expI;";else{if("imag"!==b)throw new Error(`FFT component must be either "real" or "imag", got ${b}.`);ue="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${H};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${ue}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${k});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${k}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${Q};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Hs(C,b,_){const S=_.texData.get(C.dataId),k=y.D5U.sizeFromShape(C.shape),H=C.shape[C.shape.length-1],ue=en({inputs:{x:C},backend:_,attrs:{shape:[k/H,H]}}),ae=ue.shape,Se=new cs("real",ae,b),Ne=new cs("imag",ae,b),Je=[{dataId:S.complexTensorInfos.real.dataId,dtype:S.complexTensorInfos.real.dtype,shape:ae},{dataId:S.complexTensorInfos.imag.dataId,dtype:S.complexTensorInfos.imag.dtype,shape:ae}],rt=_.runWebGLProgram(Se,Je,"float32"),ft=_.runWebGLProgram(Ne,Je,"float32"),Ot=Eo({inputs:{real:rt,imag:ft},backend:_});_.disposeIntermediateTensorInfo(rt),_.disposeIntermediateTensorInfo(ft);const Kt=en({inputs:{x:Ot},backend:_,attrs:{shape:C.shape}});return _.disposeIntermediateTensorInfo(ue),_.disposeIntermediateTensorInfo(Ot),Kt}const Ii={kernelName:y.vwp,backendName:"webgl",kernelFunc:function fr(C){const{inputs:b,backend:_}=C,{input:S}=b;return Hs(S,!1,_)}};class Dr{constructor(b,_){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=b,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function mr(C){const{backend:b,attrs:_}=C,{shape:S,value:k}=_;let{dtype:H}=_;if(H=H||y.D5U.inferDtype(k),"string"===H){const Q=y.D5U.getArrayFromDType(H,y.D5U.sizeFromShape(S));return Q.fill(k),b.makeTensorInfo(S,H,Q)}{const Q=new Dr(S,k);return b.runWebGLProgram(Q,[],H,[[k]])}}const _a={kernelName:y.deh,backendName:"webgl",kernelFunc:mr};class Gr{constructor(b){this.variableNames=["Image"],this.outputShape=[];const _=b[2];this.outputShape=b,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${_} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${_}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ul={kernelName:y.Uyb,backendName:"webgl",kernelFunc:({inputs:C,backend:b})=>{const{image:_}=C,S=b,k=new Gr(_.shape);return S.runWebGLProgram(k,[_],_.dtype)}},Jl="return floor(x);",Ji=ks({opSnippet:Jl,packedOpSnippet:Jl,cpuKernelImpl:Fi}),na={kernelName:y.OR,backendName:"webgl",kernelFunc:Ji},va=Zo({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Ml={kernelName:y.jeX,backendName:"webgl",kernelFunc:va};class mu{constructor(b){this.variableNames=["A"];const _=co(),[S,k]=b;this.outputShape=b,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${k}.0, ${S}.0);\n\n        vec4 values = ${_.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Ac{constructor(b){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const _=co(),[S,k]=b;this.outputShape=b,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${k}.0, ${S}.0);\n            vec4 values = ${_.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${_.output} = result;\n      }\n    `}}const Ku={kernelName:y.eBW,backendName:"webgl",kernelFunc:function Qd(C){const{inputs:b,backend:_,attrs:S}=C;let{pixels:k}=b;const{numChannels:H}=S,Q=typeof HTMLVideoElement<"u"&&k instanceof HTMLVideoElement,ue=typeof HTMLImageElement<"u"&&k instanceof HTMLImageElement,[ae,Se]=Q?[k.videoWidth,k.videoHeight]:[k.width,k.height],Ne=[Se,ae],Je=[Se,ae,H];if(ue||Q){const Kt=(0,y.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==eu||Kt!==bh)&&(bh=Kt,eu=document.createElement("canvas").getContext("2d",{willReadFrequently:bh})),eu.canvas.width=ae,eu.canvas.height=Se,eu.drawImage(k,0,0,ae,Se),k=eu.canvas}const rt=_.makeTensorInfo(Ne,"int32");_.texData.get(rt.dataId).usage=G.PIXELS,_.gpgpu.uploadPixelDataToTexture(_.getTexture(rt.dataId),k);const ft=(0,y.OBj)().getBool("WEBGL_PACK")?new Ac(Je):new mu(Je),Ot=_.runWebGLProgram(ft,[rt],"int32");return _.disposeData(rt.dataId),Ot}};let eu,bh=(0,y.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Op={kernelName:y._V0,backendName:"webgl",kernelFunc:function xh(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,filter:H,bias:Q,preluActivationWeights:ue}=b,{strides:ae,pad:Se,dataFormat:Ne,dilations:Je,dimRoundingMode:rt,activation:ft,leakyreluAlpha:Ot}=S,Kt=y.backend_util.convertConv2DDataFormat(Ne),tn=y.backend_util.computeConv2DInfo(k.shape,H.shape,ae,Je,Se,rt,!1,Kt);let Zt;const hn=[],ts=null!=Q,us=null!=ue,Us="leakyrelu"===ft,_i=()=>{const Sr=[k,H],vo=(Ti,Aa)=>{if("NCHW"===Aa&&1===Ti.shape.length&&1!==Ti.shape[0]){const ql=en({inputs:{x:Ti},backend:_,attrs:{shape:[Ti.shape[0],1,1]}});return hn.push(ql),ql}return Ti};if(ts&&Sr.push(vo(Q,Ne)),us&&Sr.push(vo(ue,Ne)),Us){const Ti=_.makeTensorInfo([],"float32",y.D5U.createScalarValue(Ot,"float32"));Sr.push(Ti),hn.push(Ti)}return Sr};if(1!==tn.filterHeight||1!==tn.filterWidth||1!==tn.dilationHeight||1!==tn.dilationWidth||1!==tn.strideHeight||1!==tn.strideWidth||"SAME"!==tn.padInfo.type&&"VALID"!==tn.padInfo.type)if(tn.strideWidth<=2&&"channelsLast"===Kt&&(0,y.OBj)().getBool("WEBGL_EXP_CONV")){const Sr=ft?Me(ft,!0):null,vo=new hr(tn,ts,Sr,us,Us),Ti=[[tn.padInfo.top,tn.padInfo.left],[tn.strideHeight,tn.strideWidth],[tn.dilationHeight,tn.dilationWidth],[tn.inHeight,tn.inWidth]],Aa=_i();Zt=_.runWebGLProgram(vo,Aa,"float32",Ti)}else if((0,y.OBj)().getBool("WEBGL_CONV_IM2COL"))Zt=ta({x:k,filter:H,convInfo:tn,backend:_,bias:Q,activation:ft,preluActivationWeights:ue,leakyreluAlpha:Ot});else{const Sr=ft?Me(ft,!1):null,vo=new Fn(tn,ts,Sr,us,Us),Ti=_i();Zt=_.runWebGLProgram(vo,Ti,"float32")}else Zt=Ni({x:k,filter:H,convInfo:tn,backend:_,bias:Q,activation:ft,preluActivationWeights:ue,leakyreluAlpha:Ot});const ii=en({inputs:{x:Zt},backend:_,attrs:{shape:tn.outShape}});return hn.push(Zt),hn.forEach(Sr=>_.disposeIntermediateTensorInfo(Sr)),ii}},k_={kernelName:y.luS,backendName:"webgl",kernelFunc:function A_(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,filter:H,bias:Q,preluActivationWeights:ue}=b,{strides:ae,pad:Se,dilations:Ne,dimRoundingMode:Je,activation:rt,leakyreluAlpha:ft}=S,Ot=[];let Kt=Ne;null==Kt&&(Kt=[1,1]),y.D5U.assert(y.backend_util.eitherStridesOrDilationsAreOne(ae,Kt),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${ae} and dilations '${Kt}'`);const tn=y.backend_util.computeConv2DInfo(k.shape,H.shape,ae,Kt,Se,Je,!0),Zt=(0,y.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&tn.strideWidth<=2&&tn.outChannels/tn.inChannels==1,hn=rt?Me(rt,Zt):null,ts=[k,H],us=null!=Q,Us=null!=ue,_i="leakyrelu"===rt;if(us&&ts.push(Q),Us&&ts.push(ue),_i){const Ti=_.makeTensorInfo([],"float32",y.D5U.createScalarValue(ft,"float32"));ts.push(Ti),Ot.push(Ti)}let ii;ii=Zt?new Ap(tn,us,hn,Us,_i):new Tp(tn,us,hn,Us,_i);const vo=_.runWebGLProgram(ii,ts,"float32",[[tn.padInfo.top,tn.padInfo.left],[tn.strideHeight,tn.strideWidth],[tn.dilationHeight,tn.dilationWidth],[tn.inHeight,tn.inWidth]]);return Ot.forEach(Ti=>_.disposeIntermediateTensorInfo(Ti)),vo}};class mf{constructor(b,_,S,k){this.sliceDim=b,this.strides=_,this.paramsShape=k,this.variableNames=["x","indices"],this.outputShape=S;const H=mi(S.length);let Q="\n    int index;";for(let ue=0;ue<this.sliceDim;ue++)Q+=`\n          index = round(getIndices(coords[0], ${ue}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[ue]};\n          flattenIndex += index * ${this.strides[ue]};`;this.userCode=`\n         void main() {\n          ${H} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${Q}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const Hb={kernelName:y.q1x,backendName:"webgl",kernelFunc:function rg(C){const{inputs:b,backend:_}=C,{params:S,indices:k}=b,H=k.shape,Q=H[H.length-1],ue=y.D5U.sizeFromShape(S.shape),[ae,Se,Ne,Je]=y.backend_util.prepareAndValidate(S,k),rt=en({inputs:{x:k},backend:_,attrs:{shape:[Se,Q]}}),ft=en({inputs:{x:S},backend:_,attrs:{shape:[y.D5U.sizeFromShape(S.shape)/Ne,Ne]}});if(_.shouldExecuteOnCPU([S,k])||"string"===S.dtype){const Zt=_.readSync(k.dataId),hn=_.bufferSync(S),ts=Yc(Zt,hn,S.dtype,Se,Q,Ne,Je,S.shape,ue);return _.makeTensorInfo(ae,S.dtype,ts.values)}const Ot=new mf(Q,Je,[Se,Ne],S.shape),Kt=_.runWebGLProgram(Ot,[ft,rt],ft.dtype),tn=en({inputs:{x:Kt},backend:_,attrs:{shape:ae}});return _.disposeIntermediateTensorInfo(rt),_.disposeIntermediateTensorInfo(ft),_.disposeIntermediateTensorInfo(Kt),tn}};class kc{constructor(b,_){this.variableNames=["A","indices"],this.outputShape=_,this.rank=_.length;const S=mi(this.rank),k=function I0(C,b){const _=["resRC.x","resRC.y","resRC.z","resRC.w"],S=[];for(let k=0;k<C.length;k++)S.push(2===k?"index":`${_[k]}`);return S.join()}(b);this.userCode=`\n      void main() {\n        ${S} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${b[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${k}));\n      }\n    `}}function jh(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,indices:H}=b,{axis:Q,batchDims:ue}=S,ae=y.D5U.parseAxisParam(Q,k.shape)[0];if((0,y.OBj)().get("DEBUG")){const hn=_.readSync(H.dataId),ts=k.shape[ae];for(let us=0;us<hn.length;++us){const Us=hn[us];y.D5U.assert(Us<=ts-1&&Us>=0,()=>`GatherV2: the index value ${Us} is not in [0, ${ts-1}]`)}}const Se=y.backend_util.segment_util.collectGatherOpShapeInfo(k,H,ae,ue),Ne=y.D5U.sizeFromShape(H.shape),Je=[],rt=en({inputs:{x:k},backend:_,attrs:{shape:[Se.batchSize,Se.outerSize,Se.dimSize,Se.sliceSize]}}),ft=en({inputs:{x:H},backend:_,attrs:{shape:[Se.batchSize,Ne/Se.batchSize]}});Je.push(rt),Je.push(ft);const Ot=[Se.batchSize,Se.outerSize,Ne/Se.batchSize,Se.sliceSize];if(_.shouldExecuteOnCPU([k,H])||"string"===k.dtype){const hn=_.bufferSync(ft),ts=_.bufferSync(rt),us=Wu(ts,hn,Ot);return Je.forEach(Us=>_.disposeIntermediateTensorInfo(Us)),_.makeTensorInfo(Se.outputShape,us.dtype,us.values)}const Kt=new kc(rt.shape,Ot),tn=_.runWebGLProgram(Kt,[rt,ft],rt.dtype);Je.push(tn);const Zt=en({inputs:{x:tn},backend:_,attrs:{shape:Se.outputShape}});return Je.forEach(hn=>_.disposeIntermediateTensorInfo(hn)),Zt}const jb={kernelName:y.qi_,backendName:"webgl",kernelFunc:jh},sm=Zo({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:vl,dtype:"bool"}),ig={kernelName:y.iZT,backendName:"webgl",kernelFunc:sm},ag=Zo({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Hl}),O_={kernelName:y.Acj,backendName:"webgl",kernelFunc:ag},Xu={kernelName:y.Qg5,backendName:"webgl",kernelFunc:function R_(C){const{inputs:b,backend:_}=C,{input:S}=b;return Hs(S,!0,_)}},Rp=ks({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Kb={kernelName:y.avt,backendName:"webgl",kernelFunc:Rp},WC=ks({opSnippet:"return float(isinf(x));",dtype:"bool"}),A0={kernelName:y.iWB,backendName:"webgl",kernelFunc:WC},k0=ks({opSnippet:"return float(isnan(x));",dtype:"bool"}),O0={kernelName:y.r7n,backendName:"webgl",kernelFunc:k0},rm=Zo({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Zc,dtype:"bool"}),R0={kernelName:y.vtC,backendName:"webgl",kernelFunc:rm},Gh=Zo({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Oc,dtype:"bool"}),Xb={kernelName:y.CAk,backendName:"webgl",kernelFunc:Gh},im={kernelName:y.e7N,backendName:"webgl",kernelFunc:function N0(C){const{backend:b,attrs:_}=C,{start:S,stop:k,num:H}=_,Q=Fc(S,k,H);return b.makeTensorInfo([Q.length],"float32",Q)}},P_=ks({opSnippet:Do+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Qc}),M0={kernelName:y.ZbH,backendName:"webgl",kernelFunc:P_},om=ks({opSnippet:Do+"\n  return log(1.0 + x);\n"}),F_={kernelName:y.kU,backendName:"webgl",kernelFunc:om},Yb=Zo({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),XC={kernelName:y.PYm,backendName:"webgl",kernelFunc:Yb},Qb=ks({opSnippet:"return float(!(x >= 1.0));"}),Jb={kernelName:y.VfG,backendName:"webgl",kernelFunc:Qb},F0=Zo({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),L_={kernelName:y.MZg,backendName:"webgl",kernelFunc:F0};class ex{constructor(b,_,S,k,H){this.variableNames=["x"],this.outputShape=[];const Q=_,ue=b[3]-1;let ae;this.outputShape=b;const Se=`float(${S}) + float(${k}) * sum`;ae=.5===H?`inversesqrt(${Se})`:1===H?`1.0/(${Se})`:`exp(log(${Se}) * float(-${H}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${Q}; j <= ${Q}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${ue}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${ae};\n        setOutput(val);\n      }\n    `}}class L0{constructor(b,_,S,k,H){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const Q=_,ue=b[3]-1;let ae;this.outputShape=b;const Se=`float(${S}) + float(${k}) * sum`;ae=.5===H?`inversesqrt(${Se})`:1===H?`1.0/(${Se})`:`exp(log(${Se}) * float(-${H}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${Q};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${Q}; j <= ${Q}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${ue}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${ae};\n        setOutput(result);\n      }\n    `}}const tx={kernelName:y.eZ0,backendName:"webgl",kernelFunc:C=>{const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{depthRadius:H,bias:Q,alpha:ue,beta:ae}=S,Se=(0,y.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new L0(k.shape,H,Q,ue,ae):new ex(k.shape,H,Q,ue,ae);return _.runWebGLProgram(Se,[k],k.dtype)}};class nx{constructor(b,_,S,k,H){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=b,this.depth=b[3],this.depthRadius=_,this.bias=S,this.alpha=k,this.beta=H,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${_})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${_} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${k}) * norm + float(${S});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${k})\n                * float(${H})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${H});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const ZC={kernelName:y.Hhh,backendName:"webgl",kernelFunc:C=>{const{inputs:b,backend:_,attrs:S}=C,{x:k,y:H,dy:Q}=b,{depthRadius:ue,bias:ae,alpha:Se,beta:Ne}=S,Je=new nx(k.shape,ue,ae,Se,Ne);return _.runWebGLProgram(Je,[k,H,Q],k.dtype)}};function lm(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{reductionIndices:H,keepDims:Q}=S,ue=k.shape.length,ae=y.D5U.parseAxisParam(H,k.shape);let Se=ae;const Ne=y.backend_util.getAxesPermutation(Se,ue),Je=null!=Ne,rt=_.shouldExecuteOnCPU([k]);let ft=k;if(Je){if(rt){const ts=_.texData.get(ft.dataId).values,us=new Array(ue);for(let ii=0;ii<us.length;ii++)us[ii]=k.shape[Ne[ii]];const Us=Bo(ts,k.shape,k.dtype,Ne,us);ft=_.makeTensorInfo(us,k.dtype),_.texData.get(ft.dataId).values=Us}else ft=Pn(k,Ne,_);Se=y.backend_util.getInnerMostAxes(Se.length,ue)}y.backend_util.assertAxesAreInnerMostDims("max",Se,ue);const[Ot,Kt]=y.backend_util.computeOutAndReduceShapes(ft.shape,Se);let Zt,tn=Ot;if(Q&&(tn=y.backend_util.expandShapeToKeepDim(Ot,ae)),rt){const ts=_.texData.get(ft.dataId).values,us=Ai(ts,y.D5U.sizeFromShape(Kt),tn,k.dtype);Zt=_.makeTensorInfo(tn,k.dtype),_.texData.get(Zt.dataId).values=us}else Zt=function QC(C,b,_,S){const k=y.D5U.sizeFromShape(b),ue=en({inputs:{x:C},attrs:{shape:[y.D5U.sizeFromShape(C.shape)/k,k]},backend:S}),ae=Fe(ue,C.dtype,"max",S),Se=en({inputs:{x:ae},attrs:{shape:_},backend:S});return S.disposeIntermediateTensorInfo(ue),S.disposeIntermediateTensorInfo(ae),Se}(ft,Kt,tn,_);return Je&&_.disposeIntermediateTensorInfo(ft),Zt}const JC={kernelName:y.YoZ,backendName:"webgl",kernelFunc:lm},e1=Zo({opSnippet:Ou+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Lc+"\n  return result;\n",cpuKernelImpl:Iu}),t1={kernelName:y.BMI,backendName:"webgl",kernelFunc:e1},lg={kernelName:y.mTV,backendName:"webgl",kernelFunc:function sx(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b;la(k,"maxPool");const{filterSize:H,strides:Q,pad:ue,dimRoundingMode:ae}=S;y.D5U.assert(y.backend_util.eitherStridesOrDilationsAreOne(Q,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${Q} and dilations '1'`);const Ne=y.backend_util.computePool2DInfo(k.shape,H,Q,1,ue,ae);if(1===Ne.filterWidth&&1===Ne.filterHeight&&y.D5U.arraysEqual(Ne.inShape,Ne.outShape))return Wr({inputs:{x:k},backend:_});const Je=new bc(Ne,"max",!1);return _.runWebGLProgram(Je,[k],k.dtype)}},$0={kernelName:y.OAf,backendName:"webgl",kernelFunc:function cg(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{filterSize:H,strides:Q,pad:ue,dataFormat:ae,dimRoundingMode:Se}=S,Je=y.backend_util.computePool3DInfo(k.shape,H,Q,[1,1,1],ue,Se,ae),rt=new _p(Je,"max",!1);return _.runWebGLProgram(rt,[k],k.dtype)}};class B0{constructor(b){this.variableNames=["dy","maxPos"],this.outputShape=b.inShape;const H=b.effectiveFilterHeight,Q=b.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${H-1-b.padInfo.top}, ${Q-1-b.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${H};\n          wR += ${b.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${b.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${b.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${Q}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${b.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${b.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${H*Q-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${Q} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class V0{constructor(b){this.variableNames=["dy","maxPos"],this.outputShape=b.inShape;const ae=b.effectiveFilterDepth,Se=b.effectiveFilterHeight,Ne=b.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${ae-1-b.padInfo.front}, ${Se-1-b.padInfo.top}, ${Ne-1-b.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${ae};\n           wD += ${b.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${b.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${b.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${Se};\n              wR += ${b.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${b.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${b.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${Ne};\n                wC += ${b.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${b.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${b.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${ae*Se*Ne-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${Se} * ${Ne} +\n                  wR * ${Ne} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const $_={kernelName:y.OU7,backendName:"webgl",kernelFunc:function gf(C){const{inputs:b,backend:_,attrs:S}=C,{dy:k,input:H}=b,Q=H,{filterSize:ue,strides:ae,pad:Se,dimRoundingMode:Ne}=S,rt=y.backend_util.computePool3DInfo(Q.shape,ue,ae,[1,1,1],Se,Ne),ft=new _p(rt,"max",!0),Ot=_.runWebGLProgram(ft,[Q],Q.dtype),Kt=new V0(rt),tn=_.runWebGLProgram(Kt,[k,Ot],Q.dtype);return _.disposeIntermediateTensorInfo(Ot),tn}},ug={kernelName:y.OV7,backendName:"webgl",kernelFunc:function U0(C){const{inputs:b,backend:_,attrs:S}=C,{dy:k,input:H,output:Q}=b,ue=H;la([H,Q],"maxPoolGrad");const{filterSize:ae,strides:Se,pad:Ne,dimRoundingMode:Je}=S,rt=y.backend_util.computePool2DInfo(ue.shape,ae,Se,1,Ne,Je),Ot=new bc(rt,"max",!0),Kt=_.runWebGLProgram(Ot,[ue],ue.dtype),tn=new B0(rt),Zt=_.runWebGLProgram(tn,[k,Kt],ue.dtype);return _.disposeIntermediateTensorInfo(Kt),Zt}},Eu={kernelName:y.vFR,backendName:"webgl",kernelFunc:({inputs:C,attrs:b,backend:_})=>{const{x:S}=C,{filterSize:k,strides:H,pad:Q,includeBatchInIndex:ue}=b,ae=_;y.D5U.assert(4===S.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${S.shape.length}.`);const Se=[1,1];y.D5U.assert(y.backend_util.eitherStridesOrDilationsAreOne(H,Se),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${H} and dilations '${Se}'`);const Ne=y.backend_util.computePool2DInfo(S.shape,k,H,Se,Q),[Je,rt]=function dg(C,b,_,S){let k=new bc(_,"max",!1);const H=S.runWebGLProgram(k,[C],"float32");return k=new bc(_,"max",!0,!0,b),[H,S.runWebGLProgram(k,[C],"float32")]}(S,ue,Ne,ae);return[Je,rt]}},Xh={kernelName:y.q2K,backendName:"webgl",kernelFunc:({inputs:C,attrs:b,backend:_})=>{const{x:S}=C,{keepDims:k,axis:H}=b,Q=_,ue=S.shape.length,ae=y.D5U.parseAxisParam(H,S.shape);let Se=ae;const Ne=y.backend_util.getAxesPermutation(Se,ue),Je=null!=Ne,rt=Q.shouldExecuteOnCPU([S]),ft=[];let Ot=S;if(Je){if(rt){const us=Q.texData.get(Ot.dataId).values,Us=new Array(ue);for(let Sr=0;Sr<Us.length;Sr++)Us[Sr]=S.shape[Ne[Sr]];const _i=Bo(us,S.shape,S.dtype,Ne,Us);Ot=Q.makeTensorInfo(Us,S.dtype),Q.texData.get(Ot.dataId).values=_i}else Ot=Pn(S,Ne,Q);ft.push(Ot),Se=y.backend_util.getInnerMostAxes(Se.length,ue)}y.backend_util.assertAxesAreInnerMostDims("sum",Se,ue);const[Kt,tn]=y.backend_util.computeOutAndReduceShapes(Ot.shape,Se);let Zt=Kt;k&&(Zt=y.backend_util.expandShapeToKeepDim(Kt,ae));const hn=function B_(C,b,_,S){const k=y.D5U.sizeFromShape(b),ue=en({inputs:{x:C},attrs:{shape:[y.D5U.sizeFromShape(C.shape)/k,k]},backend:S}),ae=Fe(ue,"float32","mean",S),Se=en({inputs:{x:ae},attrs:{shape:_},backend:S});return S.disposeIntermediateTensorInfo(ue),S.disposeIntermediateTensorInfo(ae),Se}(Ot,tn,Zt,Q);for(const ts of ft)Q.disposeIntermediateTensorInfo(ts);return hn}},U_={kernelName:y.c17,backendName:"webgl",kernelFunc:function V_(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H,keepDims:Q}=S,ue=k.shape.length,ae=y.D5U.parseAxisParam(H,k.shape);let Se=ae;const Ne=y.backend_util.getAxesPermutation(Se,ue);let Je=k;null!=Ne&&(Je=An({inputs:{x:k},backend:_,attrs:{perm:Ne}}),Se=y.backend_util.getInnerMostAxes(Se.length,k.shape.length)),y.backend_util.assertAxesAreInnerMostDims("min",Se,ue);const[rt,ft]=y.backend_util.computeOutAndReduceShapes(Je.shape,Se),Kt=en({inputs:{x:Je},backend:_,attrs:{shape:[-1,y.D5U.sizeFromShape(ft)]}}),tn=Fe(Kt,Kt.dtype,"min",_);let Zt;return Zt=en(Q?{inputs:{x:tn},backend:_,attrs:{shape:y.backend_util.expandShapeToKeepDim(rt,ae)}}:{inputs:{x:tn},backend:_,attrs:{shape:rt}}),_.disposeIntermediateTensorInfo(Kt),_.disposeIntermediateTensorInfo(tn),null!=Ne&&_.disposeIntermediateTensorInfo(Je),Zt}},ix=Zo({opSnippet:Ou+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Lc+"\n  return result;\n",cpuKernelImpl:B}),z0={kernelName:y.q8u,backendName:"webgl",kernelFunc:ix};class Ta{constructor(b,_,S){this.variableNames=["x"],this.outputShape=_.map((Ne,Je)=>Ne[0]+b[Je]+Ne[1]);const k=b.length,H=mi(k),Q=_.map(Ne=>Ne[0]).join(","),ue=_.map((Ne,Je)=>Ne[0]+b[Je]).join(","),ae=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,k),Se="reflect"===S?0:1;this.userCode=1!==k?`\n      ${H} start = ${H}(${Q});\n      ${H} end = ${H}(${ue});\n\n      void main() {\n        ${H} outC = getOutputCoords();\n        for (int i = 0; i < ${k}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${Se};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${Se};\n          }\n        }\n        ${H} coords = outC - start;\n        setOutput(getX(${ae}));\n      }\n    `:`\n        int start = ${Q};\n        int end = ${ue};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${Se};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${Se};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class W0{constructor(b,_,S){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_.map((Ot,Kt)=>Ot[0]+b[Kt]+Ot[1]);const k=b.length,H=mi(k),Q=_.map(Ot=>Ot[0]).join(","),ue=_.map((Ot,Kt)=>Ot[0]+b[Kt]).join(","),ae=Gi("rc",k),Se=Gi("source",k),Ne=`${ae[k-1]} < ${this.outputShape[k-1]}`,Je=1===k?"source":`vec2(${Se.slice(-2).join()})`,rt="reflect"===S?0:1;let ft="";if(1===k){const Ot=`\n        ${H} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${rt};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${rt};\n        }\n        source -= start;\n      `;ft=`\n        ${H} rc = outputLoc;\n        ${Ot}\n        result[0] = getChannel(getX(${Se.join()}), ${Je});\n        ${ae[k-1]} += 1;\n        if(${Ne}) {\n          ${Ot}\n          result[1] = getChannel(getX(${Se.join()}), ${Je});\n        }\n      `}else{const Ot=`\n        ${H} source = rc;\n        ${H} lt = ${H}(lessThan(source, start));\n        ${H} gte = ${H}(greaterThanEqual(source, end));\n        ${H} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${rt}) +\n                gte * ((end - 1) * 2 - source + ${rt});\n        source -= start;\n      `;ft=`\n        ${H} rc = outputLoc;\n        ${Ot}\n        result[0] = getChannel(getX(${Se.join()}), ${Je});\n        ${ae[k-1]} += 1;\n        if(${Ne}) {\n          ${Ot}\n          result[1] = getChannel(getX(${Se.join()}), ${Je});\n        }\n        rc = outputLoc;\n        ${ae[k-2]} += 1;\n        if(${ae[k-2]} < ${this.outputShape[k-2]}) {\n          ${Ot}\n          result[2] = getChannel(getX(${Se.join()}), ${Je});\n          ${ae[k-1]} += 1;\n          if(${Ne}) {\n            ${Ot}\n            result[3] = getChannel(getX(${Se.join()}), ${Je});\n          }\n        }\n      `}this.userCode=`\n      const ${H} start = ${H}(${Q});\n      const ${H} end = ${H}(${ue});\n\n      void main() {\n        ${H} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${ft}\n        setOutput(result);\n      }\n    `}}const Du={kernelName:y.jQs,backendName:"webgl",kernelFunc:({inputs:C,backend:b,attrs:_})=>{const{x:S}=C,{paddings:k,mode:H}=_,Q=(0,y.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new W0(S.shape,k,H):new Ta(S.shape,k,H);return b.runWebGLProgram(Q,[S],S.dtype)}},pg=Zo({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Lc+"\n  return result;\n"}),tu={kernelName:y.Vbg,backendName:"webgl",kernelFunc:pg};class yf{constructor(b,_,S){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[b,S],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${_-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${_-1}));\n      }\n    `}}const kd=Zo({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),fg={kernelName:y.oHH,backendName:"webgl",kernelFunc:kd},W_="return a - b;",mg=Zo({opSnippet:W_,packedOpSnippet:W_,supportsComplex:!0,cpuKernelImpl:qt}),n1={kernelName:y.Tr8,backendName:"webgl",kernelFunc:mg};function H0(C){const{inputs:b,backend:_,attrs:S}=C,{logits:k}=b,{dim:H}=S,Q=y.D5U.parseAxisParam([H],k.shape),ue=lm({inputs:{x:k},backend:_,attrs:{reductionIndices:Q,keepDims:!1}}),ae=y.backend_util.expandShapeToKeepDim(ue.shape,Q),Se=en({inputs:{x:ue},backend:_,attrs:{shape:ae}}),Ne=mg({inputs:{a:k,b:Se},backend:_}),Je=Ze({inputs:{x:Ne},backend:_}),rt=Kn({inputs:{x:Je},backend:_,attrs:{axis:Q,keepDims:!1}}),ft=en({inputs:{x:rt},backend:_,attrs:{shape:ae}}),Ot=kd({inputs:{a:Je,b:ft},backend:_});return _.disposeIntermediateTensorInfo(ue),_.disposeIntermediateTensorInfo(Se),_.disposeIntermediateTensorInfo(Ne),_.disposeIntermediateTensorInfo(Je),_.disposeIntermediateTensorInfo(rt),_.disposeIntermediateTensorInfo(ft),Ot}const H_={kernelName:y.Gcp,backendName:"webgl",kernelFunc:H0},gg={kernelName:y.NZg,backendName:"webgl",kernelFunc:function s1(C){const{inputs:b,backend:_,attrs:S}=C,{logits:k}=b,{numSamples:H,seed:Q,normalized:ue}=S,ae=ue?k:H0({inputs:{logits:k},backend:_,attrs:{dim:k.shape.length-1}}),Je=new yf(ae.shape[0],ae.shape[1],H),ft=_.runWebGLProgram(Je,[ae],"int32",[[Q]]);return ue||_.disposeIntermediateTensorInfo(ae),ft}},bf=pe+"\n  return -x;\n",j_={kernelName:y.kuV,backendName:"webgl",kernelFunc:function Np(C){const{inputs:b,backend:_}=C,{x:S}=b;if(_.shouldExecuteOnCPU([S])){const H=_.texData.get(S.dataId),[Q,ue]=Be(H.values,S.shape,S.dtype);return _.makeTensorInfo(ue,S.dtype,Q)}let k;return k=(0,y.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new zr(S.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new z(S.shape,bf),_.runWebGLProgram(k,[S],S.dtype)}},j0=y.GDt.nonMaxSuppressionV3Impl,G0={kernelName:y.uv1,backendName:"webgl",kernelFunc:function G_(C){y.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:b,backend:_,attrs:S}=C,{boxes:k,scores:H}=b,{maxOutputSize:Q,iouThreshold:ue,scoreThreshold:ae}=S,Se=_.readSync(k.dataId),Ne=_.readSync(H.dataId),{selectedIndices:Je}=j0(Se,Ne,Q,ue,ae);return _.makeTensorInfo([Je.length],"int32",new Int32Array(Je))}},K_=y.GDt.nonMaxSuppressionV4Impl,cm={kernelName:y.cye,backendName:"webgl",kernelFunc:function Mp(C){y.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:b,backend:_,attrs:S}=C,{boxes:k,scores:H}=b,{maxOutputSize:Q,iouThreshold:ue,scoreThreshold:ae,padToMaxOutputSize:Se}=S,Ne=_.readSync(k.dataId),Je=_.readSync(H.dataId),{selectedIndices:rt,validOutputs:ft}=K_(Ne,Je,Q,ue,ae,Se);return[_.makeTensorInfo([rt.length],"int32",new Int32Array(rt)),_.makeTensorInfo([],"int32",new Int32Array([ft]))]}},X_=y.GDt.nonMaxSuppressionV5Impl,um={kernelName:y.W0H,backendName:"webgl",kernelFunc:function Y_(C){y.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:b,backend:_,attrs:S}=C,{boxes:k,scores:H}=b,{maxOutputSize:Q,iouThreshold:ue,scoreThreshold:ae,softNmsSigma:Se}=S,Ne=_.readSync(k.dataId),Je=_.readSync(H.dataId),rt=Q,ft=ue,Ot=ae,Kt=Se,{selectedIndices:tn,selectedScores:Zt}=X_(Ne,Je,rt,ft,Ot,Kt);return[_.makeTensorInfo([tn.length],"int32",new Int32Array(tn)),_.makeTensorInfo([Zt.length],"float32",new Float32Array(Zt))]}};class K0{constructor(b,_,S,k){this.variableNames=["indices"],this.outputShape=[b,_],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${k}), float(${S}),\n                      float(index == coords.y)));\n      }\n    `}}const Yh={kernelName:y.we_,backendName:"webgl",kernelFunc:C=>{const{inputs:b,backend:_,attrs:S}=C,{indices:k}=b,{dtype:H,depth:Q,onValue:ue,offValue:ae}=S,Se=y.D5U.sizeFromShape(k.shape),Ne=new K0(Se,Q,ue,ae),Je=en({inputs:{x:k},backend:_,attrs:{shape:[Se]}}),rt=_.runWebGLProgram(Ne,[Je],H);_.disposeIntermediateTensorInfo(Je);const Ot=en({inputs:{x:rt},backend:_,attrs:{shape:[...k.shape,Q]}});return _.disposeIntermediateTensorInfo(rt),Ot}};function Zh(C){const{inputs:b,backend:_}=C,{x:S}=b;if("complex64"===S.dtype){const k=Uo({inputs:{input:S},backend:_}),H=Zh({inputs:{x:k},backend:_}),Q=is({inputs:{input:S},backend:_}),ue=Zh({inputs:{x:Q},backend:_}),ae=Eo({inputs:{real:H,imag:ue},backend:_});return _.disposeIntermediateTensorInfo(k),_.disposeIntermediateTensorInfo(H),_.disposeIntermediateTensorInfo(Q),_.disposeIntermediateTensorInfo(ue),ae}return mr({attrs:{shape:S.shape,dtype:S.dtype,value:"string"===S.dtype?"":0},backend:_})}const Z_={kernelName:y.RuY,backendName:"webgl",kernelFunc:Zh},_g={kernelName:y.qWM,backendName:"webgl",kernelFunc:function Q_(C){const{inputs:b,backend:_}=C,{x:S}=b;if("string"===S.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===S.dtype){const k=Uo({inputs:{input:S},backend:_}),H=Q_({inputs:{x:k},backend:_}),Q=is({inputs:{input:S},backend:_}),ue=Zh({inputs:{x:Q},backend:_}),ae=Eo({inputs:{real:H,imag:ue},backend:_});return _.disposeIntermediateTensorInfo(k),_.disposeIntermediateTensorInfo(H),_.disposeIntermediateTensorInfo(Q),_.disposeIntermediateTensorInfo(ue),ae}return mr({attrs:{shape:S.shape,dtype:S.dtype,value:1},backend:_})}},wf={kernelName:y.QiL,backendName:"webgl",kernelFunc:function dm(C){const{inputs:b,backend:_,attrs:S}=C,{axis:k}=S;if(1===b.length)return Dt({inputs:{input:b[0]},backend:_,attrs:{dim:k}});const H=b[0].shape,Q=b[0].dtype;b.forEach(Ne=>{y.D5U.assertShapesMatch(H,Ne.shape,"All tensors passed to stack must have matching shapes"),y.D5U.assert(Q===Ne.dtype,()=>"All tensors passed to stack must have matching dtypes")});const ue=[],Se=pi({inputs:b.map(Ne=>{const Je=Dt({inputs:{input:Ne},backend:_,attrs:{dim:k}});return ue.push(Je),Je}),backend:_,attrs:{axis:k}});return ue.forEach(Ne=>_.disposeIntermediateTensorInfo(Ne)),Se}};class yg{constructor(b,_,S){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=_.map((Se,Ne)=>Se[0]+b[Ne]+Se[1]);const k=b.length,H=mi(k),Q=_.map(Se=>Se[0]).join(","),ue=_.map((Se,Ne)=>Se[0]+b[Ne]).join(","),ae=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,k);this.userCode=1!==k?`\n      ${H} start = ${H}(${Q});\n      ${H} end = ${H}(${ue});\n\n      void main() {\n        ${H} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${H} coords = outC - start;\n          setOutput(getX(${ae}));\n        }\n      }\n    `:`\n        int start = ${Q};\n        int end = ${ue};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class J_{constructor(b,_,S){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=_.map((Kt,tn)=>Kt[0]+b[tn]+Kt[1]);const k=b.length,H=mi(k),Q=_.map(Kt=>Kt[0]).join(","),ue=_.map((Kt,tn)=>Kt[0]+b[tn]).join(","),ae=Gi("rc",k),Se=Gi("source",k),Ne=`${ae[k-1]} < ${this.outputShape[k-1]}`,Je=1===k?"source":`vec2(${Se.slice(-2).join()})`,rt=[`${H} rc = outputLoc;`,`${ae[k-1]} += 1;\n       if(${Ne}) {\n      `,1===k?"":`}\n       rc = outputLoc;\n       ${ae[k-2]} += 1;\n       if(${ae[k-2]} < ${this.outputShape[k-2]}) {`,1===k?"":`  ${ae[k-1]} += 1;\n         if(${Ne}) {`],ft=1===k?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let Ot="";for(let Kt=0,tn=1===k?2:4;Kt<tn;Kt++)Ot+=`\n        ${rt[Kt]}\n        if (${ft}) {\n          result[${Kt}] = float(value);\n        } else {\n          ${H} source = rc - start;\n          result[${Kt}] = getChannel(getX(${Se.join()}), ${Je});\n        }\n      `;Ot+=1===k?"} ":"}}",this.userCode=`\n      const ${H} start = ${H}(${Q});\n      const ${H} end = ${H}(${ue});\n\n      void main() {\n        ${H} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${Ot}\n        setOutput(result);\n      }\n    `}}const Ch=C=>{const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{paddings:H,constantValue:Q}=S;if(0===y.D5U.sizeFromShape(k.shape))return mr({backend:_,attrs:{shape:H.map((Ne,Je)=>Ne[0]+k.shape[Je]+Ne[1]),value:Q,dtype:k.dtype}});const ue=(0,y.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new J_(k.shape,H,Q):new yg(k.shape,H,Q);return _.runWebGLProgram(ue,[k],k.dtype,[[Q]])},q_={kernelName:y.lyA,backendName:"webgl",kernelFunc:Ch},vg=Zo({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Lc+"\n  return result;\n"}),ey={kernelName:y.pe_,backendName:"webgl",kernelFunc:vg},ax={kernelName:y.DlI,backendName:"webgl",kernelFunc:function ty(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{axis:H,keepDims:Q}=S,ue=k.shape.length,ae=[],Se=y.D5U.parseAxisParam(H,k.shape);let Ne=Se;const Je=y.backend_util.getAxesPermutation(Ne,ue);let ft,rt=k;if(null!=Je&&(rt=An({inputs:{x:k},backend:_,attrs:{perm:Je}}),Ne=y.backend_util.getInnerMostAxes(Ne.length,ue),ae.push(rt)),y.backend_util.assertAxesAreInnerMostDims("prod",Ne,ue),_.shouldExecuteOnCPU([rt])){const Ot=_.texData.get(rt.dataId).values,{outVals:Kt,outShape:tn,outDtype:Zt}=st(rt.shape,rt.dtype,Ot,Ne);ft=_.makeTensorInfo(tn,Zt,Kt)}else{const[Ot,Kt]=y.backend_util.computeOutAndReduceShapes(rt.shape,Ne),tn=y.D5U.sizeFromShape(Kt),Zt=en({inputs:{x:rt},backend:_,attrs:{shape:[-1,tn]}}),ts=Fe(Zt,(0,y.z4k)(k.dtype),"prod",_);ft=en({inputs:{x:ts},backend:_,attrs:{shape:Ot}}),ae.push(Zt),ae.push(ts)}if(Q){ae.push(ft);const Ot=y.backend_util.expandShapeToKeepDim(ft.shape,Se);ft=en({inputs:{x:ft},backend:_,attrs:{shape:Ot}})}return ae.forEach(Ot=>_.disposeIntermediateTensorInfo(Ot)),ft}},Y0={kernelName:y.dDz,backendName:"webgl",kernelFunc:function hm(C){const{inputs:b,backend:_,attrs:S}=C,{paramsNestedSplits:k,paramsDenseValues:H,indices:Q}=b,{outputRaggedRank:ue}=S,ae=k.map(Zt=>_.readSync(Zt.dataId)),Se=k.map(Zt=>Zt.shape),Ne=_.readSync(H.dataId),Je=_.readSync(Q.dataId),[rt,ft,Ot]=Xt(ae,Se,Ne,H.shape,H.dtype,Je,Q.shape,ue),Kt=rt.map(Zt=>_.makeTensorInfo([Zt.length],"int32",Zt)),tn=_.makeTensorInfo(Ot,H.dtype,ft);return Kt.concat([tn])}},sy={kernelName:y.CQl,backendName:"webgl",kernelFunc:function ny(C){const{inputs:b,backend:_}=C,{starts:S,limits:k,deltas:H}=b,Q=_.readSync(S.dataId),ue=_.readSync(k.dataId),ae=_.readSync(H.dataId),[Se,Ne]=jt(Q,S.shape,S.dtype,ue,k.shape,ae,H.shape);return[_.makeTensorInfo([Se.length],"int32",Se),_.makeTensorInfo([Ne.length],S.dtype,Ne)]}},bg={kernelName:y.BiW,backendName:"webgl",kernelFunc:function ry(C){const{inputs:b,backend:_,attrs:S}=C,{shape:k,values:H,defaultValue:Q,rowPartitionTensors:ue}=b,{rowPartitionTypes:ae}=S,Se=_.readSync(k.dataId),Ne=_.readSync(H.dataId),Je=_.readSync(Q.dataId),rt=ue.map(tn=>_.readSync(tn.dataId)),ft=ue.map(tn=>tn.shape),[Ot,Kt]=Yt(Se,k.shape,Ne,H.shape,H.dtype,Je,Q.shape,rt,ft,ae);return _.makeTensorInfo(Ot,H.dtype,Kt)}},xg=C=>{const{backend:b,attrs:_}=C,{start:S,stop:k,step:H,dtype:Q}=_,ue=xn(S,k,H,Q);return b.makeTensorInfo([ue.length],Q,ue)},pm={kernelName:y.e6w,backendName:"webgl",kernelFunc:xg},fm=ks({opSnippet:"return 1.0 / x;"}),Z0={kernelName:y.$HU,backendName:"webgl",kernelFunc:fm},Cf=ks({opSnippet:pe+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),wg={kernelName:y.qkr,backendName:"webgl",kernelFunc:Cf},Eg=ks({opSnippet:pe+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),a1={kernelName:y.SbG,backendName:"webgl",kernelFunc:Eg};class Dg{constructor(b,_,S,k,H){this.variableNames=["A"],this.outputShape=[];const[Q,ue,ae,Se]=b;this.outputShape=[Q,_,S,Se];const Ne=[k&&_>1?ue-1:ue,k&&S>1?ae-1:ae],Je=[k&&_>1?_-1:_,k&&S>1?S-1:S];let rt;rt=H?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${Ne[0]/Je[0]},\n          ${Ne[1]/Je[1]});\n      const vec2 inputShapeRC = vec2(${ue}.0, ${ae}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${rt};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class lx{constructor(b,_,S,k,H){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[Q,ue,ae,Se]=b;this.outputShape=[Q,_,S,Se];const Ne=[k&&_>1?ue-1:ue,k&&S>1?ae-1:ae],Je=[k&&_>1?_-1:_,k&&S>1?S-1:S];let rt;rt=H?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${Ne[0]/Je[0]},\n          ${Ne[1]/Je[1]},\n          ${Ne[1]/Je[1]});\n      const vec3 inputShapeRC = vec3(${ue}.0, ${ae}.0,\n                                     ${ae}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${rt};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${Se-1};\n        bool hasNextRow = coords.z < ${S-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Sg={kernelName:y._Yw,backendName:"webgl",kernelFunc:function Ef(C){const{inputs:b,backend:_,attrs:S}=C,{images:k}=b,{alignCorners:H,halfPixelCenters:Q,size:ue}=S,[ae,Se]=ue,Ne=(0,y.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lx(k.shape,ae,Se,H,Q):new Dg(k.shape,ae,Se,H,Q);return _.runWebGLProgram(Ne,[k],"float32")}};class Ig{constructor(b,_,S){this.variableNames=["dy"],this.outputShape=[],this.outputShape=_;const[,k,H]=_,[,Q,ue]=b,ae=[S&&Q>1?k-1:k,S&&ue>1?H-1:H],Se=[S&&Q>1?Q-1:Q,S&&ue>1?ue-1:ue],Ne=ae[0]/Se[0],Je=ae[1]/Se[1],rt=1/Ne,ft=1/Je,Ot=2*Math.ceil(rt)+2,Kt=2*Math.ceil(ft)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${Ne});\n        const float widthScale = float(${Je});\n\n        const float invHeightScale = float(${rt});\n        const float invWidthScale = float(${ft});\n\n        const int winHeight = int(${Ot});\n        const int winWidth = int(${Kt});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${Q}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${ue}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${k-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${H-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Q0={kernelName:y.zbQ,backendName:"webgl",kernelFunc:function Lp(C){const{inputs:b,backend:_,attrs:S}=C,{images:k,dy:H}=b,{alignCorners:Q}=S,ue=new Ig(H.shape,k.shape,Q);return _.runWebGLProgram(ue,[H],H.dtype)}};class J0{constructor(b,_,S,k,H){this.variableNames=["A"],this.outputShape=[];const[Q,ue,ae,Se]=b;this.outputShape=[Q,_,S,Se];const Ne=[k&&_>1?ue-1:ue,k&&S>1?ae-1:ae],Je=[k&&_>1?_-1:_,k&&S>1?S-1:S];let ft;ft=H?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${Ne[0]/Je[0]},\n          ${Ne[1]/Je[1]});\n      const vec2 inputShapeRC = vec2(${ue}.0, ${ae}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${ft};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${k?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Tg{constructor(b,_,S,k,H){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[Q,ue,ae,Se]=b;this.outputShape=[Q,_,S,Se];const Ne=[k&&_>1?ue-1:ue,k&&S>1?ae-1:ae],Je=[k&&_>1?_-1:_,k&&S>1?S-1:S];let ft;ft=H?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${Ne[0]/Je[0]},\n          ${Ne[1]/Je[1]},\n          ${Ne[1]/Je[1]});\n      const vec3 inputShapeRC = vec3(${ue}.0, ${ae}.0,\n                                     ${ae}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${ft};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${k?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${Se-1};\n        bool hasNextRow = coords.z < ${S-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const iy={kernelName:y.dpD,backendName:"webgl",kernelFunc:function cx(C){const{inputs:b,backend:_,attrs:S}=C,{images:k}=b,{alignCorners:H,halfPixelCenters:Q,size:ue}=S,[ae,Se]=ue,Ne=(0,y.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Tg(k.shape,ae,Se,H,Q):new J0(k.shape,ae,Se,H,Q);return _.runWebGLProgram(Ne,[k],k.dtype)}};class ux{constructor(b,_,S){this.variableNames=["dy"],this.outputShape=[],this.outputShape=_;const[,k,H]=_,[,Q,ue]=b,ae=[S&&Q>1?k-1:k,S&&ue>1?H-1:H],Se=[S&&Q>1?Q-1:Q,S&&ue>1?ue-1:ue],Ne=ae[0]/Se[0],Je=ae[1]/Se[1],rt=1/Ne,ft=1/Je,Ot=2*Math.ceil(rt)+2,Kt=2*Math.ceil(ft)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${Ne});\n        const float widthScale = float(${Je});\n\n        const float invHeightScale = float(${rt});\n        const float invWidthScale = float(${ft});\n\n        const int winHeight = int(${Ot});\n        const int winWidth = int(${Kt});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${Q}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${ue}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${ae[0]}) *\n                (float(dyR) / float(${Se[0]}));\n\n            float sourceFracCol =\n                float(${ae[1]}) *\n                  (float(dyC) / float(${Se[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${k}) - 1),\n                ${S} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${H}) - 1),\n                ${S} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const mm={kernelName:y.Hmb,backendName:"webgl",kernelFunc:function $p(C){const{inputs:b,backend:_,attrs:S}=C,{images:k,dy:H}=b,{alignCorners:Q}=S,ue=new ux(H.shape,k.shape,Q);return _.runWebGLProgram(ue,[H],H.dtype)}};class q0{constructor(b,_){this.variableNames=["x"];const S=b.length;if(S>4)throw new Error(`WebGL backend: Reverse of rank-${S} tensor is not yet supported`);if(this.outputShape=b,1===S)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${b[0]} - coord - 1));\n        }\n      `);const H=b.map((ue,ae)=>(ue=>-1!==_.indexOf(ue)&&1!==b[ue]?`${b[ue]} - coords[${ue}] - 1`:`coords[${ue}]`)(ae)).join(","),Q=mi(S);this.userCode=`\n      void main() {\n        ${Q} coords = getOutputCoords();\n        setOutput(getX(${H}));\n      }\n    `}}class ev{constructor(b,_){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const S=b.length;if(S>4)throw new Error(`WebGL backend: Reverse of rank-${S} tensor is not yet supported`);this.outputShape=b;const k=Gi("rc",S),H=`${k[S-1]} + 1 < ${this.outputShape[S-1]}`,Q=`${k[S-2]} + 1 < ${this.outputShape[S-2]}`,ue=mi(S);function rt(Ot){const Kt=b.map((hn,ts)=>function ft(Ot,Kt){return-1!==_.indexOf(Ot)&&1!==b[Ot]?`${b[Ot]} - ${Kt[Ot]} - 1`:`${Kt[Ot]}`}(ts,Ot));return`getChannel(getX(${Kt.join(",")}), vec2(${Kt.slice(-2).join(",")}))`}this.userCode=1===S?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${b[0]} - rc - 1),\n            ${b[0]} - rc - 1);\n          if(${H}){\n              result.g = getChannel(getX(${b[0]} - (rc  + 1) - 1),\n                ${b[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${ue} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function ae(Ot){return rt(Ot)}(k.slice())};\n          if(${H}){\n            result.g = ${function Se(Ot){return Ot[S-1]="("+Ot[S-1]+" + 1)",rt(Ot)}(k.slice())};\n          }\n          if(${Q}) {\n            result.b = ${function Ne(Ot){return Ot[S-2]="("+Ot[S-2]+" + 1)",rt(Ot)}(k.slice())};\n            if(${H}) {\n              result.a = ${function Je(Ot){return Ot[S-1]="("+Ot[S-1]+" + 1)",Ot[S-2]="("+Ot[S-2]+" + 1)",rt(Ot)}(k.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const gm={kernelName:y.mKl,backendName:"webgl",kernelFunc:function oy(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{dims:H}=S,Q=k.shape.length,ue=y.D5U.parseAxisParam(H,k.shape);if(0===Q)return Wr({inputs:{x:k},backend:_});const ae=(0,y.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ev(k.shape,ue):new q0(k.shape,ue);return _.runWebGLProgram(ae,[k],k.dtype)}};class Qh{constructor(b,_){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const S=b[1],k=b[2];this.outputShape=b;let H="";H="number"==typeof _?`float outputValue = ${_.toFixed(2)};`:`\n        vec3 fill = vec3(${_.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${H}\n          if(coordX >= 0 && coordX < ${k} && coordY >= 0 && coordY < ${S}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const tv={kernelName:y.b9H,backendName:"webgl",kernelFunc:({inputs:C,attrs:b,backend:_})=>{const{image:S}=C,{radians:k,fillValue:H,center:Q}=b,ue=_,ae=new Qh(S.shape,H),[Se,Ne]=y.backend_util.getImageCenter(Q,S.shape[1],S.shape[2]),Je=[[Se,Ne,Math.sin(k),Math.cos(k)]];return ue.runWebGLProgram(ae,[S],S.dtype,Je)}},nv=ks({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),sv={kernelName:y.e07,backendName:"webgl",kernelFunc:nv},Lu=ks({opSnippet:"return inversesqrt(x);",cpuKernelImpl:ss}),Od={kernelName:y.bV0,backendName:"webgl",kernelFunc:Lu};class Ag{constructor(b,_,S,k,H,Q,ue=!0,ae=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=Q;const Se=mi(H.length),Ne=mi(Q.length);let Je="";1===S?Je="i":2===S&&(Je="i, j");let ft="";1===k?ft="i":2===k&&(ft="i, coords[1]");let Kt="";ae&&(Kt="coords[0], coords[1]"),this.userCode=`\n        ${Se} strides = ${Se}(${H});\n\n        void main() {\n          ${Ne} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${b}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${_}; j++) {\n              int index = round(getIndices(${Je}));\n              flattenedIndex += index * ${_>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${ft});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${Kt}), sum, float(found)));\n        }\n      `}}class rv{constructor(b,_,S,k,H,Q,ue=!0,ae=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Q;const Se=mi(H.length),Ne=mi(Q.length);let Je="";1===S?Je="i":2===S&&(Je="i, j");let ft="";1===k?ft="i":2===k&&(ft="i, coords[1]");let Kt="";ae&&(Kt="coords[0], coords[1]"),this.userCode=`\n        ${Se} strides = ${Se}(${H});\n\n        void main() {\n          ${Ne} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${b}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${_}; j+=2) {\n              ivec4 index = round(getIndices(${Je}));\n              flattenedIndex += index.xz * ${_>1?"strides[j]":"strides"};\n              if (j + 1 < ${_}) {\n                flattenedIndex += index.yw * ${_>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${ft});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${Kt}), sum, found));\n        }\n      `}}const ov={kernelName:y.xQA,backendName:"webgl",kernelFunc:function iv(C){const{inputs:b,backend:_,attrs:S}=C,{indices:k,updates:H}=b,{shape:Q}=S,{sliceRank:ue,numUpdates:ae,sliceSize:Se,strides:Ne,outputSize:Je}=y.backend_util.calculateShapes(H,k,Q),rt=[Je/Se,Se];if(0===Je)return _.makeTensorInfo(Q,k.dtype);const ft=en({inputs:{x:k},backend:_,attrs:{shape:[ae,ue]}}),Ot=en({inputs:{x:H},backend:_,attrs:{shape:[ae,Se]}}),Kt=_.makeTensorInfo([],"float32",new Float32Array([0]));let tn;tn=(0,y.OBj)().getBool("WEBGL_PACK")?new rv(ae,ue,ft.shape.length,Ot.shape.length,Ne,rt):new Ag(ae,ue,ft.shape.length,Ot.shape.length,Ne,rt);const Zt=_.runWebGLProgram(tn,[Ot,ft,Kt],Ot.dtype),hn=en({inputs:{x:Zt},backend:_,attrs:{shape:Q}});return _.disposeIntermediateTensorInfo(ft),_.disposeIntermediateTensorInfo(Ot),_.disposeIntermediateTensorInfo(Zt),_.disposeIntermediateTensorInfo(Kt),hn}};class av{constructor(b,_,S,k){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[b,S];const Q=`for (int i = 0; i < ${Math.ceil(Math.log2(_+1))}; ++i) { if (left >= right) break;`,ue=2===(0,y.OBj)().getNumber("WEBGL_VERSION")?"while (left < right) {":Q;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${ue}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===k?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const ay={kernelName:y.nr8,backendName:"webgl",kernelFunc:function lv(C){const{inputs:b,backend:_,attrs:S}=C,{sortedSequence:k,values:H}=b,{side:Q}=S,ue=new av(k.shape[0],k.shape[1],H.shape[1],Q);return _.runWebGLProgram(ue,[k,H],"int32",[[k.shape[1]]])}};class cv{constructor(b,_,S){let k,H;if(this.variableNames=["c","a","b"],this.outputShape=_,S>4)throw Error(`Where for rank ${S} is not yet supported`);if(1===S)H="resRC",k="resRC";else{const ue=["resRC.x","resRC.y","resRC.z","resRC.w"],ae=[],Se=[];for(let Ne=0;Ne<_.length;Ne++)Se.push(`${ue[Ne]}`),Ne<b&&ae.push(`${ue[Ne]}`);k=ae.join(),H=Se.join()}const Q=mi(S);this.userCode=`\n      void main() {\n        ${Q} resRC = getOutputCoords();\n        float cVal = getC(${k});\n        if (cVal >= 1.0) {\n          setOutput(getA(${H}));\n        } else {\n          setOutput(getB(${H}));\n        }\n      }\n    `}}const dv={kernelName:y.PhF,backendName:"webgl",kernelFunc:function uv(C){const{inputs:b,backend:_}=C,{condition:S,t:k,e:H}=b,Q=new cv(S.shape.length,k.shape,k.shape.length);return _.runWebGLProgram(Q,[S,k,H],(0,y.x8V)(k.dtype,H.dtype))}},kg=ks({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${y.backend_util.SELU_SCALEALPHA};\n  float scale = ${y.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),eh={kernelName:y.oFR,backendName:"webgl",kernelFunc:kg},hv=ks({opSnippet:Do+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:_r}),ly={kernelName:y.a5O,backendName:"webgl",kernelFunc:hv},mx=ks({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),l1={kernelName:y.i5y,backendName:"webgl",kernelFunc:mx},c1=ks({opSnippet:Do+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Lc}\n  return result;\n`}),u1={kernelName:y.RQH,backendName:"webgl",kernelFunc:c1},pv=ks({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),fv={kernelName:y.wYB,backendName:"webgl",kernelFunc:pv},_x=ks({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),mv={kernelName:y.MRv,backendName:"webgl",kernelFunc:_x},gv={kernelName:y.TQc,backendName:"webgl",kernelFunc:C=>{const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{blockShape:H,paddings:Q}=S;y.D5U.assert(k.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const ue=H.reduce((Zt,hn)=>Zt*hn),ae=[[0,0]];ae.push(...Q);for(let Zt=1+H.length;Zt<k.shape.length;++Zt)ae.push([0,0]);const Se=[],Ne=Ch({inputs:{x:k},backend:_,attrs:{paddings:ae,constantValue:0}}),Je=y.backend_util.getReshaped(Ne.shape,H,ue,!1),rt=y.backend_util.getPermuted(Je.length,H.length,!1),ft=y.backend_util.getReshapedPermuted(Ne.shape,H,ue,!1),Ot=en({inputs:{x:Ne},backend:_,attrs:{shape:Je}}),Kt=An({inputs:{x:Ot},backend:_,attrs:{perm:rt}}),tn=en({inputs:{x:Kt},backend:_,attrs:{shape:ft}});return Se.push(Ne),Se.push(Ot),Se.push(Kt),Se.forEach(Zt=>_.disposeIntermediateTensorInfo(Zt)),tn}},yx={kernelName:y.O3z,backendName:"webgl",kernelFunc:function cy(C){const{inputs:b,backend:_}=C,{indices:S,values:k,denseShape:H,defaultValue:Q}=b;if(1!==H.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${H.shape}`);if(2!==S.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${S.shape}`);if(1!==k.shape.length)throw new Error(`Values must be a vector, saw:\n         ${k.shape}`);if(0!==Q.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${Q.shape}`);const ue=_.readSync(S.dataId),ae=_.readSync(k.dataId),Se=_.readSync(H.dataId),Ne=_.readSync(Q.dataId)[0],[Je,rt,ft,Ot,Kt]=cn(ue,S.shape,S.dtype,ae,k.dtype,Se,Ne);return[_.makeTensorInfo(rt,S.dtype,Je),_.makeTensorInfo([rt[0]],k.dtype,ft),_.makeTensorInfo([Ot.length],"bool",new Uint8Array(Ot.map(tn=>Number(tn)))),_.makeTensorInfo([Kt.length],S.dtype,new Int32Array(Kt))]}},vx={kernelName:y.nhH,backendName:"webgl",kernelFunc:function nu(C){const{inputs:b,backend:_}=C,{inputIndices:S,inputShape:k,newShape:H}=b;if(2!==S.shape.length)throw new Error(`Input indices should be a matrix but received shape ${S.shape}`);if(1!==k.shape.length)throw new Error(`Input shape should be a vector but received shape ${k.shape}`);if(1!==H.shape.length)throw new Error(`Target shape should be a vector but received shape ${H.shape}`);const Q=Array.from(_.readSync(k.dataId)),ue=_.readSync(S.dataId),ae=Array.from(_.readSync(H.dataId)),[Se,Ne,Je]=Zr(ue,S.shape,S.dtype,Q,ae);return[_.makeTensorInfo(Ne,S.dtype,Se),_.makeTensorInfo([Je.length],H.dtype,new Int32Array(Je))]}},uy={kernelName:y.w3H,backendName:"webgl",kernelFunc:function bx(C){const{inputs:b,backend:_}=C,{data:S,indices:k,segmentIds:H}=b;if(S.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==k.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${k.shape}`);if(1!==H.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${H.shape}`);const Q=_.readSync(S.dataId),ue=_.readSync(k.dataId),ae=_.readSync(H.dataId),[Se,Ne]=jn(Q,S.shape,S.dtype,ue,ae,!0);return _.makeTensorInfo(Ne,S.dtype,Se)}},xx={kernelName:y.ZjV,backendName:"webgl",kernelFunc:function _v(C){const{inputs:b,backend:_}=C,{data:S,indices:k,segmentIds:H}=b;if(S.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==k.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${k.shape}`);if(1!==H.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${H.shape}`);const Q=_.readSync(S.dataId),ue=_.readSync(k.dataId),ae=_.readSync(H.dataId),[Se,Ne]=jn(Q,S.shape,S.dtype,ue,ae);return _.makeTensorInfo(Ne,S.dtype,Se)}},Cx={kernelName:y.D2d,backendName:"webgl",kernelFunc:function wx(C){const{inputs:b,backend:_,attrs:S}=C,{sparseIndices:k,sparseValues:H,defaultValue:Q}=b,{outputShape:ue}=S,{sliceRank:ae,numUpdates:Se,sliceSize:Ne,strides:Je,outputSize:rt}=y.backend_util.calculateShapes(H,k,ue);if("string"===H.dtype){const Zt=_.bufferSync(k),hn=_.bufferSync(H),ts=y.D5U.decodeString(_.readSync(Q.dataId)[0]),us=Jn(Zt,hn,ue,rt,Ne,Se,ae,Je,ts,!1);return _.makeTensorInfo(ue,us.dtype,us.values)}const Ot=new Ag(Se,ae,k.shape.length,H.shape.length,Je,[rt,1],!1),Kt=_.runWebGLProgram(Ot,[H,k,Q],H.dtype),tn=en({inputs:{x:Kt},backend:_,attrs:{shape:ue}});return _.disposeIntermediateTensorInfo(Kt),tn}},yv={kernelName:y.L8s,backendName:"webgl",kernelFunc:function Ex(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{numOrSizeSplits:H,axis:Q}=S,ue=y.D5U.parseAxisParam(Q,k.shape)[0],ae=y.backend_util.prepareSplitSize(k,H,ue),Ne=new Array(k.shape.length).fill(0),Je=k.shape.slice();return ae.map(rt=>{const ft=[...Je];ft[ue]=rt;const Ot=Dd({inputs:{x:k},backend:_,attrs:{begin:Ne,size:ft}});return Ne[ue]+=rt,Ot})}},Dx="return sqrt(x);",h1=ks({opSnippet:Dx,packedOpSnippet:Dx,cpuKernelImpl:Oi}),_m={kernelName:y.FKq,backendName:"webgl",kernelFunc:h1},ym=ks({opSnippet:"return x * x;"}),vv={kernelName:y.bK0,backendName:"webgl",kernelFunc:ym},dy="return (a - b) * (a - b);",hy=Zo({opSnippet:dy,packedOpSnippet:dy}),py={kernelName:y._tC,backendName:"webgl",kernelFunc:hy},bv={kernelName:y.e0R,backendName:"webgl",kernelFunc:function Sx(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b;if("string"!==k.dtype)throw new Error("Input must be of datatype string");const H=_.readSync(k.dataId),Q=y.backend_util.fromUint8ToStringArray(H),ue=ca(Q,"string",S);return _.makeTensorInfo(k.shape,"string",ue)}},Mg={kernelName:y.h8e,backendName:"webgl",kernelFunc:function xv({inputs:C,attrs:b,backend:_}){const{x:S}=C,H=new z(S.shape,pe+`\n    return x > 0.0 ? 1.0 : float(${b.alpha});\n  `);return _.runWebGLProgram(H,[S],S.dtype)}};class p1{constructor(b,_,S){this.variableNames=["x"],this.outputShape=S;const k=S.length,H=mi(S.length),Q=mi(S.length);let ue="";if(1===k)ue="coords * strides + begin";else{let ae=0;ue=S.map((Se,Ne)=>(ae++,1===S.length?`coords * strides[${Ne}] + begin[${Ne}]`:`coords[${ae-1}] * strides[${Ne}] + begin[${Ne}]`)).join(",")}this.userCode=`\n      ${H} begin = ${H}(${b});\n      ${H} strides = ${H}(${_});\n\n      void main() {\n        ${Q} coords = getOutputCoords();\n        setOutput(getX(${ue}));\n      }\n    `}}const Ix={kernelName:y.jQk,backendName:"webgl",kernelFunc:function fy(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{begin:H,end:Q,strides:ue,beginMask:ae,endMask:Se,ellipsisMask:Ne,newAxisMask:Je,shrinkAxisMask:rt}=S,{finalShapeSparse:ft,finalShape:Ot,isIdentity:Kt,sliceDim0:tn,isSimpleSlice:Zt,begin:hn,end:ts,strides:us}=y.kuN.sliceInfo(k.shape,H,Q,ue,ae,Se,Ne,Je,rt);let Us;if(Kt)Us=en({inputs:{x:k},backend:_,attrs:{shape:Ot}});else if(tn||Zt){y.D5U.assert(k.shape.length>=1,()=>`Input must have rank at least 1, got: ${k.shape.length}`);const ii=y.kuN.computeOutShape(hn,ts,us),Sr=Dd({inputs:{x:k},backend:_,attrs:{begin:hn,size:ii}});Us=en({inputs:{x:Sr},backend:_,attrs:{shape:Ot}}),_.disposeIntermediateTensorInfo(Sr)}else if(_.shouldExecuteOnCPU([k])){const Sr=_.readSync(k.dataId),vo=(0,y.f3b)(k.shape,k.dtype,Sr),Ti=Yo(ft,vo,us,hn);Us=_.makeTensorInfo(Ot,k.dtype,Ti.values)}else{const Sr=new p1(hn,us,ft);Us=_.runWebGLProgram(Sr,[k],k.dtype)}const _i=en({inputs:{x:Us},backend:_,attrs:{shape:Ot}});return _.disposeIntermediateTensorInfo(Us),_i}},wv={kernelName:y._JP,backendName:"webgl",kernelFunc:function my(C){const{inputs:b,backend:_,attrs:S}=C,{separator:k,nGramWidths:H,leftPad:Q,rightPad:ue,padWidth:ae,preserveShortSequences:Se}=S,{data:Ne,dataSplits:Je}=b,rt=_.readSync(Ne.dataId),ft=_.readSync(Je.dataId),[Ot,Kt]=La(rt,ft,k,H,Q,ue,ae,Se);return[_.makeTensorInfo([Ot.length],"string",Ot),_.makeTensorInfo(Je.shape,"int32",Kt)]}},Bp={kernelName:y.s1s,backendName:"webgl",kernelFunc:function Pg(C){const{inputs:b,backend:_,attrs:S}=C,{skipEmpty:k}=S,{input:H,delimiter:Q}=b;if("string"!==H.dtype)throw new Error("Input must be of datatype string");if(1!==H.shape.length)throw new Error(`Input must be a vector, got shape: ${H.shape}`);if(0!==Q.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${Q.shape}`);const ue=_.readSync(H.dataId),ae=_.readSync(Q.dataId)[0],[Se,Ne,Je]=hi(ue,ae,k),rt=Ne.length;return[_.makeTensorInfo([rt,2],"int32",Se),_.makeTensorInfo([rt],"string",Ne),_.makeTensorInfo([2],"int32",new Int32Array(Je))]}},vm={kernelName:y.XkS,backendName:"webgl",kernelFunc:function Tx(C){const{inputs:b,backend:_,attrs:S}=C,{numBuckets:k}=S,{input:H}=b;if("string"!==H.dtype)throw new Error("Input must be of datatype string");if(k<=0)throw new Error("Number of buckets must be at least 1");const Q=_.readSync(H.dataId),ue=ci(Q,k);return _.makeTensorInfo(H.shape,"int32",ue)}},Ax=ks({opSnippet:"return tan(x);"}),bm={kernelName:y.sEM,backendName:"webgl",kernelFunc:Ax},Yu=ks({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Fg={kernelName:y.MIZ,backendName:"webgl",kernelFunc:Yu},Cv={kernelName:y.SIB,backendName:"webgl",kernelFunc:function yy(C){const{inputs:b,backend:_}=C,{tensor:k,indices:H,updates:Q}=b,{sliceRank:ue,numUpdates:ae,sliceSize:Se,strides:Ne,outputSize:Je}=y.backend_util.calculateShapes(Q,H,k.shape),rt=[Je/Se,Se];if(0===Je)return _.makeTensorInfo(k.shape,H.dtype);const ft=en({inputs:{x:H},backend:_,attrs:{shape:[ae,ue]}}),Ot=en({inputs:{x:Q},backend:_,attrs:{shape:[ae,Se]}}),Kt=en({inputs:{x:k},backend:_,attrs:{shape:rt}}),tn=new Ag(ae,ue,ft.shape.length,Ot.shape.length,Ne,rt,!1,!0),Zt=_.runWebGLProgram(tn,[Ot,ft,Kt],Kt.dtype),hn=en({inputs:{x:Zt},backend:_,attrs:{shape:k.shape}});return _.disposeIntermediateTensorInfo(ft),_.disposeIntermediateTensorInfo(Ot),_.disposeIntermediateTensorInfo(Kt),_.disposeIntermediateTensorInfo(Zt),hn}};class Ev{constructor(b,_){this.variableNames=["A"];const S=new Array(b.length);for(let Q=0;Q<S.length;Q++)S[Q]=b[Q]*_[Q];this.outputShape=S,this.rank=S.length;const k=mi(this.rank),H=function vy(C){const b=C.length;if(b>5)throw Error(`Tile for rank ${b} is not yet supported`);if(1===b)return`imod(resRC, ${C[0]})`;const _=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],S=[];for(let k=0;k<C.length;k++)S.push(`imod(${_[k]}, ${C[k]})`);return S.join()}(b);this.userCode=`\n      void main() {\n        ${k} resRC = getOutputCoords();\n        setOutput(getA(${H}));\n      }\n    `}}function Jh(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{reps:H}=S;if("string"===k.dtype||k.shape.length>5){const ae=_.readSync(k.dataId),Se="string"===k.dtype?ae.map(rt=>y.D5U.decodeString(rt)):ae,Ne=(0,y.f3b)(k.shape,k.dtype,Se),Je=jl(Ne,H);return _.makeTensorInfo(Je.shape,Je.dtype,Je.values)}const Q=new Ev(k.shape,H);return _.runWebGLProgram(Q,[k],k.dtype)}const kx={kernelName:y.n9L,backendName:"webgl",kernelFunc:Jh};class Ox{constructor(b){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=b,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Rx{constructor(b){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=b,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Eh(C,b){null!==b&&C.disposeIntermediateTensorInfo(b)}function Sf(C){let b=1;for(;b<C;)b*=2;return b}const Dv={kernelName:y.cWu,backendName:"webgl",kernelFunc:function Nx(C){const{inputs:b,backend:_,attrs:S}=C,{x:k}=b,{k:H,sorted:Q}=S,ue=(0,y.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),ae=(0,y.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),Se=k.shape,Ne=Se[Se.length-1];if(_.shouldExecuteOnCPU([k])||Ne<ue||H>ae){const Ti=_.readSync(k.dataId),[Aa,ql]=oo(Ti,Se,k.dtype,H,Q);return[_.makeTensorInfo(Aa.shape,Aa.dtype,Aa.values),_.makeTensorInfo(ql.shape,ql.dtype,ql.values)]}if(0===H)return Se[Se.length-1]=0,[_.makeTensorInfo(Se,k.dtype,[]),_.makeTensorInfo(Se,"int32",[])];if(1===Ne)return[k,mr({attrs:{shape:Se,dtype:"int32",value:0},backend:_})];const Je=_.texData.get(k.dataId),rt=null!==Je&&Je.isPacked,ft=rt?_.unpackTensor(k):k,Kt=y.D5U.sizeFromShape(Se)/Ne,tn=en({inputs:{x:ft},attrs:{shape:[Kt,Ne]},backend:_});rt&&Eh(_,ft);const Zt=Sf(H),hn=Sf(Ne);let ts=null;const us=()=>null===ts?[tn,tn]:[tn,ts],Us=(Ti,Aa,ql)=>{const cd=us(),$u=new Ox(ql),Zu=ts;ts=_.runWebGLProgram($u,cd,"int32",[[Ne],[null===ts?1:0],[Number.NEGATIVE_INFINITY],[Ti],[Aa]]),Eh(_,Zu)};for(let Ti=1;Ti<Zt;Ti*=2){const Aa=2*Ti;for(let ql=Ti;ql>=1;ql/=2)Us(Aa,ql,[Kt,hn])}for(let Ti=hn;Ti>Zt;Ti/=2){const Aa=us(),ql=new Rx([Kt,Ti/2]),Bu=ts;ts=_.runWebGLProgram(ql,Aa,"int32",[[Ne],[null===ts?1:0],[Zt]]),Eh(_,Bu);const su=Zt/2,Zu=2*su;for(let lc=su;lc>=1;lc/=2)Us(Zu,lc,ts.shape)}let _i=ts;ts=Dd({inputs:{x:ts},backend:_,attrs:{begin:0,size:[Kt,H]}}),Eh(_,_i);let ii=jh({inputs:{x:tn,indices:ts},backend:_,attrs:{axis:1,batchDims:1}});Eh(_,tn);const Sr=Se.slice(0,-1);Sr.push(H),_i=ts,ts=en({inputs:{x:ts},attrs:{shape:Sr},backend:_}),Eh(_,_i);const vo=ii;return ii=en({inputs:{x:ii},attrs:{shape:Sr},backend:_}),Eh(_,vo),[ii,ts]}};class qh{constructor(b,_,S,k,H,Q){this.variableNames=["Image","Transforms"],this.outputShape=Q;const ue="nearest"===S?1:2;let ae;switch(k){case"constant":default:ae=1;break;case"reflect":ae=2;break;case"wrap":ae=3;break;case"nearest":ae=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${ae} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${ae} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${ae} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${b} && 0 <= coordX && coordX < ${_}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${H});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${H});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${_}));\n                float mapY = mapCoord(inY, float(${b}));\n\n                if (${ue} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const ac={kernelName:y.wx7,backendName:"webgl",kernelFunc:function f1(C){const{inputs:b,backend:_,attrs:S}=C,{image:k,transforms:H}=b,{interpolation:Q,fillMode:ue,fillValue:ae,outputShape:Se}=S,[Ne,Je,rt,ft]=k.shape,[Ot,Kt]=Se??[Je,rt],Zt=new qh(Je,rt,Q,ue,ae,[Ne,Ot,Kt,ft]);return _.runWebGLProgram(Zt,[k,H],"float32")}},Mx={kernelName:y.kpP,backendName:"webgl",kernelFunc:function by(C){const{inputs:b,attrs:_,backend:S}=C,{axis:k}=_,{x:H}=b;la(H,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const Q=S.readSync(H.dataId),{outputValues:ue,outputShape:ae,indices:Se}=wi(Q,k,H.shape,H.dtype);return[S.makeTensorInfo(ae,H.dtype,ue),S.makeTensorInfo([Se.length],"int32",Se)]}},g1={kernelName:y.ToN,backendName:"webgl",kernelFunc:function m1(C){const{inputs:b,backend:_,attrs:S}=C,{value:k}=b;let{axis:H}=S;H<0&&(H+=k.shape.length);const Q=k,ue=Q.shape.length,ae=k.shape[H],Se=new Array(ue-1);let Ne=0;for(let Kt=0;Kt<ue;Kt++)Kt!==H&&(Se[Ne++]=Q.shape[Kt]);const Je=[],rt=new Array(ue).fill(0),ft=Q.shape.slice();ft[H]=1;const Ot=new Array(ae);for(let Kt=0;Kt<Ot.length;Kt++){rt[H]=Kt;const tn=Dd({inputs:{x:Q},backend:_,attrs:{begin:rt,size:ft}}),Zt=en({inputs:{x:tn},backend:_,attrs:{shape:Se}});Ot[Kt]=Zt,Je.push(tn)}return Je.forEach(Kt=>_.disposeIntermediateTensorInfo(Kt)),Ot}};class Lg{constructor(b,_){this.variableNames=["x","segmentIds"];const S=b.windowSize,k=b.batchSize,H=b.inSize,Q=b.numSegments,ue=Q*Math.ceil(H/S);this.outputShape=[k,ue];const Ne=4*Math.floor(S/4),Je=S%4,rt="\n        sumValue += dot(values, segFilter);\n    ";let ft="";H%S>0&&(ft=`\n        if (inIdx < 0 || inIdx >= ${H}) {\n          return initializationValue;\n        }\n      `);let Ot="";H%S>0&&(Ot=`\n        if (inIdx < 0 || inIdx >= ${H}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${ft}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${Ot}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${Q})) * float(${S}));\n        int currentSeg = int(mod(float(outIdx), float(${Q})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${Ne}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${rt}\n        }\n\n        int inIdx = inOffset + ${Ne};\n        if (${1===Je}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${rt}\n        } else if (${2===Je}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${rt}\n        } else if (${3===Je}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${rt}\n        }\n        setOutput(sumValue);\n      }\n    `}}const wy=[So,Qo,cl,Ud,Vf,Zp,dh,Qp,du,hh,Jp,od,Wd,$h,Hd,Pc,ad,jf,tf,Gf,rf,lf,mh,gh,_h,Uh,Xf,vt,Ol,un,Xr,da,El,zc,Ep,E0,yh,Zf,Jf,qf,w_,C_,Jm,E_,ns,zh,Wh,S_,I_,wu,Zd,sg,ff,se,ct,Ht,wn,Ii,_a,ul,na,Ml,Ku,Op,k_,Hb,jb,ig,O_,Mo,Xu,js,Kb,A0,O0,Nc,R0,Xb,im,M0,F_,XC,Jb,L_,tx,ZC,JC,t1,lg,$0,$_,ug,Eu,Xh,U_,z0,Du,tu,gg,dn,j_,G0,cm,um,Va,Yh,_g,wf,q_,ey,wd,ax,Y0,sy,bg,pm,Xl,fg,Z0,wg,a1,re,Sg,Q0,iy,mm,gm,tv,sv,Od,ov,ay,dv,eh,ly,l1,u1,fv,af,H_,mv,gv,yx,vx,uy,xx,Cx,yv,_m,vv,py,bv,Mg,Ix,wv,Bp,vm,n1,Ln,bm,Fg,Cv,kx,Dv,ac,vs,Mx,g1,{kernelName:y.Qvg,backendName:"webgl",kernelFunc:function Px(C){const{inputs:b,backend:_,attrs:S}=C,{x:k,segmentIds:H}=b,{numSegments:Q}=S,ue=k.shape.length,ae=[];let Se=0;const Ne=y.backend_util.getAxesPermutation([Se],ue);let Je=k;null!=Ne&&(Je=An({inputs:{x:k},backend:_,attrs:{perm:Ne}}),ae.push(Je),Se=y.backend_util.getInnerMostAxes(1,ue)[0]);const rt=y.backend_util.segment_util.computeOutShape(Je.shape,Se,Q),ft=y.D5U.sizeFromShape([Je.shape[Se]]),Ot=en({inputs:{x:Je},backend:_,attrs:{shape:[-1,ft]}});ae.push(Ot);const Kt=(0,y.z4k)(k.dtype),tn=(us,Us,_i,ii,Sr)=>{const vo=us.shape[0],Ti=us.shape[1],Aa=y.backend_util.segment_util.segOpComputeOptimalWindowSize(Ti,Sr),cd=new Lg({windowSize:Aa,inSize:Ti,batchSize:vo,numSegments:Sr},Us),$u=_.compileAndRun(cd,[us,_i],ii);if(ae.push($u),$u.shape[1]===Sr)return $u;const Bu=xg({backend:_,attrs:{start:0,stop:Sr,step:1,dtype:"float32"}}),su=Jh({inputs:{x:Bu},backend:_,attrs:{reps:[Ti/Aa]}});return ae.push(Bu),ae.push(su),tn($u,Us,su,ii,Sr)},hn=en({inputs:{x:tn(Ot,"unsortedSegmentSum",H,Kt,Q)},backend:_,attrs:{shape:rt}});let ts=hn;if(null!=Ne){ae.push(hn);const us=y.backend_util.getUndoAxesPermutation(Ne);ts=An({inputs:{x:ts},backend:_,attrs:{perm:us}})}return ae.forEach(us=>_.disposeIntermediateTensorInfo(us)),ts}},Z_];for(const C of wy)(0,y.wCN)(C)},7926:(Et,le,h)=>{"use strict";h.d(le,{g_:()=>Ca,Ue:()=>Te,YL:()=>Pa,fM:()=>Ea,iw:()=>oe,gJ:()=>_l});var U={};h.r(U),h.d(U,{json:()=>bn});var Z={};h.r(Z),h.d(Z,{json:()=>Qn});var y={};h.r(y),h.d(y,{json:()=>Dn});var F={};h.r(F),h.d(F,{json:()=>ps});var I={};h.r(I),h.d(I,{json:()=>Es});var N={};h.r(N),h.d(N,{json:()=>Xn});var W={};h.r(W),h.d(W,{json:()=>Ts});var l={};h.r(l),h.d(l,{json:()=>or});var w={};h.r(w),h.d(w,{json:()=>Ir});var M={};h.r(M),h.d(M,{json:()=>Ss});var T={};h.r(T),h.d(T,{json:()=>Qe});var D={};h.r(D),h.d(D,{json:()=>Lt});var G={};h.r(G),h.d(G,{json:()=>Qt});var J={};h.r(J),h.d(J,{json:()=>Nn});var K={};h.r(K),h.d(K,{json:()=>Os});var _e={};h.r(_e),h.d(_e,{json:()=>zs});var Re={};h.r(Re),h.d(Re,{json:()=>cr});var we={};h.r(we),h.d(we,{json:()=>xr});var We={};h.r(We),h.d(We,{json:()=>$r});var Oe={};h.r(Oe),h.d(Oe,{OP_SCOPE_SUFFIX:()=>qe.zvA,abs:()=>qe.WnP,acos:()=>qe.Khb,acosh:()=>qe.__u,add:()=>qe.IHx,addN:()=>qe.QBD,all:()=>qe.$6P,any:()=>qe.YjB,argMax:()=>qe.NqF,argMin:()=>qe.vHJ,asin:()=>qe.ZRM,asinh:()=>qe.VfV,atan:()=>qe.z4N,atan2:()=>qe.fvJ,atanh:()=>qe.C80,avgPool:()=>qe.wS1,avgPool3d:()=>qe.uR5,basicLSTMCell:()=>qe.zEQ,batchNorm:()=>qe.tgs,batchNorm2d:()=>qe.Dxk,batchNorm3d:()=>qe.JY5,batchNorm4d:()=>qe.p3b,batchToSpaceND:()=>qe.E4h,bincount:()=>qe.yE8,bitwiseAnd:()=>qe.ycw,booleanMaskAsync:()=>qe.anm,broadcastArgs:()=>qe.XsQ,broadcastTo:()=>qe.UFq,buffer:()=>qe.f3b,cast:()=>qe.pju,ceil:()=>qe.mDi,clipByValue:()=>qe.iUl,clone:()=>qe.d9v,complex:()=>qe.PYB,concat:()=>qe.zoF,concat1d:()=>qe.gME,concat2d:()=>qe.Izb,concat3d:()=>qe.MNy,concat4d:()=>qe.ZaL,conv1d:()=>qe.PAt,conv2d:()=>qe.Tek,conv2dTranspose:()=>qe.bc,conv3d:()=>qe.pdZ,conv3dTranspose:()=>qe.$QV,cos:()=>qe.mCk,cosh:()=>qe.f9Y,cosineWindow:()=>qe.mew,cumprod:()=>qe.$Gn,cumsum:()=>qe.zbp,denseBincount:()=>qe.ppE,depthToSpace:()=>qe.nTT,depthwiseConv2d:()=>qe.B10,diag:()=>qe.Ka3,dilation2d:()=>qe.WmZ,div:()=>qe.hiC,divNoNan:()=>qe.NTj,dot:()=>qe.AKD,dropout:()=>qe.rvX,einsum:()=>qe.WYO,elu:()=>qe.pyx,enclosingPowerOfTwo:()=>qe.GRh,ensureShape:()=>qe.EDe,equal:()=>qe.DgJ,erf:()=>qe.qNN,euclideanNorm:()=>qe.d2q,exp:()=>qe.Qqt,expandDims:()=>qe.dt4,expm1:()=>qe.t$B,eye:()=>qe.iyy,fft:()=>qe.kp_,fill:()=>qe.hlL,floor:()=>qe.GWj,floorDiv:()=>qe.qPi,fused:()=>qe.imm,gather:()=>qe.Iqj,gatherND:()=>qe.dbB,greater:()=>qe.pjt,greaterEqual:()=>qe.brS,ifft:()=>qe.Sxn,imag:()=>qe.asL,image:()=>qe.BHj,inTopKAsync:()=>qe.V3u,irfft:()=>qe.wx0,isFinite:()=>qe.xVT,isInf:()=>qe.UWc,isNaN:()=>qe.i2d,leakyRelu:()=>qe.hi7,less:()=>qe.d9m,lessEqual:()=>qe.zN1,linalg:()=>qe.$r2,linspace:()=>qe.SX3,localResponseNormalization:()=>qe.G9k,log:()=>qe.cM7,log1p:()=>qe.Krr,logSigmoid:()=>qe.e_t,logSoftmax:()=>qe.CmS,logSumExp:()=>qe.l_t,logicalAnd:()=>qe.HvI,logicalNot:()=>qe.hJK,logicalOr:()=>qe.K5V,logicalXor:()=>qe.egP,losses:()=>qe.MB5,lowerBound:()=>qe.eab,matMul:()=>qe.OI3,max:()=>qe.Fp7,maxPool:()=>qe._sB,maxPool3d:()=>qe.YQQ,maxPoolWithArgmax:()=>qe.Ip$,maximum:()=>qe.gWQ,mean:()=>qe.J69,meshgrid:()=>qe.ry_,min:()=>qe.VV$,minimum:()=>qe.LTh,mirrorPad:()=>qe.VdP,mod:()=>qe.wQq,moments:()=>qe.Gi7,movingAverage:()=>qe.p_,mul:()=>qe.dC7,multiRNNCell:()=>qe.rq4,multinomial:()=>qe.SJ_,neg:()=>qe.W76,norm:()=>qe.KOy,notEqual:()=>qe.Quu,oneHot:()=>qe.lfX,ones:()=>qe.iUs,onesLike:()=>qe.JpU,op:()=>qe.op,outerProduct:()=>qe.N2O,pad:()=>qe.vku,pad1d:()=>qe.pNR,pad2d:()=>qe.koy,pad3d:()=>qe.t1L,pad4d:()=>qe.lGY,pool:()=>qe.d_R,pow:()=>qe.sQ3,prelu:()=>qe.AL3,print:()=>qe.S0v,prod:()=>qe.WVs,raggedGather:()=>qe.$gW,raggedRange:()=>qe.VT$,raggedTensorToTensor:()=>qe.N89,rand:()=>qe.TN_,randomGamma:()=>qe.wzB,randomNormal:()=>qe.nGf,randomStandardNormal:()=>qe.ruB,randomUniform:()=>qe.LGj,randomUniformInt:()=>qe.pe5,range:()=>qe.w6H,real:()=>qe.kwC,reciprocal:()=>qe.M25,relu:()=>qe.UYe,relu6:()=>qe.btT,reshape:()=>qe.XLQ,reverse:()=>qe.GYS,reverse1d:()=>qe.SDf,reverse2d:()=>qe.diP,reverse3d:()=>qe.sx7,reverse4d:()=>qe.mG2,rfft:()=>qe.QEs,round:()=>qe.NMM,rsqrt:()=>qe.bp0,scalar:()=>qe.iD$,scatterND:()=>qe.snQ,searchSorted:()=>qe.zcT,selu:()=>qe.U8D,separableConv2d:()=>qe.U_I,setdiff1dAsync:()=>qe.ODp,sigmoid:()=>qe.XD2,sign:()=>qe.Xxe,signal:()=>qe.tdS,sin:()=>qe.O$l,sinh:()=>qe.R_K,slice:()=>qe.tPi,slice1d:()=>qe.jZU,slice2d:()=>qe.SmN,slice3d:()=>qe.CnO,slice4d:()=>qe.p0P,softmax:()=>qe.XAC,softplus:()=>qe.Wvh,spaceToBatchND:()=>qe.fBT,sparse:()=>qe.rVs,sparseToDense:()=>qe.ers,spectral:()=>qe.uN7,split:()=>qe.Vl2,sqrt:()=>qe._b3,square:()=>qe.h62,squaredDifference:()=>qe.$i,squeeze:()=>qe.L9e,stack:()=>qe.knu,step:()=>qe.Nbs,stridedSlice:()=>qe.NXj,string:()=>qe.Z_8,sub:()=>qe.luU,sum:()=>qe.Smz,tan:()=>qe.ORZ,tanh:()=>qe.AEp,tensor:()=>qe.XeE,tensor1d:()=>qe.RRF,tensor2d:()=>qe.odF,tensor3d:()=>qe.wOQ,tensor4d:()=>qe.yXz,tensor5d:()=>qe.Bfx,tensor6d:()=>qe.xZs,tensorScatterUpdate:()=>qe.Pg0,tile:()=>qe.Gg6,topk:()=>qe.hg7,transpose:()=>qe.p4s,truncatedNormal:()=>qe.Xu6,unique:()=>qe.Two,unsortedSegmentSum:()=>qe.pUJ,unstack:()=>qe.HHK,upperBound:()=>qe.GaM,variable:()=>qe.VD$,where:()=>qe.arb,whereAsync:()=>qe.itS,zeros:()=>qe.lls,zerosLike:()=>qe.P84});var ie=h(9075);(0,ie.OBj)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,q=>{q&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var de,De=h(5861),te=function(q){return q[q.DT_INVALID=0]="DT_INVALID",q[q.DT_FLOAT=1]="DT_FLOAT",q[q.DT_DOUBLE=2]="DT_DOUBLE",q[q.DT_INT32=3]="DT_INT32",q[q.DT_UINT8=4]="DT_UINT8",q[q.DT_INT16=5]="DT_INT16",q[q.DT_INT8=6]="DT_INT8",q[q.DT_STRING=7]="DT_STRING",q[q.DT_COMPLEX64=8]="DT_COMPLEX64",q[q.DT_INT64=9]="DT_INT64",q[q.DT_BOOL=10]="DT_BOOL",q[q.DT_QINT8=11]="DT_QINT8",q[q.DT_QUINT8=12]="DT_QUINT8",q[q.DT_QINT32=13]="DT_QINT32",q[q.DT_BFLOAT16=14]="DT_BFLOAT16",q[q.DT_QINT16=15]="DT_QINT16",q[q.DT_QUINT16=16]="DT_QUINT16",q[q.DT_UINT16=17]="DT_UINT16",q[q.DT_COMPLEX128=18]="DT_COMPLEX128",q[q.DT_HALF=19]="DT_HALF",q[q.DT_RESOURCE=20]="DT_RESOURCE",q[q.DT_VARIANT=21]="DT_VARIANT",q[q.DT_UINT32=22]="DT_UINT32",q[q.DT_UINT64=23]="DT_UINT64",q[q.DT_FLOAT_REF=101]="DT_FLOAT_REF",q[q.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",q[q.DT_INT32_REF=103]="DT_INT32_REF",q[q.DT_UINT8_REF=104]="DT_UINT8_REF",q[q.DT_INT16_REF=105]="DT_INT16_REF",q[q.DT_INT8_REF=106]="DT_INT8_REF",q[q.DT_STRING_REF=107]="DT_STRING_REF",q[q.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",q[q.DT_INT64_REF=109]="DT_INT64_REF",q[q.DT_BOOL_REF=110]="DT_BOOL_REF",q[q.DT_QINT8_REF=111]="DT_QINT8_REF",q[q.DT_QUINT8_REF=112]="DT_QUINT8_REF",q[q.DT_QINT32_REF=113]="DT_QINT32_REF",q[q.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",q[q.DT_QINT16_REF=115]="DT_QINT16_REF",q[q.DT_QUINT16_REF=116]="DT_QUINT16_REF",q[q.DT_UINT16_REF=117]="DT_UINT16_REF",q[q.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",q[q.DT_HALF_REF=119]="DT_HALF_REF",q[q.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",q[q.DT_VARIANT_REF=121]="DT_VARIANT_REF",q[q.DT_UINT32_REF=122]="DT_UINT32_REF",q[q.DT_UINT64_REF=123]="DT_UINT64_REF",q}(te||{});!function(q){let L;var X;(X=L=q.CheckpointFormatVersion||(q.CheckpointFormatVersion={}))[X.LEGACY=0]="LEGACY",X[X.V1=1]="V1",X[X.V2=2]="V2"}(de||(de={}));const P={};function oe(q,L){P[q]={tfOpName:q,category:"custom",inputs:[],attrs:[],customExecutor:L}}function ye(q){return P[q]}function Te(q){delete P[q]}function v(q,L,X,Ae,He){const Ye=L.inputParams[q];if(Ye&&void 0!==Ye.inputIndexStart){const _t=Ye.inputIndexStart,wt=0===Ye.inputIndexEnd?void 0:void 0===Ye.inputIndexEnd?_t+1:Ye.inputIndexEnd,kn=_t<0?L.inputNames.length+_t:_t;if("tensor"===Ye.type)return at(L.inputNames[kn],X,Ae,He);if("tensors"===Ye.type){const os=L.inputs.slice(_t,wt);return L.inputNames.slice(_t,wt).filter((Tr,Cr)=>{var Is;return"NoOp"!==(null===(Is=os[Cr])||void 0===Is?void 0:Is.op)}).map(Tr=>at(Tr,X,Ae,He))}const pn=at(L.inputNames[kn],X,Ae,He),qn=pn.dataSync();return"number"===Ye.type?qn[0]:ie.D5U.toNestedArray(pn.shape,qn)}const it=L.attrParams[q];return it&&it.value}function at(q,L,X,Ae){const[He,Ye]=Ct(q,X);if(null!=Ae){const _t=Ae.getHashTableHandleByName(He);if(null!=_t)return _t}const it=X.currentContextIds.find(_t=>!!L[pt(He,_t)]);return void 0!==it?L[pt(He,it)][Ye]:void 0}function Xe(q,L,X){return L[pt(q,X.currentContextId)]}function Ue(q,L){const[X,Ae,He]=Ct(q,L);return[pt(X,L&&L.currentContextId),Ae,He]}function pt(q,L){return L?`${q}-${L}`:q}function Ct(q,L){if(""===q)return["",0,void 0];const X=null!=L&&null!=L.parseNodeNameCache;if(X){const Ye=L.parseNodeNameCache.get(q);if(null!=Ye)return Ye}const Ae=q.split(":");let He;if(1===Ae.length)He=[q,0,void 0];else{const it=3===Ae.length?Ae[1]:void 0;He=[Ae[0],Number(Ae[Ae.length-1]),it]}return X&&L.parseNodeNameCache.set(q,He),He}function nn(q,L,X){let Ae=v("pad",q,L,X);if("explicit"===Ae){Ae=v("explicitPaddings",q,L,X);const He=[[0,0],[0,0],[0,0],[0,0]];for(let Ye=0;Ye<4;Ye++)He[Ye][0]=Ae[2*Ye],He[Ye][1]=Ae[2*Ye+1];return He}return Ae}function Bt(q){return q.kept?q:(0,ie.d9v)(q)}const bn=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qn=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Dn=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],ps=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Es=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Xn=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ts=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],or=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ir=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Ss=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Qe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Lt=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Qt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Nn=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Os=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],zs=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],cr=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],xr=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],$r=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class eo{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const X=[].concat(...[U,Z,y,F,I,N,W,l,w,M,T,D,G,J,K,_e,Re,we,We].map(Ae=>Ae.json));this.opMappers=X.reduce((Ae,He)=>(Ae[He.tfOpName]=He,Ae),{})}transformGraph(L,X={}){const He=[],Ye=[],it=[],_t=L.node.reduce((Cr,Is)=>(Cr[Is.name]=this.mapNode(Is),Is.op.startsWith("Placeholder")?He.push(Cr[Is.name]):"Const"===Is.op?Ye.push(Cr[Is.name]):(null==Is.input||0===Is.input.length)&&it.push(Cr[Is.name]),Cr),{});let wt=[];const kn=[];let pn={},qn={};null!=X&&(pn=this.mapSignatureEntries(X.inputs),qn=this.mapSignatureEntries(X.outputs));const os=Object.keys(_t);os.forEach(Cr=>{const Is=_t[Cr];Is.inputNames.forEach((lr,yo)=>{const[Da,,Jt]=Ue(lr),ai=_t[Da];if(null!=ai.outputs){const oc=ai.outputs.indexOf(Jt);-1!==oc&&(Is.inputNames[yo]=`${Da}:${oc}`)}Is.inputs.push(ai),ai.children.push(Is)})}),0===Object.keys(qn).length?os.forEach(Cr=>{const Is=_t[Cr];0===Is.children.length&&kn.push(Is)}):Object.keys(qn).forEach(Cr=>{const[Is]=Ue(Cr),lr=_t[Is];null!=lr&&(lr.signatureKey=qn[Cr],kn.push(lr))}),Object.keys(pn).length>0?Object.keys(pn).forEach(Cr=>{const[Is]=Ue(Cr),lr=_t[Is];lr&&(lr.signatureKey=pn[Cr],wt.push(lr))}):wt=He;let Ms={};null!=L.library&&null!=L.library.function&&(Ms=L.library.function.reduce((Cr,Is)=>(Cr[Is.signature.name]=this.mapFunction(Is),Cr),{}));const Tr={nodes:_t,inputs:wt,outputs:kn,weights:Ye,placeholders:He,signature:X,functions:Ms};return it.length>0&&(Tr.initNodes=it),Tr}mapSignatureEntries(L){return Object.keys(L||{}).reduce((X,Ae)=>(X[L[Ae].name]=Ae,X),{})}mapNode(L){const X=ye(L.op)||this.opMappers[L.op]||{};null==L.attr&&(L.attr={});const Ae={name:L.name,op:L.op,category:X.category,inputNames:(L.input||[]).map(He=>He.startsWith("^")?He.slice(1):He),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:L.attr,outputs:X.outputs};return null!=X.inputs&&(Ae.inputParams=X.inputs.reduce((He,Ye)=>(He[Ye.name]={type:Ye.type,inputIndexStart:Ye.start,inputIndexEnd:Ye.end},He),{})),null!=X.attrs&&(Ae.attrParams=X.attrs.reduce((He,Ye)=>{const it=Ye.type;let _t;switch(Ye.type){case"string":_t=Po(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=Po(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"string[]":_t=rl(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=rl(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"number":_t=za(L.attr,Ye.tfName,Ye.defaultValue||0),void 0===_t&&Ye.tfDeprecatedName&&(_t=za(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"number[]":_t=to(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=to(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"bool":_t=xa(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=xa(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"bool[]":_t=Fo(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=Fo(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"shape":_t=ka(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=ka(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"shape[]":_t=Wa(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=Wa(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"dtype":_t=Ao(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=Ao(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"dtype[]":_t=Ho(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=Ho(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"func":_t=lo(L.attr,Ye.tfName,Ye.defaultValue),void 0===_t&&Ye.tfDeprecatedName&&(_t=lo(L.attr,Ye.tfDeprecatedName,Ye.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${Ye.type} for op: ${L.op}`)}return He[Ye.name]={value:_t,type:it},He},{})),Ae}mapFunction(L){const X=L.nodeDef,He=[];let Ye={};null!=X&&(Ye=X.reduce((qn,os)=>(qn[os.name]=this.mapNode(os),"Const"===os.op&&He.push(qn[os.name]),qn),{}));const it=[],_t=[];L.signature.inputArg.forEach(qn=>{const[os]=Ue(qn.name),Ms={name:os,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:To(qn.type),type:"dtype"}},children:[]};Ms.signatureKey=qn.name,it.push(Ms),Ye[os]=Ms}),Object.keys(Ye).forEach(qn=>{const os=Ye[qn];os.inputNames.forEach((Ms,Tr)=>{const[Cr,,Is]=Ue(Ms),lr=Ye[Cr];if(null!=lr.outputs){const yo=lr.outputs.indexOf(Is);-1!==yo&&(os.inputNames[Tr]=`${Cr}:${yo}`)}os.inputs.push(lr),lr.children.push(os)})});const kn=L.ret;L.signature.outputArg.forEach(qn=>{const[os,Ms]=Ue(kn[qn.name]),Tr=Ye[os];null!=Tr&&(Tr.defaultOutput=Ms,_t.push(Tr))});const pn=this.mapArgsToSignature(L);return{nodes:Ye,inputs:it,outputs:_t,weights:He,placeholders:[],signature:pn}}mapArgsToSignature(L){return{methodName:L.signature.name,inputs:L.signature.inputArg.reduce((X,Ae)=>(X[Ae.name]=this.mapArgToTensorInfo(Ae),X),{}),outputs:L.signature.outputArg.reduce((X,Ae)=>(X[Ae.name]=this.mapArgToTensorInfo(Ae,L.ret),X),{})}}mapArgToTensorInfo(L,X){let Ae=L.name;return null!=X&&(Ae=X[Ae]),{name:Ae,dtype:L.type}}}function aa(q,L){const X=Array.isArray(q)?String.fromCharCode.apply(null,q):function oa(q){const L=(0,ie.OBj)().global;if(typeof L.atob<"u")return L.atob(q);if(typeof Buffer<"u")return new Buffer(q,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(q);return L?X:X.toLowerCase()}function Po(q,L,X,Ae=!1){const He=q[L];return null!=He?aa(He.s,Ae):X}function xa(q,L,X){const Ae=q[L];return Ae?Ae.b:X}function za(q,L,X){const Ae=q[L]||{},He=null!=Ae.i?Ae.i:null!=Ae.f?Ae.f:X;return"number"==typeof He?He:parseInt(He,10)}function To(q){switch("string"==typeof q&&(q=te[q]),q){case te.DT_FLOAT:case te.DT_HALF:return"float32";case te.DT_INT32:case te.DT_INT64:case te.DT_INT8:case te.DT_UINT8:return"int32";case te.DT_BOOL:return"bool";case te.DT_DOUBLE:return"float32";case te.DT_STRING:return"string";default:return null}}function lo(q,L,X){const Ae=q[L];return Ae&&Ae.func?Ae.func.name:X}function Ao(q,L,X){const Ae=q[L];return Ae&&Ae.type?To(Ae.type):X}function Ho(q,L,X){const Ae=q[L];return Ae&&Ae.list&&Ae.list.type?Ae.list.type.map(He=>To(He)):X}function sl(q){if(!q.unknownRank)return null!=q.dim?q.dim.map(L=>"number"==typeof L.size?L.size:parseInt(L.size,10)):[]}function ka(q,L,X){const Ae=q[L];return Ae&&Ae.shape?sl(Ae.shape):X}function to(q,L,X){const Ae=q[L];return Ae?((Ae.list.f&&Ae.list.f.length?Ae.list.f:Ae.list.i)||[]).map(He=>"number"==typeof He?He:parseInt(He,10)):X}function rl(q,L,X,Ae=!1){const He=q[L];return He&&He.list&&He.list.s?He.list.s.map(Ye=>aa(Ye,Ae)):X}function Wa(q,L,X){const Ae=q[L];return Ae&&Ae.list&&Ae.list.shape?Ae.list.shape.map(He=>sl(He)):X}function Fo(q,L,X){const Ae=q[L];return Ae&&Ae.list&&Ae.list.b?Ae.list.b:X}class Ha{constructor(L,X,Ae){this.node=L,this.tensorMap=X,this.context=Ae,this.inputs=[],this.attrs={},this.inputs=L.inputNames.map(He=>this.getInput(He)),null!=L.rawAttrs&&(this.attrs=Object.keys(L.rawAttrs).reduce((He,Ye)=>(He[Ye]=this.getAttr(Ye),He),{}))}getInput(L){return at(L,this.tensorMap,this.context)}getAttr(L,X){const Ae=this.node.rawAttrs[L];if(null!=Ae.tensor)return at(L,this.tensorMap,this.context);if(null!=Ae.i||null!=Ae.f)return za(this.node.rawAttrs,L,X);if(null!=Ae.s)return Po(this.node.rawAttrs,L,X);if(null!=Ae.b)return xa(this.node.rawAttrs,L,X);if(null!=Ae.shape)return ka(this.node.rawAttrs,L,X);if(null!=Ae.type)return Ao(this.node.rawAttrs,L,X);if(null!=Ae.list){if(null!=Ae.list.i||null!=Ae.list.f)return to(this.node.rawAttrs,L,X);if(null!=Ae.list.s)return rl(this.node.rawAttrs,L,X);if(null!=Ae.list.shape)return Wa(this.node.rawAttrs,L,X);if(null!=Ae.list.b)return Fo(this.node.rawAttrs,L,X);if(null!=Ae.list.type)return Ho(this.node.rawAttrs,L,X)}return X}}var Jr,qe=h(3667);function ui(q,L,X=""){if("number"!=typeof q&&"number"!=typeof L){ie.D5U.assert(q.length===L.length,()=>X+` Shapes ${q} and ${L} must match`);for(let Ae=0;Ae<q.length;Ae++){const He=q[Ae],Ye=L[Ae];ie.D5U.assert(He<0||Ye<0||He===Ye,()=>X+` Shapes ${q} and ${L} must match`)}}}function ja(q){return!("number"==typeof q||q.some(L=>L<0))}function Go(q,L,X){let Ae=Li(q,X);const He=!ja(Ae);if(He&&0===L.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${Ae}`);if(He&&L.forEach(Ye=>{Ae=Li(Ye.shape,Ae)}),!ja(Ae))throw new Error(`Non-fully-defined elementShape: ${Ae}`);return Ae}function Li(q,L){if("number"==typeof q)return L;if("number"==typeof L)return q;if(q.length!==L.length)throw new Error(`Incompatible ranks during merge: ${q} vs. ${L}`);const X=[];for(let Ae=0;Ae<q.length;++Ae){const He=q[Ae],Ye=L[Ae];if(He>=0&&Ye>=0&&He!==Ye)throw new Error(`Incompatible shape during merge: ${q} vs. ${L}`);X[Ae]=He>=0?He:Ye}return X}class wa{constructor(L,X,Ae,He,Ye,it,_t){this.name=L,this.dtype=X,this.maxSize=Ae,this.elementShape=He,this.identicalElementShapes=Ye,this.dynamicSize=it,this.clearAfterRead=_t,this.tensors=[],this.closed_=!1,this.idTensor=(0,ie.iD$)(0),(0,ie.CnY)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(L){this.tensors.forEach(X=>{(null==L||!L.has(X.tensor.id))&&X.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(L){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(L<0||L>=this.size())throw new Error(`Tried to read from index ${L}, but array size is: ${this.size()}`);const X=this.tensors[L];if(X.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${L} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(X.cleared=!0),X.read=!0,X.tensor}readMany(L){return L.map(X=>this.read(X))}write(L,X){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(L<0||!this.dynamicSize&&L>=this.maxSize)throw new Error(`Tried to write to index ${L}, but array is not resizeable and size is: ${this.maxSize}`);const Ae=this.tensors[L]||{};if(X.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${L},\n          because the value dtype is ${X.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=X.shape),ui(this.elementShape,X.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${L}.`),Ae.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${L}, because it has already been read.`);if(Ae.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${L}, because it has already been written.`);Ae.tensor=X,(0,ie.CnY)(X),Ae.written=!0,this.tensors[L]=Ae}writeMany(L,X){if(L.length!==X.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${L.length} is not the same as tensors size: ${X.length}.`);L.forEach((Ae,He)=>this.write(Ae,X[He]))}gather(L,X){if(X&&X!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${X}`);if(L)L=L.slice(0,this.size());else{L=[];for(let He=0;He<this.size();He++)L.push(He)}if(0===L.length)return(0,ie.XeE)([],[0].concat(this.elementShape));const Ae=this.readMany(L);return ui(this.elementShape,Ae[0].shape,"TensorArray shape mismatch: "),(0,ie.knu)(Ae,0)}concat(L){if(L&&L!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${L}`);if(0===this.size())return(0,ie.XeE)([],[0].concat(this.elementShape));const X=[];for(let He=0;He<this.size();He++)X.push(He);const Ae=this.readMany(X);return ui(this.elementShape,Ae[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${Ae[0].shape})`),(0,ie.zoF)(Ae,0)}scatter(L,X){if(X.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${X.dtype}`);if(L.length!==X.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${L.length} vs. ${X.shape[0]}`);const Ae=Math.max(...L);if(!this.dynamicSize&&Ae>=this.maxSize)throw new Error(`Max index must be < array size (${Ae}  vs. ${this.maxSize})`);this.writeMany(L,(0,ie.HHK)(X,0))}split(L,X){if(X.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${X.dtype}`);let Ae=0;const He=L.map(wt=>(Ae+=wt,Ae));if(Ae!==X.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${Ae}, and tensor's shape is: ${X.shape}`);if(!this.dynamicSize&&L.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${L.length}), and the TensorArray is not marked as dynamically resizeable`);const Ye=0===Ae?0:X.size/Ae,it=[];(0,ie.lub)(()=>{X=(0,ie.XLQ)(X,[1,Ae,Ye]);for(let wt=0;wt<L.length;++wt)it[wt]=(0,ie.XLQ)((0,ie.tPi)(X,[0,0===wt?0:He[wt-1],0],[1,L[wt],Ye]),this.elementShape);return it});const _t=[];for(let wt=0;wt<L.length;wt++)_t[wt]=wt;this.writeMany(_t,it)}}class Ki{get id(){return this.idTensor.id}constructor(L,X,Ae,He=-1){this.tensors=L,this.elementShape=X,this.elementDtype=Ae,L?.forEach(Ye=>{if(Ae!==Ye.dtype)throw new Error(`Invalid data types; op elements ${Ae}, but list elements ${Ye.dtype}`);ui(X,Ye.shape,"TensorList shape mismatch: "),(0,ie.CnY)(Ye)}),this.idTensor=(0,ie.iD$)(0),this.maxNumElements=He,(0,ie.CnY)(this.idTensor)}copy(){return new Ki([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(L){this.tensors.forEach(X=>{(null==L||!L.has(X.id))&&X.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(L,X,Ae=-1){if(X!==this.elementDtype)throw new Error(`Invalid data types; op elements ${X}, but list elements ${this.elementDtype}`);if(-1!==Ae&&this.tensors.length!==Ae)throw new Error(`Operation expected a list with ${Ae} elements but got a list with ${this.tensors.length} elements.`);ui(L,this.elementShape,"TensorList shape mismatch: ");const He=Go(this.elementShape,this.tensors,L);return(0,ie.lub)(()=>{const Ye=this.tensors.map(it=>(0,ie.XLQ)(it,He));return(0,ie.knu)(Ye,0)})}popBack(L,X){if(X!==this.elementDtype)throw new Error(`Invalid data types; op elements ${X}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const Ae=Go(this.elementShape,this.tensors,L),He=this.tensors.pop();return He.kept=!1,ui(He.shape,L,"TensorList shape mismatch: "),(0,ie.XLQ)(He,Ae)}pushBack(L){if(L.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${L.dtype}, but list elements ${this.elementDtype}`);if(ui(L.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,ie.CnY)(L),this.tensors.push(L)}resize(L){if(L<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${L}`);if(-1!==this.maxNumElements&&L>this.maxNumElements)throw new Error(`TensorListResize input size ${L} is greater maxNumElement ${this.maxNumElements}.`);const X=new Ki([],this.elementShape,this.elementDtype,this.maxNumElements);X.tensors.length=L;for(let Ae=0;Ae<Math.min(this.tensors.length,L);++Ae)X.tensors[Ae]=this.tensors[Ae];return X}getItem(L,X,Ae){if(Ae!==this.elementDtype)throw new Error(`Invalid data types; op elements ${Ae}, but list elements ${this.elementDtype}`);if(L<0||L>this.tensors.length)throw new Error(`Trying to access element ${L} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[L])throw new Error(`element at index ${L} is null.`);ui(this.tensors[L].shape,X,"TensorList shape mismatch: ");const He=Go(this.elementShape,this.tensors,X);return(0,ie.XLQ)(this.tensors[L],He)}setItem(L,X){if(X.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${X.dtype}, but list elements ${this.elementDtype}`);if(L<0||-1!==this.maxNumElements&&L>=this.maxNumElements)throw new Error(`Trying to set element ${L} in a list with max ${this.maxNumElements} elements.`);ui(this.elementShape,X.shape,"TensorList shape mismatch: "),(0,ie.CnY)(X),null!=this.tensors[L]&&(this.tensors[L].kept=!1),this.tensors[L]=X}gather(L,X,Ae){if(X!==this.elementDtype)throw new Error(`Invalid data types; op elements ${X}, but list elements ${this.elementDtype}`);ui(this.elementShape,Ae,"TensorList shape mismatch: "),L=L.slice(0,this.size());const He=Go(this.elementShape,this.tensors,Ae);return 0===L.length?(0,ie.XeE)([],[0].concat(He)):(0,ie.lub)(()=>{const Ye=L.map(it=>(0,ie.XLQ)(this.tensors[it],He));return(0,ie.knu)(Ye,0)})}concat(L,X){if(L&&L!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${L}`);ui(this.elementShape,X,"TensorList shape mismatch: ");const Ae=Go(this.elementShape,this.tensors,X);return 0===this.size()?(0,ie.XeE)([],[0].concat(Ae)):(0,ie.lub)(()=>{const He=this.tensors.map(Ye=>(0,ie.XLQ)(Ye,Ae));return(0,ie.zoF)(He,0)})}}function hc(q,L,X){const[Ae,He]=v("fusedOps",q,L,X),Ye="biasadd"===Ae,it=!Ye,_t="prelu"===He,wt="fusedbatchnorm"===Ae,kn=v("numArgs",q,L,X);if(Ye){if(_t&&2!==kn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!_t&&Ye&&1!==kn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(wt)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const pn=v("strides",q,L,X),qn=nn(q,L,X),os=v("dataFormat",q,L,X).toUpperCase(),Ms=v("dilations",q,L,X);let[Tr,Cr]=v("args",q,L,X);return it&&(Cr=Tr,Tr=void 0),{stride:pn,pad:qn,dataFormat:os,dilations:Ms,biasArg:Tr,preluArg:Cr,activationFunc:He,leakyreluAlpha:v("leakyreluAlpha",q,L,X)}}var ko;function fl(q,L,X){return{boxes:v("boxes",q,L,X),scores:v("scores",q,L,X),maxOutputSize:v("maxOutputSize",q,L,X),iouThreshold:v("iouThreshold",q,L,X),scoreThreshold:v("scoreThreshold",q,L,X),softNmsSigma:v("softNmsSigma",q,L,X)}}var Xa,zl=h(8661);class ol{get id(){return this.handle.id}constructor(L,X){this.keyDType=L,this.valueDType=X,this.handle=(0,ie.iD$)(0),this.tensorMap=new Map,(0,ie.CnY)(this.handle)}clearAndClose(){this.tensorMap.forEach(L=>L.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return zl.i(this.size(),"int32")}import(L,X){var Ae=this;return(0,De.Z)(function*(){Ae.checkKeyAndValueTensor(L,X);const He=yield L.data();return Ae.tensorMap.forEach(Ye=>Ye.dispose()),Ae.tensorMap.clear(),(0,ie.lub)(()=>{const Ye=(0,ie.HHK)(X),it=He.length,_t=Ye.length;ie.D5U.assert(it===_t,()=>`The number of elements doesn't match, keys has ${it} elements, the values has ${_t} elements.`);for(let wt=0;wt<it;wt++){const kn=He[wt],pn=Ye[wt];(0,ie.CnY)(pn),Ae.tensorMap.set(kn,pn)}return Ae.handle})})()}find(L,X){var Ae=this;return(0,De.Z)(function*(){Ae.checkKeyAndValueTensor(L,X);const He=yield L.data();return(0,ie.lub)(()=>{const Ye=[];for(let it=0;it<He.length;it++){const wt=Ae.findWithDefault(He[it],X);Ye.push(wt)}return(0,ie.knu)(Ye)})})()}findWithDefault(L,X){return this.tensorMap.get(L)??X}checkKeyAndValueTensor(L,X){if(L.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${L.dtype}`);if(X.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${X.dtype}`)}}function Br(q,L,X,Ae,He=ie.lub){const Ye=((it,_t,wt)=>{switch(it.category){case"arithmetic":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"BiasAdd":case"AddV2":case"Add":return[Ae.add(v("a",q,L,X),v("b",q,L,X))];case"AddN":return[Ae.addN(v("tensors",q,L,X))];case"FloorMod":case"Mod":return[Ae.mod(v("a",q,L,X),v("b",q,L,X))];case"Mul":return[Ae.mul(v("a",q,L,X),v("b",q,L,X))];case"RealDiv":case"Div":return[Ae.div(v("a",q,L,X),v("b",q,L,X))];case"DivNoNan":return[Ae.divNoNan(v("a",q,L,X),v("b",q,L,X))];case"FloorDiv":return[Ae.floorDiv(v("a",q,L,X),v("b",q,L,X))];case"Sub":return[Ae.sub(v("a",q,L,X),v("b",q,L,X))];case"Minimum":return[Ae.minimum(v("a",q,L,X),v("b",q,L,X))];case"Maximum":return[Ae.maximum(v("a",q,L,X),v("b",q,L,X))];case"Pow":return[Ae.pow(v("a",q,L,X),v("b",q,L,X))];case"SquaredDifference":return[Ae.squaredDifference(v("a",q,L,X),v("b",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"basic_math":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"Abs":case"ComplexAbs":return[Ae.abs(v("x",q,L,X))];case"Acos":return[Ae.acos(v("x",q,L,X))];case"Acosh":return[Ae.acosh(v("x",q,L,X))];case"Asin":return[Ae.asin(v("x",q,L,X))];case"Asinh":return[Ae.asinh(v("x",q,L,X))];case"Atan":return[Ae.atan(v("x",q,L,X))];case"Atan2":return[Ae.atan2(v("x",q,L,X),v("y",q,L,X))];case"Atanh":return[Ae.atanh(v("x",q,L,X))];case"Ceil":return[Ae.ceil(v("x",q,L,X))];case"Complex":return[Ae.complex(v("real",q,L,X),v("imag",q,L,X))];case"Cos":return[Ae.cos(v("x",q,L,X))];case"Cosh":return[Ae.cosh(v("x",q,L,X))];case"Elu":return[Ae.elu(v("x",q,L,X))];case"Erf":return[Ae.erf(v("x",q,L,X))];case"Exp":return[Ae.exp(v("x",q,L,X))];case"Expm1":return[Ae.expm1(v("x",q,L,X))];case"Floor":return[Ae.floor(v("x",q,L,X))];case"Log":return[Ae.log(v("x",q,L,X))];case"Log1p":return[Ae.log1p(v("x",q,L,X))];case"Imag":return[Ae.imag(v("x",q,L,X))];case"Neg":return[Ae.neg(v("x",q,L,X))];case"Reciprocal":return[Ae.reciprocal(v("x",q,L,X))];case"Real":return[Ae.real(v("x",q,L,X))];case"Relu":return[Ae.relu(v("x",q,L,X))];case"Round":return[Ae.round(v("x",q,L,X))];case"Selu":return[Ae.selu(v("x",q,L,X))];case"Sigmoid":return[Ae.sigmoid(v("x",q,L,X))];case"Sin":return[Ae.sin(v("x",q,L,X))];case"Sign":return[Ae.sign(v("x",q,L,X))];case"Sinh":return[Ae.sinh(v("x",q,L,X))];case"Softplus":return[Ae.softplus(v("x",q,L,X))];case"Sqrt":return[Ae.sqrt(v("x",q,L,X))];case"Square":return[Ae.square(v("x",q,L,X))];case"Tanh":return[Ae.tanh(v("x",q,L,X))];case"Tan":return[Ae.tan(v("x",q,L,X))];case"ClipByValue":return[Ae.clipByValue(v("x",q,L,X),v("clipValueMin",q,L,X),v("clipValueMax",q,L,X))];case"Relu6":return[Ae.relu6(v("x",q,L,X))];case"Rsqrt":return[Ae.rsqrt(at(q.inputNames[0],L,X))];case"LeakyRelu":return[Ae.leakyRelu(v("x",q,L,X),v("alpha",q,L,X))];case"Prelu":return[Ae.prelu(v("x",q,L,X),v("alpha",q,L,X))];case"IsNan":return[Ae.isNaN(at(q.inputNames[0],L,X))];case"IsInf":return[Ae.isInf(at(q.inputNames[0],L,X))];case"IsFinite":return[Ae.isFinite(at(q.inputNames[0],L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"control":return function(L,X,Ae){return(Jr=Jr||(0,De.Z)(function*(He,Ye,it){switch(He.op){case"If":case"StatelessIf":{const _t=v("thenBranch",He,Ye,it),wt=v("elseBranch",He,Ye,it),kn=v("cond",He,Ye,it),pn=v("args",He,Ye,it);return(yield kn.data())[0]?it.functionMap[_t].executeFunctionAsync(pn,it.tensorArrayMap,it.tensorListMap):it.functionMap[wt].executeFunctionAsync(pn,it.tensorArrayMap,it.tensorListMap)}case"While":case"StatelessWhile":{const _t=v("body",He,Ye,it),wt=v("cond",He,Ye,it),kn=v("args",He,Ye,it),pn=yield it.functionMap[wt].executeFunctionAsync(kn,it.tensorArrayMap,it.tensorListMap),qn=kn.map(Tr=>Tr.id);let os=yield pn[0].data();pn.forEach(Tr=>{!Tr.kept&&-1===qn.indexOf(Tr.id)&&Tr.dispose()});let Ms=kn;for(;os[0];){const Tr=Ms;Ms=yield it.functionMap[_t].executeFunctionAsync(Ms,it.tensorArrayMap,it.tensorListMap);const Cr=Ms.map(lr=>lr.id);Tr.forEach(lr=>{!lr.kept&&-1===qn.indexOf(lr.id)&&-1===Cr.indexOf(lr.id)&&lr.dispose()});const Is=yield it.functionMap[wt].executeFunctionAsync(Ms,it.tensorArrayMap,it.tensorListMap);os=yield Is[0].data(),Is.forEach(lr=>{!lr.kept&&-1===qn.indexOf(lr.id)&&-1===Cr.indexOf(lr.id)&&lr.dispose()})}return Ms}case"LoopCond":return[Bt(v("pred",He,Ye,it))];case"Switch":{const _t=v("pred",He,Ye,it);let wt=v("data",He,Ye,it);return wt.kept||(wt=Bt(wt)),(yield _t.data())[0]?[void 0,wt]:[wt,void 0]}case"Merge":{const _t=He.inputNames.find(wt=>void 0!==at(wt,Ye,it));return _t?[Bt(at(_t,Ye,it))]:void 0}case"Enter":{const _t=v("frameName",He,Ye,it),wt=v("tensor",He,Ye,it);return it.enterFrame(_t),[Bt(wt)]}case"Exit":{const _t=v("tensor",He,Ye,it);return it.exitFrame(),[Bt(_t)]}case"NextIteration":{const _t=v("tensor",He,Ye,it);return it.nextIteration(),[Bt(_t)]}case"TensorArrayV3":{const _t=v("size",He,Ye,it),wt=v("dtype",He,Ye,it),kn=v("elementShape",He,Ye,it),pn=v("dynamicSize",He,Ye,it),qn=v("clearAfterRead",He,Ye,it),os=v("identicalElementShapes",He,Ye,it),Ms=v("name",He,Ye,it),Tr=new wa(Ms,wt,_t,kn,os,pn,qn);return it.addTensorArray(Tr),[Tr.idTensor,(0,ie.iD$)(1)]}case"TensorArrayWriteV3":{const _t=v("tensorArrayId",He,Ye,it),wt=v("index",He,Ye,it),kn=v("tensor",He,Ye,it),pn=it.getTensorArray(_t.id);return pn.write(wt,kn),[pn.idTensor]}case"TensorArrayReadV3":{const _t=v("tensorArrayId",He,Ye,it),wt=v("index",He,Ye,it);return[it.getTensorArray(_t.id).read(wt)]}case"TensorArrayGatherV3":{const _t=v("tensorArrayId",He,Ye,it),wt=v("indices",He,Ye,it),kn=v("dtype",He,Ye,it);return[it.getTensorArray(_t.id).gather(wt,kn)]}case"TensorArrayScatterV3":{const _t=v("tensorArrayId",He,Ye,it),wt=v("indices",He,Ye,it),kn=v("tensor",He,Ye,it),pn=it.getTensorArray(_t.id);return pn.scatter(wt,kn),[pn.idTensor]}case"TensorArrayConcatV3":{const _t=v("tensorArrayId",He,Ye,it),wt=it.getTensorArray(_t.id),kn=v("dtype",He,Ye,it);return[wt.concat(kn)]}case"TensorArraySplitV3":{const _t=v("tensorArrayId",He,Ye,it),wt=v("tensor",He,Ye,it),kn=v("lengths",He,Ye,it),pn=it.getTensorArray(_t.id);return pn.split(kn,wt),[pn.idTensor]}case"TensorArraySizeV3":{const _t=v("tensorArrayId",He,Ye,it),wt=it.getTensorArray(_t.id);return[(0,ie.iD$)(wt.size(),"int32")]}case"TensorArrayCloseV3":{const _t=v("tensorArrayId",He,Ye,it),wt=it.getTensorArray(_t.id);return wt.clearAndClose(),[wt.idTensor]}case"TensorListSetItem":{const _t=v("tensorListId",He,Ye,it),wt=v("index",He,Ye,it),kn=v("tensor",He,Ye,it),pn=it.getTensorList(_t.id);return pn.setItem(wt,kn),[pn.idTensor]}case"TensorListGetItem":{const _t=v("tensorListId",He,Ye,it),wt=v("index",He,Ye,it),kn=v("elementShape",He,Ye,it),pn=v("elementDType",He,Ye,it);return[it.getTensorList(_t.id).getItem(wt,kn,pn)]}case"TensorListScatterV2":case"TensorListScatter":{const _t=v("indices",He,Ye,it),qn=function Bi(q,L,X,Ae){if(L.length!==q.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${L.length} vs. ${q.shape[0]}`);const He=Math.max(...L);if(null!=Ae&&-1!==Ae&&He>=Ae)throw new Error(`Max index must be < array size (${He}  vs. ${Ae})`);const Ye=new Ki([],X,q.dtype,Ae),it=(0,ie.HHK)(q,0);return L.forEach((_t,wt)=>{Ye.setItem(_t,it[wt])}),Ye}(v("tensor",He,Ye,it),_t,v("elementShape",He,Ye,it),v("numElements",He,Ye,it));return it.addTensorList(qn),[qn.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const _t=v("elementShape",He,Ye,it),wt=v("elementDType",He,Ye,it);let kn;kn="TensorListReserve"===He.op?"numElements":"maxNumElements";const pn=v(kn,He,Ye,it),os=function $i(q,L,X,Ae){return new Ki([],q,L,Ae)}(_t,wt,0,"TensorListReserve"===He.op?-1:pn);return it.addTensorList(os),[os.idTensor]}case"TensorListGather":{const _t=v("tensorListId",He,Ye,it),wt=v("indices",He,Ye,it),kn=v("elementShape",He,Ye,it),pn=v("elementDType",He,Ye,it);return[it.getTensorList(_t.id).gather(wt,pn,kn)]}case"TensorListStack":{const _t=v("tensorListId",He,Ye,it),wt=v("elementShape",He,Ye,it),kn=v("elementDType",He,Ye,it),pn=v("numElements",He,Ye,it);return[it.getTensorList(_t.id).stack(wt,kn,pn)]}case"TensorListFromTensor":{const pn=function Xi(q,L,X){const Ae=q.dtype;if(q.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${q.shape}`);if(q.dtype!==X)throw new Error(`Invalid data types; op elements ${q.dtype}, but list elements ${X}`);ui(q.shape.slice(1),L,"TensorList shape mismatch: ");const Ye=(0,ie.HHK)(q);return new Ki(Ye,L,Ae)}(v("tensor",He,Ye,it),v("elementShape",He,Ye,it),v("elementDType",He,Ye,it));return it.addTensorList(pn),[pn.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const _t=v("tensorListId",He,Ye,it),wt=it.getTensorList(_t.id),kn=v("dtype",He,Ye,it),pn=v("elementShape",He,Ye,it);return[wt.concat(kn,pn)]}case"TensorListPushBack":{const _t=v("tensorListId",He,Ye,it),wt=v("tensor",He,Ye,it),kn=it.getTensorList(_t.id);return kn.pushBack(wt),[kn.idTensor]}case"TensorListPopBack":{const _t=v("tensorListId",He,Ye,it),wt=v("elementShape",He,Ye,it),kn=v("elementDType",He,Ye,it);return[it.getTensorList(_t.id).popBack(wt,kn)]}case"TensorListSplit":{const _t=v("tensor",He,Ye,it),wt=v("elementShape",He,Ye,it),pn=function hl(q,L,X){let Ae=0;const He=L.map(pn=>(Ae+=pn,Ae));if(Ae!==q.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${Ae}, and tensor's shape is: ${q.shape}`);const it=Li(q.shape.slice(1),X),_t=0===Ae?0:q.size/Ae,wt=(0,ie.lub)(()=>{const pn=[];q=(0,ie.XLQ)(q,[1,Ae,_t]);for(let qn=0;qn<L.length;++qn)pn[qn]=(0,ie.XLQ)((0,ie.tPi)(q,[0,0===qn?0:He[qn-1],0],[1,L[qn],_t]),it);return q.dispose(),pn}),kn=new Ki([],X,q.dtype,L.length);for(let pn=0;pn<wt.length;pn++)kn.setItem(pn,wt[pn]);return kn}(_t,v("lengths",He,Ye,it),wt);return it.addTensorList(pn),[pn.idTensor]}case"TensorListLength":{const _t=v("tensorListId",He,Ye,it),wt=it.getTensorList(_t.id);return[(0,ie.iD$)(wt.size(),"int32")]}case"TensorListResize":{const _t=v("tensorListId",He,Ye,it),wt=v("size",He,Ye,it),pn=it.getTensorList(_t.id).resize(wt);return it.addTensorList(pn),[pn.idTensor]}default:throw TypeError(`Node type ${He.op} is not implemented`)}})).apply(this,arguments)}(it,_t,wt);case"convolution":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"Conv1D":{const He=v("stride",q,L,X),Ye=v("pad",q,L,X),it=v("dataFormat",q,L,X).toUpperCase(),_t=v("dilation",q,L,X);return[Ae.conv1d(v("x",q,L,X),v("filter",q,L,X),He,Ye,it,_t)]}case"Conv2D":{const He=v("strides",q,L,X),Ye=nn(q,L,X),it=v("dataFormat",q,L,X).toUpperCase(),_t=v("dilations",q,L,X);return[Ae.conv2d(v("x",q,L,X),v("filter",q,L,X),[He[1],He[2]],Ye,it,[_t[1],_t[2]])]}case"_FusedConv2D":{const{stride:He,pad:Ye,dataFormat:it,dilations:_t,biasArg:wt,preluArg:kn,activationFunc:pn,leakyreluAlpha:qn}=hc(q,L,X);return[Ae.fused.conv2d({x:v("x",q,L,X),filter:v("filter",q,L,X),strides:[He[1],He[2]],pad:Ye,dataFormat:it,dilations:[_t[1],_t[2]],bias:wt,activation:pn,preluActivationWeights:kn,leakyreluAlpha:qn})]}case"FusedDepthwiseConv2dNative":{const{stride:He,pad:Ye,dataFormat:it,dilations:_t,biasArg:wt,preluArg:kn,activationFunc:pn,leakyreluAlpha:qn}=hc(q,L,X);return[Ae.fused.depthwiseConv2d({x:v("x",q,L,X),filter:v("filter",q,L,X),strides:[He[1],He[2]],pad:Ye,dataFormat:it,dilations:[_t[1],_t[2]],bias:wt,activation:pn,preluActivationWeights:kn,leakyreluAlpha:qn})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const He=v("outputShape",q,L,X),Ye=v("strides",q,L,X),it=nn(q,L,X);return[Ae.conv2dTranspose(v("x",q,L,X),v("filter",q,L,X),He,[Ye[1],Ye[2]],it)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const He=v("strides",q,L,X),Ye=nn(q,L,X),it=v("dilations",q,L,X),_t=v("dataFormat",q,L,X).toUpperCase();return[Ae.depthwiseConv2d(v("input",q,L,X),v("filter",q,L,X),[He[1],He[2]],Ye,_t,[it[1],it[2]])]}case"Conv3D":{const He=v("strides",q,L,X),Ye=v("pad",q,L,X),it=v("dataFormat",q,L,X).toUpperCase(),_t=v("dilations",q,L,X);return[Ae.conv3d(v("x",q,L,X),v("filter",q,L,X),[He[1],He[2],He[3]],Ye,it,[_t[1],_t[2],_t[3]])]}case"AvgPool":{const He=v("strides",q,L,X),Ye=v("pad",q,L,X),it=v("kernelSize",q,L,X);return[Ae.avgPool(v("x",q,L,X),[it[1],it[2]],[He[1],He[2]],Ye)]}case"MaxPool":{const He=v("strides",q,L,X),Ye=v("pad",q,L,X),it=v("kernelSize",q,L,X);return[Ae.maxPool(v("x",q,L,X),[it[1],it[2]],[He[1],He[2]],Ye)]}case"MaxPoolWithArgmax":{const He=v("strides",q,L,X),Ye=v("pad",q,L,X),it=v("kernelSize",q,L,X),_t=v("includeBatchInIndex",q,L,X),{result:wt,indexes:kn}=Ae.maxPoolWithArgmax(v("x",q,L,X),[it[1],it[2]],[He[1],He[2]],Ye,_t);return[wt,kn]}case"AvgPool3D":{const He=v("strides",q,L,X),Ye=v("pad",q,L,X),it=v("kernelSize",q,L,X);return[Ae.avgPool3d(v("x",q,L,X),[it[1],it[2],it[3]],[He[1],He[2],He[3]],Ye)]}case"MaxPool3D":{const He=v("strides",q,L,X),Ye=v("pad",q,L,X),it=v("kernelSize",q,L,X);return[Ae.maxPool3d(v("x",q,L,X),[it[1],it[2],it[3]],[He[1],He[2],He[3]],Ye)]}case"Dilation2D":{const He=v("strides",q,L,X),Ye=v("pad",q,L,X),it=v("dilations",q,L,X),_t=He[1],wt=He[2],kn=it[1],pn=it[2];return[Ae.dilation2d(v("x",q,L,X),v("filter",q,L,X),[_t,wt],Ye,[kn,pn],"NHWC")]}default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"creation":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"Fill":{const He=v("shape",q,L,X),Ye=v("dtype",q,L,X),it=v("value",q,L,X);return[Ae.fill(He,it,Ye)]}case"LinSpace":{const He=v("start",q,L,X),Ye=v("stop",q,L,X),it=v("num",q,L,X);return[Ae.linspace(He,Ye,it)]}case"Multinomial":{const He=v("logits",q,L,X),Ye=v("numSamples",q,L,X),it=v("seed",q,L,X);return[Ae.multinomial(He,Ye,it)]}case"OneHot":{const He=v("indices",q,L,X),Ye=v("depth",q,L,X),it=v("onValue",q,L,X),_t=v("offValue",q,L,X),wt=v("dtype",q,L,X);return[Ae.oneHot(He,Ye,it,_t,wt)]}case"Ones":return[Ae.ones(v("shape",q,L,X),v("dtype",q,L,X))];case"OnesLike":return[Ae.onesLike(v("x",q,L,X))];case"RandomStandardNormal":return[Ae.randomStandardNormal(v("shape",q,L,X),v("dtype",q,L,X),v("seed",q,L,X))];case"RandomUniform":return[Ae.randomUniform(v("shape",q,L,X),v("minval",q,L,X),v("maxval",q,L,X),v("dtype",q,L,X))];case"RandomUniformInt":return[Ae.randomUniformInt(v("shape",q,L,X),v("minval",q,L,X),v("maxval",q,L,X),v("seed",q,L,X))];case"Range":{const He=v("start",q,L,X),Ye=v("stop",q,L,X),it=v("step",q,L,X);return[Ae.range(He,Ye,it,v("dtype",q,L,X))]}case"TruncatedNormal":{const He=v("shape",q,L,X),Ye=v("mean",q,L,X),it=v("stdDev",q,L,X),_t=v("seed",q,L,X);return[Ae.truncatedNormal(He,Ye,it,v("dtype",q,L,X),_t)]}case"Zeros":return[Ae.zeros(v("shape",q,L,X),v("dtype",q,L,X))];case"ZerosLike":return[Ae.zerosLike(v("x",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"dynamic":return function(L,X,Ae,He){return(ko=ko||(0,De.Z)(function*(Ye,it,_t,wt,kn=Oe){switch(Ye.op){case"NonMaxSuppressionV5":{const{boxes:pn,scores:qn,maxOutputSize:os,iouThreshold:Ms,scoreThreshold:Tr,softNmsSigma:Cr}=fl(Ye,it,_t),Is=yield kn.image.nonMaxSuppressionWithScoreAsync(pn,qn,os,Ms,Tr,Cr);return[Is.selectedIndices,Is.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:pn,scores:qn,maxOutputSize:os,iouThreshold:Ms,scoreThreshold:Tr}=fl(Ye,it,_t),Cr=v("padToMaxOutputSize",Ye,it,_t),Is=yield kn.image.nonMaxSuppressionPaddedAsync(pn,qn,os,Ms,Tr,Cr);return[Is.selectedIndices,Is.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:pn,scores:qn,maxOutputSize:os,iouThreshold:Ms,scoreThreshold:Tr}=fl(Ye,it,_t);return[yield kn.image.nonMaxSuppressionAsync(pn,qn,os,Ms,Tr)]}case"Where":{const pn=kn.cast(v("condition",Ye,it,_t),"bool"),qn=[yield kn.whereAsync(pn)];return pn.dispose(),qn}case"ListDiff":return kn.setdiff1dAsync(v("x",Ye,it,_t),v("y",Ye,it,_t));default:throw TypeError(`Node type ${Ye.op} is not implemented`)}})).apply(this,arguments)}(it,_t,wt);case"evaluation":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"LowerBound":{const He=v("sortedSequence",q,L,X),Ye=v("values",q,L,X);return[Ae.lowerBound(He,Ye)]}case"TopKV2":{const He=v("x",q,L,X),Ye=v("k",q,L,X),it=v("sorted",q,L,X),_t=Ae.topk(He,Ye,it);return[_t.values,_t.indices]}case"UpperBound":{const He=v("sortedSequence",q,L,X),Ye=v("values",q,L,X);return[Ae.upperBound(He,Ye)]}case"Unique":{const He=v("x",q,L,X),Ye=Ae.unique(He);return[Ye.values,Ye.indices]}case"UniqueV2":{const He=v("x",q,L,X),Ye=v("axis",q,L,X),it=Ae.unique(He,Ye);return[it.values,it.indices]}default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"image":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"ResizeBilinear":{const He=v("images",q,L,X),Ye=v("size",q,L,X),it=v("alignCorners",q,L,X),_t=v("halfPixelCenters",q,L,X);return[Ae.image.resizeBilinear(He,[Ye[0],Ye[1]],it,_t)]}case"ResizeNearestNeighbor":{const He=v("images",q,L,X),Ye=v("size",q,L,X),it=v("alignCorners",q,L,X),_t=v("halfPixelCenters",q,L,X);return[Ae.image.resizeNearestNeighbor(He,[Ye[0],Ye[1]],it,_t)]}case"CropAndResize":{const He=v("image",q,L,X),Ye=v("boxes",q,L,X),it=v("boxInd",q,L,X),_t=v("cropSize",q,L,X),wt=v("method",q,L,X),kn=v("extrapolationValue",q,L,X);return[Ae.image.cropAndResize(He,Ye,it,_t,wt,kn)]}case"ImageProjectiveTransformV3":{const He=v("images",q,L,X),Ye=v("transforms",q,L,X),it=v("outputShape",q,L,X),_t=v("fillValue",q,L,X),wt=v("interpolation",q,L,X),kn=v("fillMode",q,L,X);return[Ae.image.transform(He,Ye,wt.toLowerCase(),kn.toLowerCase(),_t,it)]}default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"graph":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"Const":return L[q.name];case"PlaceholderWithDefault":const He=v("default",q,L,X);return[at(q.name,L,X)||He];case"Placeholder":return[at(q.name,L,X)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Bt(v("x",q,L,X))];case"IdentityN":return v("x",q,L,X).map(pn=>Bt(pn));case"Shape":return[Ae.tensor1d(v("x",q,L,X).shape,"int32")];case"ShapeN":return v("x",q,L,X).map(pn=>Ae.tensor1d(pn.shape));case"Size":return[Ae.scalar(v("x",q,L,X).size,"int32")];case"Rank":return[Ae.scalar(v("x",q,L,X).rank,"int32")];case"NoOp":return[Ae.scalar(1)];case"Print":const it=v("x",q,L,X),_t=v("data",q,L,X),wt=v("message",q,L,X),kn=v("summarize",q,L,X);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(wt);for(let pn=0;pn<_t.length;pn++)console.log(Array.prototype.slice.call(_t[pn].dataSync()).slice(0,kn));return[it];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"logical":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"Equal":return[Ae.equal(v("a",q,L,X),v("b",q,L,X))];case"NotEqual":return[Ae.notEqual(v("a",q,L,X),v("b",q,L,X))];case"Greater":return[Ae.greater(v("a",q,L,X),v("b",q,L,X))];case"GreaterEqual":return[Ae.greaterEqual(v("a",q,L,X),v("b",q,L,X))];case"Less":return[Ae.less(v("a",q,L,X),v("b",q,L,X))];case"LessEqual":return[Ae.lessEqual(v("a",q,L,X),v("b",q,L,X))];case"LogicalAnd":return[Ae.logicalAnd(v("a",q,L,X),v("b",q,L,X))];case"LogicalNot":return[Ae.logicalNot(v("a",q,L,X))];case"LogicalOr":return[Ae.logicalOr(v("a",q,L,X),v("b",q,L,X))];case"Select":case"SelectV2":return[Ae.where(v("condition",q,L,X),v("a",q,L,X),v("b",q,L,X))];case"BitwiseAnd":return[Ae.bitwiseAnd(v("a",q,L,X),v("b",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"matrices":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ae.matMul(v("a",q,L,X),v("b",q,L,X),v("transposeA",q,L,X),v("transposeB",q,L,X))];case"Einsum":return[Ae.einsum(v("equation",q,L,X),...v("tensors",q,L,X))];case"Transpose":return[Ae.transpose(v("x",q,L,X),v("perm",q,L,X))];case"_FusedMatMul":const[He,Ye]=v("fusedOps",q,L,X),it="biasadd"===He,_t="prelu"===Ye,wt=v("numArgs",q,L,X),kn=v("leakyreluAlpha",q,L,X);if(it){if(_t&&2!==wt)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!_t&&1!==wt)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[pn,qn]=v("args",q,L,X);return[Ae.fused.matMul({a:v("a",q,L,X),b:v("b",q,L,X),transposeA:v("transposeA",q,L,X),transposeB:v("transposeB",q,L,X),bias:pn,activation:Ye,preluActivationWeights:qn,leakyreluAlpha:kn})];case"MatrixBandPart":return[Ae.linalg.bandPart(v("a",q,L,X),v("numLower",q,L,X),v("numUpper",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"normalization":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"EuclideanNorm":return[Ae.euclideanNorm(v("x",q,L,X),v("axis",q,L,X),v("keepDims",q,L,X))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Ae.batchNorm(v("x",q,L,X),v("mean",q,L,X),v("variance",q,L,X),v("offset",q,L,X),v("scale",q,L,X),v("epsilon",q,L,X))];case"LRN":return[Ae.localResponseNormalization(v("x",q,L,X),v("radius",q,L,X),v("bias",q,L,X),v("alpha",q,L,X),v("beta",q,L,X))];case"Softmax":return[Ae.softmax(v("x",q,L,X))];case"LogSoftmax":return[Ae.logSoftmax(v("x",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"ragged":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"RaggedGather":{const{outputNestedSplits:He,outputDenseValues:Ye}=Ae.raggedGather(v("paramsNestedSplits",q,L,X),v("paramsDenseValues",q,L,X),v("indices",q,L,X),v("outputRaggedRank",q,L,X));return He.concat(Ye)}case"RaggedRange":{const{rtNestedSplits:He,rtDenseValues:Ye}=Ae.raggedRange(v("starts",q,L,X),v("limits",q,L,X),v("splits",q,L,X));return[He,Ye]}case"RaggedTensorToTensor":return[Ae.raggedTensorToTensor(v("shape",q,L,X),v("values",q,L,X),v("defaultValue",q,L,X),v("rowPartitionTensors",q,L,X),v("rowPartitionTypes",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"reduction":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"Max":{const _t=v("axis",q,L,X),wt=v("keepDims",q,L,X);return[Ae.max(v("x",q,L,X),_t,wt)]}case"Mean":{const _t=v("axis",q,L,X),wt=v("keepDims",q,L,X);return[Ae.mean(v("x",q,L,X),_t,wt)]}case"Min":{const _t=v("axis",q,L,X),wt=v("keepDims",q,L,X);return[Ae.min(v("x",q,L,X),_t,wt)]}case"Sum":{const _t=v("axis",q,L,X),wt=v("keepDims",q,L,X);return[Ae.sum(v("x",q,L,X),_t,wt)]}case"All":{const _t=v("axis",q,L,X),wt=v("keepDims",q,L,X);return[Ae.all(v("x",q,L,X),_t,wt)]}case"Any":{const _t=v("axis",q,L,X),wt=v("keepDims",q,L,X);return[Ae.any(v("x",q,L,X),_t,wt)]}case"ArgMax":{const _t=v("axis",q,L,X);return[Ae.argMax(v("x",q,L,X),_t)]}case"ArgMin":{const _t=v("axis",q,L,X);return[Ae.argMin(v("x",q,L,X),_t)]}case"Prod":{const _t=v("axis",q,L,X),wt=v("keepDims",q,L,X);return[Ae.prod(v("x",q,L,X),_t,wt)]}case"Cumprod":{const _t=v("axis",q,L,X),wt=v("exclusive",q,L,X),kn=v("reverse",q,L,X);return[Ae.cumprod(v("x",q,L,X),_t,wt,kn)]}case"Cumsum":{const _t=v("axis",q,L,X),wt=v("exclusive",q,L,X),kn=v("reverse",q,L,X);return[Ae.cumsum(v("x",q,L,X),_t,wt,kn)]}case"Bincount":const He=v("x",q,L,X),Ye=v("weights",q,L,X),it=v("size",q,L,X);return[Ae.bincount(He,Ye,it)];case"DenseBincount":{const _t=v("x",q,L,X),wt=v("weights",q,L,X),kn=v("size",q,L,X),pn=v("binaryOutput",q,L,X);return[Ae.denseBincount(_t,wt,kn,pn)]}default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"slice_join":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"ConcatV2":case"Concat":{const He=v("n",q,L,X),Ye=v("axis",q,L,X);let it=v("tensors",q,L,X);return it=it.slice(0,He),[Ae.concat(it,Ye)]}case"Gather":{const He=v("x",q,L,X),Ye=v("indices",q,L,X);return[Ae.gather(He,Ae.cast(Ye,"int32"),0)]}case"GatherV2":{const He=v("axis",q,L,X),Ye=v("batchDims",q,L,X),it=v("x",q,L,X),_t=v("indices",q,L,X);return[Ae.gather(it,Ae.cast(_t,"int32"),He,Ye)]}case"Reverse":{const He=v("dims",q,L,X),Ye=[];for(let _t=0;_t<He.length;_t++)He[_t]&&Ye.push(_t);const it=v("x",q,L,X);return[Ae.reverse(it,Ye)]}case"ReverseV2":{const He=v("axis",q,L,X),Ye=v("x",q,L,X);return[Ae.reverse(Ye,He)]}case"Slice":{const He=v("begin",q,L,X),Ye=v("size",q,L,X);return[Ae.slice(v("x",q,L,X),He,Ye)]}case"StridedSlice":{const He=v("begin",q,L,X),Ye=v("end",q,L,X),it=v("strides",q,L,X),_t=v("beginMask",q,L,X),wt=v("endMask",q,L,X),kn=v("ellipsisMask",q,L,X),pn=v("newAxisMask",q,L,X),qn=v("shrinkAxisMask",q,L,X),os=v("x",q,L,X);return[Ae.stridedSlice(os,He,Ye,it,_t,wt,kn,pn,qn)]}case"Pack":return(0,ie.lub)(()=>{const He=v("axis",q,L,X),Ye=v("tensors",q,L,X),it=Ye[0].shape,_t=Ae.squeeze(Ye[0]).shape,wt=Ye.map(kn=>{const pn=ie.D5U.arraysEqual(kn.shape,it);if(!pn&&!ie.D5U.arraysEqual(Ae.squeeze(kn).shape,_t))throw new Error("the input tensors shape does not match");return pn?kn:Ae.reshape(kn,it)});return[Ae.stack(wt,He)]});case"Unpack":{const He=v("axis",q,L,X),Ye=v("tensor",q,L,X);return Ae.unstack(Ye,He)}case"Tile":{const He=v("reps",q,L,X);return[Ae.tile(v("x",q,L,X),He)]}case"Split":case"SplitV":{const He=v("axis",q,L,X),Ye=v("numOrSizeSplits",q,L,X),it=v("x",q,L,X);return Ae.split(it,Ye,He)}case"ScatterNd":{const He=v("indices",q,L,X),Ye=v("values",q,L,X),it=v("shape",q,L,X);return[Ae.scatterND(He,Ye,it)]}case"GatherNd":{const He=v("x",q,L,X),Ye=v("indices",q,L,X);return[Ae.gatherND(He,Ye)]}case"SparseToDense":{const He=v("sparseIndices",q,L,X),Ye=v("outputShape",q,L,X),it=v("sparseValues",q,L,X),_t=v("defaultValue",q,L,X);return[Ae.sparseToDense(He,it,Ye,it.dtype===_t.dtype?_t:Ae.cast(_t,it.dtype))]}case"TensorScatterUpdate":{const He=v("indices",q,L,X),Ye=v("values",q,L,X),it=v("tensor",q,L,X);return[Ae.tensorScatterUpdate(it,He,Ye)]}default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"sparse":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"SparseFillEmptyRows":{const{outputIndices:He,outputValues:Ye,emptyRowIndicator:it,reverseIndexMap:_t}=Ae.sparse.sparseFillEmptyRows(v("indices",q,L,X),v("values",q,L,X),v("denseShape",q,L,X),v("defaultValue",q,L,X));return[He,Ye,it,_t]}case"SparseReshape":{const{outputIndices:He,outputShape:Ye}=Ae.sparse.sparseReshape(v("inputIndices",q,L,X),v("inputShape",q,L,X),v("newShape",q,L,X));return[He,Ye]}case"SparseSegmentMean":return[Ae.sparse.sparseSegmentMean(v("data",q,L,X),v("indices",q,L,X),v("segmentIds",q,L,X))];case"SparseSegmentSum":return[Ae.sparse.sparseSegmentSum(v("data",q,L,X),v("indices",q,L,X),v("segmentIds",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"spectral":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"FFT":return[Ae.fft(v("x",q,L,X))];case"IFFT":return[Ae.ifft(v("x",q,L,X))];case"RFFT":return[Ae.rfft(v("x",q,L,X))];case"IRFFT":return[Ae.irfft(v("x",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"string":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"StaticRegexReplace":return[Ae.string.staticRegexReplace(v("input",q,L,X),v("pattern",q,L,X),v("rewrite",q,L,X),v("replaceGlobal",q,L,X))];case"StringNGrams":{const{nGrams:He,nGramsSplits:Ye}=Ae.string.stringNGrams(v("data",q,L,X),v("dataSplits",q,L,X),v("separator",q,L,X),v("nGramWidths",q,L,X),v("leftPad",q,L,X),v("rightPad",q,L,X),v("padWidth",q,L,X),v("preserveShortSequences",q,L,X));return[He,Ye]}case"StringSplit":{const{indices:He,values:Ye,shape:it}=Ae.string.stringSplit(v("input",q,L,X),v("delimiter",q,L,X),v("skipEmpty",q,L,X));return[He,Ye,it]}case"StringToHashBucketFast":return[Ae.string.stringToHashBucketFast(v("input",q,L,X),v("numBuckets",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"transformation":return He(()=>((q,L,X,Ae=Oe)=>{switch(q.op){case"Cast":return[Ae.cast(v("x",q,L,X),v("dtype",q,L,X))];case"ExpandDims":{const He=v("axis",q,L,X);return[Ae.expandDims(v("x",q,L,X),He)]}case"Squeeze":{const He=v("axis",q,L,X);return[Ae.squeeze(v("x",q,L,X),He)]}case"Reshape":return[Ae.reshape(v("x",q,L,X),v("shape",q,L,X))];case"EnsureShape":return[Ae.ensureShape(v("x",q,L,X),v("shape",q,L,X))];case"MirrorPad":return[Ae.mirrorPad(v("x",q,L,X),v("padding",q,L,X),v("mode",q,L,X))];case"PadV2":case"Pad":return[Ae.pad(v("x",q,L,X),v("padding",q,L,X),v("constantValue",q,L,X))];case"SpaceToBatchND":{const He=v("blockShape",q,L,X),Ye=v("paddings",q,L,X);return[Ae.spaceToBatchND(v("x",q,L,X),He,Ye)]}case"BatchToSpaceND":{const He=v("blockShape",q,L,X),Ye=v("crops",q,L,X);return[Ae.batchToSpaceND(v("x",q,L,X),He,Ye)]}case"DepthToSpace":{const He=v("blockSize",q,L,X),Ye=v("dataFormat",q,L,X).toUpperCase();return[Ae.depthToSpace(v("x",q,L,X),He,Ye)]}case"BroadcastTo":return[Ae.broadcastTo(v("x",q,L,X),v("shape",q,L,X))];case"BroadcastArgs":return[Ae.broadcastArgs(v("s0",q,L,X),v("s1",q,L,X))];default:throw TypeError(`Node type ${q.op} is not implemented`)}})(it,_t,wt));case"hash_table":return function(L,X,Ae,He){return(Xa=Xa||(0,De.Z)(function*(Ye,it,_t,wt){switch(Ye.op){case"HashTable":case"HashTableV2":{const kn=wt.getHashTableHandleByName(Ye.name);if(null!=kn)return[kn];{const pn=v("keyDType",Ye,it,_t),qn=v("valueDType",Ye,it,_t),os=new ol(pn,qn);return wt.addHashTable(Ye.name,os),[os.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const kn=v("tableHandle",Ye,it,_t,wt),pn=v("keys",Ye,it,_t),qn=v("values",Ye,it,_t);return[yield wt.getHashTableById(kn.id).import(pn,qn)]}case"LookupTableFind":case"LookupTableFindV2":{const kn=v("tableHandle",Ye,it,_t,wt),pn=v("keys",Ye,it,_t),qn=v("defaultValue",Ye,it,_t);return[yield wt.getHashTableById(kn.id).find(pn,qn)]}case"LookupTableSize":case"LookupTableSizeV2":{const kn=v("tableHandle",Ye,it,_t,wt);return[wt.getHashTableById(kn.id).tensorSize()]}default:throw TypeError(`Node type ${Ye.op} is not implemented`)}})).apply(this,arguments)}(it,_t,wt,Ae);case"custom":const kn=ye(it.op);if(kn&&kn.customExecutor)return kn.customExecutor(new Ha(it,_t,wt));throw TypeError(`Custom op ${it.op} is not registered.`);default:throw TypeError(`Unknown op '${it.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(q,L,X);return ie.D5U.isPromise(Ye)?Ye.then(it=>[].concat(it)):[].concat(Ye)}class dr{constructor(L={},X={},Ae={},He={},Ye){this.weightMap=L,this.tensorArrayMap=X,this.tensorListMap=Ae,this.functionMap=He,this.parseNodeNameCache=Ye,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(L,X){return{id:L,frameName:X,iterationId:0}}set currentContext(L){this.contexts!==L&&(this.contexts=L,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const L=[];for(let X=0;X<this.contexts.length-1;X++){const Ae=this.contexts.slice(0,this.contexts.length-X);L.push(this.contextIdforContexts(Ae))}L.push(""),this._currentContextIds=L}contextIdforContexts(L){return L?L.map(X=>0===X.id&&0===X.iterationId?"":`${X.frameName}-${X.iterationId}`).join("/"):""}enterFrame(L){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,L)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const L=Object.assign({},this.contexts[this.contexts.length-1]);L.iterationId+=1,L.id=this.lastId,this.contexts.splice(-1,1,L),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(L){return this.weightMap[L]}addTensorArray(L){this.tensorArrayMap[L.id]=L}getTensorArray(L){return this.tensorArrayMap[L]}addTensorList(L){this.tensorListMap[L.id]=L}getTensorList(L){return this.tensorListMap[L]}dispose(L){for(const X in this.tensorArrayMap)this.tensorArrayMap[X].clearAndClose(L);for(const X in this.tensorListMap)this.tensorListMap[X].clearAndClose(L)}}function Xo(q,L,X,Ae){const He=new Set,Ye=[];let it=null,_t=null;const wt=new Set,kn=new Set(Object.keys(q).map(os=>Ct(os)[0]));Ae=Ae||[];const pn=new Set(Ae.map(os=>Ct(os.name)[0])),qn=[...L];for(;qn.length>0;){const os=qn.pop();if((gn(os)||qr(os)||Wl(os))&&null==it&&(it=os,_t=it.children.map(Ms=>Ms.name).filter(Ms=>He.has(Ms))),He.add(os.name),null==X[os.name]&&!kn.has(os.name)&&!pn.has(os.name)){if(0===os.inputs.length){Ye.push(os.name);continue}os.inputs.forEach(Ms=>{wt.has(Ms.name)||(wt.add(Ms.name),qn.push(Ms))})}}return{inputs:q,outputs:L,usedNodes:He,missingInputs:Ye,dynamicNode:it,syncInputs:_t}}class Na extends Error{constructor(L){super(`NodesExecutionOrderError: ${L}`)}}const wr=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),ar=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Ma=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function gn(q){return wr.has(q.op)}function qr(q){return ar.has(q.op)}function Wl(q){return Ma.has(q.op)}class _o{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(L){const X=Object.keys(L).map(Ae=>L[Ae].map(He=>He.id));this._weightIds=[].concat(...X),this._weightMap=L}set resourceManager(L){this._resourceManager=L}get inputs(){return this._inputs.map(L=>({name:L.name,shape:L.attrParams.shape?L.attrParams.shape.value:void 0,dtype:L.attrParams.dtype?L.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(L=>({name:L.name,shape:L.attrParams.shape?L.attrParams.shape.value:void 0,dtype:L.attrParams.dtype?L.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(L=>L.signatureKey||L.name)}get outputNodes(){return this._outputs.map(L=>{const X=L.signatureKey||L.name;return L.defaultOutput?`${X}:${L.defaultOutput}`:X})}get functions(){return Object.keys(this._functions).reduce((L,X)=>(L[X]=this._functions[X].signature,L),{})}constructor(L,X){this.graph=L,this.parent=X,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=L.outputs,this._inputs=L.inputs,this._initNodes=L.initNodes,this._signature=L.signature,this._functions=L.functions,null!=L.functions&&Object.keys(L.functions).forEach(Ae=>{this._functionExecutorMap[Ae]=new _o(L.functions[Ae],this)})}getCompilationKey(L,X){const Ae=L.map(Ye=>Ye.name).sort(),He=X.map(Ye=>Ye.name).sort();return Ae.join(this.SEPARATOR)+"--"+He.join(this.SEPARATOR)}compile(L,X){const Ae=Xo(L,X,this.weightMap,this._initNodes),{missingInputs:He,dynamicNode:Ye,syncInputs:it}=Ae;if(null!=Ye)throw new Error(`This execution contains the node '${Ye.name}', which has the dynamic op '${Ye.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${it}]`);if(He.length>0){const kn=X.map(qn=>qn.name),pn=Object.keys(L);throw new Error(`Cannot compute the outputs [${kn}] from the provided inputs [${pn}]. Missing the following inputs: [${He}]`)}const _t=function go(q,L){const{usedNodes:X,inputs:Ae}=L,it=Is=>X.has("string"==typeof Is?Is:Is.name);function _t(Is){return[...new Map(Is.map(lr=>[lr.name,lr])).values()]}const wt=_t([...Object.keys(Ae).map(Is=>Ct(Is)[0]).map(Is=>q.nodes[Is]),...q.weights,...q.initNodes||[]]).filter(it),kn=_t([...wt,...Object.values(q.nodes)]).filter(it),pn=new Map(kn.map(Is=>[Is.name,Is])),qn={};for(const Is of kn){qn[Is.name]=qn[Is.name]||0;for(const lr of Is.children)it(lr)||(qn[lr.name]=Number.POSITIVE_INFINITY),qn[lr.name]=(qn[lr.name]||0)+1}const os=Object.entries(qn).filter(([,Is])=>0===Is).map(([Is])=>Is),Ms=[...os];for(;os.length>0;){const Is=os.pop(),lr=pn.get(Is);for(const yo of lr.children.filter(it))0==--qn[yo.name]&&(Ms.push(yo.name),os.push(yo.name))}const Cr=function ml(q,L){const X=new Map(q.map(it=>[it.name,it])),Ae=L.map(it=>it.name),He=new Set(Ae);for(;Ae.length>0;){const it=Ae.pop(),_t=X.get(it);for(const wt of _t.children)!X.has(wt.name)||He.has(wt.name)||(He.add(wt.name),Ae.push(wt.name))}return q.filter(it=>He.has(it.name))}(Ms.map(Is=>pn.get(Is)),wt);return function En(q,L){const X=new Map(q.map((_t,wt)=>[_t.name,wt])),Ae=new Set(L.map(_t=>_t.name)),He=_t=>Ae.has("string"==typeof _t?_t:_t.name),Ye=new Set(q.map(_t=>_t.name)),it=_t=>Ye.has("string"==typeof _t?_t:_t.name);for(const _t of q){for(const wt of _t.children.filter(it)){if(!X.has(wt.name))throw new Na(`Child ${wt.name} of node ${_t.name} is unreachable.`);if(X.get(_t.name)>X.get(wt.name))throw new Na(`Node ${_t.name} is scheduled to run after its child ${wt.name}.`)}if(!He(_t))for(const wt of _t.inputs){if(!X.has(wt.name))throw new Na(`Input ${wt.name} of node ${_t.name} is unreachable.`);if(X.get(wt.name)>X.get(_t.name))throw new Na(`Node ${_t.name} is scheduled to run before its input ${wt.name}.`)}}}(Cr,wt),Cr}(this.graph,Ae),wt=function ki(q){const L=new Map(q.map((_t,wt)=>[_t.name,wt])),X=Number.MAX_SAFE_INTEGER,Ae=q.map((_t,wt)=>gn(_t)?X:wt),He=_t=>Ae[L.get(_t.name)]??-1,Ye=q.map((_t,wt)=>_t.children.map(He).reduce((kn,pn)=>Math.max(kn,pn),Ae[wt])),it=new Map;for(let _t=0;_t<q.length;++_t){const wt=Ye[_t];if(wt===X)continue;const kn=q[_t],pn=q[wt];it.has(pn.name)||it.set(pn.name,[]),it.get(pn.name).push(kn)}return it}(_t);return{orderedNodes:_t,nodeLiveUntilMap:wt}}cloneAndKeepTensor(L){if(null==L)return null;const X=L.clone();return(0,ie.CnY)(X),X}cloneTensorList(L){return L?L.map(Ae=>this.cloneAndKeepTensor(Ae)):null}cloneTensorMap(L){return Object.fromEntries(Object.entries(L).map(([X,Ae])=>[X,this.cloneTensorList(Ae)]))}execute(L,X){this.disposeIntermediateTensors(),L=this.mapInputs(L);const Ae=Object.keys(L).sort();this.checkInputs(L),this.checkInputShapeAndType(L),X=this.mapOutputs(X),this.checkOutputs(X);const He=Ae.map(os=>this.graph.nodes[Ct(os)[0]]),Ye=X.map(os=>Ct(os)[0]),it=new Set(Ye);let _t=Ye.map(os=>this.graph.nodes[os]);0===_t.length&&(_t=this._outputs);const wt=this.getCompilationKey(He,_t);let kn=this.compiledMap.get(wt);null==kn&&(kn=this.compile(L,_t),this.compiledMap.set(wt,kn));try{this.keepIntermediateTensors=(0,ie.OBj)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(os){this.keepIntermediateTensors=!1,console.warn(os.message)}const pn={},qn={};return(0,ie.lub)(()=>{const os=new dr(this.weightMap,pn,qn,this.functionExecutorMap,this.parseNodeNameCache),Ms=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(L).forEach(lr=>{const[yo,Da]=Ct(lr,os),Jt=[];Jt[Da]=L[lr],Ms[yo]=Jt,this.keepIntermediateTensors&&(this.clonedTensorsMap[yo]=this.cloneTensorList(Jt))});const Tr=this.getFrozenTensorIds(Ms),{orderedNodes:Cr,nodeLiveUntilMap:Is}=kn;for(const lr of Cr){if(Ms[lr.name])continue;const yo=Br(lr,Ms,os,this._resourceManager);if(ie.D5U.isPromise(yo))throw new Error(`The execution of the op '${lr.op}' returned a promise. Please use model.executeAsync() instead.`);Ms[lr.name]=yo,this.keepIntermediateTensors&&(this.clonedTensorsMap[lr.name]=this.cloneTensorList(yo)),this.checkTensorForDisposalWithNodeLiveUntilInfo(lr,Ms,os,Tr,it,Is.get(lr.name))}return null==this.parent&&os.dispose(Tr),X.map(lr=>at(lr,Ms,os))})}getFrozenTensorIds(L){const X=[].concat.apply([],Object.keys(L).map(Ae=>L[Ae]).map(Ae=>Ae.map(He=>He.id)));return new Set(X)}checkTensorForDisposal(L,X,Ae,He,Ye,it,_t){if(!gn(X)&&!it.has(L)){for(const wt of Ae[L])null!=wt&&(_t[wt.id]=(_t[wt.id]||0)+X.children.length);for(const wt of X.inputs){if(gn(wt))continue;const kn=Xe(wt.name,Ae,He);if(null!=kn)for(const pn of kn){if(!pn||pn.kept||Ye.has(pn.id))continue;const qn=_t[pn.id];1===qn?(pn.dispose(),delete _t[pn.id]):null!=qn&&_t[pn.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(L,X,Ae,He,Ye,it){function _t(wt){return gn(wt)||Ye.has(wt.name)}if(!gn(L)&&null!=it)for(const wt of it){if(_t(wt))continue;const kn=Xe(wt.name,X,Ae);for(const pn of kn)!pn||pn.kept||He.has(pn.id)||pn.dispose()}}executeAsync(L,X){var Ae=this;return(0,De.Z)(function*(){return Ae._executeAsync(L,X)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(L=>{for(const X of L)X&&!X.isDisposed&&X.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(L,X,Ae=!1,He={},Ye={}){var it=this;return(0,De.Z)(function*(){it.disposeIntermediateTensors(),Ae||(L=it.mapInputs(L),it.checkInputs(L),it.checkInputShapeAndType(L),X=it.mapOutputs(X),it.checkOutputs(X));try{it.keepIntermediateTensors=(0,ie.OBj)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Ms){it.keepIntermediateTensors=!1,console.warn(Ms.message)}const _t=new dr(it.weightMap,He,Ye,it.functionExecutorMap,it.parseNodeNameCache);it.keepIntermediateTensors&&(it.clonedTensorsMap=it.cloneTensorMap(it.weightMap));const wt=yield it.executeWithControlFlow(L,_t,X,Ae),kn=X.map(Ms=>at(Ms,wt,_t)),pn=kn.map(Ms=>Ms.id),qn=Object.keys(L).map(Ms=>L[Ms].id),os=new Set([...pn,...qn,...it.weightIds]);return Object.values(wt).forEach(Ms=>{Ms.forEach(Tr=>{Tr&&!Tr.isDisposed&&!os.has(Tr.id)&&Tr.dispose()})}),null==it.parent&&_t.dispose(os),kn})()}executeFunctionAsync(L,X,Ae){var He=this;return(0,De.Z)(function*(){const Ye=L.reduce((it,_t,wt)=>(it[He.inputs[wt].name]=_t,it),{});return He._executeAsync(Ye,He.outputNodes,!0,X,Ae)})()}executeWithControlFlow(L,X,Ae,He){var Ye=this;return(0,De.Z)(function*(){const it=Object.keys(L),_t=it.map(ai=>Ye.graph.nodes[Ct(ai)[0]]),wt=Ae.map(ai=>Ct(ai)[0]),kn=new Set(wt);let pn=wt.map(ai=>Ye.graph.nodes[ai]);0===pn.length&&(pn=Ye._outputs);const{usedNodes:qn,missingInputs:os,dynamicNode:Ms,syncInputs:Tr}=Xo(L,pn,Ye.weightMap,Ye._initNodes),Cr=[..._t,...Ye.graph.weights,...Ye._initNodes||[]].map(ai=>({node:ai,contexts:X.currentContext})),Is=Object.assign({},Ye.weightMap);Object.keys(L).forEach(ai=>{const[oc,wo]=Ct(ai),Fa=[];Fa[wo]=L[ai],Is[oc]=Fa});const lr={},yo=Ye.getFrozenTensorIds(Is),Da={};for(;Cr.length>0;){const ai=Ye.processStack(_t,Cr,X,Is,Da,yo,kn,lr,qn);yield Promise.all(ai)}null==Ms&&!He&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const Jt=pn.filter(ai=>!gn(ai)&&!at(ai.name,Is,X)).map(ai=>ai.name);if(Jt.length>0){let ai="";throw null!=Ms&&(ai=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${Tr}]`),new Error(`Cannot compute the outputs [${Jt}] from the provided inputs [${it}]. Consider providing the following inputs: [${os}]. ${ai}`)}return Is})()}processStack(L,X,Ae,He,Ye,it,_t,wt,kn){const pn=[];for(;X.length>0;){const qn=X.pop();Ae.currentContext=qn.contexts;let os="";if("Enter"===qn.node.op&&v("isConstant",qn.node,He,Ae)&&([os]=Ue(qn.node.name,Ae)),null==He[qn.node.name]){const Ms=Br(qn.node,He,Ae,this._resourceManager);os||([os]=Ue(qn.node.name,Ae));const Tr=Ae.currentContext;ie.D5U.isPromise(Ms)?pn.push(Ms.then(Cr=>(He[os]=Cr,this.keepIntermediateTensors&&(this.clonedTensorsMap[os]=this.cloneTensorList(Cr)),Ae.currentContext=Tr,this.checkTensorForDisposal(os,qn.node,He,Ae,it,_t,wt),this.processChildNodes(qn.node,X,Ae,He,Ye,kn),Cr))):(He[os]=Ms,this.keepIntermediateTensors&&(this.clonedTensorsMap[os]=this.cloneTensorList(Ms)),this.checkTensorForDisposal(os,qn.node,He,Ae,it,_t,wt),this.processChildNodes(qn.node,X,Ae,He,Ye,kn))}else this.processChildNodes(qn.node,X,Ae,He,Ye,kn)}return pn}processChildNodes(L,X,Ae,He,Ye,it){L.children.forEach(_t=>{const[wt]=Ue(_t.name,Ae);Ye[wt]||!it.has(_t.name)||("Merge"===_t.op?_t.inputNames.some(kn=>!!at(kn,He,Ae))&&(Ye[wt]=!0,X.push({contexts:Ae.currentContext,node:_t})):_t.inputNames.every(kn=>!!at(kn,He,Ae))&&(Ye[wt]=!0,X.push({contexts:Ae.currentContext,node:_t})))})}dispose(){Object.keys(this.weightMap).forEach(L=>this.weightMap[L].forEach(X=>X.dispose()))}checkInputShapeAndType(L){Object.keys(L).forEach(X=>{const Ae=L[X],[He]=Ct(X),Ye=this.graph.nodes[He];if(Ye.attrParams.shape&&Ye.attrParams.shape.value){const it=Ye.attrParams.shape.value,_t=it.length===Ae.shape.length&&Ae.shape.every((wt,kn)=>-1===it[kn]||it[kn]===wt);ie.D5U.assert(_t,()=>`The shape of dict['${Ye.name}'] provided in model.execute(dict) must be [${it}], but was [${Ae.shape}]`)}Ye.attrParams.dtype&&Ye.attrParams.dtype.value&&ie.D5U.assert(Ae.dtype===Ye.attrParams.dtype.value,()=>`The dtype of dict['${Ye.name}'] provided in model.execute(dict) must be ${Ye.attrParams.dtype.value}, but was ${Ae.dtype}`)})}mapInputs(L){var X,Ae;const He={};for(const Ye in L){const it=null===(Ae=null===(X=this._signature)||void 0===X?void 0:X.inputs)||void 0===Ae?void 0:Ae[Ye];null!=it?He[it.name]=L[Ye]:He[Ye]=L[Ye]}return He}checkInputs(L){const X=Object.keys(L).filter(Ae=>{const[He]=Ct(Ae);return null==this.graph.nodes[He]});if(X.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${X}] that are not part of graph`)}mapOutputs(L){return L.map(X=>{var Ae,He;const Ye=null===(He=null===(Ae=this._signature)||void 0===Ae?void 0:Ae.outputs)||void 0===He?void 0:He[X];return null!=Ye?Ye.name:X},{})}checkOutputs(L){L.forEach(X=>{const[Ae]=Ct(X);if(!this.graph.nodes[Ae])throw new Error(`The output '${X}' is not found in the graph`)})}}class mc{constructor(L={},X={}){this.hashTableNameToHandle=L,this.hashTableMap=X}addHashTable(L,X){this.hashTableNameToHandle[L]=X.handle,this.hashTableMap[X.id]=X}getHashTableHandleByName(L){return this.hashTableNameToHandle[L]}getHashTableById(L){return this.hashTableMap[L]}dispose(){for(const L in this.hashTableMap)this.hashTableMap[L].clearAndClose(),delete this.hashTableMap[L];for(const L in this.hashTableNameToHandle)this.hashTableNameToHandle[L].dispose(),delete this.hashTableNameToHandle[L]}}var Ro;const ll="?tfjs-format=file",Si="model.json";class Ca{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(L,X={},Ae=ie.io){this.modelUrl=L,this.loadOptions=X,this.version="n/a",this.io=Ae,null==X&&(this.loadOptions={}),this.resourceManager=new mc}findIOHandler(){const L=this.modelUrl;if(null!=L.load)this.handler=L;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(L,this.loadOptions);else{const X=this.io.getLoadHandlers(L,this.loadOptions);if(0===X.length)X.push(this.io.browserHTTPRequest(L,this.loadOptions));else if(X.length>1)throw new Error(`Found more than one (${X.length}) load handlers for URL '${[L]}'`);this.handler=X[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const L=this.handler.load();return ie.D5U.isPromise(L)?L.then(X=>this.loadSync(X)):this.loadSync(L)}loadSync(L){this.artifacts=L;const X=this.artifacts.modelTopology;let Ae=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const Ye=this.artifacts.userDefinedMetadata;null!=Ye.signature&&(Ae=Ye.signature),null!=Ye.structuredOutputKeys&&(this.structuredOutputKeys=Ye.structuredOutputKeys)}this.signature=Ae,this.version=`${X.versions.producer}.${X.versions.minConsumer}`;const He=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new _o(eo.Instance.transformGraph(X,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(He),this.executor.resourceManager=this.resourceManager,null!=L.modelInitializer&&null!=L.modelInitializer.node){const Ye=eo.Instance.transformGraph(L.modelInitializer);this.initializer=new _o(Ye),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=L.initializerSignature}return!0}save(L,X){var Ae=this;return(0,De.Z)(function*(){if("string"==typeof L){const He=Ae.io.getSaveHandlers(L);if(0===He.length)throw new Error(`Cannot find any save handlers for URL '${L}'`);if(He.length>1)throw new Error(`Found more than one (${He.length}) save handlers for URL '${L}'`);L=He[0]}if(null==L.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return L.save(Ae.artifacts)})()}addStructuredOutputNames(L){if(this.structuredOutputKeys){const Ae={};return(L instanceof ie.esB?[L]:L).forEach((He,Ye)=>Ae[this.structuredOutputKeys[Ye]]=He),Ae}return L}predict(L,X){const Ae=this.execute(L,this.outputNodes);return this.addStructuredOutputNames(Ae)}predictAsync(L,X){var Ae=this;return(0,De.Z)(function*(){const He=yield Ae.executeAsync(L,Ae.outputNodes);return Ae.addStructuredOutputNames(He)})()}normalizeInputs(L){var X;if(!(L instanceof ie.esB||Array.isArray(L))){const Ye=null===(X=this.signature)||void 0===X?void 0:X.inputs;if(null!=Ye)for(const it in Ye){const _t=Ye[it];null!=_t.resourceId&&(L[it]=this.resourceIdToCapturedInput[_t.resourceId])}return L}L=Array.isArray(L)?L:[L];const Ae=Object.keys(this.resourceIdToCapturedInput).length;if(L.length+Ae!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-Ae} non-resource placeholders, while there are ${L.length} input tensors provided.`);let He=0;return this.inputNodes.reduce((Ye,it)=>{var _t,wt,kn;const pn=null===(kn=null===(wt=null===(_t=this.signature)||void 0===_t?void 0:_t.inputs)||void 0===wt?void 0:wt[it])||void 0===kn?void 0:kn.resourceId;return Ye[it]=null!=pn?this.resourceIdToCapturedInput[pn]:L[He++],Ye},{})}normalizeOutputs(L){return L=L||this.outputNodes,Array.isArray(L)?L:[L]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var L=this;return(0,De.Z)(function*(){return null==L.initializer?[]:L.initializer.executeAsync({},null==L.initializerSignature?[]:Object.keys(L.initializerSignature.outputs))})()}setResourceIdToCapturedInput(L){if(this.resourceIdToCapturedInput={},this.initializerSignature){const X=this.initializerSignature.outputs,Ae=Object.keys(X);for(let He=0;He<Ae.length;He++)this.resourceIdToCapturedInput[X[Ae[He]].resourceId]=L[He]}}execute(L,X){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),L=this.normalizeInputs(L),X=this.normalizeOutputs(X);const Ae=this.executor.execute(L,X);return Ae.length>1?Ae:Ae[0]}executeAsync(L,X){var Ae=this;return(0,De.Z)(function*(){null==Ae.resourceIdToCapturedInput&&Ae.setResourceIdToCapturedInput(yield Ae.executeInitializerGraphAsync()),L=Ae.normalizeInputs(L),X=Ae.normalizeOutputs(X);const He=yield Ae.executor.executeAsync(L,X);return He.length>1?He:He[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(L){return Object.keys(L).reduce((X,Ae)=>(X[Ae]=[L[Ae]],X),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,ie.B90)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function Pa(q){return(Ro=Ro||(0,De.Z)(function*(L,X={},Ae=ie.io){if(null==L)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==X&&(X={}),X.fromTFHub&&"string"==typeof L&&(L=function gl(q){return q.endsWith("/")||(q+="/"),`${q}${Si}${ll}`}(L));const He=new Ca(L,X,Ae);return yield He.load(),He})).apply(this,arguments)}function Ea(q){if(null==q)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let L;if(q instanceof Array){const[Ae,He]=q;if(!Ae)throw new Error("modelJSON must be the first element of the array");if(!(He&&He instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in Ae))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in Ae))throw new Error("Model JSON is missing 'weightsManifest'");const Ye=ie.io.getWeightSpecs(Ae.weightsManifest),it=ie.io.getModelArtifactsForJSONSync(Ae,Ye,He);L=ie.io.fromMemorySync(it)}else if("load"in q)L=q;else{if(!("modelTopology"in q&&"weightSpecs"in q&&"weightData"in q))throw new Error("Unknown model format");L=ie.io.fromMemorySync(q)}const X=new Ca(L);return X.load(),X}const _l="4.11.0"},7173:(Et,le,h)=>{"use strict";h.d(le,{JL:()=>y,Zu:()=>F});class y{constructor(W,l){this.backend=W,this.dataMover=l,this.data=new WeakMap,this.dataIdsCount=0}get(W){return this.data.has(W)||this.dataMover.moveData(this.backend,W),this.data.get(W)}set(W,l){this.dataIdsCount++,this.data.set(W,l)}has(W){return this.data.has(W)}delete(W){return this.dataIdsCount--,this.data.delete(W)}numDataIds(){return this.dataIdsCount}}class F{refCount(W){return I("refCount")}incRef(W){return I("incRef")}timerAvailable(){return!0}time(W){return I("time")}read(W){return I("read")}readSync(W){return I("readSync")}readToGPU(W,l){return I("readToGPU")}numDataIds(){return I("numDataIds")}disposeData(W,l){return I("disposeData")}write(W,l,w){return I("write")}move(W,l,w,M,T){return I("move")}createTensorFromGPUData(W,l,w){return I("createTensorFromGPUData")}memory(){return I("memory")}floatPrecision(){return I("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return I("dispose")}}function I(N){throw new Error(`'${N}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},5672:(Et,le,h)=>{"use strict";function U(D,G,J){const K=function Z(D,G,J){return function F(D,G,J){let K=0,_e=D.length,Re=0,we=!1;for(;K<_e;){Re=K+(_e-K>>>1);const We=J(G,D[Re]);We>0?K=Re+1:(_e=Re,we=!We)}return we?K:-K-1}(D,G,J||y)}(D,G,J);D.splice(K<0?-(K+1):K,0,G)}function y(D,G){return D>G?1:D<G?-1:0}function I(D,G,J,K,_e){return l(D,G,J,K,_e,0)}function N(D,G,J,K,_e,Re){return l(D,G,J,K,_e,0,!1,Re,!0)}function W(D,G,J,K,_e,Re){return l(D,G,J,K,_e,Re,!0)}function l(D,G,J,K,_e,Re,we=!1,We=!1,Oe=!1){const ie=[];for(let ye=0;ye<G.length;ye++)G[ye]>_e&&ie.push({score:G[ye],boxIndex:ye,suppressBeginIndex:0});ie.sort(T);const Le=Re>0?-.5/Re:0,De=[],te=[];for(;De.length<J&&ie.length>0;){const ye=ie.pop(),{score:Te,boxIndex:v,suppressBeginIndex:at}=ye;if(Te<_e)break;let Xe=!1;for(let Ue=De.length-1;Ue>=at;--Ue){const pt=w(D,v,De[Ue]);if(pt>=K){Xe=!0;break}if(ye.score=ye.score*M(K,Le,pt),ye.score<=_e)break}ye.suppressBeginIndex=De.length,Xe||(ye.score===Te?(De.push(v),te.push(ye.score)):ye.score>_e&&U(ie,ye,T))}const de=De.length,P=J-de;We&&P>0&&(De.push(...new Array(P).fill(0)),te.push(...new Array(P).fill(0)));const oe={selectedIndices:De};return we&&(oe.selectedScores=te),Oe&&(oe.validOutputs=de),oe}function w(D,G,J){const K=D.subarray(4*G,4*G+4),_e=D.subarray(4*J,4*J+4),Re=Math.min(K[0],K[2]),we=Math.min(K[1],K[3]),We=Math.max(K[0],K[2]),Oe=Math.max(K[1],K[3]),ie=Math.min(_e[0],_e[2]),Le=Math.min(_e[1],_e[3]),De=Math.max(_e[0],_e[2]),te=Math.max(_e[1],_e[3]),de=(We-Re)*(Oe-we),P=(De-ie)*(te-Le);if(de<=0||P<=0)return 0;const oe=Math.max(Re,ie),ye=Math.max(we,Le),Te=Math.min(We,De),v=Math.min(Oe,te),at=Math.max(Te-oe,0)*Math.max(v-ye,0);return at/(de+P-at)}function M(D,G,J){const K=Math.exp(G*J*J);return J<=D?K:0}function T(D,G){return D.score-G.score||D.score===G.score&&G.boxIndex-D.boxIndex}h.d(le,{GP:()=>I,qP:()=>N,pA:()=>W})},7349:(Et,le,h)=>{"use strict";h.d(le,{Z:()=>Z});var U=h(582);function Z(y,F){const I=[];for(let l=0;l<F.length;l++)F[l]&&I.push(l);const N=(0,U.f)(y,"int32"),W=(0,U.f)([I.length,y.length],"int32");for(let l=0;l<I.length;l++){const w=N.indexToLoc(I[l]);W.values.set(w,l*y.length)}return W.toTensor()}},687:(Et,le,h)=>{"use strict";h.d(le,{BV:()=>Le,wv:()=>ie});var U=h(5861),Z=h(7173),y=h(5527),F=h(2918),I=h(4251),N=h(8987),W=h(2932),l=h(1153),w=h(5359);class M{constructor(de,P){this.backendTimer=de,this.logger=P,null==P&&(this.logger=new D)}profileKernel(de,P,oe){let ye;const Te=()=>{ye=oe()};let v;const at=l.now();if(this.backendTimer.timerAvailable())v=this.backendTimer.time(Te);else{Te();for(const Ue of ye)Ue.dataSync();v=Promise.resolve({kernelMs:l.now()-at})}if((0,y.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let Ue=0;Ue<ye.length;Ue++){const pt=ye[Ue];pt.data().then(Ct=>{T(Ct,pt.dtype,de)})}return{kernelName:de,outputs:ye,inputs:P,timeMs:v.then(Ue=>Ue.kernelMs),extraInfo:v.then(Ue=>null!=Ue.getExtraProfileInfo?Ue.getExtraProfileInfo():"")}}logKernelProfile(de){const{kernelName:P,outputs:oe,timeMs:ye,inputs:Te,extraInfo:v}=de;oe.forEach(at=>{Promise.all([at.data(),ye,v]).then(Xe=>{this.logger.logKernelProfile(P,at,Xe[0],Xe[1],Te,Xe[2])})})}}function T(te,de,P){if("float32"!==de)return!1;for(let oe=0;oe<te.length;oe++){const ye=te[oe];if(isNaN(ye)||!isFinite(ye))return console.warn(`Found ${ye} in the result of '${P}'`),!0}return!1}class D{logKernelProfile(de,P,oe,ye,Te,v){const at="number"==typeof ye?w.oj(`${ye}ms`,9):ye.error,Xe=w.oj(de,25),Ue=P.rank,pt=P.size,Ct=w.oj(P.shape.toString(),14);let It="";for(const nn in Te){const Bt=Te[nn];if(null!=Bt){const bn=Bt.shape||P.shape,Qn=bn.length;It+=`${nn}: ${Qn}D ${Qn>0?bn:""} `}}console.log(`%c${Xe}\t%c${at}\t%c${Ue}D ${Ct}\t%c${pt}\t%c${It}\t%c${v}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var K=h(4945),_e=h(7664);function Re(te){return null!=te.kernelName}class we{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(de=>de.name)))}}}dispose(){for(const de in this.registeredVariables)this.registeredVariables[de].dispose()}}let We=(()=>{class te{constructor(P){this.ENV=P,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new we}ready(){var P=this;return(0,U.Z)(function*(){if(null!=P.pendingBackendInit)return P.pendingBackendInit.then(()=>{});if(null!=P.backendInstance)return;const oe=P.getSortedBackends();for(let ye=0;ye<oe.length;ye++){const Te=oe[ye];if(yield P.initializeBackend(Te).success)return void(yield P.setBackend(Te))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:P,asyncInit:oe}=this.initializeBackendsAndReturnBest();if(oe)throw new Error(`The highest priority backend '${P}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(P)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(P){if(!(P in this.registry)){if(!(P in this.registryFactory))return null;{const{asyncInit:oe}=this.initializeBackend(P);if(oe)return null}}return this.registry[P]}findBackendFactory(P){return P in this.registryFactory?this.registryFactory[P].factory:null}registerBackend(P,oe,ye=1){return P in this.registryFactory?(W.Z(`${P} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[P]={factory:oe,priority:ye},!0)}setBackend(P){var oe=this;return(0,U.Z)(function*(){if(null==oe.registryFactory[P])throw new Error(`Backend name '${P}' not found in registry`);if(oe.backendName=P,null==oe.registry[P]){oe.backendInstance=null;const{success:ye,asyncInit:Te}=oe.initializeBackend(P);if(!(Te?yield ye:ye))return!1}return oe.backendInstance=oe.registry[P],oe.setupRegisteredKernels(),oe.profiler=new M(oe.backendInstance),!0})()}setupRegisteredKernels(){(0,N.tr)(this.backendName).forEach(oe=>{null!=oe.setupFunc&&oe.setupFunc(this.backendInstance)})}disposeRegisteredKernels(P){(0,N.tr)(P).forEach(ye=>{null!=ye.disposeFunc&&ye.disposeFunc(this.registry[P])})}initializeBackend(P){const oe=this.registryFactory[P];if(null==oe)throw new Error(`Cannot initialize backend ${P}, no registration found.`);try{const ye=oe.factory();if(!ye||ye instanceof Z.Zu||"function"!=typeof ye.then)return this.registry[P]=ye,{success:!0,asyncInit:!1};{const Te=++this.pendingBackendInitId,v=ye.then(at=>!(Te<this.pendingBackendInitId||(this.registry[P]=at,this.pendingBackendInit=null,0))).catch(at=>(Te<this.pendingBackendInitId||(this.pendingBackendInit=null,W.Z(`Initialization of backend ${P} failed`),W.Z(at.stack||at.message)),!1));return this.pendingBackendInit=v,{success:v,asyncInit:!0}}}catch(ye){return W.Z(`Initialization of backend ${P} failed`),W.Z(ye.stack||ye.message),{success:!1,asyncInit:!1}}}removeBackend(P){if(!(P in this.registryFactory))throw new Error(`${P} backend not found in registry`);this.backendName===P&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,P in this.registry&&(this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P]),delete this.registryFactory[P],this.backendName===P&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((P,oe)=>this.registryFactory[oe].priority-this.registryFactory[P].priority)}initializeBackendsAndReturnBest(){const P=this.getSortedBackends();for(let oe=0;oe<P.length;oe++){const ye=P[oe],{success:Te,asyncInit:v}=this.initializeBackend(ye);if(v||Te)return{name:ye,asyncInit:v}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(P,oe){const ye=this.state.tensorInfo.get(oe),Te=ye.backend,v=this.readSync(oe),at=Te.refCount(oe);Te.disposeData(oe,!0),ye.backend=P,P.move(oe,v,ye.shape,ye.dtype,at),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(P,oe){let Te,ye=null;if(null==oe){if("function"!=typeof P)throw new Error("Please provide a function to tidy()");oe=P}else{if("string"!=typeof P&&!(P instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof oe)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");ye=P}return this.scopedRun(()=>this.startScope(ye),()=>this.endScope(Te),()=>(Te=oe(),Te instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Te))}scopedRun(P,oe,ye){P();try{const Te=ye();return oe(),Te}catch(Te){throw oe(),Te}}nextTensorId(){return te.nextTensorId++}nextVariableId(){return te.nextVariableId++}clone(P){const oe=Le.runKernel(I.iJz,{x:P});return this.addTapeNode(this.state.activeScope.name,{x:P},[oe],at=>({x:()=>Le.runKernel(I.RFZ,{x:at},{dtype:"float32"})}),[],{}),oe}runKernel(P,oe,ye){if(null==(0,N.pI)(P,this.backendName))throw new Error(`Kernel '${P}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:P,inputs:oe,attrs:ye})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(P,oe,ye){const Te=this.backend.numDataIds();let v=0;ye.forEach(Ue=>{v+="complex64"===Ue.dtype?3:1});const Xe=Te-oe-v-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(Xe>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${Xe} data ids) after running '${P}'`)}runKernelFunc(P){let oe,ye=[];const Te=this.isTapeOn(),v=this.state.numBytes,at=this.state.numTensors;let Xe,Ue;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const pt=Re(P)?P.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Re(P)){const{kernelName:bn,inputs:Qn,attrs:Dn}=P,ps=(0,N.pI)(bn,this.backendName);w.hu(null!=ps,()=>`Cannot find registered kernel '${bn}' for backend '${this.backendName}'`),Xe=()=>{const Es=this.backend.numDataIds();Ue=ps.kernelFunc({inputs:Qn,attrs:Dn,backend:this.backend});const Xn=Array.isArray(Ue)?Ue:[Ue];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(bn,Es,Xn);const Ts=Xn.map(or=>null!=or.rank?or:this.makeTensorFromTensorInfo(or));if(Te){const or=this.getTensorsForGradient(bn,Qn,Ts);ye=this.saveTensorsForBackwardMode(or)}return Ts}}else{const{forwardFunc:bn}=P,Qn=Dn=>{Te&&(ye=Dn.map(ps=>this.keep(this.clone(ps))))};Xe=()=>{const Dn=this.backend.numDataIds();Ue=this.tidy(()=>bn(this.backend,Qn));const ps=Array.isArray(Ue)?Ue:[Ue];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(pt,Dn,ps),ps}}const{inputs:Ct,attrs:It}=P,nn=Re(P)?null:P.backwardsFunc;let Bt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Bt=this.profiler.profileKernel(pt,Ct,()=>Xe()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Bt),oe=Bt.outputs):oe=Xe()}),Te&&this.addTapeNode(pt,Ct,oe,nn,ye,It),this.state.profiling&&this.state.activeProfile.kernels.push({name:pt,bytesAdded:this.state.numBytes-v,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-at,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Ct).map(bn=>null!=Ct[bn]?Ct[bn].shape:null),outputShapes:oe.map(bn=>bn.shape),kernelTimeMs:Bt.timeMs,extraInfo:Bt.extraInfo}),Array.isArray(Ue)?oe:oe[0]}saveTensorsForBackwardMode(P){return P.map(ye=>this.keep(this.clone(ye)))}getTensorsForGradient(P,oe,ye){const Te=(0,N.uk)(P);if(null!=Te){const v=Te.inputsToSave||[],at=Te.outputsToSave||[];let Xe;Te.saveAllInputs?(w.hu(Array.isArray(oe),()=>"saveAllInputs is true, expected inputs to be an array."),Xe=Object.keys(oe).map(pt=>oe[pt])):Xe=v.map(pt=>oe[pt]);const Ue=ye.filter((pt,Ct)=>at[Ct]);return Xe.concat(Ue)}return[]}makeTensor(P,oe,ye,Te){if(null==P)throw new Error("Values passed to engine.makeTensor() are null");Te=Te||this.backend;let v=P;"string"===(ye=ye||"float32")&&w.HD(P[0])&&(v=P.map(Ue=>l.encodeString(Ue)));const at=Te.write(v,oe,ye),Xe=new K.es(oe,ye,at,this.nextTensorId());if(this.trackTensor(Xe,Te),"string"===ye){const Ue=this.state.tensorInfo.get(at),pt=(0,w.Ub)(v);this.state.numBytes+=pt-Ue.bytes,Ue.bytes=pt}return Xe}makeTensorFromDataId(P,oe,ye,Te){return this.makeTensorFromTensorInfo({dataId:P,shape:oe,dtype:ye=ye||"float32"},Te)}makeTensorFromTensorInfo(P,oe){const{dataId:ye,shape:Te,dtype:v}=P,at=new K.es(Te,v,ye,this.nextTensorId());return this.trackTensor(at,oe),at}makeVariable(P,oe=!0,ye,Te){ye=ye||this.nextVariableId().toString(),null!=Te&&Te!==P.dtype&&(P=P.cast(Te));const v=new K._w(P,oe,ye,this.nextTensorId());if(null!=this.state.registeredVariables[v.name])throw new Error(`Variable with name ${v.name} was already registered`);return this.state.registeredVariables[v.name]=v,this.incRef(v,this.backend),v}trackTensor(P,oe){this.state.numTensors++,"string"===P.dtype&&this.state.numStringTensors++;let ye=0;"complex64"!==P.dtype&&"string"!==P.dtype&&(ye=P.size*w.bT(P.dtype)),this.state.numBytes+=ye,this.state.tensorInfo.has(P.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(P.dataId,{backend:oe||this.backend,dtype:P.dtype,shape:P.shape,bytes:ye})),P instanceof K._w||this.track(P)}incRef(P,oe){this.trackTensor(P,oe),this.backend.incRef(P.dataId)}removeDataId(P,oe){this.state.tensorInfo.has(P)&&this.state.tensorInfo.get(P).backend===oe&&(this.state.tensorInfo.delete(P),this.state.numDataBuffers--)}disposeTensor(P){if(!this.state.tensorInfo.has(P.dataId))return;const oe=this.state.tensorInfo.get(P.dataId);if(this.state.numTensors--,"string"===P.dtype&&(this.state.numStringTensors--,this.state.numBytes-=oe.bytes),"complex64"!==P.dtype&&"string"!==P.dtype){const ye=P.size*w.bT(P.dtype);this.state.numBytes-=ye}oe.backend.disposeData(P.dataId)&&this.removeDataId(P.dataId,oe.backend)}disposeVariables(){for(const P in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[P])}disposeVariable(P){this.disposeTensor(P),null!=this.state.registeredVariables[P.name]&&delete this.state.registeredVariables[P.name]}memory(){const P=this.backend.memory();return P.numTensors=this.state.numTensors,P.numDataBuffers=this.state.numDataBuffers,P.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(P.unreliable=!0,null==P.reasons&&(P.reasons=[]),P.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),P}profile(P){var oe=this;return(0,U.Z)(function*(){oe.state.profiling=!0;const ye=oe.state.numBytes,Te=oe.state.numTensors;oe.state.activeProfile.kernels=[],oe.state.activeProfile.result=yield P(),oe.state.profiling=!1,oe.state.activeProfile.peakBytes=Math.max(...oe.state.activeProfile.kernels.map(v=>v.totalBytesSnapshot)),oe.state.activeProfile.newBytes=oe.state.numBytes-ye,oe.state.activeProfile.newTensors=oe.state.numTensors-Te;for(const v of oe.state.activeProfile.kernels)v.kernelTimeMs=yield v.kernelTimeMs,v.extraInfo=yield v.extraInfo;return oe.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(P,oe,ye,Te,v,at){const Xe={id:this.state.nextTapeNodeId++,kernelName:P,inputs:oe,outputs:ye,saved:v},Ue=(0,N.uk)(P);null!=Ue&&(Te=Ue.gradFunc),null!=Te&&(Xe.gradient=pt=>(pt=pt.map((Ct,It)=>{if(null==Ct){const nn=ye[It],Bt=w.wT(nn.size,nn.dtype);return this.makeTensor(Bt,nn.shape,nn.dtype)}return Ct}),Te(pt.length>1?pt:pt[0],v,at))),this.state.activeTape.push(Xe)}keep(P){return P.kept=!0,P}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(P){const oe={track:[],name:"unnamed scope",id:this.state.nextScopeId++};P&&(oe.name=P),this.state.scopeStack.push(oe),this.state.activeScope=oe}endScope(P){const oe=(0,_e.getTensorsInContainer)(P),ye=new Set(oe.map(v=>v.id));for(let v=0;v<this.state.activeScope.track.length;v++){const at=this.state.activeScope.track[v];!at.kept&&!ye.has(at.id)&&at.dispose()}const Te=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],oe.forEach(v=>{!v.kept&&v.scopeId===Te.id&&this.track(v)})}gradients(P,oe,ye,Te=!1){if(w.hu(oe.length>0,()=>"gradients() received an empty list of xs."),null!=ye&&"float32"!==ye.dtype)throw new Error(`dy must have 'float32' dtype, but has '${ye.dtype}'`);const v=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",P));w.hu(v instanceof K.es,()=>"The result y returned by f() must be a tensor.");const at=function G(te,de,P){const oe={},ye={};for(let Xe=0;Xe<de.length;Xe++)oe[de[Xe].id]=!0;for(let Xe=0;Xe<te.length;Xe++){const Ue=te[Xe],pt=Ue.inputs;for(const Ct in pt){const It=pt[Ct];let nn=!1;for(let Bt=0;Bt<de.length;Bt++)if(oe[It.id]){Ue.outputs.forEach(bn=>oe[bn.id]=!0),nn=!0,ye[Ue.id]=!0;break}if(nn)break}}const Te={};Te[P.id]=!0;const v={};for(let Xe=te.length-1;Xe>=0;Xe--){const Ue=te[Xe],pt=Ue.inputs;for(let Ct=0;Ct<Ue.outputs.length;Ct++)if(Te[Ue.outputs[Ct].id]){for(const It in pt)Te[pt[It].id]=!0,v[Ue.id]=!0;break}}const at=[];for(let Xe=0;Xe<te.length;Xe++){const Ue=te[Xe];if(ye[Ue.id]&&v[Ue.id]){const pt={};for(const It in Ue.inputs){const nn=Ue.inputs[It];oe[nn.id]&&(pt[It]=nn)}const Ct=Object.assign({},Ue);Ct.inputs=pt,Ct.outputs=Ue.outputs,at.push(Ct)}}return at}(this.state.activeTape,oe,v);if(!Te&&0===at.length&&oe.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const Xe={};Xe[v.id]=ye??function Oe(te){const de=(0,w.p8)((0,w.NA)(te),"float32");return Le.makeTensor(de,te,"float32")}(v.shape),function J(te,de,P,oe){for(let ye=de.length-1;ye>=0;ye--){const Te=de[ye],v=[];if(Te.outputs.forEach(Xe=>{const Ue=te[Xe.id];v.push(null!=Ue?Ue:null)}),null==Te.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${Te.kernelName}.`);const at=Te.gradient(v);for(const Xe in Te.inputs){if(!(Xe in at))throw new Error(`Cannot backprop through input ${Xe}. Available gradients found: ${Object.keys(at)}.`);const Ue=P(()=>at[Xe]());if("float32"!==Ue.dtype)throw new Error(`Error in gradient for op ${Te.kernelName}. The gradient of input ${Xe} must have 'float32' dtype, but has '${Ue.dtype}'`);const pt=Te.inputs[Xe];if(!w.cO(Ue.shape,pt.shape))throw new Error(`Error in gradient for op ${Te.kernelName}. The gradient of input '${Xe}' has shape '${Ue.shape}', which does not match the shape of the input '${pt.shape}'`);if(null==te[pt.id])te[pt.id]=Ue;else{const Ct=te[pt.id];te[pt.id]=oe(Ct,Ue),Ct.dispose()}}}}(Xe,at,pt=>this.tidy(pt),De);const Ue=oe.map(pt=>Xe[pt.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(pt=>{for(const Ct of pt.saved)Ct.dispose()}),this.state.activeTape=null),{value:v,grads:Ue}})}customGrad(P){return w.hu(w.mf(P),()=>"The f passed in customGrad(f) must be a function."),(...oe)=>{let ye;w.hu(oe.every(Xe=>Xe instanceof K.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const Te={};return oe.forEach((Xe,Ue)=>{Te[Ue]=Xe}),this.runKernelFunc({forwardFunc:(Xe,Ue)=>(ye=P(...oe,Ue),w.hu(ye.value instanceof K.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),w.hu(w.mf(ye.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),ye.value),backwardsFunc:(Xe,Ue)=>{const pt=ye.gradFunc(Xe,Ue),Ct=Array.isArray(pt)?pt:[pt];w.hu(Ct.length===oe.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),w.hu(Ct.every(nn=>nn instanceof K.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const It={};return Ct.forEach((nn,Bt)=>{It[Bt]=()=>nn}),It},inputs:Te})}}readSync(P){return this.state.tensorInfo.get(P).backend.readSync(P)}read(P){return this.state.tensorInfo.get(P).backend.read(P)}readToGPU(P,oe){return this.state.tensorInfo.get(P).backend.readToGPU(P,oe)}time(P){var oe=this;return(0,U.Z)(function*(){const ye=(0,l.now)(),Te=yield oe.backend.time(P);return Te.wallMs=(0,l.now)()-ye,Te})()}track(P){return null!=this.state.activeScope&&(P.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(P)),P}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new we;for(const P in this.registry)this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return te.nextTensorId=0,te.nextVariableId=0,te})();function ie(){const te=(0,F.D)();if(null==te._tfengine){const de=new y.qA(te);te._tfengine=new We(de)}return(0,y.iG)(te._tfengine.ENV),(0,K.Vi)(()=>te._tfengine),te._tfengine}const Le=ie();function De(te,de){return Le.runKernel(I.mm_,{a:te,b:de})}},5527:(Et,le,h)=>{"use strict";h.d(le,{OB:()=>l,Vi:()=>w,iG:()=>M,qA:()=>F});var U=h(5861),Z=h(5359);const y="tfjsflags";class F{constructor(D){this.global=D,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=I,this.populateURLFlags()}setPlatform(D,G){null!=this.platform&&(l().getBool("IS_TEST")||l().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${D}.`)),this.platformName=D,this.platform=G}registerFlag(D,G,J){if(this.flagRegistry[D]={evaluationFn:G,setHook:J},null!=this.urlFlags[D]){const K=this.urlFlags[D];l().getBool("IS_TEST")||l().getBool("PROD")||console.warn(`Setting feature override from URL ${D}: ${K}.`),this.set(D,K)}}getAsync(D){var G=this;return(0,U.Z)(function*(){return D in G.flags||(G.flags[D]=yield G.evaluateFlag(D)),G.flags[D]})()}get(D){if(D in this.flags)return this.flags[D];const G=this.evaluateFlag(D);if((0,Z.tI)(G))throw new Error(`Flag ${D} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[D]=G,this.flags[D]}getNumber(D){return this.get(D)}getBool(D){return this.get(D)}getString(D){return this.get(D)}getFlags(){return this.flags}get features(){return this.flags}set(D,G){if(null==this.flagRegistry[D])throw new Error(`Cannot set flag ${D} as it has not been registered.`);this.flags[D]=G,null!=this.flagRegistry[D].setHook&&this.flagRegistry[D].setHook(G)}evaluateFlag(D){if(null==this.flagRegistry[D])throw new Error(`Cannot evaluate flag '${D}': no evaluation function found.`);return this.flagRegistry[D].evaluationFn()}setFlags(D){this.flags=Object.assign({},D)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const D=this.getQueryParams(this.global.location.search);y in D&&D[y].split(",").forEach(J=>{const[K,_e]=J.split(":");this.urlFlags[K]=function W(T,D){const G=D.toLowerCase();return"true"===G||"false"===G?"true"===G:""+ +G===G?+G:D}(0,_e)})}}function I(T){const D={};return T.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(G,...J)=>(function N(T,D,G){T[decodeURIComponent(D)]=decodeURIComponent(G||"")}(D,J[0],J[1]),J.join("="))),D}function l(){return w}let w=null;function M(T){w=T}},2918:(Et,le,h)=>{"use strict";let U;function Z(){if(null==U){let I;if(typeof window<"u")I=window;else if(typeof global<"u")I=global;else if(typeof process<"u")I=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");I=self}U=I}return U}function F(I,N){const W=function y(){const I=Z();return null==I._tfGlobals&&(I._tfGlobals=new Map),I._tfGlobals}();if(W.has(I))return W.get(I);{const l=N();return W.set(I,l),W.get(I)}}h.d(le,{D:()=>Z,R:()=>F})},2773:(Et,le,h)=>{"use strict";h.d(le,{B9:()=>J,CQ:()=>Re,Cd:()=>we,Cn:()=>K,G4:()=>I,MX:()=>l,N5:()=>D,N8:()=>w,N_:()=>We,R:()=>N,SR:()=>M,VY:()=>de,XV:()=>_e,cF:()=>W,cj:()=>Oe,jq:()=>De,lu:()=>G,sq:()=>T,x3:()=>ie,y3:()=>te,ze:()=>Le});var U=h(687),Z=h(5527),y=h(4945),F=h(7664);function I(){(0,Z.OB)().set("PROD",!0)}function N(){(0,Z.OB)().set("DEBUG",!0)}function W(){(0,Z.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function l(P){(0,Z.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(P+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function w(){U.BV.disposeVariables()}function M(){return U.BV}function T(){return U.BV.memory()}function D(P){return U.BV.profile(P)}function G(P,oe){return U.BV.tidy(P,oe)}function J(P){(0,F.getTensorsInContainer)(P).forEach(ye=>ye.dispose())}function K(P){return U.BV.keep(P)}function _e(P){return U.BV.time(P)}function Re(P){return U.BV.setBackend(P)}function we(){return U.BV.ready()}function We(){return U.BV.backendName}function Oe(P){U.BV.removeBackend(P)}function ie(P){return U.BV.findBackend(P)}function Le(P){return U.BV.findBackendFactory(P)}function De(P,oe,ye=1){return U.BV.registerBackend(P,oe,ye)}function te(){return U.BV.backend}function de(P,oe){(0,Z.OB)().setPlatform(P,oe)}(0,y.FZ)(l)},3537:(Et,le,h)=>{"use strict";h.d(le,{UQ:()=>I,cb:()=>M,fN:()=>l,h7:()=>W,pn:()=>w,ti:()=>N});var U=h(687),Z=h(4945),y=h(1257),F=h(5359);function I(D){return F.hu(F.mf(D),()=>"The f passed in grad(f) must be a function"),(G,J)=>{const K=(0,y._1)(G,"x","tf.grad","string_or_numeric"),_e=null!=J?(0,y._1)(J,"dy","tf.grad"):null;return U.BV.tidy(()=>{const{value:Re,grads:we}=U.BV.gradients(()=>D(K),[K],_e);return null!=_e&&F.k5(Re.shape,_e.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),T(we),we[0]})}}function N(D){return F.hu(F.mf(D),()=>"The f passed in grads(f) must be a function"),(G,J)=>{F.hu(Array.isArray(G),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const K=(0,y.sI)(G,"args","tf.grads","string_or_numeric"),_e=null!=J?(0,y._1)(J,"dy","tf.grads"):null;return U.BV.tidy(()=>{const{value:Re,grads:we}=U.BV.gradients(()=>D(...K),K,_e);return null!=_e&&F.k5(Re.shape,_e.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),T(we),we})}}function W(D){return F.hu(F.mf(D),()=>"The f passed in valueAndGrad(f) must be a function"),(G,J)=>{F.hu(G instanceof Z.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),F.hu(null==J||J instanceof Z.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:K,value:_e}=U.BV.gradients(()=>D(G),[G],J);return T(K),{grad:K[0],value:_e}}}function l(D){return F.hu(F.mf(D),()=>"The f passed in valueAndGrads(f) must be a function"),(G,J)=>{F.hu(Array.isArray(G)&&G.every(_e=>_e instanceof Z.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),F.hu(null==J||J instanceof Z.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const K=U.BV.gradients(()=>D(...G),G,J);return null!=J&&F.k5(K.value.shape,J.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),T(K.grads),K}}function w(D,G){F.hu(F.mf(D),()=>"The f passed in variableGrads(f) must be a function"),F.hu(null==G||Array.isArray(G)&&G.every(ie=>ie instanceof Z._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const J=null!=G;if(!J){G=[];for(const ie in U.BV.registeredVariables)G.push(U.BV.registeredVariables[ie])}const K=J?G.filter(ie=>!ie.trainable):null,_e=G.length;G=G.filter(ie=>ie.trainable),F.hu(G.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${_e} variables is trainable.`);const{value:we,grads:We}=U.BV.gradients(D,G,null,!0);F.hu(We.some(ie=>null!=ie),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),F.hu(0===we.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${we.rank} tensor`);const Oe={};return G.forEach((ie,Le)=>{null!=We[Le]&&(Oe[ie.name]=We[Le])}),K?.forEach(ie=>Oe[ie.name]=null),{value:we,grads:Oe}}function M(D){return U.BV.customGrad(D)}function T(D){if(D.filter(J=>null==J).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},9075:(Et,le,h)=>{"use strict";h.d(le,{SYM:()=>Jt.SYM,VGw:()=>Jt.VGw,SpW:()=>Jt.SpW,zJI:()=>Qi,HeW:()=>fa,a4z:()=>mo,DBS:()=>Br,mm_:()=>Jt.mm_,Xze:()=>Jt.Xze,oT6:()=>Jt.oT6,IKK:()=>Jt.IKK,sJF:()=>Jt.sJF,aJk:()=>Jt.aJk,M2y:()=>Jt.M2y,qw7:()=>Jt.qw7,jMg:()=>Jt.jMg,QCc:()=>Jt.QCc,Oyi:()=>Jt.Oyi,JhU:()=>Jt.JhU,_k9:()=>Jt._k9,IMb:()=>Jt.IMb,ROF:()=>Jt.ROF,XLW:()=>Jt.XLW,zws:()=>Jt.zws,zvY:()=>Jt.zvY,hCO:()=>Jt.hCO,eEB:()=>Jt.eEB,Ly9:()=>Jt.Ly9,RFZ:()=>Jt.RFZ,gJX:()=>Jt.gJX,xnO:()=>Jt.xnO,Zz9:()=>Jt.Zz9,yj2:()=>Jt.yj2,Eh3:()=>Jt.Eh3,mhS:()=>Jt.mhS,wUP:()=>Jt.wUP,wm:()=>Jt.wm,x12:()=>Jt.x12,o2y:()=>Jt.o2y,ik2:()=>Jt.ik2,mc4:()=>Jt.mc4,TR1:()=>Jt.TR1,VcC:()=>Jt.VcC,Byc:()=>Jt.Byc,iHb:()=>Jt.iHb,JLz:()=>Zo.JL,QRR:()=>Jt.QRR,T0n:()=>Jt.T0n,cie:()=>Jt.cie,sL$:()=>Jt.sL$,y7R:()=>Jt.y7R,$w:()=>Jt.$w,p4S:()=>Jt.p4S,Vn9:()=>Jt.Vn9,ekb:()=>Jt.ekb,hGc:()=>Jt.hGc,ViN:()=>Re.Vi,$g6:()=>Jt.$g6,SX0:()=>Jt.SX0,HEU:()=>Jt.HEU,qAh:()=>Re.qA,hdR:()=>Jt.hdR,Omj:()=>Jt.Omj,NEP:()=>Jt.NEP,YFo:()=>Jt.YFo,Y0y:()=>Jt.Y0y,vwp:()=>Jt.vwp,deh:()=>Jt.deh,Uyb:()=>Jt.Uyb,OR:()=>Jt.OR,jeX:()=>Jt.jeX,eBW:()=>Jt.eBW,sHE:()=>Jt.sHE,_V0:()=>Jt._V0,luS:()=>Jt.luS,q1x:()=>Jt.q1x,qi_:()=>Jt.qi_,iZT:()=>Jt.iZT,Acj:()=>Jt.Acj,Qg5:()=>Jt.Qg5,iJz:()=>Jt.iJz,J_u:()=>Jt.J_u,avt:()=>Jt.avt,iWB:()=>Jt.iWB,r7n:()=>Jt.r7n,Zuw:()=>Zo.Zu,eZ0:()=>Jt.eZ0,Hhh:()=>Jt.Hhh,J$2:()=>Jt.J$2,vtC:()=>Jt.vtC,CAk:()=>Jt.CAk,e7N:()=>Jt.e7N,ZbH:()=>Jt.ZbH,kU:()=>Jt.kU,qCd:()=>Jt.qCd,PYm:()=>Jt.PYm,VfG:()=>Jt.VfG,MZg:()=>Jt.MZg,w6g:()=>Jt.w6g,qIC:()=>Jt.qIC,J7O:()=>Jt.J7O,YoZ:()=>Jt.YoZ,mTV:()=>Jt.mTV,OAf:()=>Jt.OAf,OU7:()=>Jt.OU7,OV7:()=>Jt.OV7,vFR:()=>Jt.vFR,BMI:()=>Jt.BMI,q2K:()=>Jt.q2K,c17:()=>Jt.c17,q8u:()=>Jt.q8u,jQs:()=>Jt.jQs,Vbg:()=>Jt.Vbg,rIn:()=>Xo,NZg:()=>Jt.NZg,wYn:()=>Jt.wYn,kuV:()=>Jt.kuV,uv1:()=>Jt.uv1,cye:()=>Jt.cye,W0H:()=>Jt.W0H,yQU:()=>Jt.yQU,zvA:()=>qt.zvA,we_:()=>Jt.we_,qWM:()=>Jt.qWM,gaJ:()=>pa,eEe:()=>hi,QiL:()=>Jt.QiL,lyA:()=>Jt.lyA,Kgp:()=>Jt.Kgp,pe_:()=>Jt.pe_,o0g:()=>Jt.o0g,DlI:()=>Jt.DlI,gVI:()=>go,dDz:()=>Jt.dDz,CQl:()=>Jt.CQl,BiW:()=>Jt.BiW,e6w:()=>Jt.e6w,yw1:()=>ci.yw,xJR:()=>Jt.xJR,oHH:()=>Jt.oHH,$HU:()=>Jt.$HU,IH3:()=>jl.I,qkr:()=>Jt.qkr,SbG:()=>Jt.SbG,HZH:()=>Jt.HZH,_Yw:()=>Jt._Yw,zbQ:()=>Jt.zbQ,dpD:()=>Jt.dpD,Hmb:()=>Jt.Hmb,mKl:()=>Jt.mKl,b9H:()=>Jt.b9H,e07:()=>Jt.e07,bV0:()=>Jt.bV0,DYp:()=>dr,xQA:()=>Jt.xQA,nr8:()=>Jt.nr8,PhF:()=>Jt.PhF,oFR:()=>Jt.oFR,a5O:()=>Jt.a5O,i5y:()=>Jt.i5y,RQH:()=>Jt.RQH,wYB:()=>Jt.wYB,p2w:()=>Jt.p2w,Gcp:()=>Jt.Gcp,MRv:()=>Jt.MRv,TQc:()=>Jt.TQc,O3z:()=>Jt.O3z,nhH:()=>Jt.nhH,w3H:()=>Jt.w3H,ZjV:()=>Jt.ZjV,D2d:()=>Jt.D2d,L8s:()=>Jt.L8s,FKq:()=>Jt.FKq,bK0:()=>Jt.bK0,_tC:()=>Jt._tC,e0R:()=>Jt.e0R,h8e:()=>Jt.h8e,jQk:()=>Jt.jQk,_JP:()=>Jt._JP,s1s:()=>Jt.s1s,XkS:()=>Jt.XkS,Tr8:()=>Jt.Tr8,GBy:()=>Jt.GBy,sEM:()=>Jt.sEM,MIZ:()=>Jt.MIZ,esB:()=>ol.es,YDk:()=>ol.YD,SIB:()=>Jt.SIB,n9L:()=>Jt.n9L,cWu:()=>Jt.cWu,wx7:()=>Jt.wx7,G3Y:()=>Jt.G3Y,kpP:()=>Jt.kpP,ToN:()=>Jt.ToN,Qvg:()=>Jt.Qvg,XDQ:()=>Jt.XDQ,_wD:()=>ol._w,RuY:()=>Jt.RuY,usg:()=>Jt.usg,WnP:()=>qt.WnP,Khb:()=>qt.Khb,__u:()=>qt.__u,IHx:()=>qt.IHx,QBD:()=>qt.QBD,$6P:()=>qt.$6P,YjB:()=>qt.YjB,NqF:()=>qt.NqF,vHJ:()=>qt.vHJ,ZRM:()=>qt.ZRM,VfV:()=>qt.VfV,z4N:()=>qt.z4N,fvJ:()=>qt.fvJ,C80:()=>qt.C80,wS1:()=>qt.wS1,uR5:()=>qt.uR5,y3$:()=>Js.y3,backend_util:()=>w,zEQ:()=>qt.zEQ,tgs:()=>qt.tgs,Dxk:()=>qt.Dxk,JY5:()=>qt.JY5,p3b:()=>qt.p3b,E4h:()=>qt.E4h,yE8:()=>qt.yE8,ycw:()=>qt.ycw,anm:()=>qt.anm,XsQ:()=>qt.XsQ,UFq:()=>qt.UFq,Jyw:()=>Da,Xhn:()=>I,f3b:()=>qt.f3b,pju:()=>qt.pju,mDi:()=>qt.mDi,iUl:()=>qt.iUl,d9v:()=>qt.d9v,PYB:()=>qt.PYB,zoF:()=>qt.zoF,gME:()=>qt.gME,Izb:()=>qt.Izb,MNy:()=>qt.MNy,ZaL:()=>qt.ZaL,PAt:()=>qt.PAt,Tek:()=>qt.Tek,bc:()=>qt.bc,pdZ:()=>qt.pdZ,$QV:()=>qt.$QV,T3b:()=>ai.T3,mCk:()=>qt.mCk,f9Y:()=>qt.f9Y,mew:()=>qt.mew,$Gn:()=>qt.$Gn,zbp:()=>qt.zbp,cbc:()=>Ra.cb,ppE:()=>qt.ppE,MXe:()=>Js.MX,nTT:()=>qt.nTT,B10:()=>qt.B10,C2$:()=>U,Ka3:()=>qt.Ka3,WmZ:()=>qt.WmZ,cFr:()=>Js.cF,B90:()=>Js.B9,N8o:()=>Js.N8,hiC:()=>qt.hiC,NTj:()=>qt.NTj,AKD:()=>qt.AKD,rvX:()=>qt.rvX,WYO:()=>qt.WYO,pyx:()=>qt.pyx,Ra$:()=>Js.R,G48:()=>Js.G4,GRh:()=>qt.GRh,SRH:()=>Js.SR,EDe:()=>qt.EDe,OBj:()=>Re.OB,DgJ:()=>qt.DgJ,qNN:()=>qt.qNN,d2q:()=>qt.d2q,Qqt:()=>qt.Qqt,dt4:()=>qt.dt4,t$B:()=>qt.t$B,iyy:()=>qt.iyy,kp_:()=>qt.kp_,hlL:()=>qt.hlL,x3e:()=>Js.x3,zel:()=>Js.ze,GWj:()=>qt.GWj,qPi:()=>qt.qPi,imm:()=>qt.imm,Iqj:()=>qt.Iqj,dbB:()=>qt.dbB,DaI:()=>N,N_N:()=>Js.N_,ukX:()=>ai.uk,pIF:()=>ai.pI,trD:()=>ai.tr,UQy:()=>Ra.UQ,tiA:()=>Ra.ti,pjt:()=>qt.pjt,brS:()=>qt.brS,Sxn:()=>qt.Sxn,asL:()=>qt.asL,image:()=>qt.BHj,V3u:()=>qt.V3u,io:()=>y,wx0:()=>qt.wx0,xVT:()=>qt.xVT,UWc:()=>qt.UWc,i2d:()=>qt.i2d,CnY:()=>Js.Cn,GDt:()=>M,hi7:()=>qt.hi7,d9m:()=>qt.d9m,zN1:()=>qt.zN1,$r2:()=>qt.$r2,SX3:()=>qt.SX3,G9k:()=>qt.G9k,cM7:()=>qt.cM7,Krr:()=>qt.Krr,e_t:()=>qt.e_t,CmS:()=>qt.CmS,l_t:()=>qt.l_t,HvI:()=>qt.HvI,hJK:()=>qt.hJK,K5V:()=>qt.K5V,egP:()=>qt.egP,MB5:()=>qt.MB5,eab:()=>qt.eab,OI3:()=>qt.OI3,mAU:()=>F,Fp7:()=>qt.Fp7,_sB:()=>qt._sB,YQQ:()=>qt.YQQ,Ip$:()=>qt.Ip$,gWQ:()=>qt.gWQ,J69:()=>qt.J69,sq6:()=>Js.sq,ry_:()=>qt.ry_,VV$:()=>qt.VV$,LTh:()=>qt.LTh,VdP:()=>qt.VdP,wQq:()=>qt.wQq,Gi7:()=>qt.Gi7,p_:()=>qt.p_,dC7:()=>qt.dC7,rq4:()=>qt.rq4,SJ_:()=>qt.SJ_,W76:()=>qt.W76,glt:()=>wi,KOy:()=>qt.KOy,Quu:()=>qt.Quu,lfX:()=>qt.lfX,iUs:()=>qt.iUs,JpU:()=>qt.JpU,op:()=>qt.op,N2O:()=>qt.N2O,vku:()=>qt.vku,pNR:()=>qt.pNR,koy:()=>qt.koy,t1L:()=>qt.t1L,lGY:()=>qt.lGY,d_R:()=>qt.d_R,sQ3:()=>qt.sQ3,AL3:()=>qt.AL3,S0v:()=>qt.S0v,WVs:()=>qt.WVs,N5s:()=>Js.N5,$gW:()=>qt.$gW,VT$:()=>qt.VT$,N89:()=>qt.N89,TN_:()=>qt.TN_,wzB:()=>qt.wzB,nGf:()=>qt.nGf,ruB:()=>qt.ruB,LGj:()=>qt.LGj,pe5:()=>qt.pe5,w6H:()=>qt.w6H,Cd_:()=>Js.Cd,kwC:()=>qt.kwC,M25:()=>qt.M25,jqO:()=>Js.jq,LiG:()=>ai.Li,wCN:()=>ai.wC,UYe:()=>qt.UYe,btT:()=>qt.btT,cjG:()=>Js.cj,XLQ:()=>qt.XLQ,GYS:()=>qt.GYS,SDf:()=>qt.SDf,diP:()=>qt.diP,sx7:()=>qt.sx7,mG2:()=>qt.mG2,QEs:()=>qt.QEs,NMM:()=>qt.NMM,bp0:()=>qt.bp0,iD$:()=>qt.iD$,snQ:()=>qt.snQ,yV1:()=>Be,zcT:()=>qt.zcT,U8D:()=>qt.U8D,U_I:()=>qt.U_I,m7h:()=>Z,CQI:()=>Js.CQ,VYu:()=>Js.VY,ODp:()=>qt.ODp,XD2:()=>qt.XD2,Xxe:()=>qt.Xxe,tdS:()=>qt.tdS,O$l:()=>qt.O$l,R_K:()=>qt.R_K,tPi:()=>qt.tPi,jZU:()=>qt.jZU,SmN:()=>qt.SmN,CnO:()=>qt.CnO,p0P:()=>qt.p0P,kuN:()=>ot,XAC:()=>qt.XAC,Wvh:()=>qt.Wvh,fBT:()=>qt.fBT,rVs:()=>qt.rVs,ers:()=>qt.ers,uN7:()=>qt.uN7,Vl2:()=>qt.Vl2,_b3:()=>qt._b3,h62:()=>qt.h62,$i:()=>qt.$i,L9e:()=>qt.L9e,knu:()=>qt.knu,Nbs:()=>qt.Nbs,NXj:()=>qt.NXj,Z_8:()=>qt.Z_8,luU:()=>qt.luU,Smz:()=>qt.Smz,z4k:()=>ci.z4,ORZ:()=>qt.ORZ,AEp:()=>qt.AEp,XeE:()=>qt.XeE,RRF:()=>qt.RRF,odF:()=>qt.odF,wOQ:()=>qt.wOQ,yXz:()=>qt.yXz,Bfx:()=>qt.Bfx,xZs:()=>qt.xZs,Pg0:()=>qt.Pg0,piX:()=>st,p3L:()=>W,lub:()=>Js.lu,Gg6:()=>qt.Gg6,XVJ:()=>Js.XV,hg7:()=>qt.hg7,p_j:()=>oo,p4s:()=>qt.p4s,Xu6:()=>qt.Xu6,Two:()=>qt.Two,bt3:()=>ai.bt,nEe:()=>ai.nE,pUJ:()=>qt.pUJ,HHK:()=>qt.HHK,x8V:()=>ci.x8,GaM:()=>qt.GaM,D5U:()=>te,h76:()=>Ra.h7,fNQ:()=>Ra.fN,VD$:()=>qt.VD$,pnJ:()=>Ra.pn,jTM:()=>La,arb:()=>qt.arb,itS:()=>qt.itS,lls:()=>qt.lls,P84:()=>qt.P84});var U={};h.r(U),h.d(U,{isBrowser:()=>_e,isMobile:()=>K,mockIsMobile:()=>J});var Z={};h.r(Z),h.d(Z,{Serializable:()=>ji,SerializationMap:()=>Di,getRegisteredName:()=>ro,registerClass:()=>Xs});var y={};h.r(y),h.d(y,{CompositeArrayBuffer:()=>de,browserFiles:()=>_o,browserHTTPRequest:()=>He,concatenateArrayBuffers:()=>nn,copyModel:()=>hc,decodeWeights:()=>at,encodeWeights:()=>v,fromMemory:()=>wt,fromMemorySync:()=>kn,getLoadHandlers:()=>Nn,getModelArtifactsForJSON:()=>Dn,getModelArtifactsForJSONSync:()=>Qn,getModelArtifactsInfoForJSON:()=>ps,getSaveHandlers:()=>Qt,getWeightSpecs:()=>Es,http:()=>Ae,isHTTPScheme:()=>L,listModels:()=>Lo,loadWeights:()=>Ca,moveModel:()=>Ga,registerLoadRouter:()=>Lt,registerSaveRouter:()=>Qe,removeModel:()=>dc,weightsLoaderFactory:()=>Pa,withSaveHandler:()=>pn,withSaveHandlerSync:()=>qn});var F={};h.r(F),h.d(F,{confusionMatrix:()=>yo});var I={};h.r(I),h.d(I,{draw:()=>Iu,fromPixels:()=>B,fromPixelsAsync:()=>Oc,toPixels:()=>Ai});var N={};h.r(N),h.d(N,{prepareAndValidate:()=>ve});var W={};h.r(W),h.d(W,{TEST_EPSILON_FLOAT16:()=>Yt,createVideoElement:()=>ca,encodeStrings:()=>Oi,expectArrayBuffersEqual:()=>jn,expectArraysClose:()=>xn,expectArraysEqual:()=>Qs,expectNumbersClose:()=>As,expectPromiseToFail:()=>_r,expectValuesInRange:()=>Zr,play:()=>Yo,testEpsilon:()=>ss});var l={};h.r(l),h.d(l,{collectGatherOpShapeInfo:()=>Ur,computeOutShape:()=>Mc,segOpComputeOptimalWindowSize:()=>Nc});var w={};h.r(w),h.d(w,{ERF_A1:()=>mn,ERF_A2:()=>rn,ERF_A3:()=>$n,ERF_A4:()=>zn,ERF_A5:()=>Bs,ERF_P:()=>Wt,PARALLELIZE_THRESHOLD:()=>Au,RowPartitionType:()=>Gl,SELU_SCALE:()=>mt.$,SELU_SCALEALPHA:()=>mt.y,applyActivation:()=>kl.QH,assertAndGetBroadcastShape:()=>Da.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>$a.lB,assertParamsConsistent:()=>Gi,assignToTypedArray:()=>ho,axesAreInnerMostDims:()=>$a.YB,calculateShapes:()=>Be.calculateShapes,checkEinsumDimSizes:()=>Kl,checkPadOnDimRoundingMode:()=>an.m,combineLocations:()=>$a.Vh,combineRaggedTensorToTensorShapes:()=>Tu,complexWithEvenIndex:()=>zr,complexWithOddIndex:()=>sr,computeConv2DInfo:()=>an.Ix,computeConv3DInfo:()=>an.jw,computeDefaultPad:()=>an.aO,computeDilation2DInfo:()=>an.Rf,computeOptimalWindowSize:()=>V,computeOutAndReduceShapes:()=>$a.kz,computeOutShape:()=>uu,computePool2DInfo:()=>an.Xw,computePool3DInfo:()=>an.pl,convertConv2DDataFormat:()=>an.sl,decodeEinsumEquation:()=>Vi,eitherStridesOrDilationsAreOne:()=>an.jT,expandShapeToKeepDim:()=>$a.rv,exponent:()=>Vr,exponents:()=>Rc,fromStringArrayToUint8:()=>wd,fromUint8ToStringArray:()=>wl,getAxesPermutation:()=>$a.Q3,getBroadcastDims:()=>Da.getBroadcastDims,getComplexWithIndex:()=>No,getEinsumComputePath:()=>bu,getEinsumPermutation:()=>xl,getFusedBiasGradient:()=>kl.pf,getFusedDyActivation:()=>kl.Fr,getImageCenter:()=>O,getInnerMostAxes:()=>$a.sY,getPermuted:()=>pe,getRaggedRank:()=>gc,getReductionAxes:()=>Da.getReductionAxes,getReshaped:()=>z,getReshapedPermuted:()=>Pe,getRowPartitionTypesHelper:()=>sd,getSliceBeginCoords:()=>Ve,getSliceSize:()=>et,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>yc,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Lc,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Ru,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Wr,getSparseReshapeInputOutputMismatchErrorMessage:()=>Eo,getSparseReshapeInputOutputMultipleErrorMessage:()=>Mo,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Sa,getSparseReshapeNegativeOutputDimErrorMessage:()=>Ws,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>ua,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Ol,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ln,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ei,getUndoAxesPermutation:()=>$a.LJ,isIdentityPermutation:()=>_c,log:()=>ur.c,mergeRealAndImagArrays:()=>Rs,prepareAndValidate:()=>ve,prepareSplitSize:()=>xd,segment_util:()=>l,shouldFuse:()=>kl.uy,slice_util:()=>ot,splitRealAndImagArrays:()=>Or,stridesOrDilationsArePositive:()=>an.U3,tupleValuesAreOne:()=>an.I0,upcastType:()=>ci.x8,validateDefaultValueShape:()=>rd,validateInput:()=>Be.validateInput,validateUpdateShape:()=>Be.validateUpdateShape,warn:()=>ur.Z});var M={};h.r(M),h.d(M,{nonMaxSuppressionV3Impl:()=>Do.GP,nonMaxSuppressionV4Impl:()=>Do.qP,nonMaxSuppressionV5Impl:()=>Do.pA,whereImpl:()=>ks.Z});var T=h(687);let G;function J(Me){G=Me}function K(Me){if(void 0!==G)return G;if(Me||function D(){return typeof navigator<"u"&&null!=navigator}()){if(Me||(Me=navigator),"ReactNative"===Me.product)return!0;const ge=Me.userAgent||Me.vendor||(typeof window<"u"?window.opera:"");return ge?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(ge)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ge.substr(0,4)):Me.userAgentData&&Me.userAgentData.mobile}return!1}function _e(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}var Re=h(5527);const we=(0,Re.OB)();we.registerFlag("DEBUG",()=>!1,Me=>{Me&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),we.registerFlag("IS_BROWSER",()=>_e()),we.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),we.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),we.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),we.registerFlag("PROD",()=>!1),we.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>we.getBool("DEBUG")),we.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),we.registerFlag("IS_TEST",()=>!1),we.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>we.getBool("DEBUG")),we.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),we.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),we.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var We=h(5861),Oe=h(3037),ie=h(3905),Le=h(5359);const De={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var oe,ye,te=h(1153);class de{static join(ge){return new de(ge).slice()}constructor(ge){if(this.shards=[],this.previousShardIndex=0,null==ge||(ge instanceof Array||(ge=[ge]),0===(ge=ge.map(Ke=>te.isTypedArray(Ke)?Ke.buffer:Ke)).length))return;this.bufferUniformSize=ge[0].byteLength;let ke=0;for(let Ke=0;Ke<ge.length;Ke++){const dt=ge[Ke];Ke!==ge.length-1&&dt.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const $t=ke+dt.byteLength;this.shards.push({buffer:dt,start:ke,end:$t}),ke=$t}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(ge=0,ke=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(ge=isNaN(Number(ge))?0:ge,ke=isNaN(Number(ke))?0:ke,ge=Math.max(0,ge),(ke=Math.min(this.byteLength,ke))<=ge)return new ArrayBuffer(0);const Ke=this.findShardForByte(ge);if(-1===Ke)throw new Error(`Could not find start shard for byte ${ge}`);const $t=new ArrayBuffer(ke-ge),dn=new Uint8Array($t);let Sn=0;for(let en=Ke;en<this.shards.length;en++){const re=this.shards[en],ee=ge+Sn-re.start,me=Sn,gt=Math.min(ke,re.end)-re.start,At=new Uint8Array(re.buffer,ee,gt-ee);if(dn.set(At,me),Sn+=At.length,ke<re.end)break}return $t}findShardForByte(ge){if(0===this.shards.length||ge<0||ge>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(ge/this.bufferUniformSize),this.previousShardIndex;function ke(dt){return ge<dt.start?-1:ge>=dt.end?1:0}if(0===ke(this.shards[this.previousShardIndex]))return this.previousShardIndex;const Ke=function P(Me,ge){let ke=0,Ke=Me.length;for(;ke<=Ke;){const dt=Math.floor((Ke-ke)/2)+ke,$t=ge(Me[dt]);if(0===$t)return dt;$t<0?Ke=dt:ke=dt+1}return-1}(this.shards,ke);return-1===Ke?-1:(this.previousShardIndex=Ke,this.previousShardIndex)}}const Te=4;function v(Me,ge){return(oe=oe||(0,We.Z)(function*(ke,Ke){const dt=[],$t=[],dn=Array.isArray(ke)?ke.map(re=>re.name):Object.keys(ke);for(let re=0;re<dn.length;++re){const xe=dn[re],ee=Array.isArray(ke)?ke[re].tensor:ke[xe];if("float32"!==ee.dtype&&"int32"!==ee.dtype&&"bool"!==ee.dtype&&"string"!==ee.dtype&&"complex64"!==ee.dtype)throw new Error(`Unsupported dtype in weight '${xe}': ${ee.dtype}`);const me={name:xe,shape:ee.shape,dtype:ee.dtype};if("string"===ee.dtype){var Sn;const Fe=new Promise(function(gt){return(Sn=Sn||(0,We.Z)(function*(At){const zt=yield ee.bytes(),Pn=zt.reduce((Ln,An)=>Ln+An.length,0)+Te*zt.length,On=new Uint8Array(Pn);let Kn=0;for(let Ln=0;Ln<zt.length;Ln++){const An=zt[Ln],vs=new Uint8Array(new Uint32Array([An.length]).buffer);On.set(vs,Kn),Kn+=Te,On.set(An,Kn),Kn+=An.length}At(On)})).apply(this,arguments)});$t.push(Fe)}else $t.push(ee.data());null!=Ke&&(me.group=Ke),dt.push(me)}return{data:Xe(yield Promise.all($t)),specs:dt}})).apply(this,arguments)}function at(Me,ge){const ke=new de(Me),Ke={};let dt,$t=0;for(const dn of ge){const Sn=dn.name,en=dn.dtype,re=dn.shape,xe=(0,Le.NA)(re);let ee;if("quantization"in dn){const me=dn.quantization;if("uint8"===me.dtype||"uint16"===me.dtype){if(!("min"in me)||!("scale"in me))throw new Error(`Weight ${dn.name} with quantization ${me.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==me.dtype)throw new Error(`Weight ${dn.name} has unknown quantization dtype ${me.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==en)throw new Error(`Weight ${dn.name} is quantized with ${me.dtype} which only supports weights of type float32 not ${en}.`)}const Fe=De[me.dtype],gt=ke.slice($t,$t+xe*Fe),At="uint8"===me.dtype?new Uint8Array(gt):new Uint16Array(gt);if("float32"===en)if("uint8"===me.dtype||"uint16"===me.dtype){ee=new Float32Array(At.length);for(let zt=0;zt<At.length;zt++)ee[zt]=At[zt]*me.scale+me.min}else{if("float16"!==me.dtype)throw new Error(`Unsupported quantization type ${me.dtype} for weight type float32.`);void 0===dt&&(dt=Ir()),ee=dt(At)}else{if("int32"!==en)throw new Error(`Unsupported dtype in weight '${Sn}': ${en}`);if("uint8"!==me.dtype&&"uint16"!==me.dtype)throw new Error(`Unsupported quantization type ${me.dtype} for weight type int32.`);ee=new Int32Array(At.length);for(let zt=0;zt<At.length;zt++)ee[zt]=Math.round(At[zt]*me.scale+me.min)}$t+=xe*Fe}else if("string"===en){const me=(0,Le.NA)(dn.shape);ee=[];for(let Fe=0;Fe<me;Fe++){const gt=new Uint32Array(ke.slice($t,$t+Te))[0];$t+=Te;const At=new Uint8Array(ke.slice($t,$t+gt));ee.push(At),$t+=gt}}else{const me=De[en],Fe=ke.slice($t,$t+xe*me);if("float32"===en)ee=new Float32Array(Fe);else if("int32"===en)ee=new Int32Array(Fe);else if("bool"===en)ee=new Uint8Array(Fe);else{if("complex64"!==en)throw new Error(`Unsupported dtype in weight '${Sn}': ${en}`);{ee=new Float32Array(Fe);const gt=new Float32Array(ee.length/2),At=new Float32Array(ee.length/2);for(let On=0;On<gt.length;On++)gt[On]=ee[2*On],At[On]=ee[2*On+1];const zt=(0,ie.X)(gt,re,"float32"),Pn=(0,ie.X)(At,re,"float32");Ke[Sn]=(0,Oe.P)(zt,Pn),zt.dispose(),Pn.dispose()}}$t+=xe*me}"complex64"!==en&&(Ke[Sn]=(0,ie.X)(ee,re,en))}return Ke}function Xe(Me){if(null===Me)throw new Error(`Invalid input value: ${JSON.stringify(Me)}`);let ge=0;const ke=[];Me.forEach($t=>{if(ge+=$t.byteLength,ke.push($t.byteLength===$t.buffer.byteLength?$t:new $t.constructor($t)),!($t instanceof Float32Array||$t instanceof Int32Array||$t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${$t.constructor.name}`)});const Ke=new Uint8Array(ge);let dt=0;return ke.forEach($t=>{Ke.set(new Uint8Array($t.buffer),dt),dt+=$t.byteLength}),Ke.buffer}const Ue=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function pt(Me){return Ue?Buffer.byteLength(Me,"utf8"):new Blob([Me]).size}function nn(Me){return de.join(Me)}function Bt(Me){for(Me=Me.trim();Me.endsWith("/");)Me=Me.slice(0,Me.length-1);const ke=Me.split("/");return ke[ke.length-1]}function bn(Me,ge){const ke={modelTopology:Me.modelTopology,format:Me.format,generatedBy:Me.generatedBy,convertedBy:Me.convertedBy,weightsManifest:ge};return null!=Me.signature&&(ke.signature=Me.signature),null!=Me.userDefinedMetadata&&(ke.userDefinedMetadata=Me.userDefinedMetadata),null!=Me.modelInitializer&&(ke.modelInitializer=Me.modelInitializer),null!=Me.initializerSignature&&(ke.initializerSignature=Me.initializerSignature),null!=Me.trainingConfig&&(ke.trainingConfig=Me.trainingConfig),ke}function Qn(Me,ge,ke){const Ke={modelTopology:Me.modelTopology,format:Me.format,generatedBy:Me.generatedBy,convertedBy:Me.convertedBy};if(null!=Me.trainingConfig&&(Ke.trainingConfig=Me.trainingConfig),null!=Me.weightsManifest){if(!ge)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!ke)throw new Error("modelJSON has weightsManifest but weightData is null");Ke.weightSpecs=ge,Ke.weightData=ke}return null!=Me.signature&&(Ke.signature=Me.signature),null!=Me.userDefinedMetadata&&(Ke.userDefinedMetadata=Me.userDefinedMetadata),null!=Me.modelInitializer&&(Ke.modelInitializer=Me.modelInitializer),null!=Me.initializerSignature&&(Ke.initializerSignature=Me.initializerSignature),Ke}function Dn(Me,ge){return(ye=ye||(0,We.Z)(function*(ke,Ke){let dt,$t;return null!=ke.weightsManifest&&([dt,$t]=yield Ke(ke.weightsManifest)),Qn(ke,dt,$t)})).apply(this,arguments)}function ps(Me){if(Me.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==Me.modelTopology?0:pt(JSON.stringify(Me.modelTopology)),weightSpecsBytes:null==Me.weightSpecs?0:pt(JSON.stringify(Me.weightSpecs)),weightDataBytes:null==Me.weightData?0:new de(Me.weightData).byteLength}}function Es(Me){const ge=[];for(const ke of Me)ge.push(...ke.weights);return ge}function Ir(){const Me=function Xn(){const Me=ke=>{let Ke=ke<<13,dt=0;for(;!(8388608&Ke);)dt-=8388608,Ke<<=1;return Ke&=-8388609,dt+=947912704,Ke|dt},ge=new Uint32Array(2048);ge[0]=0;for(let ke=1;ke<1024;ke++)ge[ke]=Me(ke);for(let ke=1024;ke<2048;ke++)ge[ke]=939524096+(ke-1024<<13);return ge}(),ge=function Ts(){const Me=new Uint32Array(64);Me[0]=0,Me[31]=1199570944,Me[32]=2147483648,Me[63]=3347054592;for(let ge=1;ge<31;ge++)Me[ge]=ge<<23;for(let ge=33;ge<63;ge++)Me[ge]=2147483648+(ge-32<<23);return Me}(),ke=function or(){const Me=new Uint32Array(64);for(let ge=0;ge<64;ge++)Me[ge]=1024;return Me[0]=Me[32]=0,Me}();return Ke=>{const dt=new ArrayBuffer(4*Ke.length),$t=new Uint32Array(dt);for(let dn=0;dn<Ke.length;dn++){const Sn=Ke[dn];$t[dn]=Me[ke[Sn>>10]+(1023&Sn)]+ge[Sn>>10]}return new Float32Array(dt)}}class Ss{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ss.instance&&(Ss.instance=new Ss),Ss.instance}static registerSaveRouter(ge){Ss.getInstance().saveRouters.push(ge)}static registerLoadRouter(ge){Ss.getInstance().loadRouters.push(ge)}static getSaveHandlers(ge){return Ss.getHandlers(ge,"save")}static getLoadHandlers(ge,ke){return Ss.getHandlers(ge,"load",ke)}static getHandlers(ge,ke,Ke){const dt=[];return("load"===ke?Ss.getInstance().loadRouters:Ss.getInstance().saveRouters).forEach(dn=>{const Sn=dn(ge,Ke);null!==Sn&&dt.push(Sn)}),dt}}const Qe=Me=>Ss.registerSaveRouter(Me),Lt=Me=>Ss.registerLoadRouter(Me),Qt=Me=>Ss.getSaveHandlers(Me),Nn=(Me,ge)=>Ss.getLoadHandlers(Me,ge),zs="tensorflowjs",xr="models_store",$r="model_info_store";function oa(){if(!(0,Re.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const Me=typeof window>"u"?self:window,ge=Me.indexedDB||Me.mozIndexedDB||Me.webkitIndexedDB||Me.msIndexedDB||Me.shimIndexedDB;if(null==ge)throw new Error("The current browser does not appear to support IndexedDB.");return ge}function aa(Me){const ge=Me.result;ge.createObjectStore(xr,{keyPath:"modelPath"}),ge.createObjectStore($r,{keyPath:"modelPath"})}let Po=(()=>{class Me{constructor(ke){if(this.indexedDB=oa(),null==ke||!ke)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=ke}save(ke){var Ke=this;return(0,We.Z)(function*(){if(ke.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return Ke.databaseAction(Ke.modelPath,ke)})()}load(){var ke=this;return(0,We.Z)(function*(){return ke.databaseAction(ke.modelPath)})()}databaseAction(ke,Ke){return new Promise((dt,$t)=>{const dn=this.indexedDB.open(zs,1);dn.onupgradeneeded=()=>aa(dn),dn.onsuccess=()=>{const Sn=dn.result;if(null==Ke){const en=Sn.transaction(xr,"readonly"),xe=en.objectStore(xr).get(this.modelPath);xe.onsuccess=()=>{if(null==xe.result)return Sn.close(),$t(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));dt(xe.result.modelArtifacts)},xe.onerror=ee=>(Sn.close(),$t(xe.error)),en.oncomplete=()=>Sn.close()}else{Ke.weightData=de.join(Ke.weightData);const en=ps(Ke),re=Sn.transaction($r,"readwrite");let ee,me,xe=re.objectStore($r);try{ee=xe.put({modelPath:this.modelPath,modelArtifactsInfo:en})}catch(Fe){return $t(Fe)}ee.onsuccess=()=>{me=Sn.transaction(xr,"readwrite");const Fe=me.objectStore(xr);let gt;try{gt=Fe.put({modelPath:this.modelPath,modelArtifacts:Ke,modelArtifactsInfo:en})}catch(At){return $t(At)}gt.onsuccess=()=>dt({modelArtifactsInfo:en}),gt.onerror=At=>{xe=re.objectStore($r);const zt=xe.delete(this.modelPath);zt.onsuccess=()=>(Sn.close(),$t(gt.error)),zt.onerror=Pn=>(Sn.close(),$t(gt.error))}},ee.onerror=Fe=>(Sn.close(),$t(ee.error)),re.oncomplete=()=>{null==me?Sn.close():me.oncomplete=()=>Sn.close()}}},dn.onerror=Sn=>$t(dn.error)})}}return Me.URL_SCHEME="indexeddb://",Me})();const xa=Me=>(0,Re.OB)().getBool("IS_BROWSER")&&!Array.isArray(Me)&&Me.startsWith(Po.URL_SCHEME)?function za(Me){return new Po(Me)}(Me.slice(Po.URL_SCHEME.length)):null;Ss.registerSaveRouter(xa),Ss.registerLoadRouter(xa);class lo{constructor(){this.indexedDB=oa()}listModels(){var ge=this;return(0,We.Z)(function*(){return new Promise((ke,Ke)=>{const dt=ge.indexedDB.open(zs,1);dt.onupgradeneeded=()=>aa(dt),dt.onsuccess=()=>{const $t=dt.result,dn=$t.transaction($r,"readonly"),en=dn.objectStore($r).getAll();en.onsuccess=()=>{const re={};for(const xe of en.result)re[xe.modelPath]=xe.modelArtifactsInfo;ke(re)},en.onerror=re=>($t.close(),Ke(en.error)),dn.oncomplete=()=>$t.close()},dt.onerror=$t=>Ke(dt.error)})})()}removeModel(ge){var ke=this;return(0,We.Z)(function*(){return ge=function To(Me){return Me.startsWith(Po.URL_SCHEME)?Me.slice(Po.URL_SCHEME.length):Me}(ge),new Promise((Ke,dt)=>{const $t=ke.indexedDB.open(zs,1);$t.onupgradeneeded=()=>aa($t),$t.onsuccess=()=>{const dn=$t.result,Sn=dn.transaction($r,"readwrite"),en=Sn.objectStore($r),re=en.get(ge);let xe;re.onsuccess=()=>{if(null==re.result)return dn.close(),dt(new Error(`Cannot find model with path '${ge}' in IndexedDB.`));{const ee=en.delete(ge),me=()=>{xe=dn.transaction(xr,"readwrite");const gt=xe.objectStore(xr).delete(ge);gt.onsuccess=()=>Ke(re.result.modelArtifactsInfo),gt.onerror=At=>dt(re.error)};ee.onsuccess=me,ee.onerror=Fe=>(me(),dn.close(),dt(re.error))}},re.onerror=ee=>(dn.close(),dt(re.error)),Sn.oncomplete=()=>{null==xe?dn.close():xe.oncomplete=()=>dn.close()}},$t.onerror=dn=>dt($t.error)})})()}}const Ao="/",Ho="tensorflowjs_models",sl="info",ka="model_topology",to="weight_specs",rl="weight_data",Wa="model_metadata";function Ha(Me){return{info:[Ho,Me,sl].join(Ao),topology:[Ho,Me,ka].join(Ao),weightSpecs:[Ho,Me,to].join(Ao),weightData:[Ho,Me,rl].join(Ao),modelMetadata:[Ho,Me,Wa].join(Ao)}}function qe(Me){for(const ge of Object.values(Me))window.localStorage.removeItem(ge)}function jo(Me){const ge=Me.split(Ao);if(ge.length<3)throw new Error(`Invalid key format: ${Me}`);return ge.slice(1,ge.length-1).join(Ao)}let $s=(()=>{class Me{constructor(ke){if(!(0,Re.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==ke||!ke)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=ke,this.keys=Ha(this.modelPath)}save(ke){var Ke=this;return(0,We.Z)(function*(){if(ke.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const dt=JSON.stringify(ke.modelTopology),$t=JSON.stringify(ke.weightSpecs),dn=ps(ke),Sn=de.join(ke.weightData);try{return Ke.LS.setItem(Ke.keys.info,JSON.stringify(dn)),Ke.LS.setItem(Ke.keys.topology,dt),Ke.LS.setItem(Ke.keys.weightSpecs,$t),Ke.LS.setItem(Ke.keys.weightData,function Ct(Me){if(Ue)return Buffer.from(Me).toString("base64");const ge=new Uint8Array(Me);let ke="";for(let Ke=0,dt=ge.length;Ke<dt;Ke++)ke+=String.fromCharCode(ge[Ke]);return btoa(ke)}(Sn)),Ke.LS.setItem(Ke.keys.modelMetadata,JSON.stringify({format:ke.format,generatedBy:ke.generatedBy,convertedBy:ke.convertedBy,signature:null!=ke.signature?ke.signature:void 0,userDefinedMetadata:null!=ke.userDefinedMetadata?ke.userDefinedMetadata:void 0,modelInitializer:null!=ke.modelInitializer?ke.modelInitializer:void 0,initializerSignature:null!=ke.initializerSignature?ke.initializerSignature:void 0,trainingConfig:null!=ke.trainingConfig?ke.trainingConfig:void 0})),{modelArtifactsInfo:dn}}catch{throw qe(Ke.keys),new Error(`Failed to save model '${Ke.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${dn.modelTopologyBytes}, weightSpecsBytes=${dn.weightSpecsBytes}, weightDataBytes=${dn.weightDataBytes}.`)}}})()}load(){var ke=this;return(0,We.Z)(function*(){const Ke=JSON.parse(ke.LS.getItem(ke.keys.info));if(null==Ke)throw new Error(`In local storage, there is no model with name '${ke.modelPath}'`);if("JSON"!==Ke.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const dt={},$t=JSON.parse(ke.LS.getItem(ke.keys.topology));if(null==$t)throw new Error(`In local storage, the topology of model '${ke.modelPath}' is missing.`);dt.modelTopology=$t;const dn=JSON.parse(ke.LS.getItem(ke.keys.weightSpecs));if(null==dn)throw new Error(`In local storage, the weight specs of model '${ke.modelPath}' are missing.`);dt.weightSpecs=dn;const Sn=ke.LS.getItem(ke.keys.modelMetadata);if(null!=Sn){const re=JSON.parse(Sn);dt.format=re.format,dt.generatedBy=re.generatedBy,dt.convertedBy=re.convertedBy,null!=re.signature&&(dt.signature=re.signature),null!=re.userDefinedMetadata&&(dt.userDefinedMetadata=re.userDefinedMetadata),null!=re.modelInitializer&&(dt.modelInitializer=re.modelInitializer),null!=re.initializerSignature&&(dt.initializerSignature=re.initializerSignature),null!=re.trainingConfig&&(dt.trainingConfig=re.trainingConfig)}const en=ke.LS.getItem(ke.keys.weightData);if(null==en)throw new Error(`In local storage, the binary weight values of model '${ke.modelPath}' are missing.`);return dt.weightData=function It(Me){if(Ue){const Ke=Buffer.from(Me,"base64");return Ke.buffer.slice(Ke.byteOffset,Ke.byteOffset+Ke.byteLength)}const ge=atob(Me),ke=new Uint8Array(ge.length);for(let Ke=0;Ke<ge.length;++Ke)ke.set([ge.charCodeAt(Ke)],Ke);return ke.buffer}(en),dt})()}}return Me.URL_SCHEME="localstorage://",Me})();const co=Me=>(0,Re.OB)().getBool("IS_BROWSER")&&!Array.isArray(Me)&&Me.startsWith($s.URL_SCHEME)?function ui(Me){return new $s(Me)}(Me.slice($s.URL_SCHEME.length)):null;Ss.registerSaveRouter(co),Ss.registerLoadRouter(co);class ja{constructor(){(0,Le.hu)((0,Re.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,Le.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var ge=this;return(0,We.Z)(function*(){const ke={},Ke=Ho+Ao,dt=Ao+sl;for(let $t=0;$t<ge.LS.length;++$t){const dn=ge.LS.key($t);dn.startsWith(Ke)&&dn.endsWith(dt)&&(ke[jo(dn)]=JSON.parse(ge.LS.getItem(dn)))}return ke})()}removeModel(ge){var ke=this;return(0,We.Z)(function*(){const Ke=Ha(ge=function la(Me){return Me.startsWith($s.URL_SCHEME)?Me.slice($s.URL_SCHEME.length):Me}(ge));if(null==ke.LS.getItem(Ke.info))throw new Error(`Cannot find model at path '${ge}'`);const dt=JSON.parse(ke.LS.getItem(Ke.info));return qe(Ke),dt})()}}var Go,Li,wa,Ki,Xi;const $i="://";class Bi{constructor(){this.managers={}}static getInstance(){return null==Bi.instance&&(Bi.instance=new Bi),Bi.instance}static registerManager(ge,ke){(0,Le.hu)(null!=ge,()=>"scheme must not be undefined or null."),ge.endsWith($i)&&(ge=ge.slice(0,ge.indexOf($i))),(0,Le.hu)(ge.length>0,()=>"scheme must not be an empty string.");const Ke=Bi.getInstance();(0,Le.hu)(null==Ke.managers[ge],()=>`A model store manager is already registered for scheme '${ge}'.`),Ke.managers[ge]=ke}static getManager(ge){const ke=Bi.getInstance().managers[ge];if(null==ke)throw new Error(`Cannot find model manager for scheme '${ge}'`);return ke}static getSchemes(){return Object.keys(Bi.getInstance().managers)}}function hl(Me){if(-1===Me.indexOf($i))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Bi.getSchemes().join(",")}`);return{scheme:Me.split($i)[0],path:Me.split($i)[1]}}function Jr(Me,ge){return(Go=Go||(0,We.Z)(function*(ke,Ke,dt=!1){(0,Le.hu)(ke!==Ke,()=>`Old path and new path are the same: '${ke}'`);const $t=Ss.getLoadHandlers(ke);(0,Le.hu)($t.length>0,()=>`Copying failed because no load handler is found for source URL ${ke}.`),(0,Le.hu)($t.length<2,()=>`Copying failed because more than one (${$t.length}) load handlers for source URL ${ke}.`);const dn=$t[0],Sn=Ss.getSaveHandlers(Ke);(0,Le.hu)(Sn.length>0,()=>`Copying failed because no save handler is found for destination URL ${Ke}.`),(0,Le.hu)(Sn.length<2,()=>`Copying failed because more than one (${$t.length}) save handlers for destination URL ${Ke}.`);const en=Sn[0],re=hl(ke).scheme,xe=hl(ke).path,ee=re===hl(ke).scheme,me=yield dn.load();dt&&ee&&(yield Bi.getManager(re).removeModel(xe));const Fe=yield en.save(me);return dt&&!ee&&(yield Bi.getManager(re).removeModel(xe)),Fe.modelArtifactsInfo})).apply(this,arguments)}function Lo(){return(Li=Li||(0,We.Z)(function*(){const Me=Bi.getSchemes(),ge={};for(const ke of Me){const Ke=yield Bi.getManager(ke).listModels();for(const dt in Ke)ge[ke+$i+dt]=Ke[dt]}return ge})).apply(this,arguments)}function dc(Me){return(wa=wa||(0,We.Z)(function*(ge){const ke=hl(ge);return Bi.getManager(ke.scheme).removeModel(ke.path)})).apply(this,arguments)}function hc(Me,ge){return(Ki=Ki||(0,We.Z)(function*(ke,Ke){return Jr(ke,Ke,!1)})).apply(this,arguments)}function Ga(Me,ge){return(Xi=Xi||(0,We.Z)(function*(ke,Ke){return Jr(ke,Ke,!0)})).apply(this,arguments)}var Ko=h(4705);class pc{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(ge,ke){return fetch(ge,ke)}now(){return performance.now()}encode(ge,ke){if("utf-8"!==ke&&"utf8"!==ke)throw new Error(`Browser's encoder only supports utf-8, but got ${ke}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(ge)}decode(ge,ke){return new TextDecoder(ke).decode(ge)}setTimeoutCustom(ge,ke){typeof window>"u"||!(0,Re.OB)().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(ge,ke):(this.functionRefs.push(ge),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},ke),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",Ke=>{Ke.source===window&&Ke.data.name===this.messageName&&(Ke.stopPropagation(),(0,this.functionRefs[Ke.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(ge){return(0,Ko.j)(ge)}}if((0,Re.OB)().get("IS_BROWSER")){(0,Re.OB)().setPlatform("browser",new pc);try{Bi.registerManager($s.URL_SCHEME,new ja)}catch{}try{Bi.registerManager(Po.URL_SCHEME,new lo)}catch{}}let ko;(0,Re.OB)().get("IS_NODE")&&!(0,Re.OB)().get("IS_BROWSER")&&(0,Re.OB)().setPlatform("node",new class so{constructor(){this.util=h(8628),this.textEncoder=new this.util.TextEncoder}fetch(ge,ke){return null!=(0,Re.OB)().global.fetch?(0,Re.OB)().global.fetch(ge,ke):(null==ko&&(ko=h(5410)),ko(ge,ke))}now(){const ge=process.hrtime();return 1e3*ge[0]+ge[1]/1e6}encode(ge,ke){if("utf-8"!==ke&&"utf8"!==ke)throw new Error(`Node built-in encoder only supports utf-8, but got ${ke}`);return this.textEncoder.encode(ge)}decode(ge,ke){return 0===ge.length?"":new this.util.TextDecoder(ke).decode(ge)}isTypedArray(ge){return this.util.types.isFloat32Array(ge)||this.util.types.isInt32Array(ge)||this.util.types.isUint8Array(ge)||this.util.types.isUint8ClampedArray(ge)}});var il=h(582),Yi=h(3062),fc=h(7315),zl=h(3006),ol=h(4945);(0,T.wv)(),(0,ol.Vp)({buffer:il.f,cast:Yi.p,clone:fc.d,print:zl.S});var Js=h(2773),vi=h(7066),$o=h(3530),Pr=h(8737),Oa=h(930),Al=h(7527),uo=h(3143),Ra=h(3537),Zi=h(8661);const Oo=new Map,Hi=new Map;class ji{getClassName(){return this.constructor.className}static fromConfig(ge,ke){return new ge(ke)}}class Di{constructor(){this.classNameMap={}}static getMap(){return null==Di.instance&&(Di.instance=new Di),Di.instance}static register(ge){Di.getMap().classNameMap[ge.className]=[ge,ge.fromConfig]}}function Xs(Me,ge,ke){(0,Le.hu)(null!=Me.className,()=>"Class being registered does not have the static className property defined."),(0,Le.hu)("string"==typeof Me.className,()=>"className is required to be a string, but got type "+typeof Me.className),(0,Le.hu)(Me.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof ge>"u"&&(ge="Custom"),typeof ke>"u"&&(ke=Me.className);const dt=ge+">"+ke;return Di.register(Me),Oo.set(dt,Me),Hi.set(Me,dt),Me}function ro(Me){return Hi.has(Me)?Hi.get(Me):Me.className}class pa extends ji{minimize(ge,ke=!1,Ke){const{value:dt,grads:$t}=this.computeGradients(ge,Ke);if(null!=Ke){const dn=Ke.map(Sn=>({name:Sn.name,tensor:$t[Sn.name]}));this.applyGradients(dn)}else this.applyGradients($t);return(0,Js.B9)($t),ke?dt:(dt.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(ge,ke){return(0,Ra.pn)(ge,ke)}dispose(){null!=this.iterations_&&(0,Js.B9)(this.iterations_)}saveIterations(){var ge=this;return(0,We.Z)(function*(){return null==ge.iterations_&&(ge.iterations_=0),{name:"iter",tensor:(0,Zi.i)(ge.iterations_,"int32")}})()}getWeights(){return(0,We.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(ge){var ke=this;return(0,We.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${ke.getClassName()}`)})()}extractIterations(ge){var ke=this;return(0,We.Z)(function*(){return ke.iterations_=(yield ge[0].tensor.data())[0],ge.slice(1)})()}}Object.defineProperty(pa,Symbol.hasInstance,{value:Me=>null!=Me.minimize&&null!=Me.computeGradients&&null!=Me.applyGradients});class Qi extends pa{static get className(){return"Adadelta"}constructor(ge,ke,Ke=null){super(),this.learningRate=ge,this.rho=ke,this.epsilon=Ke,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==Ke&&(this.epsilon=T.BV.backend.epsilon())}applyGradients(ge){(Array.isArray(ge)?ge.map(Ke=>Ke.name):Object.keys(ge)).forEach((Ke,dt)=>{const $t=T.BV.registeredVariables[Ke];null==this.accumulatedGrads[dt]&&(this.accumulatedGrads[dt]={originalName:`${Ke}/accum_grad`,variable:(0,Js.lu)(()=>(0,uo.P)($t).variable(!1))}),null==this.accumulatedUpdates[dt]&&(this.accumulatedUpdates[dt]={originalName:`${Ke}/accum_var`,variable:(0,Js.lu)(()=>(0,uo.P)($t).variable(!1))});const Sn=Array.isArray(ge)?ge[dt].tensor:ge[Ke];if(null==Sn)return;const en=this.accumulatedGrads[dt].variable,re=this.accumulatedUpdates[dt].variable;(0,Js.lu)(()=>{const xe=(0,vi.I)((0,Pr.d)(en,this.rho),(0,Pr.d)((0,Al.h)(Sn),1-this.rho)),ee=(0,Pr.d)((0,$o.h)((0,Oa._)((0,vi.I)(re,this.epsilon)),(0,Oa._)((0,vi.I)(en,this.epsilon))),Sn),me=(0,vi.I)((0,Pr.d)(re,this.rho),(0,Pr.d)((0,Al.h)(ee),1-this.rho));en.assign(xe),re.assign(me);const Fe=(0,vi.I)((0,Pr.d)(ee,-this.learningRate),$t);$t.assign(Fe)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,Js.B9)(this.accumulatedGrads.map(ge=>ge.variable)),(0,Js.B9)(this.accumulatedUpdates.map(ge=>ge.variable)))}getWeights(){var ge=this;return(0,We.Z)(function*(){const ke=[...ge.accumulatedGrads,...ge.accumulatedUpdates];return[yield ge.saveIterations()].concat(ke.map(Ke=>({name:Ke.originalName,tensor:Ke.variable})))})()}setWeights(ge){var ke=this;return(0,We.Z)(function*(){const Ke=(ge=yield ke.extractIterations(ge)).length/2;ke.accumulatedGrads=ge.slice(0,Ke).map($t=>({originalName:$t.name,variable:$t.tensor.variable(!1)})),ke.accumulatedUpdates=ge.slice(Ke,2*Ke).map($t=>({originalName:$t.name,variable:$t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(ge,ke){return new ge(ke.learningRate,ke.rho,ke.epsilon)}}var al=h(2787);class fa extends pa{static get className(){return"Adagrad"}constructor(ge,ke=.1){super(),this.learningRate=ge,this.initialAccumulatorValue=ke,this.accumulatedGrads=[]}applyGradients(ge){(Array.isArray(ge)?ge.map(Ke=>Ke.name):Object.keys(ge)).forEach((Ke,dt)=>{const $t=T.BV.registeredVariables[Ke];null==this.accumulatedGrads[dt]&&(this.accumulatedGrads[dt]={originalName:`${Ke}/accumulator`,variable:(0,Js.lu)(()=>(0,al.h)($t.shape,this.initialAccumulatorValue).variable(!1))});const dn=Array.isArray(ge)?ge[dt].tensor:ge[Ke];if(null==dn)return;const Sn=this.accumulatedGrads[dt].variable;(0,Js.lu)(()=>{const en=(0,vi.I)(Sn,(0,Al.h)(dn));Sn.assign(en);const re=(0,vi.I)((0,Pr.d)((0,$o.h)(dn,(0,Oa._)((0,vi.I)(en,T.BV.backend.epsilon()))),-this.learningRate),$t);$t.assign(re)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,Js.B9)(this.accumulatedGrads.map(ge=>ge.variable))}getWeights(){var ge=this;return(0,We.Z)(function*(){return[yield ge.saveIterations()].concat(ge.accumulatedGrads.map(ke=>({name:ke.originalName,tensor:ke.variable})))})()}setWeights(ge){var ke=this;return(0,We.Z)(function*(){ge=yield ke.extractIterations(ge),ke.accumulatedGrads=ge.map(dt=>({originalName:dt.name,variable:dt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(ge,ke){return new ge(ke.learningRate,ke.initialAccumulatorValue)}}var di=h(2962),ma=h(1191);class mo extends pa{static get className(){return"Adam"}constructor(ge,ke,Ke,dt=null){super(),this.learningRate=ge,this.beta1=ke,this.beta2=Ke,this.epsilon=dt,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,Js.lu)(()=>{this.accBeta1=(0,Zi.i)(ke).variable(),this.accBeta2=(0,Zi.i)(Ke).variable()}),null==dt&&(this.epsilon=T.BV.backend.epsilon())}applyGradients(ge){const ke=Array.isArray(ge)?ge.map(Ke=>Ke.name):Object.keys(ge);(0,Js.lu)(()=>{const Ke=(0,ma.l)(1,this.accBeta1),dt=(0,ma.l)(1,this.accBeta2);ke.forEach(($t,dn)=>{const Sn=T.BV.registeredVariables[$t];null==this.accumulatedFirstMoment[dn]&&(this.accumulatedFirstMoment[dn]={originalName:`${$t}/m`,variable:(0,Js.lu)(()=>(0,uo.P)(Sn).variable(!1))}),null==this.accumulatedSecondMoment[dn]&&(this.accumulatedSecondMoment[dn]={originalName:`${$t}/v`,variable:(0,Js.lu)(()=>(0,uo.P)(Sn).variable(!1))});const re=Array.isArray(ge)?ge[dn].tensor:ge[$t];if(null==re)return;const xe=this.accumulatedFirstMoment[dn].variable,ee=this.accumulatedSecondMoment[dn].variable,me=(0,vi.I)((0,Pr.d)(xe,this.beta1),(0,Pr.d)(re,1-this.beta1)),Fe=(0,vi.I)((0,Pr.d)(ee,this.beta2),(0,Pr.d)((0,Al.h)(re),1-this.beta2)),gt=(0,$o.h)(me,Ke),At=(0,$o.h)(Fe,dt);xe.assign(me),ee.assign(Fe);const zt=(0,vi.I)((0,Pr.d)((0,$o.h)(gt,(0,vi.I)((0,Oa._)(At),this.epsilon)),-this.learningRate),Sn);Sn.assign(zt)}),this.accBeta1.assign((0,Pr.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,Pr.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,Js.B9)(this.accumulatedFirstMoment.map(ge=>ge.variable)),null!=this.accumulatedSecondMoment&&(0,Js.B9)(this.accumulatedSecondMoment.map(ge=>ge.variable))}getWeights(){var ge=this;return(0,We.Z)(function*(){const ke=[...ge.accumulatedFirstMoment,...ge.accumulatedSecondMoment];return[yield ge.saveIterations()].concat(ke.map(Ke=>({name:Ke.originalName,tensor:Ke.variable})))})()}setWeights(ge){var ke=this;return(0,We.Z)(function*(){ge=yield ke.extractIterations(ge),(0,Js.lu)(()=>{ke.accBeta1.assign((0,di.s)(ke.beta1,ke.iterations_+1)),ke.accBeta2.assign((0,di.s)(ke.beta2,ke.iterations_+1))});const Ke=ge.length/2;ke.accumulatedFirstMoment=ge.slice(0,Ke).map($t=>({originalName:$t.name,variable:$t.tensor.variable(!1)})),ke.accumulatedSecondMoment=ge.slice(Ke,2*Ke).map($t=>({originalName:$t.name,variable:$t.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(ge,ke){return new ge(ke.learningRate,ke.beta1,ke.beta2,ke.epsilon)}}var mi=h(6989),ic=h(765);class Br extends pa{static get className(){return"Adamax"}constructor(ge,ke,Ke,dt=null,$t=0){super(),this.learningRate=ge,this.beta1=ke,this.beta2=Ke,this.epsilon=dt,this.decay=$t,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,Js.lu)(()=>{this.iteration=(0,Zi.i)(0).variable(),this.accBeta1=(0,Zi.i)(ke).variable()}),null==dt&&(this.epsilon=T.BV.backend.epsilon())}applyGradients(ge){const ke=Array.isArray(ge)?ge.map(Ke=>Ke.name):Object.keys(ge);(0,Js.lu)(()=>{const Ke=(0,ma.l)(1,this.accBeta1),dt=(0,$o.h)(-this.learningRate,(0,vi.I)((0,Pr.d)(this.iteration,this.decay),1));ke.forEach(($t,dn)=>{const Sn=T.BV.registeredVariables[$t];null==this.accumulatedFirstMoment[dn]&&(this.accumulatedFirstMoment[dn]={originalName:`${$t}/m`,variable:(0,uo.P)(Sn).variable(!1)}),null==this.accumulatedWeightedInfNorm[dn]&&(this.accumulatedWeightedInfNorm[dn]={originalName:`${$t}/v`,variable:(0,uo.P)(Sn).variable(!1)});const re=Array.isArray(ge)?ge[dn].tensor:ge[$t];if(null==re)return;const xe=this.accumulatedFirstMoment[dn].variable,ee=this.accumulatedWeightedInfNorm[dn].variable,me=(0,vi.I)((0,Pr.d)(xe,this.beta1),(0,Pr.d)(re,1-this.beta1)),Fe=(0,Pr.d)(ee,this.beta2),gt=(0,mi.W)(re),At=(0,ic.g)(Fe,gt);xe.assign(me),ee.assign(At);const zt=(0,vi.I)((0,Pr.d)((0,$o.h)(dt,Ke),(0,$o.h)(me,(0,vi.I)(At,this.epsilon))),Sn);Sn.assign(zt)}),this.iteration.assign((0,vi.I)(this.iteration,1)),this.accBeta1.assign((0,Pr.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,Js.B9)(this.accumulatedFirstMoment.map(ge=>ge.variable)),null!=this.accumulatedWeightedInfNorm&&(0,Js.B9)(this.accumulatedWeightedInfNorm.map(ge=>ge.variable))}getWeights(){return(0,We.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(ge){return(0,We.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(ge,ke){return new ge(ke.learningRate,ke.beta1,ke.beta2,ke.epsilon,ke.decay)}}class dr extends pa{static get className(){return"SGD"}constructor(ge){super(),this.learningRate=ge,this.setLearningRate(ge)}applyGradients(ge){(Array.isArray(ge)?ge.map(Ke=>Ke.name):Object.keys(ge)).forEach((Ke,dt)=>{const $t=Array.isArray(ge)?ge[dt].tensor:ge[Ke];if(null==$t)return;const dn=T.BV.registeredVariables[Ke];(0,Js.lu)(()=>{const Sn=(0,vi.I)((0,Pr.d)(this.c,$t),dn);dn.assign(Sn)})}),this.incrementIterations()}setLearningRate(ge){this.learningRate=ge,null!=this.c&&this.c.dispose(),this.c=(0,Js.Cn)((0,Zi.i)(-ge))}dispose(){this.c.dispose()}getWeights(){var ge=this;return(0,We.Z)(function*(){return[yield ge.saveIterations()]})()}setWeights(ge){var ke=this;return(0,We.Z)(function*(){if(0!==(ge=yield ke.extractIterations(ge)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(ge,ke){return new ge(ke.learningRate)}}class Xo extends dr{static get className(){return"Momentum"}constructor(ge,ke,Ke=!1){super(ge),this.learningRate=ge,this.momentum=ke,this.useNesterov=Ke,this.accumulations=[],this.m=(0,Zi.i)(this.momentum)}applyGradients(ge){(Array.isArray(ge)?ge.map(Ke=>Ke.name):Object.keys(ge)).forEach((Ke,dt)=>{const $t=T.BV.registeredVariables[Ke];null==this.accumulations[dt]&&(this.accumulations[dt]={originalName:`${Ke}/momentum`,variable:(0,Js.lu)(()=>(0,uo.P)($t).variable(!1))});const dn=this.accumulations[dt].variable,Sn=Array.isArray(ge)?ge[dt].tensor:ge[Ke];null!=Sn&&(0,Js.lu)(()=>{let en;const re=(0,vi.I)((0,Pr.d)(this.m,dn),Sn);en=(0,vi.I)((0,Pr.d)(this.c,this.useNesterov?(0,vi.I)(Sn,(0,Pr.d)(re,this.m)):re),$t),dn.assign(re),$t.assign(en)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,Js.B9)(this.accumulations.map(ge=>ge.variable))}setMomentum(ge){this.momentum=ge}getWeights(){var ge=this;return(0,We.Z)(function*(){return[yield ge.saveIterations()].concat(ge.accumulations.map(ke=>({name:ke.originalName,tensor:ke.variable})))})()}setWeights(ge){var ke=this;return(0,We.Z)(function*(){ge=yield ke.extractIterations(ge),ke.accumulations=ge.map(dt=>({originalName:dt.name,variable:dt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(ge,ke){return new ge(ke.learningRate,ke.momentum,ke.useNesterov)}}class go extends pa{static get className(){return"RMSProp"}constructor(ge,ke=.9,Ke=0,dt=null,$t=!1){if(super(),this.learningRate=ge,this.decay=ke,this.momentum=Ke,this.epsilon=dt,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=$t,null==dt&&(this.epsilon=T.BV.backend.epsilon()),null==ge)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(ge){(Array.isArray(ge)?ge.map(Ke=>Ke.name):Object.keys(ge)).forEach((Ke,dt)=>{const $t=T.BV.registeredVariables[Ke];null==this.accumulatedMeanSquares[dt]&&(this.accumulatedMeanSquares[dt]={originalName:`${Ke}/rms`,variable:(0,Js.lu)(()=>(0,uo.P)($t).variable(!1))}),null==this.accumulatedMoments[dt]&&(this.accumulatedMoments[dt]={originalName:`${Ke}/momentum`,variable:(0,Js.lu)(()=>(0,uo.P)($t).variable(!1))}),null==this.accumulatedMeanGrads[dt]&&this.centered&&(this.accumulatedMeanGrads[dt]={originalName:`${Ke}/mg`,variable:(0,Js.lu)(()=>(0,uo.P)($t).variable(!1))});const Sn=Array.isArray(ge)?ge[dt].tensor:ge[Ke];if(null==Sn)return;const en=this.accumulatedMeanSquares[dt].variable,re=this.accumulatedMoments[dt].variable;(0,Js.lu)(()=>{const xe=(0,vi.I)((0,Pr.d)(en,this.decay),(0,Pr.d)((0,Al.h)(Sn),1-this.decay));if(this.centered){const ee=this.accumulatedMeanGrads[dt].variable,me=(0,vi.I)((0,Pr.d)(ee,this.decay),(0,Pr.d)(Sn,1-this.decay)),Fe=(0,$o.h)((0,Pr.d)(Sn,this.learningRate),(0,Oa._)((0,ma.l)(xe,(0,vi.I)((0,Al.h)(me),this.epsilon)))),gt=(0,vi.I)((0,Pr.d)(re,this.momentum),Fe);en.assign(xe),ee.assign(me),re.assign(gt);const At=(0,ma.l)($t,gt);$t.assign(At)}else{const ee=(0,vi.I)((0,Pr.d)(en,this.decay),(0,Pr.d)((0,Al.h)(Sn),1-this.decay)),me=(0,vi.I)((0,Pr.d)(re,this.momentum),(0,$o.h)((0,Pr.d)(Sn,this.learningRate),(0,Oa._)((0,vi.I)(ee,this.epsilon))));en.assign(ee),re.assign(me);const Fe=(0,ma.l)($t,me);$t.assign(Fe)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,Js.B9)(this.accumulatedMeanSquares.map(ge=>ge.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,Js.B9)(this.accumulatedMeanGrads.map(ge=>ge.variable)),null!=this.accumulatedMoments&&(0,Js.B9)(this.accumulatedMoments.map(ge=>ge.variable))}getWeights(){var ge=this;return(0,We.Z)(function*(){const ke=[...ge.accumulatedMeanSquares,...ge.accumulatedMoments];return ge.centered&&ke.push(...ge.accumulatedMeanGrads),[yield ge.saveIterations()].concat(ke.map(Ke=>({name:Ke.originalName,tensor:Ke.variable})))})()}setWeights(ge){var ke=this;return(0,We.Z)(function*(){ge=yield ke.extractIterations(ge);const Ke=ke.centered?ge.length/3:ge.length/2;ke.accumulatedMeanSquares=ge.slice(0,Ke).map($t=>({originalName:$t.name,variable:$t.tensor.variable(!1)})),ke.accumulatedMoments=ge.slice(Ke,2*Ke).map($t=>({originalName:$t.name,variable:$t.tensor.variable(!1)})),ke.centered&&(ke.accumulatedMeanGrads=ge.slice(2*Ke,3*Ke).map($t=>({originalName:$t.name,variable:$t.tensor.variable(!1)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(ge,ke){return new ge(ke.learningRate,ke.decay,ke.momentum,ke.epsilon,ke.centered)}}const ml=[Qi,fa,mo,Br,Xo,go,dr];function ar(Me){return new Promise(ge=>setTimeout(ge)).then(Me)}let Ma=(()=>{class Me{constructor(ke){if(!(0,Re.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");ke.startsWith(Me.URL_SCHEME)&&(ke=ke.slice(Me.URL_SCHEME.length)),(null==ke||0===ke.length)&&(ke="model"),this.modelJsonFileName=ke+".json",this.weightDataFileName=ke+".weights.bin"}save(ke){var Ke=this;return(0,We.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const dt=de.join(ke.weightData),$t=window.URL.createObjectURL(new Blob([dt],{type:"application/octet-stream"}));if(ke.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const Sn=bn(ke,[{paths:["./"+Ke.weightDataFileName],weights:ke.weightSpecs}]),en=window.URL.createObjectURL(new Blob([JSON.stringify(Sn)],{type:"application/json"})),re=null==Ke.modelJsonAnchor?document.createElement("a"):Ke.modelJsonAnchor;if(re.download=Ke.modelJsonFileName,re.href=en,yield ar(()=>re.dispatchEvent(new MouseEvent("click"))),null!=ke.weightData){const xe=null==Ke.weightDataAnchor?document.createElement("a"):Ke.weightDataAnchor;xe.download=Ke.weightDataFileName,xe.href=$t,yield ar(()=>xe.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ps(ke)}}})()}}return Me.URL_SCHEME="downloads://",Me})();class gn{constructor(ge){if(null==ge||ge.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${ge}`);this.jsonFile=ge[0],this.weightsFiles=ge.slice(1)}load(){var ge=this;return(0,We.Z)(function*(){return new Promise((ke,Ke)=>{const dt=new FileReader;dt.onload=$t=>{const dn=JSON.parse($t.target.result),Sn=dn.modelTopology;if(null==Sn)return void Ke(new Error(`modelTopology field is missing from file ${ge.jsonFile.name}`));if(null==dn.weightsManifest)return void Ke(new Error(`weightManifest field is missing from file ${ge.jsonFile.name}`));if(0===ge.weightsFiles.length)return void ke({modelTopology:Sn});const re=Dn(dn,xe=>ge.loadWeights(xe));ke(re)},dt.onerror=$t=>Ke(`Failed to read model topology and weights manifest JSON from file '${ge.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),dt.readAsText(ge.jsonFile)})})()}loadWeights(ge){const ke=[],Ke=[];for(const dn of ge)ke.push(...dn.weights),Ke.push(...dn.paths);const dt=this.checkManifestAndWeightFiles(ge),$t=Ke.map(dn=>this.loadWeightsFile(dn,dt[dn]));return Promise.all($t).then(dn=>[ke,dn])}loadWeightsFile(ge,ke){return new Promise((Ke,dt)=>{const $t=new FileReader;$t.onload=dn=>{Ke(dn.target.result)},$t.onerror=dn=>dt(`Failed to weights data from file of path '${ge}'.`),$t.readAsArrayBuffer(ke)})}checkManifestAndWeightFiles(ge){const ke=[],Ke=this.weightsFiles.map($t=>Bt($t.name)),dt={};for(const $t of ge)$t.paths.forEach(dn=>{const Sn=Bt(dn);if(-1!==ke.indexOf(Sn))throw new Error(`Duplicate file basename found in weights manifest: '${Sn}'`);if(ke.push(Sn),-1===Ke.indexOf(Sn))throw new Error(`Weight file with basename '${Sn}' is not provided.`);dt[dn]=this.weightsFiles[Ke.indexOf(Sn)]});if(ke.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${ke.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return dt}}function _o(Me){return new gn(Me)}function mc(Me,ge,ke,Ke){(function dn(en){(0,Le.hu)(null!=en&&Array.isArray(en)&&en.length>0,()=>"promises must be a none empty array")})(Me),function Sn(en,re){(0,Le.hu)(en>=0&&en<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${en}`),(0,Le.hu)(re>=0&&re<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${re}`),(0,Le.hu)(re>=en,()=>`startFraction must be no more than endFraction, but got startFraction ${en} and endFraction ${re}`)}(ke=ke??0,Ke=Ke??1);let dt=0;return Promise.all(Me.map(en=>(en.then(re=>{const xe=ke+ ++dt/Me.length*(Ke-ke);return ge(xe),re}),en)))}var Ro,ll;function Si(Me,ge){return(Ro=Ro||(0,We.Z)(function*(ke,Ke){null==Ke&&(Ke={});const dt=null==Ke.fetchFunc?(0,Re.OB)().platform.fetch:Ke.fetchFunc,$t=ke.map(Fe=>dt(Fe,Ke.requestInit,{isBinary:!0})),re=(null==Ke.onProgress?yield Promise.all($t):yield mc($t,Ke.onProgress,0,.5)).map(Fe=>Fe.arrayBuffer());return null==Ke.onProgress?yield Promise.all(re):yield mc(re,Ke.onProgress,.5,1)})).apply(this,arguments)}function Ca(Me){return(ll=ll||(0,We.Z)(function*(ge,ke="",Ke,dt){return Pa(Sn=>Si(Sn,{requestInit:dt}))(ge,ke,Ke)})).apply(this,arguments)}function Pa(Me){var ge;return function(ke){return(ge=ge||(0,We.Z)(function*(Ke,dt="",$t){const dn=Ke.map(()=>!1),Sn={},en=null!=$t?$t.map(()=>!1):[],re=[];if(Ke.forEach((At,zt)=>{let Pn=0;At.weights.forEach(On=>{const Ln=De["quantization"in On?On.quantization.dtype:On.dtype]*Le.NA(On.shape),An=()=>{dn[zt]=!0,null==Sn[zt]&&(Sn[zt]=[]),Sn[zt].push({manifestEntry:On,groupOffset:Pn,sizeBytes:Ln})};null!=$t?$t.forEach((vs,ir)=>{vs===On.name&&(An(),en[ir]=!0)}):An(),re.push(On.name),Pn+=Ln})}),!en.every(At=>At)){const At=$t.filter((zt,Pn)=>!en[Pn]);throw new Error(`Could not find weights in manifest with names: ${At.join(", ")}. \nManifest JSON has weights with names: ${re.join(", ")}.`)}const xe=dn.reduce((At,zt,Pn)=>(zt&&At.push(Pn),At),[]),ee=[];xe.forEach(At=>{Ke[At].paths.forEach(zt=>{const Pn=dt+(dt.endsWith("/")?"":"/")+zt;ee.push(Pn)})});const me=yield Me(ee),Fe={};let gt=0;return xe.forEach(At=>{const zt=Ke[At].paths.length,Pn=new de(me.slice(gt,gt+zt));Sn[At].forEach(Kn=>{const An=at(Pn.slice(Kn.groupOffset,Kn.groupOffset+Kn.sizeBytes),[Kn.manifestEntry]);for(const vs in An)Fe[vs]=An[vs]}),gt+=zt}),Fe})).apply(this,arguments)}}Ss.registerSaveRouter(Me=>(0,Re.OB)().getBool("IS_BROWSER")&&!Array.isArray(Me)&&Me.startsWith(Ma.URL_SCHEME)?function Wl(Me="model"){return new Ma(Me)}(Me.slice(Ma.URL_SCHEME.length)):null);let _l=(()=>{class Me{constructor(ke,Ke){if(this.DEFAULT_METHOD="POST",null==Ke&&(Ke={}),this.weightPathPrefix=Ke.weightPathPrefix,this.onProgress=Ke.onProgress,this.weightUrlConverter=Ke.weightUrlConverter,null!=Ke.fetchFunc?((0,Le.hu)("function"==typeof Ke.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=Ke.fetchFunc):this.fetch=(0,Re.OB)().platform.fetch,(0,Le.hu)(null!=ke&&ke.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(ke)&&(0,Le.hu)(2===ke.length,()=>`URL paths for http must have a length of 2, (actual length is ${ke.length}).`),this.path=ke,null!=Ke.requestInit&&null!=Ke.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=Ke.requestInit||{}}save(ke){var Ke=this;return(0,We.Z)(function*(){if(ke.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const dt=Object.assign({method:Ke.DEFAULT_METHOD},Ke.requestInit);dt.body=new FormData;const dn=bn(ke,[{paths:["./model.weights.bin"],weights:ke.weightSpecs}]);if(dt.body.append("model.json",new Blob([JSON.stringify(dn)],{type:"application/json"}),"model.json"),null!=ke.weightData){const en=de.join(ke.weightData);dt.body.append("model.weights.bin",new Blob([en],{type:"application/octet-stream"}),"model.weights.bin")}const Sn=yield Ke.fetch(Ke.path,dt);if(Sn.ok)return{modelArtifactsInfo:ps(ke),responses:[Sn]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${Sn.status}.`)})()}load(){var ke=this;return(0,We.Z)(function*(){const Ke=yield ke.fetch(ke.path,ke.requestInit);if(!Ke.ok)throw new Error(`Request to ${ke.path} failed with status code ${Ke.status}. Please verify this URL points to the model JSON of the model to load.`);let dt;try{dt=yield Ke.json()}catch{let en=`Failed to parse model JSON of response from ${ke.path}.`;throw ke.path.endsWith(".pb")?en+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":en+=" Please make sure the server is serving valid JSON for this request.",new Error(en)}if(null==dt.modelTopology&&null==dt.weightsManifest)throw new Error(`The JSON from HTTP path ${ke.path} contains neither model topology or manifest for weights.`);return Dn(dt,Sn=>ke.loadWeights(Sn))})()}loadWeights(ke){var Ke=this;return(0,We.Z)(function*(){const dt=Array.isArray(Ke.path)?Ke.path[1]:Ke.path,[$t,dn]=function q(Me){const ge=Me.lastIndexOf("/"),ke=Me.lastIndexOf("?");return[Me.substring(0,ge)+"/",ke>ge?Me.substring(ke):""]}(dt),Sn=Ke.weightPathPrefix||$t,en=Es(ke),re=[],xe=[];for(const me of ke)for(const Fe of me.paths)null!=Ke.weightUrlConverter?xe.push(Ke.weightUrlConverter(Fe)):re.push(Sn+Fe+dn);return Ke.weightUrlConverter&&re.push(...yield Promise.all(xe)),[en,yield Si(re,{requestInit:Ke.requestInit,fetchFunc:Ke.fetch,onProgress:Ke.onProgress})]})()}}return Me.URL_SCHEME_REGEX=/^https?:\/\//,Me})();function L(Me){return null!=Me.match(_l.URL_SCHEME_REGEX)}const X=(Me,ge)=>{if(typeof fetch>"u"&&(null==ge||null==ge.fetchFunc))return null;{let ke=!0;if(ke=Array.isArray(Me)?Me.every(Ke=>L(Ke)):L(Me),ke)return Ae(Me,ge)}return null};function Ae(Me,ge){return new _l(Me,ge)}function He(Me,ge){return Ae(Me,ge)}Ss.registerSaveRouter(X),Ss.registerLoadRouter(X);class Ye{constructor(ge){this.modelArtifacts=ge}load(){return this.modelArtifacts}}class it{constructor(ge){this.saveHandler=ge}save(ge){return this.saveHandler(ge)}}class _t{constructor(ge){ge.load&&(this.load=()=>Promise.resolve(ge.load())),ge.save&&(this.save=ke=>Promise.resolve(ge.save(ke)))}}function wt(Me,ge,ke,Ke){return new _t(kn(...arguments))}function kn(Me,ge,ke,Ke){return 1===arguments.length?null!=Me.modelTopology||null!=Me.weightSpecs?new Ye(Me):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ye({modelTopology:Me})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ye({modelTopology:Me,weightSpecs:ge,weightData:ke,trainingConfig:Ke}))}function pn(Me){return new it(Me)}function qn(Me){return new it(Me)}var os=h(1257),Ms=h(5592),Tr=h(5618),Cr=h(4195),Is=h(9194);const yo=(0,Cr.op)({confusionMatrix_:function lr(Me,ge,ke){const Ke=(0,os._1)(Me,"labels","confusionMatrix"),dt=(0,os._1)(ge,"predictions","confusionMatrix");Le.hu(null==ke||ke>0&&Number.isInteger(ke),()=>`If provided, numClasses must be a positive integer, but got ${ke}`),Le.hu(1===Ke.rank,()=>`Expected the rank of labels to be 1, but got ${Ke.rank}`),Le.hu(1===dt.rank,()=>`Expected the rank of predictions to be 1, but got ${dt.rank}`),Le.hu(Ke.shape[0]===dt.shape[0],()=>`Mismatch in the number of examples: ${Ke.shape[0]} vs. ${dt.shape[0]}. Labels and predictions should have the same number of elements.`),Le.hu(ke>0&&Number.isInteger(ke),()=>`numClasses is required to be a positive integer, but got ${ke}`);const $t=(0,Tr.l)((0,Yi.p)(Ke,"int32"),ke),dn=(0,Tr.l)((0,Yi.p)(dt,"int32"),ke),Sn=(0,Is.p)($t),en=(0,Ms.O)(Sn,dn);return(0,Yi.p)(en,"int32")}});var wo,Fa,Da=h(3239),Jt=h(4251),ai=h(8987),oc=h(2786);let yl,Fi=!1;function Yc(Me,ge=3){if(ge>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==Me)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let ke=!1,Ke=!1,dt=!1,$t=!1,dn=!1,Sn=!1;if(Me.data instanceof Uint8Array)ke=!0;else if(typeof ImageData<"u"&&Me instanceof ImageData)Ke=!0;else if(typeof HTMLVideoElement<"u"&&Me instanceof HTMLVideoElement)dt=!0;else if(typeof HTMLImageElement<"u"&&Me instanceof HTMLImageElement)$t=!0;else if(null!=Me.getContext)dn=!0;else{if(!(typeof ImageBitmap<"u"&&Me instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${Me.constructor.name}`);Sn=!0}if(null!=(0,ai.pI)(Jt.eBW,T.BV.backendName))return T.BV.runKernel(Jt.eBW,{pixels:Me},{numChannels:ge});const[re,xe]=dt?[Me.videoWidth,Me.videoHeight]:[Me.width,Me.height];let ee,me;if(dn)ee=Me.getContext("2d").getImageData(0,0,re,xe).data;else if(Ke||ke)ee=Me.data;else if($t||dt||Sn){if(null==yl)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");yl=new OffscreenCanvas(1,1).getContext("2d")}else yl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});yl.canvas.width=re,yl.canvas.height=xe,yl.drawImage(Me,0,0,re,xe),ee=yl.getImageData(0,0,re,xe).data}if(4===ge)me=new Int32Array(ee);else{const gt=re*xe;me=new Int32Array(gt*ge);for(let At=0;At<gt;At++)for(let zt=0;zt<ge;++zt)me[At*ge+zt]=ee[4*At+zt]}return(0,oc.w)(me,[xe,re,ge],"int32")}function Oc(Me){return(wo=wo||(0,We.Z)(function*(ge,ke=3){let Ke=null;if((0,Re.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function Zc(Me){return function vl(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(Me instanceof ImageBitmap)&&function Hl(Me){return null!=Me&&0!==Me.width&&0!==Me.height}(Me)&&!function Wu(Me){return null!=Me&&Me.data instanceof Uint8Array}(Me)}(ge)){let dt;try{dt=yield createImageBitmap(ge,{premultiplyAlpha:"none"})}catch{dt=null}Ke=null!=dt&&dt.width===ge.width&&dt.height===ge.height?dt:ge}else Ke=ge;return Yc(Ke,ke)})).apply(this,arguments)}function Fc(Me){if(2!==Me.rank&&3!==Me.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${Me.rank}.`);const ge=2===Me.rank?1:Me.shape[2];if(ge>4||2===ge)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${ge}`);if("float32"!==Me.dtype&&"int32"!==Me.dtype)throw new Error(`Unsupported type for toPixels: ${Me.dtype}. Please use float32 or int32 tensors.`)}function Ai(Me,ge){return(Fa=Fa||(0,We.Z)(function*(ke,Ke){let dt=(0,os._1)(ke,"img","toPixels");if(!(ke instanceof ol.es)){const ee=dt;dt=(0,Yi.p)(ee,"int32"),ee.dispose()}Fc(dt);const[$t,dn]=dt.shape.slice(0,2),Sn=2===dt.rank?1:dt.shape[2],en=yield dt.data(),re="float32"===dt.dtype?255:1,xe=new Uint8ClampedArray(dn*$t*4);for(let ee=0;ee<$t*dn;++ee){const me=[0,0,0,255];for(let gt=0;gt<Sn;gt++){const At=en[ee*Sn+gt];if("float32"===dt.dtype){if(At<0||At>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${At}.`)}else if("int32"===dt.dtype&&(At<0||At>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${At}.`);1===Sn?(me[0]=At*re,me[1]=At*re,me[2]=At*re):me[gt]=At*re}const Fe=4*ee;xe[Fe+0]=Math.round(me[0]),xe[Fe+1]=Math.round(me[1]),xe[Fe+2]=Math.round(me[2]),xe[Fe+3]=Math.round(me[3])}if(null!=Ke){Fi||null!=(0,ai.pI)(Jt.hGc,T.BV.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Fi=!0),Ke.width=dn,Ke.height=$t;const ee=Ke.getContext("2d"),me=new ImageData(xe,dn,$t);ee.putImageData(me,0,0)}return dt!==ke&&dt.dispose(),xe})).apply(this,arguments)}function Iu(Me,ge,ke){let Ke=(0,os._1)(Me,"img","draw");if(!(Me instanceof ol.es)){const dn=Ke;Ke=(0,Yi.p)(dn,"int32"),dn.dispose()}Fc(Ke),function Qc(Me){const ge=Me?.alpha||1;if(ge>1||ge<0)throw new Error(`Alpha value ${ge} is suppoed to be in range [0 - 1].`)}(ke?.imageOptions),T.BV.runKernel(Jt.hGc,{image:Ke},{canvas:ge,options:ke})}const B=(0,Cr.op)({fromPixels_:Yc});function ve(Me,ge){const ke=Me.shape.length,Ke=ge.shape.length;if(ke<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${ke}.`);if(Ke<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${Ke}.`);if("int32"!==ge.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${ge.dtype}.`);if(ge.shape[Ke-1]>ke)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${ge.shape[Ke-1]} vs. ${ke}`);if(0===(0,Le.NA)(Me.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${Me.shape}.`);const dt=ge.shape,$t=dt[dt.length-1];let dn=1;for(let ee=0;ee<dt.length-1;++ee)dn*=dt[ee];const Sn=Me.shape,en=dt.slice();en.pop();let re=1;for(let ee=$t;ee<ke;++ee)re*=Sn[ee],en.push(Sn[ee]);const xe=[...(0,Le.e3)(Me.shape).map(ee=>ee/re),1].slice(0,$t);return[en,dn,re,xe]}var Xt,Be=h(1876),ot=h(2320),st=h(7664);const jt=.001,Yt=.1;function xn(Me,ge,ke){return null==ke&&(ke=ss()),Jn(Me,ge,(Ke,dt)=>cn(Ke,dt,ke))}function ss(){return 32===T.BV.backend.floatPrecision()?jt:Yt}function Jn(Me,ge,ke){let Ke=!0;if(((0,te.isTypedArray)(Me)||(0,te.isTypedArray)(ge))&&(Ke=!1),(0,te.isTypedArray)(Me)&&(0,te.isTypedArray)(ge)&&(Ke=!0),Ke){const dn=Me.constructor.name,Sn=ge.constructor.name;if(dn!==Sn)throw new Error(`Arrays are of different type. Actual: ${dn}. Expected: ${Sn}`)}if(Array.isArray(Me)&&Array.isArray(ge)){const dn=(0,os.C)(Me),Sn=(0,os.C)(ge);if(!(0,Le.cO)(dn,Sn))throw new Error(`Arrays have different shapes. Actual: [${dn}]. Expected: [${Sn}]`)}const dt=(0,te.isTypedArray)(Me)?Me:(0,te.flatten)(Me),$t=(0,te.isTypedArray)(ge)?ge:(0,te.flatten)(ge);if(dt.length!==$t.length)throw new Error(`Arrays have different lengths actual: ${dt.length} vs expected: ${$t.length}.\nActual:   ${dt}.\nExpected: ${$t}.`);for(let dn=0;dn<$t.length;++dn){const Sn=dt[dn],en=$t[dn];if(!ke(Sn,en))throw new Error(`Arrays differ: actual[${dn}] = ${Sn}, expected[${dn}] = ${en}.\nActual:   ${dt}.\nExpected: ${$t}.`)}typeof expect<"u"&&expect().nothing()}function _r(Me,ge){Me().then(()=>ge.fail(),()=>ge()),typeof expect<"u"&&expect().nothing()}function Qs(Me,ge){const ke="string"==typeof ge||"number"==typeof ge||"boolean"==typeof ge?[ge]:ge;return(0,Le.HD)(Me)||(0,Le.HD)(Me[0])||(0,Le.HD)(ge)||(0,Le.HD)(ge[0])?Jn(Me,ke,(Ke,dt)=>Ke==dt):Jn(Me,ge,(Ke,dt)=>cn(Ke,dt,0))}function As(Me,ge,ke){if(null==ke&&(ke=ss()),!cn(Me,ge,ke))throw new Error(`Numbers differ: actual === ${Me}, expected === ${ge}`);typeof expect<"u"&&expect().nothing()}function cn(Me,ge,ke){return!isFinite(Me)&&!isFinite(ge)||!(isNaN(Me)||isNaN(ge)||Math.abs(Me-ge)>ke)}function Zr(Me,ge,ke){for(let Ke=0;Ke<Me.length;Ke++)if(Me[Ke]<ge||Me[Ke]>ke)throw new Error(`Value out of range:${Me[Ke]} low: ${ge}, high: ${ke}`)}function jn(Me,ge){const ke=new Float32Array(Me),Ke=new Float32Array(ge);if(ke.length!==Ke.length)throw new Error(`Expected ArrayBuffer to be of length ${Ke.length}, but it was ${ke.length}`);for(let dt=0;dt<Ke.length;dt++)if(ke[dt]!==Ke[dt])throw new Error(`Expected ArrayBuffer value at ${dt} to be ${Ke[dt]} but got ${ke[dt]} instead`)}function Oi(Me){for(let ge=0;ge<Me.length;ge++){const ke=Me[ge];Array.isArray(ke)?Oi(ke):Me[ge]=(0,te.encodeString)(ke)}return Me}function ca(Me){const ge=document.createElement("video");return"playsInline"in ge&&(ge.playsInline=!0),ge.muted=!0,ge.loop=!0,ge.style.position="fixed",ge.style.left="0px",ge.style.top="0px",ge.preload="auto",ge.appendChild(Me),new Promise(ke=>{ge.addEventListener("loadeddata",Ke=>ke(ge)),ge.load()})}function Yo(Me){return(Xt=Xt||(0,We.Z)(function*(ge){yield ge.play(),"requestVideoFrameCallback"in ge&&(yield new Promise(ke=>{ge.requestVideoFrameCallback(ke)}))})).apply(this,arguments)}const La="4.11.0";class hi{static sgd(ge){return new dr(ge)}static momentum(ge,ke,Ke=!1){return new Xo(ge,ke,Ke)}static rmsprop(ge,ke=.9,Ke=0,dt=null,$t=!1){return new go(ge,ke,Ke,dt,$t)}static adam(ge=.001,ke=.9,Ke=.999,dt=null){return new mo(ge,ke,Ke,dt)}static adadelta(ge=.001,ke=.95,Ke=null){return new Qi(ge,ke,Ke)}static adamax(ge=.002,ke=.9,Ke=.999,dt=null,$t=0){return new Br(ge,ke,Ke,dt,$t)}static adagrad(ge,ke=.1){return new fa(ge,ke)}}var ci=h(1216),qt=h(3667),jl=h(4839);const oo=hi,Bo=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:Me=>Me();function wi(){return new Promise(Me=>Bo(()=>Me()))}var $a=h(929);function Gi(Me,ge){const ke=Me[0].length;Me.forEach((dt,$t)=>{Le.hu(dt.length===ke,()=>`Error in concat${ke}D: rank of tensors[${$t}] must be the same as the rank of the rest (${ke})`)}),Le.hu(ge>=0&&ge<ke,()=>`Error in concat${ke}D: axis must be between 0 and ${ke-1}.`);const Ke=Me[0];Me.forEach((dt,$t)=>{for(let dn=0;dn<ke;dn++)Le.hu(dn===ge||dt[dn]===Ke[dn],()=>`Error in concat${ke}D: Shape of tensors[${$t}] (${dt}) does not match the shape of the rest (${Ke}) along the non-concatenated axis ${$t}.`)})}function uu(Me,ge){const ke=Me[0].slice();for(let Ke=1;Ke<Me.length;Ke++)ke[ge]+=Me[Ke][ge];return ke}var an=h(5551),kl=h(6254),Gl=function(Me){return Me[Me.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",Me[Me.VALUE_ROWIDS=1]="VALUE_ROWIDS",Me[Me.ROW_LENGTHS=2]="ROW_LENGTHS",Me[Me.ROW_SPLITS=3]="ROW_SPLITS",Me[Me.ROW_LIMITS=4]="ROW_LIMITS",Me[Me.ROW_STARTS=5]="ROW_STARTS",Me}(Gl||{});function Tu(Me,ge,ke){let Ke=new Array;if(null==ke&&null==ge)return Ke;if(null==ge)for(;Ke.length<Me+ke.length;)Ke.push(-1);else Ke=ge.slice();if(null==ke)return Ke;if(Me+ke.length!==Ke.length)throw new Error(`rt input.shape and shape=${ge} are incompatible: rt input.rank = ${Me+ke.length}, but shape.rank = ${Ke.length}`);for(let dt=1;dt<ke.length;++dt){const $t=ke[dt],dn=Ke[Ke.length-ke.length+dt],Sn=Ke[dn];if($t>=0)if(Sn>=0){if(Sn!==$t)throw new Error(`rt input.shape and shape=${ge} are incompatible: rt input.shape[${dt+Me}] = ${$t} but shape[${dt+Me}] = ${Sn}`)}else Ke[dn]=$t}return Ke}function sd(Me){const ge={FIRST_DIM_SIZE:Gl.FIRST_DIM_SIZE,VALUE_ROWIDS:Gl.VALUE_ROWIDS,ROW_LENGTHS:Gl.ROW_LENGTHS,ROW_SPLITS:Gl.ROW_SPLITS,ROW_LIMITS:Gl.ROW_LIMITS,ROW_STARTS:Gl.ROW_STARTS},ke=[];for(const Ke of Me){if(!(Ke in ge))break;ke.push(ge[Ke])}return ke}function gc(Me){return 0===Me.length?0:Me[0]===Gl.FIRST_DIM_SIZE?Me.length-1:Me.length}function rd(Me,ge){if(null==Me||null==ge)return;const ke=Me.length,Ke=ge.length;if(ke>=Ke)throw new Error(`defaultValue.shape=${Me} and ragged tensor flatValues.shape=${ge}, are incompatible: defaultValue.rank = ${ke} must be less than ragged tensor input flatValues.rank = ${Ke})`);for(let dt=0;dt<Math.min(ke,Ke-1);++dt){const $t=Me[dt],dn=ge[dt+1];if($t>=0&&dn>=0&&1!==$t&&$t!==dn)throw new Error(`defaultValue.shape=${Me}, and ragged tensor input flatValues.shape=${ge} are incompatible: defaultValue.shape[${dt-Me.length}] = ${$t} but ragged tensor input.flatValues.shape[${dt-Me.length}] = ${dn}`)}}const Au=30;function V(Me){return Me<=Au?Me:(0,Le.jP)(Me,Math.floor(Math.sqrt(Me)))}function O(Me,ge,ke){return[ke*("number"==typeof Me?Me:Me[0]),ge*("number"==typeof Me?Me:Me[1])]}function z(Me,ge,ke,Ke=!0){let dt=[];if(Ke)dt=dt.concat(ge.slice(0)),dt.push(Me[0]/ke),dt=dt.concat(Me.slice(1));else{dt=dt.concat(Me[0]);const $t=ge.length;for(let dn=0;dn<$t;++dn)dt=dt.concat([Me[dn+1]/ge[dn],ge[dn]]);dt=dt.concat(Me.slice($t+1))}return dt}function pe(Me,ge,ke=!0){const Ke=[];if(ke){Ke.push(ge);for(let dt=ge+1;dt<Me;++dt)dt<=2*ge?(Ke.push(dt),Ke.push(dt-(ge+1))):Ke.push(dt)}else{const dt=[],$t=[];for(let dn=1;dn<Me;++dn)dn>=2*ge+1||dn%2==1?$t.push(dn):dt.push(dn);Ke.push(...dt),Ke.push(0),Ke.push(...$t)}return Ke}function Pe(Me,ge,ke,Ke=!0){const dt=[];dt.push(Ke?Me[0]/ke:Me[0]*ke);for(let $t=1;$t<Me.length;++$t)dt.push($t<=ge.length?Ke?ge[$t-1]*Me[$t]:Me[$t]/ge[$t-1]:Me[$t]);return dt}function Ve(Me,ge){const ke=[0];for(let Ke=0;Ke<ge;++Ke)ke.push(Me[Ke][0]);return ke}function et(Me,ge,ke){const Ke=Me.slice(0,1);for(let dt=0;dt<ke;++dt)Ke.push(Me[dt+1]-ge[dt][0]-ge[dt][1]);return Ke}var mt=h(2152);const Wt=.3275911,mn=.254829592,rn=-.284496736,$n=1.421413741,zn=-1.453152027,Bs=1.061405429;var ur=h(2932);function Rs(Me,ge){if(Me.length!==ge.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${Me.length}, imag: ${ge.length}.`);const ke=new Float32Array(2*Me.length);for(let Ke=0;Ke<ke.length;Ke+=2)ke[Ke]=Me[Ke/2],ke[Ke+1]=ge[Ke/2];return ke}function Or(Me){const ge=new Float32Array(Me.length/2),ke=new Float32Array(Me.length/2);for(let Ke=0;Ke<Me.length;Ke+=2)ge[Ke/2]=Me[Ke],ke[Ke/2]=Me[Ke+1];return{real:ge,imag:ke}}function zr(Me){const ge=Math.ceil(Me.length/4),ke=new Float32Array(ge),Ke=new Float32Array(ge);for(let dt=0;dt<Me.length;dt+=4)ke[Math.floor(dt/4)]=Me[dt],Ke[Math.floor(dt/4)]=Me[dt+1];return{real:ke,imag:Ke}}function sr(Me){const ge=Math.floor(Me.length/4),ke=new Float32Array(ge),Ke=new Float32Array(ge);for(let dt=2;dt<Me.length;dt+=4)ke[Math.floor(dt/4)]=Me[dt],Ke[Math.floor(dt/4)]=Me[dt+1];return{real:ke,imag:Ke}}function No(Me,ge){return{real:Me[2*ge],imag:Me[2*ge+1]}}function ho(Me,ge,ke,Ke){Me[2*Ke]=ge,Me[2*Ke+1]=ke}function Rc(Me,ge){const ke=new Float32Array(Me/2),Ke=new Float32Array(Me/2);for(let dt=0;dt<Math.ceil(Me/2);dt++){const $t=(ge?2:-2)*Math.PI*(dt/Me);ke[dt]=Math.cos($t),Ke[dt]=Math.sin($t)}return{real:ke,imag:Ke}}function Vr(Me,ge,ke){const Ke=(ke?2:-2)*Math.PI*(Me/ge);return{real:Math.cos(Ke),imag:Math.sin(Ke)}}const Ec="->",ku=/->/g,Gn=",",bl="...";function Vi(Me,ge){const ke=((Me=Me.replace(/\s/g,"")).length-Me.replace(ku,"").length)/Ec.length;if(ke<1)throw new Error("Equations without an arrow are not supported.");if(ke>1)throw new Error(`Equation must contain exactly one arrow ("${Ec}").`);const[Ke,dt]=Me.split(Ec);(0,Le.hu)(-1===Ke.indexOf(bl),()=>`The ellipsis notation ("${bl}") is not supported yet.`);const $t=Ke.split(Gn),dn=$t.length;if(ge!==dn)throw new Error(`Expected ${dn} input tensors, received ${ge}`);if(dn>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const Sn=[];for(let me=0;me<dt.length;++me){const Fe=dt[me];if(!$t.some(gt=>-1!==gt.indexOf(Fe)))throw new Error(`Output subscripts contain the label ${Fe} not present in the input subscripts.`);-1===Sn.indexOf(Fe)&&Sn.push(Fe)}for(let me=0;me<Ke.length;++me){const Fe=Ke[me];-1===Sn.indexOf(Fe)&&Fe!==Gn&&Sn.push(Fe)}const en=new Array($t.length);for(let me=0;me<dn;++me){if(new Set($t[me].split("")).size!==$t[me].length)throw new Error(`Found duplicate axes in input component ${$t[me]}. Support for duplicate axes in input is not implemented yet.`);en[me]=[];for(let Fe=0;Fe<$t[me].length;++Fe)en[me].push(Sn.indexOf($t[me][Fe]))}const re=Sn.length,ee=[];for(let me=dt.length;me<re;++me)ee.push(me);return{allDims:Sn,summedDims:ee,idDims:en}}function xl(Me,ge){let ke=new Array(Me);ke.fill(-1);for(let dt=0;dt<ge.length;++dt)ke[ge[dt]]=dt;const Ke=[];for(let dt=0;dt<Me;++dt)-1===ke[dt]&&Ke.push(dt);return ke=ke.filter(dt=>-1!==dt),{permutationIndices:ke,expandDims:Ke}}function Kl(Me,ge,ke){const Ke=new Array(Me);for(let dt=0;dt<ke.length;++dt){const $t=ke[dt].shape;for(let dn=0;dn<ge[dt].length;++dn)void 0===Ke[ge[dt][dn]]?Ke[ge[dt][dn]]=$t[dn]:(0,Le.hu)(Ke[ge[dt][dn]]===$t[dn],()=>`Expected dimension ${Ke[ge[dt][dn]]} at axis ${dn} of input shaped ${JSON.stringify($t)}, but got dimension ${$t[dn]}`)}}function bu(Me,ge){const ke=Me,Ke=[];let dt=0;0===Me.length&&ke.push(-1),dt=Me.length+1;for(let dn=0;dn<dt;++dn)Ke.push([]);const $t=[];for(let dn=0;dn<ke.length;++dn){const en=Ou(ge,ke[dn]);for(const re of en)-1===$t.indexOf(re)&&(Ke[dn].push(re),$t.push(re))}return{path:ke,steps:Ke}}function _c(Me){return Me.every((ge,ke)=>ge===ke)}function Ou(Me,ge){const ke=[];for(let Ke=0;Ke<Me.length;++Ke)(0===Me[Ke].length||-1!==Me[Ke].indexOf(ge)||-1===ge)&&ke.push(Ke);return ke}function xd(Me,ge,ke=0){let Ke=[];if("number"==typeof ge)(0,Le.hu)(Me.shape[ke]%ge==0,()=>"Number of splits must evenly divide the axis."),Ke=new Array(ge).fill(Me.shape[ke]/ge);else{const dt=ge.reduce((dn,Sn)=>(-1===Sn&&(dn+=1),dn),0);(0,Le.hu)(dt<=1,()=>"There should be only one negative value in split array.");const $t=ge.indexOf(-1);if(-1!==$t){const dn=ge.reduce((Sn,en)=>en>0?Sn+en:Sn);ge[$t]=Me.shape[ke]-dn}(0,Le.hu)(Me.shape[ke]===ge.reduce((dn,Sn)=>dn+Sn),()=>"The sum of sizes must match the size of the axis dimension."),Ke=ge}return Ke}function yc(Me){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${Me}`}function Lc(Me,ge){return`indices(${Me}, 0) is invalid: ${ge} < 0`}function Ru(Me,ge,ke){return`indices(${Me}, 0) is invalid: ${ge} >= ${ke}`}function Sa(Me,ge){return`only one output dimension may be -1, not both ${Me} and ${ge}`}function Ws(Me,ge){return`size ${Me} must be non-negative, not ${ge}`}function Wr(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Mo(Me,ge){return`Input to reshape is a SparseTensor with ${(0,Le.NA)(Me)}\n  dense values, but the requested shape requires a multiple of ${(0,Le.NA)(ge)}. inputShape=${Me} outputShape= ${ge}`}function Eo(Me,ge){return`Input to reshape is a tensor with ${(0,Le.NA)(Me)} dense values, but the requested shape has ${(0,Le.NA)(ge)}. inputShape=${Me} outputShape=${ge}`}function Ol(){return"segment ids must be >= 0"}function ln(){return"segment ids are not increasing"}function ei(Me,ge){return`Segment id ${Me} out of range [0, ${ge}), possibly because segmentIds input is not sorted.`}function ua(Me,ge,ke){return`Bad: indices[${Me}] == ${ge} out of range [0, ${ke})`}function Nc(Me,ge){let Ke,ke=!1;for(Me<=Au?(Ke=Me,ke=!0):Ke=(0,Le.jP)(Me,Math.floor(Math.sqrt(Me)));!ke;)Ke>ge||Ke===Me?ke=!0:Ke=(0,Le.jP)(Me,Ke+1);return Ke}function Mc(Me,ge,ke){const Ke=[],dt=Me.length;for(let $t=0;$t<dt;$t++)Ke.push($t!==ge?Me[$t]:ke);return Ke}function Ur(Me,ge,ke,Ke){const dt=ge.shape.length,$t=Me.shape.length;if(0!==Ke&&(Ke<-dt||Ke>dt))throw new Error(`Expect batchDims in the range of [-${dt}, ${dt}], but got ${Ke}`);if(Ke<0&&(Ke+=dt),Ke>$t)throw new Error(`batchDims (${Ke}) must be less than rank(x) (\n    ${$t}).`);if(ke<Ke)throw new Error(`batchDims (${Ke}) must be less than or equal to axis (${ke}).`);for(let ee=0;ee<Ke;++ee)if(Me.shape[ee]!==ge.shape[ee])throw new Error(`x.shape[${ee}]: ${Me.shape[ee]} should be equal to indices.shape[${ee}]: ${ge.shape[ee]}.`);const dn=Me.shape[ke],Sn=[];let en=1,re=1,xe=1;for(let ee=0;ee<Ke;++ee)Sn.push(Me.shape[ee]),en*=Me.shape[ee];for(let ee=Ke;ee<ke;ee++)Sn.push(Me.shape[ee]),re*=Me.shape[ee];for(let ee=Ke;ee<dt;ee++)Sn.push(ge.shape[ee]);for(let ee=ke+1;ee<$t;ee++)Sn.push(Me.shape[ee]),xe*=Me.shape[ee];return{batchSize:en,sliceSize:xe,outerSize:re,dimSize:dn,outputShape:Sn}}function wl(Me){try{return Me.map(ge=>(0,te.decodeString)(ge))}catch(ge){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${ge}`)}}function wd(Me){return Me.map(ge=>(0,te.encodeString)(ge))}var Do=h(5672),ks=h(7349),Zo=h(7173);!function Na(){for(const Me of ml)Xs(Me)}()},4251:(Et,le,h)=>{"use strict";h.d(le,{$HU:()=>pa,$g6:()=>Os,$w:()=>Ir,Acj:()=>to,BMI:()=>hc,BiW:()=>Di,Byc:()=>bn,CAk:()=>co,CQl:()=>ji,D2d:()=>gl,DlI:()=>Oo,Eh3:()=>v,FKq:()=>Wl,G3Y:()=>os,GBy:()=>_o,Gcp:()=>ll,HEU:()=>cr,HZH:()=>al,Hhh:()=>Jr,Hmb:()=>di,IKK:()=>W,IMb:()=>we,J$2:()=>la,J7O:()=>Lo,J_u:()=>Fo,JhU:()=>K,Kgp:()=>uo,L8s:()=>Ro,Ly9:()=>De,M2y:()=>M,MIZ:()=>wt,MRv:()=>qr,MZg:()=>Ki,NEP:()=>eo,NZg:()=>Yi,O3z:()=>Si,OAf:()=>pc,OR:()=>To,OU7:()=>pl,OV7:()=>Ko,Omj:()=>xr,Oyi:()=>G,PYm:()=>Li,PhF:()=>Na,QCc:()=>J,QRR:()=>ps,Qg5:()=>Wa,QiL:()=>Oa,Qvg:()=>Cr,RFZ:()=>de,ROF:()=>_e,RQH:()=>wr,RuY:()=>lr,SIB:()=>go,SX0:()=>zs,SYM:()=>U,SbG:()=>mi,SpW:()=>y,T0n:()=>Es,TQc:()=>mc,TR1:()=>Bt,ToN:()=>Tr,Tr8:()=>it,Uyb:()=>za,VGw:()=>Z,Vbg:()=>il,VcC:()=>Dn,VfG:()=>wa,Vn9:()=>Lt,W0H:()=>vi,XDQ:()=>Is,XLW:()=>We,XkS:()=>Ye,Xze:()=>I,Y0y:()=>aa,YFo:()=>oa,YoZ:()=>dc,ZbH:()=>ja,ZjV:()=>Ea,Zz9:()=>ye,_JP:()=>Ae,_V0:()=>oc,_Yw:()=>ma,_k9:()=>Re,_tC:()=>_l,a5O:()=>gn,aJk:()=>w,avt:()=>Ha,b9H:()=>Jt,bK0:()=>q,bV0:()=>dr,c17:()=>no,cWu:()=>pn,cie:()=>Xn,cye:()=>Js,dDz:()=>Hi,deh:()=>xa,dpD:()=>fa,e07:()=>Br,e0R:()=>L,e6w:()=>Xs,e7N:()=>ui,eBW:()=>Da,eEB:()=>te,eZ0:()=>hl,ekb:()=>Qe,gJX:()=>P,h8e:()=>yo,hCO:()=>Le,hGc:()=>Qt,hdR:()=>$r,i5y:()=>Ma,iHb:()=>Qn,iJz:()=>rl,iWB:()=>qe,iZT:()=>ka,ik2:()=>It,jMg:()=>D,jQk:()=>X,jQs:()=>so,jeX:()=>lo,kU:()=>Go,kpP:()=>Ms,kuV:()=>zl,luS:()=>wo,lyA:()=>Al,mKl:()=>ic,mTV:()=>Ga,mc4:()=>nn,mhS:()=>at,mm_:()=>F,n9L:()=>kn,nhH:()=>Ca,nr8:()=>ml,o0g:()=>Zi,o2y:()=>Ct,oFR:()=>En,oHH:()=>Nn,oT6:()=>N,p2w:()=>ki,p4S:()=>Ss,pe_:()=>Ra,q1x:()=>sl,q2K:()=>fl,q8u:()=>Ka,qCd:()=>$i,qIC:()=>Bi,qWM:()=>$o,qi_:()=>Ho,qkr:()=>Qi,qw7:()=>T,r7n:()=>jo,s1s:()=>He,sEM:()=>_t,sHE:()=>Ao,sJF:()=>l,sL$:()=>Ts,usg:()=>ai,uv1:()=>Xa,vFR:()=>ko,vtC:()=>$s,vwp:()=>Po,w3H:()=>Pa,w6g:()=>Xi,wUP:()=>Xe,wYB:()=>ar,wYn:()=>fc,we_:()=>Pr,wm:()=>Ue,wx7:()=>qn,x12:()=>pt,xJR:()=>ro,xQA:()=>Xo,xnO:()=>oe,y7R:()=>or,yQU:()=>ol,yj2:()=>Te,zbQ:()=>mo,zvY:()=>ie,zws:()=>Oe});const U="Abs",Z="Acos",y="Acosh",F="Add",I="AddN",N="All",W="Any",l="ArgMax",w="ArgMin",M="Asin",T="Asinh",D="Atan",G="Atanh",J="Atan2",K="AvgPool",_e="AvgPoolGrad",Re="AvgPool3D",we="AvgPool3DGrad",We="BatchMatMul",Oe="BatchToSpaceND",ie="Bincount",Le="BitwiseAnd",De="BroadcastTo",te="BroadcastArgs",de="Cast",P="Ceil",oe="ClipByValue",ye="Complex",Te="ComplexAbs",v="Concat",at="Conv2D",Xe="Conv2DBackpropFilter",Ue="Conv2DBackpropInput",pt="Conv3D",Ct="Conv3DBackpropFilterV2",It="Conv3DBackpropInputV2",nn="Cos",Bt="Cosh",bn="Cumprod",Qn="Cumsum",Dn="CropAndResize",ps="DenseBincount",Es="DepthToSpace",Xn="DepthwiseConv2dNative",Ts="DepthwiseConv2dNativeBackpropFilter",or="DepthwiseConv2dNativeBackpropInput",Ir="Diag",Ss="Dilation2D",Qe="Dilation2DBackpropInput",Lt="Dilation2DBackpropFilter",Qt="Draw",Nn="RealDiv",Os="Einsum",zs="Elu",cr="EluGrad",xr="Erf",$r="Equal",eo="Exp",oa="ExpandDims",aa="Expm1",Po="FFT",xa="Fill",za="FlipLeftRight",To="Floor",lo="FloorDiv",Ao="FusedBatchNorm",Ho="GatherV2",sl="GatherNd",ka="Greater",to="GreaterEqual",rl="Identity",Wa="IFFT",Fo="Imag",Ha="IsFinite",qe="IsInf",jo="IsNan",la="LeakyRelu",$s="Less",co="LessEqual",ui="LinSpace",ja="Log",Go="Log1p",Li="LogicalAnd",wa="LogicalNot",Ki="LogicalOr",Xi="LogicalXor",$i="LogSoftmax",Bi="LowerBound",hl="LRN",Jr="LRNGrad",Lo="MatrixBandPart",dc="Max",hc="Maximum",Ga="MaxPool",Ko="MaxPoolGrad",pc="MaxPool3D",pl="MaxPool3DGrad",ko="MaxPoolWithArgmax",fl="Mean",no="Min",Ka="Minimum",so="MirrorPad",il="Mod",Yi="Multinomial",fc="Multiply",zl="Neg",ol="NotEqual",Xa="NonMaxSuppressionV3",Js="NonMaxSuppressionV4",vi="NonMaxSuppressionV5",$o="OnesLike",Pr="OneHot",Oa="Pack",Al="PadV2",uo="Pool",Ra="Pow",Zi="Prelu",Oo="Prod",Hi="RaggedGather",ji="RaggedRange",Di="RaggedTensorToTensor",Xs="Range",ro="Real",pa="Reciprocal",Qi="Relu",al="Reshape",fa="ResizeNearestNeighbor",di="ResizeNearestNeighborGrad",ma="ResizeBilinear",mo="ResizeBilinearGrad",mi="Relu6",ic="Reverse",Br="Round",dr="Rsqrt",Xo="ScatterNd",go="TensorScatterUpdate",ml="SearchSorted",Na="Select",En="Selu",ki="Slice",wr="Sin",ar="Sinh",Ma="Sign",gn="Sigmoid",qr="Softplus",Wl="Sqrt",_o="Sum",mc="SpaceToBatchND",Ro="SplitV",ll="Softmax",Si="SparseFillEmptyRows",Ca="SparseReshape",Pa="SparseSegmentMean",Ea="SparseSegmentSum",gl="SparseToDense",_l="SquaredDifference",q="Square",L="StaticRegexReplace",X="StridedSlice",Ae="StringNGrams",He="StringSplit",Ye="StringToHashBucketFast",it="Sub",_t="Tan",wt="Tanh",kn="Tile",pn="TopK",qn="Transform",os="Transpose",Ms="Unique",Tr="Unpack",Cr="UnsortedSegmentSum",Is="UpperBound",lr="ZerosLike",yo="Step",Da="FromPixels",Jt="RotateWithOffset",ai="_FusedMatMul",oc="FusedConv2D",wo="FusedDepthwiseConv2D"},8987:(Et,le,h)=>{"use strict";h.d(le,{Li:()=>M,T3:()=>G,bt:()=>D,nE:()=>T,pI:()=>N,tr:()=>l,uk:()=>W,wC:()=>w});var U=h(5527),Z=h(2918),y=h(2932);const F=(0,Z.R)("kernelRegistry",()=>new Map),I=(0,Z.R)("gradRegistry",()=>new Map);function N(K,_e){const Re=J(K,_e);return F.get(Re)}function W(K){return I.get(K)}function l(K){const _e=F.entries(),Re=[];for(;;){const{done:we,value:We}=_e.next();if(we)break;const[Oe,ie]=We,[Le]=Oe.split("_");Le===K&&Re.push(ie)}return Re}function w(K){const{kernelName:_e,backendName:Re}=K,we=J(_e,Re);F.has(we)&&y.Z(`The kernel '${_e}' for backend '${Re}' is already registered`),F.set(we,K)}function M(K){const{kernelName:_e}=K;I.has(_e)&&(0,U.OB)().getBool("DEBUG")&&y.Z(`Overriding the gradient for '${_e}'`),I.set(_e,K)}function T(K,_e){const Re=J(K,_e);if(!F.has(Re))throw new Error(`The kernel '${K}' for backend '${_e}' is not registered`);F.delete(Re)}function D(K){if(!I.has(K))throw new Error(`The gradient '${K}' for backend is not registered`);I.delete(K)}function G(K,_e){l(K).forEach(we=>{w(Object.assign({},we,{backendName:_e}))})}function J(K,_e){return`${_e}_${K}`}},2932:(Et,le,h)=>{"use strict";h.d(le,{Z:()=>Z,c:()=>y});var U=h(5527);function Z(...F){(0,U.OB)().getBool("IS_TEST")||(0,U.OB)().getBool("PROD")||console.warn(...F)}function y(...F){(0,U.OB)().getBool("IS_TEST")||(0,U.OB)().getBool("PROD")||console.log(...F)}},6989:(Et,le,h)=>{"use strict";h.d(le,{W:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({abs_:function I(W){const l=(0,y._1)(W,"x","abs");return U.BV.runKernel("complex64"===l.dtype?Z.yj2:Z.SYM,{x:l})}})},1184:(Et,le,h)=>{"use strict";h.d(le,{K:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({acos_:function I(W){const w={x:(0,y._1)(W,"x","acos")};return U.BV.runKernel(Z.VGw,w)}})},5622:(Et,le,h)=>{"use strict";h.d(le,{_:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({acosh_:function I(W){const w={x:(0,y._1)(W,"x","acosh")};return U.BV.runKernel(Z.SpW,w)}})},7066:(Et,le,h)=>{"use strict";h.d(le,{I:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({add_:function N(l,w){let M=(0,F._1)(l,"a","add"),T=(0,F._1)(w,"b","add");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.mm_,{a:M,b:T})}})},1862:(Et,le,h)=>{"use strict";h.d(le,{$:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({all_:function I(W,l=null,w=!1){const T={x:(0,y._1)(W,"x","all","bool")};return U.BV.runKernel(Z.oT6,T,{axis:l,keepDims:w})}})},876:(Et,le,h)=>{"use strict";h.d(le,{Y:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({any_:function I(W,l=null,w=!1){const T={x:(0,y._1)(W,"x","any","bool")};return U.BV.runKernel(Z.IKK,T,{axis:l,keepDims:w})}})},5784:(Et,le,h)=>{"use strict";h.d(le,{N:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({argMax_:function I(W,l=0){const M={x:(0,y._1)(W,"x","argMax")};return U.BV.runKernel(Z.sJF,M,{axis:l})}})},8340:(Et,le,h)=>{"use strict";h.d(le,{v:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({argMin_:function I(W,l=0){const M={x:(0,y._1)(W,"x","argMin")};return U.BV.runKernel(Z.aJk,M,{axis:l})}})},586:(Et,le,h)=>{"use strict";h.d(le,{Z:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({asin_:function I(W){const w={x:(0,y._1)(W,"x","asin")};return U.BV.runKernel(Z.M2y,w)}})},8355:(Et,le,h)=>{"use strict";h.d(le,{V:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({asinh_:function I(W){const w={x:(0,y._1)(W,"x","asinh")};return U.BV.runKernel(Z.qw7,w)}})},7881:(Et,le,h)=>{"use strict";h.d(le,{z:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({atan_:function I(W){const w={x:(0,y._1)(W,"x","atan")};return U.BV.runKernel(Z.jMg,w)}})},5825:(Et,le,h)=>{"use strict";h.d(le,{f:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({atan2_:function N(l,w){let M=(0,F._1)(l,"a","atan2"),T=(0,F._1)(w,"b","atan2");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.QCc,{a:M,b:T})}})},7932:(Et,le,h)=>{"use strict";h.d(le,{C:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({atanh_:function I(W){const w={x:(0,y._1)(W,"x","atanh")};return U.BV.runKernel(Z.Oyi,w)}})},6903:(Et,le,h)=>{"use strict";h.d(le,{w:()=>M});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(3062),N=h(5551),W=h(4195),l=h(5715);const M=(0,W.op)({avgPool_:function w(T,D,G,J,K){const _e=(0,y._1)(T,"x","avgPool","float32");F.hu(N.jT(G,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${G} and dilations '1'`);let we=_e,We=!1;3===_e.rank&&(We=!0,we=(0,l.X)(_e,[1,_e.shape[0],_e.shape[1],_e.shape[2]])),F.hu(4===we.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${we.rank}.`),N.m("avgPool",J,K);let Le=U.BV.runKernel(Z.JhU,{x:we},{filterSize:D,strides:G,pad:J,dimRoundingMode:K});return Le=(0,I.p)(Le,_e.dtype),We?(0,l.X)(Le,[Le.shape[1],Le.shape[2],Le.shape[3]]):Le}})},929:(Et,le,h)=>{"use strict";h.d(le,{LJ:()=>l,Q3:()=>W,Vh:()=>y,YB:()=>Z,kz:()=>F,lB:()=>N,rv:()=>I,sY:()=>w});var U=h(5359);function Z(M,T){for(let D=0;D<M.length;++D)if(M[M.length-D-1]!==T-1-D)return!1;return!0}function y(M,T,D){const G=M.length+T.length,J=[];let K=0,_e=0;for(let Re=0;Re<G;Re++)-1===D.indexOf(Re)?J.push(M[K++]):J.push(T[_e++]);return J}function F(M,T){const D=[],G=M.length;for(let K=0;K<G;K++)-1===T.indexOf(K)&&D.push(M[K]);return[D,T.map(K=>M[K])]}function I(M,T){return y(M,T.map(G=>1),T)}function N(M,T,D){U.hu(Z(T,D),()=>`${M} supports only inner-most axes for now. Got axes ${T} and rank-${D} input.`)}function W(M,T){if(Z(M,T))return null;const D=[];for(let G=0;G<T;++G)-1===M.indexOf(G)&&D.push(G);return M.forEach(G=>D.push(G)),D}function l(M){return M.map((T,D)=>[D,T]).sort((T,D)=>T[1]-D[1]).map(T=>T[0])}function w(M,T){const D=[];for(let G=T-M;G<T;++G)D.push(G);return D}},2782:(Et,le,h)=>{"use strict";h.d(le,{E:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({batchToSpaceND_:function N(l,w,M){const T=(0,y._1)(l,"x","batchToSpaceND"),D=w.reduce((K,_e)=>K*_e);return F.hu(T.rank>=1+w.length,()=>`input rank is ${T.rank} but should be > than blockShape.length ${w.length}`),F.hu(M.length===w.length,()=>`crops.length is ${M.length} but should be equal to blockShape.length  ${w.length}`),F.hu(T.shape[0]%D==0,()=>`input tensor batch is ${T.shape[0]} but is not divisible by the product of the elements of blockShape ${w.join(" * ")} === ${D}`),U.BV.runKernel(Z.zws,{x:T},{blockShape:w,crops:M})}})},5307:(Et,le,h)=>{"use strict";h.d(le,{t:()=>w});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(5715);function N(M){let T;return T=0===M.rank||1===M.rank?(0,I.X)(M,[1,1,1,M.size]):2===M.rank?(0,I.X)(M,[1,1,M.shape[0],M.shape[1]]):3===M.rank?(0,I.X)(M,[1,M.shape[0],M.shape[1],M.shape[2]]):M,T}const w=(0,h(4195).op)({batchNorm_:function l(M,T,D,G,J,K){null==K&&(K=.001);const _e=(0,y._1)(M,"x","batchNorm"),Re=(0,y._1)(T,"mean","batchNorm"),we=(0,y._1)(D,"variance","batchNorm");let We,Oe;null!=J&&(We=(0,y._1)(J,"scale","batchNorm")),null!=G&&(Oe=(0,y._1)(G,"offset","batchNorm")),F.hu(Re.rank===we.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F.hu(null==Oe||Re.rank===Oe.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F.hu(null==We||Re.rank===We.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const Le={x:N(_e),scale:We,offset:Oe,mean:Re,variance:we},te=U.BV.runKernel(Z.sHE,Le,{varianceEpsilon:K});return(0,I.X)(te,_e.shape)}})},983:(Et,le,h)=>{"use strict";h.d(le,{U:()=>w});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(7315),N=h(4195),W=h(5715);const w=(0,N.op)({broadcastTo_:function l(M,T){let D=(0,y._1)(M,"broadcastTo","x");const G=D.shape;if((0,F.Mu)(T),T.length<D.rank)throw new Error(`broadcastTo(): shape.length=${T.length} < input.rank=${D.rank}.`);if(T.length>D.rank){const We=D.shape.slice();for(;We.length<T.length;)We.unshift(1);D=(0,W.X)(D,We)}const J=D.shape,K=Array.from(T);for(let We=T.length-1;We>=0;We--)if(J[We]===T[We])K[We]=1;else if(1!==D.shape[We])throw new Error(`broadcastTo(): [${G}] cannot be broadcast to [${T}].`);return 0===K.map((We,Oe)=>We>1?Oe:-1).filter(We=>We>=0).length?(0,I.d)(D):U.BV.runKernel(Z.n9L,{x:D},{reps:K})}})},3239:(Et,le,h)=>{"use strict";function U(F,I){const N=F.length,W=[];for(let l=0;l<N;l++){const w=N-1-l;(I[I.length-1-l]||1)>1&&1===(F[w]||1)&&W.unshift(w)}return W}function Z(F,I){const N=[];for(let W=0;W<I.length;W++){const l=F[F.length-W-1],w=I.length-W-1;(null==l||1===l&&I[w]>1)&&N.unshift(w)}return N}function y(F,I){const N=Math.max(F.length,I.length),W=new Array(N);for(let l=0;l<N;l++){let w=F[F.length-l-1];null==w&&(w=1);let M=I[I.length-l-1];if(null==M&&(M=1),1===w)W[N-l-1]=M;else if(1===M)W[N-l-1]=w;else{if(w!==M)throw Error(`Operands could not be broadcast together with shapes ${F} and ${I}.`);W[N-l-1]=w}}return W}h.r(le),h.d(le,{assertAndGetBroadcastShape:()=>y,getBroadcastDims:()=>U,getReductionAxes:()=>Z})},582:(Et,le,h)=>{"use strict";h.d(le,{f:()=>y});var U=h(4945),Z=h(5359);function y(F,I="float32",N){return I=I||"float32",Z.Mu(F),new U.YD(F,I,N)}},3062:(Et,le,h)=>{"use strict";h.d(le,{p:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({cast_:function N(l,w){const M=(0,y._1)(l,"x","cast");if(!F.LP(w))throw new Error(`Failed to cast to unknown dtype ${w}`);if("string"===w&&"string"!==M.dtype||"string"!==w&&"string"===M.dtype)throw new Error("Only strings can be casted to strings");return U.BV.runKernel(Z.RFZ,{x:M},{dtype:w})}})},9723:(Et,le,h)=>{"use strict";h.d(le,{m:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({ceil_:function I(W){const w={x:(0,y._1)(W,"x","ceil","float32")};return U.BV.runKernel(Z.gJX,w)}})},6672:(Et,le,h)=>{"use strict";h.d(le,{i:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(2787);const l=(0,h(4195).op)({clipByValue_:function W(w,M,T){const D=(0,y._1)(w,"x","clipByValue");return F.hu(M<=T,()=>`Error in clip: min (${M}) must be less than or equal to max (${T}).`),M===T?(0,I.h)(D.shape,M,D.dtype):U.BV.runKernel(Z.xnO,{x:D},{clipValueMin:M,clipValueMax:T})}})},7315:(Et,le,h)=>{"use strict";h.d(le,{d:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({clone_:function I(W){const w={x:(0,y._1)(W,"x","clone","string_or_numeric")};return U.BV.runKernel(Z.iJz,w)}})},3037:(Et,le,h)=>{"use strict";h.d(le,{P:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({complex_:function N(l,w){const M=(0,y._1)(l,"real","complex"),T=(0,y._1)(w,"imag","complex");return F.k5(M.shape,T.shape,`real and imag shapes, ${M.shape} and ${T.shape}, must match in call to tf.complex().`),U.BV.runKernel(Z.Zz9,{real:M,imag:T})}})},4111:(Et,le,h)=>{"use strict";h.d(le,{z:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(7315);const l=(0,h(4195).op)({concat_:function W(w,M=0){(0,F.hu)(w.length>=1,()=>"Pass at least one tensor to concat");const T=(0,y.sI)(w,"tensors","concat","string_or_numeric");return"complex64"===T[0].dtype&&T.forEach(J=>{if("complex64"!==J.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${J.dtype}. `)}),1===T.length?(0,I.d)(T[0]):U.BV.runKernel(Z.Eh3,T,{axis:M})}})},8577:(Et,le,h)=>{"use strict";h.d(le,{P:()=>l});var U=h(1257),Z=h(5359),y=h(4451),F=h(5551),I=h(4195),N=h(5715);const l=(0,I.op)({conv1d_:function W(w,M,T,D,G="NWC",J=1,K){const _e=(0,U._1)(w,"x","conv1d"),Re=(0,U._1)(M,"filter","conv1d");let we=_e,We=!1;2===_e.rank&&(We=!0,we=(0,N.X)(_e,[1,_e.shape[0],_e.shape[1]])),Z.hu(3===we.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${we.rank}.`),Z.hu(3===Re.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${Re.rank}.`),F.m("conv1d",D,K),Z.hu(we.shape[2]===Re.shape[1],()=>`Error in conv1d: depth of input (${we.shape[2]}) must match input depth for filter ${Re.shape[1]}.`),Z.hu(F.jT(T,J),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${T} and dilation '${J}'`),Z.hu(F.U3(J),()=>"Error in conv1D: Dilated rates should be larger than 0."),Z.hu(F.U3(T),()=>"Error in conv1D: Stride should be larger than 0."),Z.hu("NWC"===G,()=>`Error in conv1d: got dataFormat of ${G} but only NWC is currently supported.`);const Oe=(0,N.X)(Re,[1,Re.shape[0],Re.shape[1],Re.shape[2]]),ie=(0,N.X)(we,[we.shape[0],1,we.shape[1],we.shape[2]]),de=(0,y.T)(ie,Oe,[1,T],D,"NHWC",[1,J],K);return(0,N.X)(de,We?[de.shape[2],de.shape[3]]:[de.shape[0],de.shape[2],de.shape[3]])}})},4451:(Et,le,h)=>{"use strict";h.d(le,{T:()=>w});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(5551),N=h(4195),W=h(5715);const w=(0,N.op)({conv2d_:function l(M,T,D,G,J="NHWC",K=[1,1],_e){const Re=(0,y._1)(M,"x","conv2d","float32"),we=(0,y._1)(T,"filter","conv2d","float32");let We=Re,Oe=!1;3===Re.rank&&(Oe=!0,We=(0,W.X)(Re,[1,Re.shape[0],Re.shape[1],Re.shape[2]])),F.hu(4===We.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${We.rank}.`),F.hu(4===we.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${we.rank}.`),I.m("conv2d",G,_e);const ie="NHWC"===J?We.shape[3]:We.shape[1];F.hu(ie===we.shape[2],()=>`Error in conv2d: depth of input (${ie}) must match input depth for filter ${we.shape[2]}.`),F.hu(I.jT(D,K),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${D} and dilations '${K}'`),F.hu(I.U3(K),()=>"Error in conv2D: Dilated rates should be larger than 0."),F.hu(I.U3(D),()=>"Error in conv2D: Strides should be larger than 0.");const te=U.BV.runKernel(Z.mhS,{x:We,filter:we},{strides:D,pad:G,dataFormat:J,dilations:K,dimRoundingMode:_e});return Oe?(0,W.X)(te,[te.shape[1],te.shape[2],te.shape[3]]):te}})},443:(Et,le,h)=>{"use strict";h.d(le,{p:()=>l});var U=h(687),Z=h(4251),y=h(5359),F=h(5551),I=h(4195),N=h(5715);const l=(0,I.op)({conv2DBackpropFilter_:function W(w,M,T,D,G,J="NHWC",K){let _e=w;3===w.rank&&(_e=(0,N.X)(w,[1,w.shape[0],w.shape[1],w.shape[2]]));let Re=M;3===Re.rank&&(Re=(0,N.X)(M,[1,M.shape[0],M.shape[1],M.shape[2]])),y.hu(4===_e.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${_e.shape}.`),y.hu(4===Re.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${Re.shape}.`),y.hu(4===T.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${T}.`);const we="NHWC"===J?_e.shape[3]:_e.shape[1],We="NHWC"===J?Re.shape[3]:Re.shape[1];return y.hu(we===T[2],()=>`Error in conv2dDerFilter: depth of input ${we}) must match input depth in filter (${T[2]}.`),y.hu(We===T[3],()=>`Error in conv2dDerFilter: depth of dy (${We}) must match output depth for filter (${T[3]}).`),F.m("conv2dDerFilter",G,K),U.BV.runKernel(Z.wUP,{x:_e,dy:Re},{strides:D,pad:G,dataFormat:J,dimRoundingMode:K,filterShape:T})}})},5743:(Et,le,h)=>{"use strict";h.d(le,{_:()=>l});var U=h(687),Z=h(4251),y=h(5359),F=h(5551),I=h(4195),N=h(5715);const l=(0,I.op)({conv2DBackpropInput_:function W(w,M,T,D,G,J="NHWC",K){y.hu(w.length===M.rank,()=>`Length of inShape (${w.length}) and rank of dy (${M.rank}) must match`);let _e=w,Re=M,we=!1;3===M.rank&&(we=!0,Re=(0,N.X)(M,[1,M.shape[0],M.shape[1],M.shape[2]]),_e=[1,w[0],w[1],w[2]]),y.hu(4===_e.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${_e.length}.`),y.hu(4===Re.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${Re.rank}`),y.hu(4===T.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${T.rank}`);const We="NHWC"===J?_e[3]:_e[1],Oe="NHWC"===J?Re.shape[3]:Re.shape[1];y.hu(We===T.shape[2],()=>`Error in conv2dDerInput: depth of input (${We}) must match input depth for filter ${T.shape[2]}.`),y.hu(Oe===T.shape[3],()=>`Error in conv2dDerInput: depth of output (${Oe}) must match output depth for filter ${T.shape[3]}.`),F.m("conv2dDerInput",G,K);const De=U.BV.runKernel(Z.wm,{dy:Re,filter:T},{strides:D,pad:G,dataFormat:J,dimRoundingMode:K,inputShape:_e});return we?(0,N.X)(De,[De.shape[1],De.shape[2],De.shape[3]]):De}})},8554:(Et,le,h)=>{"use strict";h.d(le,{b:()=>I});var U=h(1257),Z=h(5743);const I=(0,h(4195).op)({conv2dTranspose_:function F(N,W,l,w,M,T){const D=(0,U._1)(N,"x","conv2dTranspose"),G=(0,U._1)(W,"filter","conv2dTranspose");return(0,Z._)(l,D,G,w,M,"NHWC",T)}})},7022:(Et,le,h)=>{"use strict";h.d(le,{_:()=>W});var U=h(687),Z=h(4251),y=h(5359),F=h(4195),I=h(5715);const W=(0,F.op)({conv3DBackpropInput_:function N(l,w,M,T,D){y.hu(l.length===w.rank,()=>`Length of inShape (${l.length}) and rank of dy (${w.rank}) must match`);let G=l,J=w,K=!1;4===w.rank&&(K=!0,J=(0,I.X)(w,[1,w.shape[0],w.shape[1],w.shape[2],w.shape[3]]),G=[1,l[0],l[1],l[2],l[3]]);const _e=G[4],Re=J.shape[4];y.hu(5===G.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${G.length}.`),y.hu(5===J.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${J.rank}`),y.hu(5===M.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${M.rank}`),y.hu(_e===M.shape[3],()=>`Error in conv3dDerInput: depth of input (${_e}) must match input depth for filter ${M.shape[3]}.`),y.hu(Re===M.shape[4],()=>`Error in conv3dDerInput: depth of output (${Re}) must match output depth for filter ${M.shape[4]}.`);const Oe=U.BV.runKernel(Z.ik2,{dy:J,filter:M},{pad:D,strides:T,inputShape:G});return K?(0,I.X)(Oe,[Oe.shape[1],Oe.shape[2],Oe.shape[3],Oe.shape[4]]):Oe}})},5551:(Et,le,h)=>{"use strict";h.d(le,{I0:()=>_e,Ix:()=>I,Rf:()=>Z,U3:()=>we,Xw:()=>y,aO:()=>w,jT:()=>Re,jw:()=>N,m:()=>Oe,pl:()=>F,sl:()=>We});var U=h(5359);function Z(ie,Le,De,te,de="NHWC",P){return I(ie,[...Le,ie[3]],De,P,te,null,null,We(de))}function y(ie,Le,De,te,de,P,oe="channelsLast"){const[ye,Te]=M(Le);let v;if("channelsLast"===oe)v=[ye,Te,ie[3],ie[3]];else{if("channelsFirst"!==oe)throw new Error(`Unknown dataFormat ${oe}`);v=[ye,Te,ie[1],ie[1]]}return I(ie,v,De,te,de,P,!1,oe)}function F(ie,Le,De,te,de,P,oe="NDHWC"){const[ye,Te,v]=T(Le);let at,Xe;if("NDHWC"===oe)Xe="channelsLast",at=[ye,Te,v,ie[4],ie[4]];else{if("NCDHW"!==oe)throw new Error(`Unknown dataFormat ${oe}`);Xe="channelsFirst",at=[ye,Te,v,ie[1],ie[1]]}return N(ie,at,De,te,de,!1,Xe,P)}function I(ie,Le,De,te,de,P,oe=!1,ye="channelsLast"){let[Te,v,at,Xe]=[-1,-1,-1,-1];if("channelsLast"===ye)[Te,v,at,Xe]=ie;else{if("channelsFirst"!==ye)throw new Error(`Unknown dataFormat ${ye}`);[Te,Xe,v,at]=ie}const[Ue,pt,,Ct]=Le,[It,nn]=M(De),[Bt,bn]=M(te),Qn=D(Ue,Bt),Dn=D(pt,bn),{padInfo:ps,outHeight:Es,outWidth:Xn}=function G(ie,Le,De,te,de,P,oe,ye,Te){let v,at,Xe;if("number"==typeof ie){v={top:ie,bottom:ie,left:ie,right:ie,type:0===ie?"VALID":"NUMBER"};const pt=function W(ie,Le,De,te,de){null==te&&(te=w(ie,Le,De));const oe=ie[1];return[K((ie[0]-Le+2*te)/De+1,de),K((oe-Le+2*te)/De+1,de)]}([Le,De],P,te,ie,ye);at=pt[0],Xe=pt[1]}else if("same"===ie){at=Math.ceil(Le/te),Xe=Math.ceil(De/de);const Ue=Math.max(0,(at-1)*te+P-Le),pt=Math.max(0,(Xe-1)*de+oe-De),Ct=Math.floor(Ue/2),It=Ue-Ct,nn=Math.floor(pt/2);v={top:Ct,bottom:It,left:nn,right:pt-nn,type:"SAME"}}else if("valid"===ie)v={top:0,bottom:0,left:0,right:0,type:"VALID"},at=Math.ceil((Le-P+1)/te),Xe=Math.ceil((De-oe+1)/de);else{if("object"!=typeof ie)throw Error(`Unknown padding parameter: ${ie}`);{const Ue="channelsLast"===Te?ie[1][0]:ie[2][0],pt="channelsLast"===Te?ie[1][1]:ie[2][1],Ct="channelsLast"===Te?ie[2][0]:ie[3][0],It="channelsLast"===Te?ie[2][1]:ie[3][1];v={top:Ue,bottom:pt,left:Ct,right:It,type:0===Ue&&0===pt&&0===Ct&&0===It?"VALID":"EXPLICIT"},at=K((Le-P+Ue+pt)/te+1,ye),Xe=K((De-oe+Ct+It)/de+1,ye)}}return{padInfo:v,outHeight:at,outWidth:Xe}}(de,v,at,It,nn,Qn,Dn,P,ye),Ts=oe?Ct*Xe:Ct;let or;return"channelsFirst"===ye?or=[Te,Ts,Es,Xn]:"channelsLast"===ye&&(or=[Te,Es,Xn,Ts]),{batchSize:Te,dataFormat:ye,inHeight:v,inWidth:at,inChannels:Xe,outHeight:Es,outWidth:Xn,outChannels:Ts,padInfo:ps,strideHeight:It,strideWidth:nn,filterHeight:Ue,filterWidth:pt,effectiveFilterHeight:Qn,effectiveFilterWidth:Dn,dilationHeight:Bt,dilationWidth:bn,inShape:ie,outShape:or,filterShape:Le}}function N(ie,Le,De,te,de,P=!1,oe="channelsLast",ye){let[Te,v,at,Xe,Ue]=[-1,-1,-1,-1,-1];if("channelsLast"===oe)[Te,v,at,Xe,Ue]=ie;else{if("channelsFirst"!==oe)throw new Error(`Unknown dataFormat ${oe}`);[Te,Ue,v,at,Xe]=ie}const[pt,Ct,It,,nn]=Le,[Bt,bn,Qn]=T(De),[Dn,ps,Es]=T(te),Xn=D(pt,Dn),Ts=D(Ct,ps),or=D(It,Es),{padInfo:Ir,outDepth:Ss,outHeight:Qe,outWidth:Lt}=function J(ie,Le,De,te,de,P,oe,ye,Te,v,at){let Xe,Ue,pt,Ct;if("valid"===ie&&(ie=0),"number"==typeof ie){Xe={top:ie,bottom:ie,left:ie,right:ie,front:ie,back:ie,type:0===ie?"VALID":"NUMBER"};const nn=function l(ie,Le,De,te,de,P){null==de&&(de=w(ie,Le[0],te[0]));const oe=[0,0,0,De];for(let ye=0;ye<3;ye++)ie[ye]+2*de>=Le[ye]&&(oe[ye]=K((ie[ye]-Le[ye]+2*de)/te[ye]+1,P));return oe}([Le,De,te,1],[ye,Te,v],1,[de,P,oe],ie,at);Ue=nn[0],pt=nn[1],Ct=nn[2]}else{if("same"!==ie)throw Error(`Unknown padding parameter: ${ie}`);{Ue=Math.ceil(Le/de),pt=Math.ceil(De/P),Ct=Math.ceil(te/oe);const It=(Ue-1)*de+ye-Le,nn=(pt-1)*P+Te-De,Bt=(Ct-1)*oe+v-te,bn=Math.floor(It/2),Qn=It-bn,Dn=Math.floor(nn/2),ps=nn-Dn,Es=Math.floor(Bt/2);Xe={top:Dn,bottom:ps,left:Es,right:Bt-Es,front:bn,back:Qn,type:"SAME"}}}return{padInfo:Xe,outDepth:Ue,outHeight:pt,outWidth:Ct}}(de,v,at,Xe,Bt,bn,Qn,Xn,Ts,or,ye),Qt=P?nn*Ue:nn;let Nn;return"channelsFirst"===oe?Nn=[Te,Qt,Ss,Qe,Lt]:"channelsLast"===oe&&(Nn=[Te,Ss,Qe,Lt,Qt]),{batchSize:Te,dataFormat:oe,inDepth:v,inHeight:at,inWidth:Xe,inChannels:Ue,outDepth:Ss,outHeight:Qe,outWidth:Lt,outChannels:Qt,padInfo:Ir,strideDepth:Bt,strideHeight:bn,strideWidth:Qn,filterDepth:pt,filterHeight:Ct,filterWidth:It,effectiveFilterDepth:Xn,effectiveFilterHeight:Ts,effectiveFilterWidth:or,dilationDepth:Dn,dilationHeight:ps,dilationWidth:Es,inShape:ie,outShape:Nn,filterShape:Le}}function w(ie,Le,De,te=1){const de=D(Le,te);return Math.floor((ie[0]*(De-1)-De+de)/2)}function M(ie){return"number"==typeof ie?[ie,ie,ie]:2===ie.length?[ie[0],ie[1],1]:ie}function T(ie){return"number"==typeof ie?[ie,ie,ie]:ie}function D(ie,Le){return Le<=1?ie:ie+(ie-1)*(Le-1)}function K(ie,Le){if(!Le)return Math.trunc(ie);switch(Le){case"round":return Math.round(ie);case"ceil":return Math.ceil(ie);case"floor":return Math.floor(ie);default:throw new Error(`Unknown roundingMode ${Le}`)}}function _e(ie){const[Le,De,te]=M(ie);return 1===Le&&1===De&&1===te}function Re(ie,Le){return _e(ie)||_e(Le)}function we(ie){return M(ie).every(Le=>Le>0)}function We(ie){if("NHWC"===ie)return"channelsLast";if("NCHW"===ie)return"channelsFirst";throw new Error(`Unknown dataFormat ${ie}`)}function Oe(ie,Le,De){if(null!=De){if("string"==typeof Le)throw Error(`Error in ${ie}: pad must be an integer when using dimRoundingMode ${De} but got pad ${Le}.`);if("number"==typeof Le)U.hu(U.GN(Le),()=>`Error in ${ie}: pad must be an integer when using dimRoundingMode ${De} but got pad ${Le}.`);else{if("object"!=typeof Le)throw Error(`Error in ${ie}: Unknown padding parameter: ${Le}`);Le.forEach(te=>{te.forEach(de=>{U.hu(U.GN(de),()=>`Error in ${ie}: pad must be an integer when using dimRoundingMode ${De} but got pad ${de}.`)})})}}}},9018:(Et,le,h)=>{"use strict";h.d(le,{m:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({cos_:function I(W){const w={x:(0,y._1)(W,"x","cos","float32")};return U.BV.runKernel(Z.mc4,w)}})},3237:(Et,le,h)=>{"use strict";h.d(le,{f:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({cosh_:function I(W){const w={x:(0,y._1)(W,"x","cosh","float32")};return U.BV.runKernel(Z.TR1,w)}})},9267:(Et,le,h)=>{"use strict";h.d(le,{$:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({cumprod_:function I(W,l=0,w=!1,M=!1){const D={x:(0,y._1)(W,"x","cumprod")};return U.BV.runKernel(Z.Byc,D,{axis:l,exclusive:w,reverse:M})}})},7157:(Et,le,h)=>{"use strict";h.d(le,{z:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({cumsum_:function I(W,l=0,w=!1,M=!1){const D={x:(0,y._1)(W,"x","cumsum")};return U.BV.runKernel(Z.iHb,D,{axis:l,exclusive:w,reverse:M})}})},3961:(Et,le,h)=>{"use strict";h.d(le,{n:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({depthToSpace_:function N(l,w,M="NHWC"){const T=(0,y._1)(l,"x","depthToSpace","float32"),D="NHWC"===M?T.shape[1]:T.shape[2],G="NHWC"===M?T.shape[2]:T.shape[3],J="NHWC"===M?T.shape[3]:T.shape[1];return F.hu(w>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${w}`),F.hu(D*w>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${D} and ${w}  for depthToSpace with input shape\n    ${T.shape}`),F.hu(G*w>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${G} and ${w} for depthToSpace with input shape\n        ${T.shape}`),F.hu(J%(w*w)==0,()=>`Dimension size must be evenly divisible by ${w*w} but is ${J} for depthToSpace with input shape ${T.shape}`),U.BV.runKernel(Z.T0n,{x:T},{blockSize:w,dataFormat:M})}})},1172:(Et,le,h)=>{"use strict";h.d(le,{B:()=>w});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(5551),N=h(4195),W=h(5715);const w=(0,N.op)({depthwiseConv2d_:function l(M,T,D,G,J="NHWC",K=[1,1],_e){const Re=(0,y._1)(M,"x","depthwiseConv2d","float32"),we=(0,y._1)(T,"filter","depthwiseConv2d","float32");let We=Re,Oe=!1;3===Re.rank&&(Oe=!0,We=(0,W.X)(Re,[1,Re.shape[0],Re.shape[1],Re.shape[2]])),F.hu(4===We.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${We.rank}.`),F.hu(4===we.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${we.rank}.`);const ie="NHWC"===J?We.shape[3]:We.shape[1];F.hu(ie===we.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${ie}) must match the inChannels dimension in filter ${we.shape[2]}.`),I.m("depthwiseConv2d",G,_e);const te=U.BV.runKernel(Z.cie,{x:We,filter:we},{strides:D,pad:G,dataFormat:J,dilations:K,dimRoundingMode:_e});return Oe?(0,W.X)(te,[te.shape[1],te.shape[2],te.shape[3]]):te}})},366:(Et,le,h)=>{"use strict";h.d(le,{z:()=>N});var U=h(687),Z=h(4251),y=h(4195),F=h(5715);const N=(0,y.op)({depthwiseConv2dNativeBackpropFilter_:function I(W,l,w,M,T,D=[1,1],G){let J=W;3===W.rank&&(J=(0,F.X)(W,[1,W.shape[0],W.shape[1],W.shape[2]]));let K=l;return 3===K.rank&&(K=(0,F.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),U.BV.runKernel(Z.sL$,{x:J,dy:K},{strides:M,pad:T,dimRoundingMode:G,dilations:D,filterShape:w})}})},519:(Et,le,h)=>{"use strict";h.d(le,{v:()=>N});var U=h(687),Z=h(4251),y=h(4195),F=h(5715);const N=(0,y.op)({depthwiseConv2dNativeBackpropInput_:function I(W,l,w,M,T,D=[1,1],G){let J=l,K=!1;3===l.rank&&(K=!0,J=(0,F.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const we=U.BV.runKernel(Z.y7R,{dy:J,filter:w},{strides:M,pad:T,dimRoundingMode:G,dilations:D,inputShape:W});return K?(0,F.X)(we,[we.shape[1],we.shape[2],we.shape[3]]):we}})},2395:(Et,le,h)=>{"use strict";h.d(le,{W:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(4195),N=h(5715);const l=(0,I.op)({dilation2d_:function W(w,M,T,D,G=[1,1],J="NHWC"){const K=(0,y._1)(w,"x","dilation2d"),_e=(0,y._1)(M,"filter","dilation2d");F.hu(3===K.rank||4===K.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${K.rank}.`),F.hu(3===_e.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${_e.rank}.`),F.hu("NHWC"===J,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${J}`);let Re=K,we=!1;3===K.rank&&(Re=(0,N.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]]),we=!0),F.hu(Re.shape[3]===_e.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${Re.shape[3]} vs ${_e.shape[2]}`);const ie=U.BV.runKernel(Z.p4S,{x:Re,filter:_e},{strides:T,pad:D,dilations:G});return we?(0,N.X)(ie,[ie.shape[1],ie.shape[2],ie.shape[3]]):ie}})},3530:(Et,le,h)=>{"use strict";h.d(le,{h:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(1030);const l=(0,h(4195).op)({div_:function W(w,M){let T=(0,F._1)(w,"a","div"),D=(0,F._1)(M,"b","div");return[T,D]=(0,y.makeTypesMatch)(T,D),"int32"===T.dtype&&"int32"===D.dtype?(0,I.q)(T,D):U.BV.runKernel(Z.oHH,{a:T,b:D},{})}})},4373:(Et,le,h)=>{"use strict";h.d(le,{N:()=>w});var U=h(7664),Z=h(1257),y=h(3530),F=h(4456),I=h(4195),N=h(2190),W=h(3143);const w=(0,I.op)({divNoNan_:function l(M,T){let D=(0,Z._1)(M,"a","div"),G=(0,Z._1)(T,"b","div");[D,G]=(0,U.makeTypesMatch)(D,G);const J=(0,y.h)(D,G),K=(0,W.P)(J),_e=(0,F.D)(G,K);return(0,N.a)(_e,K,J)}})},5106:(Et,le,h)=>{"use strict";h.d(le,{A:()=>W});var U=h(1257),Z=h(5359),y=h(5592),F=h(4195),I=h(5715);const W=(0,F.op)({dot_:function N(l,w){const M=(0,U._1)(l,"t1","dot"),T=(0,U._1)(w,"t2","dot");Z.hu(!(1!==M.rank&&2!==M.rank||1!==T.rank&&2!==T.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${M.rank} and ${T.rank}.`);const D=1===M.rank?M.size:M.shape[1],G=1===T.rank?T.size:T.shape[0];if(Z.hu(D===G,()=>`Error in dot: inner dimensions of inputs must match, but got ${D} and ${G}.`),1===M.rank&&1===T.rank){const J=(0,I.X)(M,[1,-1]),K=(0,I.X)(T,[-1,1]),_e=(0,y.O)(J,K);return(0,I.X)(_e,[])}if(1===M.rank&&2===T.rank){const J=(0,I.X)(M,[1,-1]),K=(0,I.X)(T,[T.shape[0],T.shape[1]]),_e=(0,y.O)(J,K);return(0,I.X)(_e,[_e.size])}if(2===M.rank&&1===T.rank){const J=(0,I.X)(T,[-1,1]),K=(0,y.O)(M,J);return(0,I.X)(K,[K.size])}{const J=(0,I.X)(T,[T.shape[0],T.shape[1]]);return(0,y.O)(M,J)}}})},9529:(Et,le,h)=>{"use strict";h.d(le,{p:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({elu_:function I(W){const w={x:(0,y._1)(W,"x","elu","float32")};return U.BV.runKernel(Z.SX0,w)}})},4456:(Et,le,h)=>{"use strict";h.d(le,{D:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239);const l=(0,h(4195).op)({equal_:function W(w,M){let T=(0,F._1)(w,"a","equal","string_or_numeric"),D=(0,F._1)(M,"b","equal","string_or_numeric");return[T,D]=(0,y.makeTypesMatch)(T,D),(0,I.assertAndGetBroadcastShape)(T.shape,D.shape),U.BV.runKernel(Z.hdR,{a:T,b:D})}})},4634:(Et,le,h)=>{"use strict";h.d(le,{q:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(3062);const l=(0,h(4195).op)({erf_:function W(w){let M=(0,y._1)(w,"x","erf");return F.hu("int32"===M.dtype||"float32"===M.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===M.dtype&&(M=(0,I.p)(M,"float32")),U.BV.runKernel(Z.Omj,{x:M})}})},4279:(Et,le,h)=>{"use strict";h.d(le,{d:()=>F});var U=h(3717);const F=(0,h(4195).op)({euclideanNorm_:function y(I,N=null,W=!1){return(0,U.K)(I,"euclidean",N,W)}})},5109:(Et,le,h)=>{"use strict";h.d(le,{Q:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({exp_:function I(W){const w={x:(0,y._1)(W,"x","exp")};return U.BV.runKernel(Z.NEP,w)}})},7228:(Et,le,h)=>{"use strict";h.d(le,{d:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({expandDims_:function N(l,w=0){const M=(0,y._1)(l,"x","expandDims","string_or_numeric");return F.hu(w<=M.rank,()=>"Axis must be <= rank of the tensor"),U.BV.runKernel(Z.YFo,{input:M},{dim:w})}})},5748:(Et,le,h)=>{"use strict";h.d(le,{t:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({expm1_:function I(W){const w={x:(0,y._1)(W,"x","expm1")};return U.BV.runKernel(Z.Y0y,w)}})},2787:(Et,le,h)=>{"use strict";h.d(le,{h:()=>F});var U=h(687),Z=h(4251),y=h(5359);function F(I,N,W){return(0,y.Mu)(I),W=W||(0,y.D2)(N),U.BV.runKernel(Z.deh,{},{shape:I,value:N,dtype:W})}},8208:(Et,le,h)=>{"use strict";h.d(le,{G:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({floor_:function I(W){const w={x:(0,y._1)(W,"x","floor","float32")};return U.BV.runKernel(Z.OR,w)}})},1030:(Et,le,h)=>{"use strict";h.d(le,{q:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({floorDiv_:function N(l,w){let M=(0,F._1)(l,"a","floorDiv"),T=(0,F._1)(w,"b","floorDiv");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.jeX,{a:M,b:T})}})},6254:(Et,le,h)=>{"use strict";h.d(le,{Fr:()=>D,QH:()=>J,pf:()=>G,uy:()=>K});var U=h(3239),Z=h(9529),y=h(9424),F=h(8737),I=h(1584),N=h(8586),W=h(4917),l=h(5715),w=h(6139),M=h(6034),T=h(9929);function D(_e,Re,we){if(null==we||"linear"===we)return _e;if("relu"===we)return(0,F.d)(_e,(0,M.N)(Re));throw new Error(`Cannot compute gradient for fused activation ${we}.`)}function G(_e,Re){let we=Re;const We=U.getReductionAxes(_e.shape,Re.shape);return We.length>0&&(we=(0,T.S)(we,We)),(0,l.X)(we,_e.shape)}function J(_e,Re,we,We){if("linear"===Re)return _e;if("relu"===Re)return(0,N.U)(_e);if("elu"===Re)return(0,Z.p)(_e);if("relu6"===Re)return(0,W.b)(_e);if("prelu"===Re)return(0,I.A)(_e,we);if("leakyrelu"===Re)return(0,y.h)(_e,We);if("sigmoid"===Re)return(0,w.X)(_e);throw new Error(`Unknown fused activation ${Re}.`)}const K=(_e,Re)=>!(_e>0)||"linear"===Re},6117:(Et,le,h)=>{"use strict";h.d(le,{I:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({gather_:function I(W,l,w=0,M=0){const T=(0,y._1)(W,"x","gather"),D=(0,y._1)(l,"indices","gather","int32");return U.BV.runKernel(Z.qi_,{x:T,indices:D},{axis:w,batchDims:M})}})},4803:(Et,le,h)=>{"use strict";h.d(le,{p:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239);const l=(0,h(4195).op)({greater_:function W(w,M){let T=(0,F._1)(w,"a","greater","string_or_numeric"),D=(0,F._1)(M,"b","greater","string_or_numeric");return[T,D]=(0,y.makeTypesMatch)(T,D),(0,I.assertAndGetBroadcastShape)(T.shape,D.shape),U.BV.runKernel(Z.iZT,{a:T,b:D})}})},9886:(Et,le,h)=>{"use strict";h.d(le,{b:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239);const l=(0,h(4195).op)({greaterEqual_:function W(w,M){let T=(0,F._1)(w,"a","greaterEqual","string_or_numeric"),D=(0,F._1)(M,"b","greaterEqual","string_or_numeric");return[T,D]=(0,y.makeTypesMatch)(T,D),(0,I.assertAndGetBroadcastShape)(T.shape,D.shape),U.BV.runKernel(Z.Acj,{a:T,b:D})}})},1844:(Et,le,h)=>{"use strict";h.d(le,{a:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({imag_:function I(W){const w={input:(0,y._1)(W,"input","imag")};return U.BV.runKernel(Z.J_u,w)}})},1353:(Et,le,h)=>{"use strict";h.d(le,{I:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(4195),N=h(5715);const l=(0,I.op)({resizeBilinear_:function W(w,M,T=!1,D=!1){const G=(0,y._1)(w,"images","resizeBilinear");F.hu(3===G.rank||4===G.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${G.rank}.`),F.hu(2===M.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${M}.`),F.hu(!1===D||!1===T,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let J=G,K=!1;3===G.rank&&(K=!0,J=(0,N.X)(G,[1,G.shape[0],G.shape[1],G.shape[2]]));const[]=M,we=U.BV.runKernel(Z._Yw,{images:J},{alignCorners:T,halfPixelCenters:D,size:M});return K?(0,N.X)(we,[we.shape[1],we.shape[2],we.shape[3]]):we}})},7373:(Et,le,h)=>{"use strict";h.d(le,{j:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(4195),N=h(5715);const l=(0,I.op)({resizeNearestNeighbor_:function W(w,M,T=!1,D=!1){const G=(0,y._1)(w,"images","resizeNearestNeighbor");F.hu(3===G.rank||4===G.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${G.rank}.`),F.hu(2===M.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${M}.`),F.hu("float32"===G.dtype||"int32"===G.dtype,()=>"`images` must have `int32` or `float32` as dtype"),F.hu(!1===D||!1===T,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let J=G,K=!1;3===G.rank&&(K=!0,J=(0,N.X)(G,[1,G.shape[0],G.shape[1],G.shape[2]]));const[]=M,we=U.BV.runKernel(Z.dpD,{images:J},{alignCorners:T,halfPixelCenters:D,size:M});return K?(0,N.X)(we,[we.shape[1],we.shape[2],we.shape[3]]):we}})},8821:(Et,le,h)=>{"use strict";h.d(le,{x:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({isFinite_:function I(W){const w={x:(0,y._1)(W,"x","isFinite")};return U.BV.runKernel(Z.avt,w)}})},8381:(Et,le,h)=>{"use strict";h.d(le,{U:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({isInf_:function I(W){const w={x:(0,y._1)(W,"x","isInf")};return U.BV.runKernel(Z.iWB,w)}})},6483:(Et,le,h)=>{"use strict";h.d(le,{i:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({isNaN_:function I(W){const w={x:(0,y._1)(W,"x","isNaN")};return U.BV.runKernel(Z.r7n,w)}})},9424:(Et,le,h)=>{"use strict";h.d(le,{h:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({leakyRelu_:function I(W,l=.2){const M={x:(0,y._1)(W,"x","leakyRelu")};return U.BV.runKernel(Z.J$2,M,{alpha:l})}})},2761:(Et,le,h)=>{"use strict";h.d(le,{d:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239);const l=(0,h(4195).op)({less_:function W(w,M){let T=(0,F._1)(w,"a","less","string_or_numeric"),D=(0,F._1)(M,"b","less","string_or_numeric");return[T,D]=(0,y.makeTypesMatch)(T,D),(0,I.assertAndGetBroadcastShape)(T.shape,D.shape),U.BV.runKernel(Z.vtC,{a:T,b:D})}})},2223:(Et,le,h)=>{"use strict";h.d(le,{z:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239);const l=(0,h(4195).op)({lessEqual_:function W(w,M){let T=(0,F._1)(w,"a","lessEqual","string_or_numeric"),D=(0,F._1)(M,"b","lessEqual","string_or_numeric");return[T,D]=(0,y.makeTypesMatch)(T,D),(0,I.assertAndGetBroadcastShape)(T.shape,D.shape),U.BV.runKernel(Z.CAk,{a:T,b:D})}})},1523:(Et,le,h)=>{"use strict";h.d(le,{G:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(4195),N=h(5715);const l=(0,I.op)({localResponseNormalization_:function W(w,M=5,T=1,D=1,G=.5){const J=(0,y._1)(w,"x","localResponseNormalization");F.hu(4===J.rank||3===J.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${J.rank}.`),F.hu(F.GN(M),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${M}.`);let K=J,_e=!1;3===J.rank&&(_e=!0,K=(0,N.X)(J,[1,J.shape[0],J.shape[1],J.shape[2]]));const We=U.BV.runKernel(Z.eZ0,{x:K},{depthRadius:M,bias:T,alpha:D,beta:G});return _e?(0,N.X)(We,[We.shape[1],We.shape[2],We.shape[3]]):We}})},5919:(Et,le,h)=>{"use strict";h.d(le,{c:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({log_:function I(W){const w={x:(0,y._1)(W,"x","log","float32")};return U.BV.runKernel(Z.ZbH,w)}})},4088:(Et,le,h)=>{"use strict";h.d(le,{K:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({log1p_:function I(W){const w={x:(0,y._1)(W,"x","log1p")};return U.BV.runKernel(Z.kU,w)}})},4034:(Et,le,h)=>{"use strict";h.d(le,{e:()=>w});var U=h(3537),Z=h(1257),y=h(8737),F=h(5048),I=h(4195),N=h(6139),W=h(4487);const w=(0,I.op)({logSigmoid_:function l(M){const T=(0,Z._1)(M,"x","logSigmoid");return(0,U.cb)(G=>({value:(0,F.W)((0,W.W)((0,F.W)(G))),gradFunc:_e=>(0,y.d)(_e,(0,N.X)((0,F.W)(G)))}))(T)}})},6455:(Et,le,h)=>{"use strict";h.d(le,{C:()=>D});var U=h(3537),Z=h(1257),y=h(3062),F=h(5109),I=h(5919),N=h(3043),W=h(8737),l=h(4195),w=h(1191),M=h(9929);const D=(0,l.op)({logSoftmax_:function T(G,J=-1){const K=(0,Z._1)(G,"logits","logSoftmax");if(-1===J&&(J=K.rank-1),J!==K.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${K.rank} and axis was ${J}`);return(0,U.cb)((Re,we)=>{const Oe=(0,N.F)(Re,J,!0),ie=(0,w.l)(Re,Oe),Le=(0,w.l)((0,y.p)(ie,"float32"),(0,I.c)((0,M.S)((0,F.Q)(ie),J,!0)));return we([Le]),{value:Le,gradFunc:(te,de)=>{const[P]=de,ye=(0,F.Q)(P);return(0,w.l)(te,(0,W.d)((0,M.S)(te,J,!0),ye))}}})(K)}})},6735:(Et,le,h)=>{"use strict";h.d(le,{l:()=>G});var U=h(1257),Z=h(5359),y=h(7066),F=h(929),I=h(5109),N=h(5919),W=h(3043),l=h(4195),w=h(5715),M=h(1191),T=h(9929);const G=(0,l.op)({logSumExp_:function D(J,K=null,_e=!1){const Re=(0,U._1)(J,"x","logSumExp"),we=(0,Z.EC)(K,Re.shape),We=(0,W.F)(Re,we,!0),Oe=(0,M.l)(Re,We),ie=(0,I.Q)(Oe),Le=(0,T.S)(ie,we),De=(0,N.c)(Le),te=(0,y.I)((0,w.X)(We,De.shape),De);if(_e){const de=(0,F.rv)(te.shape,we);return(0,w.X)(te,de)}return te}})},3080:(Et,le,h)=>{"use strict";h.d(le,{H:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(3239);const W=(0,h(4195).op)({logicalAnd_:function N(l,w){const M=(0,y._1)(l,"a","logicalAnd","bool"),T=(0,y._1)(w,"b","logicalAnd","bool");return(0,F.assertAndGetBroadcastShape)(M.shape,T.shape),U.BV.runKernel(Z.PYm,{a:M,b:T})}})},6399:(Et,le,h)=>{"use strict";h.d(le,{h:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({logicalNot_:function I(W){const w={x:(0,y._1)(W,"x","logicalNot","bool")};return U.BV.runKernel(Z.VfG,w)}})},2693:(Et,le,h)=>{"use strict";h.d(le,{K:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(3239);const W=(0,h(4195).op)({logicalOr_:function N(l,w){const M=(0,y._1)(l,"a","logicalOr","bool"),T=(0,y._1)(w,"b","logicalOr","bool");return(0,F.assertAndGetBroadcastShape)(M.shape,T.shape),U.BV.runKernel(Z.MZg,{a:M,b:T})}})},4574:(Et,le,h)=>{"use strict";h.d(le,{e:()=>l});var U=h(1257),Z=h(3239),y=h(3080),F=h(6399),I=h(2693);const l=(0,h(4195).op)({logicalXor_:function W(w,M){const T=(0,U._1)(w,"a","logicalXor","bool"),D=(0,U._1)(M,"b","logicalXor","bool");return(0,Z.assertAndGetBroadcastShape)(T.shape,D.shape),(0,y.H)((0,I.K)(w,M),(0,F.h)((0,y.H)(w,M)))}})},4839:(Et,le,h)=>{"use strict";h.d(le,{I:()=>U});var U=function(Z){return Z[Z.NONE=0]="NONE",Z[Z.MEAN=1]="MEAN",Z[Z.SUM=2]="SUM",Z[Z.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Z}(U||{})},5592:(Et,le,h)=>{"use strict";h.d(le,{O:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({matMul_:function N(l,w,M=!1,T=!1){let D=(0,F._1)(l,"a","matMul"),G=(0,F._1)(w,"b","matMul");return[D,G]=(0,y.makeTypesMatch)(D,G),U.BV.runKernel(Z.XLW,{a:D,b:G},{transposeA:M,transposeB:T})}})},3043:(Et,le,h)=>{"use strict";h.d(le,{F:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({max_:function I(W,l=null,w=!1){const T={x:(0,y._1)(W,"x","max")};return U.BV.runKernel(Z.YoZ,T,{reductionIndices:l,keepDims:w})}})},2444:(Et,le,h)=>{"use strict";h.d(le,{_:()=>w});var U=h(687),Z=h(4251),y=h(1257),F=h(5359),I=h(5551),N=h(4195),W=h(5715);const w=(0,N.op)({maxPool_:function l(M,T,D,G,J){const K=(0,y._1)(M,"x","maxPool");let Re=K,we=!1;3===K.rank&&(we=!0,Re=(0,W.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),F.hu(4===Re.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${Re.rank}.`),F.hu(I.jT(D,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${D} and dilations '1'`),I.m("maxPool",G,J);const ie=U.BV.runKernel(Z.mTV,{x:Re},{filterSize:T,strides:D,pad:G,dimRoundingMode:J});return we?(0,W.X)(ie,[ie.shape[1],ie.shape[2],ie.shape[3]]):ie}})},765:(Et,le,h)=>{"use strict";h.d(le,{g:()=>w});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239),N=h(3062);const w=(0,h(4195).op)({maximum_:function l(M,T){let D=(0,F._1)(M,"a","maximum"),G=(0,F._1)(T,"b","maximum");return[D,G]=(0,y.makeTypesMatch)(D,G),"bool"===D.dtype&&(D=(0,N.p)(D,"int32"),G=(0,N.p)(G,"int32")),(0,I.assertAndGetBroadcastShape)(D.shape,G.shape),U.BV.runKernel(Z.BMI,{a:D,b:G})}})},9357:(Et,le,h)=>{"use strict";h.d(le,{J:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({mean_:function I(W,l=null,w=!1){const T={x:(0,y._1)(W,"x","mean")};return U.BV.runKernel(Z.q2K,T,{axis:l,keepDims:w})}})},9602:(Et,le,h)=>{"use strict";h.d(le,{V:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({min_:function I(W,l=null,w=!1){const T={x:(0,y._1)(W,"x","min")};return U.BV.runKernel(Z.c17,T,{axis:l,keepDims:w})}})},2684:(Et,le,h)=>{"use strict";h.d(le,{L:()=>w});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239),N=h(3062);const w=(0,h(4195).op)({minimum_:function l(M,T){let D=(0,F._1)(M,"a","minimum"),G=(0,F._1)(T,"b","minimum");return[D,G]=(0,y.makeTypesMatch)(D,G),"bool"===D.dtype&&(D=(0,N.p)(D,"int32"),G=(0,N.p)(G,"int32")),(0,I.assertAndGetBroadcastShape)(D.shape,G.shape),U.BV.runKernel(Z.q8u,{a:D,b:G})}})},4639:(Et,le,h)=>{"use strict";h.d(le,{V:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({mirrorPad_:function N(l,w,M){F.hu("reflect"===M||"symmetric"===M,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${M}.`);const T=(0,y._1)(l,"x","mirrorPad");if(0===T.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");F.hu(w.length===T.rank,()=>`Padding doesn't match input. Must be ${T.rank}. Got ${w.length}.`);const D="reflect"===M?1:0;for(let K=0;K<T.rank;K++)F.hu(2===w[K].length,()=>"Invalid number of paddings. Must be length of 2 each."),F.hu(w[K][0]>=0&&w[K][0]<=T.shape[K]-D&&w[K][1]>=0&&w[K][1]<=T.shape[K]-D,()=>`Padding in dimension ${K} cannot be greater than or equal to ${T.shape[K]-D} or less than 0 for input of shape ${T.shape}`);return U.BV.runKernel(Z.jQs,{x:T},{paddings:w,mode:M})}})},1612:(Et,le,h)=>{"use strict";h.d(le,{w:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({mod_:function N(l,w){let M=(0,F._1)(l,"a","mod"),T=(0,F._1)(w,"b","mod");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.Vbg,{a:M,b:T})}})},8737:(Et,le,h)=>{"use strict";h.d(le,{d:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({mul_:function N(l,w){let M=(0,F._1)(l,"a","mul"),T=(0,F._1)(w,"b","mul");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.wYn,{a:M,b:T})}})},5048:(Et,le,h)=>{"use strict";h.d(le,{W:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({neg_:function I(W){const w={x:(0,y._1)(W,"x","neg")};return U.BV.runKernel(Z.kuV,w)}})},3717:(Et,le,h)=>{"use strict";h.d(le,{K:()=>_e});var U=h(1257),Z=h(5359),y=h(6989),F=h(929),I=h(3043),N=h(9602),W=h(4195),l=h(2962),w=h(5715),M=h(8661),T=h(930),D=h(7527),G=h(9929);function K(Re,we,We=null){if(0===Re.rank)return(0,y.W)(Re);if(1!==Re.rank&&null===We)return K((0,w.X)(Re,[-1]),we,We);if(1===Re.rank||"number"==typeof We||Array.isArray(We)&&1===We.length){if(1===we)return(0,G.S)((0,y.W)(Re),We);if(we===1/0)return(0,I.F)((0,y.W)(Re),We);if(we===-1/0)return(0,N.V)((0,y.W)(Re),We);if("euclidean"===we||2===we)return(0,T._)((0,G.S)((0,l.s)((0,y.W)(Re),(0,M.i)(2,"int32")),We));throw new Error(`Error in norm: invalid ord value: ${we}`)}if(Array.isArray(We)&&2===We.length){if(1===we)return(0,I.F)((0,G.S)((0,y.W)(Re),We[0]),We[1]-1);if(we===1/0)return(0,I.F)((0,G.S)((0,y.W)(Re),We[1]),We[0]);if(we===-1/0)return(0,N.V)((0,G.S)((0,y.W)(Re),We[1]),We[0]);if("fro"===we||"euclidean"===we)return(0,T._)((0,G.S)((0,D.h)(Re),We));throw new Error(`Error in norm: invalid ord value: ${we}`)}throw new Error(`Error in norm: invalid axis: ${We}`)}const _e=(0,W.op)({norm_:function J(Re,we="euclidean",We=null,Oe=!1){const ie=K(Re=(0,U._1)(Re,"x","norm"),we,We);let Le=ie.shape;if(Oe){const De=(0,Z.EC)(We,Re.shape);Le=F.rv(ie.shape,De)}return(0,w.X)(ie,Le)}})},4015:(Et,le,h)=>{"use strict";h.d(le,{Q:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239);const l=(0,h(4195).op)({notEqual_:function W(w,M){let T=(0,F._1)(w,"a","notEqual","string_or_numeric"),D=(0,F._1)(M,"b","notEqual","string_or_numeric");return[T,D]=(0,y.makeTypesMatch)(T,D),(0,I.assertAndGetBroadcastShape)(T.shape,D.shape),U.BV.runKernel(Z.yQU,{a:T,b:D})}})},5618:(Et,le,h)=>{"use strict";h.d(le,{l:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({oneHot_:function I(W,l,w=1,M=0,T="int32"){if(l<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${l}`);const G={indices:(0,y._1)(W,"indices","oneHot","int32")};return U.BV.runKernel(Z.we_,G,{dtype:T,depth:l,onValue:w,offValue:M})}})},4968:(Et,le,h)=>{"use strict";h.d(le,{i:()=>I});var U=h(687),Z=h(5359),y=h(3037),F=h(6467);function I(N,W="float32"){if((0,Z.Mu)(N),"complex64"===W){const w=I(N,"float32"),M=(0,F.l)(N,"float32");return(0,y.P)(w,M)}const l=(0,Z.p8)((0,Z.NA)(N),W);return U.BV.makeTensor(l,N,W)}},5034:(Et,le,h)=>{"use strict";h.d(le,{J:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({onesLike_:function I(W){const w={x:(0,y._1)(W,"x","onesLike")};return U.BV.runKernel(Z.qWM,w)}})},4195:(Et,le,h)=>{"use strict";h.d(le,{op:()=>F,z:()=>y});var U=h(687),Z=h(5359);const y="__op";function F(I){const N=Object.keys(I);if(1!==N.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${N.length} keys.`);let W=N[0];const l=I[W];W.endsWith("_")&&(W=W.substring(0,W.length-1)),W+=y;const w=(...M)=>{U.BV.startScope(W);try{const T=l(...M);return(0,Z.tI)(T)&&console.error("Cannot return a Promise inside of tidy."),U.BV.endScope(T),T}catch(T){throw U.BV.endScope(null),T}};return Object.defineProperty(w,"name",{value:W,configurable:!0}),w}},3667:(Et,le,h)=>{"use strict";h.d(le,{zvA:()=>M.z,WnP:()=>Z.W,Khb:()=>y.K,__u:()=>F._,IHx:()=>I.I,QBD:()=>D,$6P:()=>G.$,YjB:()=>J.Y,NqF:()=>K.N,vHJ:()=>_e.v,ZRM:()=>Re.Z,VfV:()=>we.V,z4N:()=>We.z,fvJ:()=>Oe.f,C80:()=>ie.C,wS1:()=>Le.w,uR5:()=>oe,zEQ:()=>Ct,tgs:()=>nn.t,Dxk:()=>bn,JY5:()=>Dn,p3b:()=>Es,E4h:()=>It.E,yE8:()=>Ts,ycw:()=>Ir,anm:()=>ua,XsQ:()=>Qe,UFq:()=>Lt.U,f3b:()=>Qt.f,pju:()=>De.p,mDi:()=>Nn.m,iUl:()=>Os.i,d9v:()=>zs.d,PYB:()=>cr.P,zoF:()=>ye.z,gME:()=>$r,Izb:()=>oa,MNy:()=>Po,ZaL:()=>za,PAt:()=>To.P,Tek:()=>lo.T,bc:()=>Ao.b,pdZ:()=>sl,$QV:()=>rl,mCk:()=>Wa.m,f9Y:()=>Fo.f,mew:()=>en,$Gn:()=>Ha.$,zbp:()=>qe.z,ppE:()=>la,nTT:()=>$s.n,B10:()=>co.B,Ka3:()=>ja,WmZ:()=>Go.W,hiC:()=>Li.h,NTj:()=>wa.N,AKD:()=>Ki.A,rvX:()=>dn,WYO:()=>$i,pyx:()=>Bi.p,GRh:()=>Sn,EDe:()=>Jr,DgJ:()=>Lo.D,qNN:()=>dc.q,d2q:()=>hc.d,Qqt:()=>Ga.Q,dt4:()=>Ko.d,t$B:()=>pc.t,iyy:()=>fl,kp_:()=>Pe.k,hlL:()=>no.h,GWj:()=>Ka.G,qPi:()=>so.q,imm:()=>U,Iqj:()=>il.I,dbB:()=>Ke,pjt:()=>Yi.p,brS:()=>fc.b,Sxn:()=>Ve.S,asL:()=>zl.a,BHj:()=>ao,V3u:()=>ee,wx0:()=>et.w,xVT:()=>ol.x,UWc:()=>Xa.U,i2d:()=>Js.i,hi7:()=>vi.h,d9m:()=>$o.d,zN1:()=>Pr.z,$r2:()=>Uh,SX3:()=>Oa,G9k:()=>Al.G,cM7:()=>uo.c,Krr:()=>Ra.K,e_t:()=>Zi.e,CmS:()=>Oo.C,l_t:()=>Hi.l,HvI:()=>ji.H,hJK:()=>Di.h,K5V:()=>Xs.K,egP:()=>ro.e,MB5:()=>Pu,eab:()=>fa,OI3:()=>Te.O,Fp7:()=>di.F,_sB:()=>ma._,YQQ:()=>mi,Ip$:()=>Br,gWQ:()=>dr.g,J69:()=>Xo.J,ry_:()=>Na,VV$:()=>En.V,LTh:()=>ki.L,VdP:()=>wr.V,wQq:()=>ar.w,Gi7:()=>_o,p_:()=>wd,dC7:()=>v.d,rq4:()=>Ro,SJ_:()=>Si,W76:()=>Ca.W,KOy:()=>Mc.K,Quu:()=>Pa.Q,lfX:()=>Ea.l,iUs:()=>go.i,JpU:()=>gl.J,op:()=>M.op,N2O:()=>q,vku:()=>L.v,pNR:()=>Ae,koy:()=>Ye,t1L:()=>_t,lGY:()=>kn,d_R:()=>pn.d,sQ3:()=>qn.s,AL3:()=>os.A,S0v:()=>Ms.S,WVs:()=>Tr.W,$gW:()=>Is,VT$:()=>yo,N89:()=>Jt,TN_:()=>oc,wzB:()=>Qc,nGf:()=>Iu,ruB:()=>ve,LGj:()=>ot,pe5:()=>Xt,w6H:()=>jt,kwC:()=>Yt.k,M25:()=>xn.M,UYe:()=>ss.U,btT:()=>Jn.b,XLQ:()=>de.X,GYS:()=>_r.G,SDf:()=>As,diP:()=>Zr,sx7:()=>Oi,mG2:()=>Yo,QEs:()=>mt.Q,NMM:()=>La.N,bp0:()=>hi.b,iD$:()=>ci.i,snQ:()=>ks,zcT:()=>al,U8D:()=>qt.U,U_I:()=>jl.U,ODp:()=>$a,XD2:()=>at.X,Xxe:()=>Gi.X,tdS:()=>li,O$l:()=>uu.O,R_K:()=>an.R,tPi:()=>Xe.t,jZU:()=>Gl,SmN:()=>sd,CnO:()=>rd,p0P:()=>V,XAC:()=>O.X,Wvh:()=>z.W,fBT:()=>pe.f,rVs:()=>pu,ers:()=>ge,uN7:()=>Tc,Vl2:()=>Wt.V,_b3:()=>mn._,h62:()=>gn.h,$i:()=>rn.$,L9e:()=>$n.L,knu:()=>zn.k,Nbs:()=>Bs.N,NXj:()=>ur.N,Z_8:()=>Xf,luU:()=>qr.l,Smz:()=>Rs.S,ORZ:()=>Or.O,AEp:()=>Ue.A,XeE:()=>zr.X,RRF:()=>No,odF:()=>ho,wOQ:()=>Rc.w,yXz:()=>Vr,Bfx:()=>Ec,xZs:()=>ku,Pg0:()=>Vi,Gg6:()=>pl.G,hg7:()=>xl.h,p4s:()=>Nc.p,Xu6:()=>bu,Two:()=>_c.T,pUJ:()=>Ou.p,HHK:()=>xd.H,GaM:()=>yc,VD$:()=>Lc,arb:()=>Ru.a,itS:()=>Mo,lls:()=>Eo.l,P84:()=>Ol.P});var U={};h.r(U),h.d(U,{conv2d:()=>On,depthwiseConv2d:()=>vs,matMul:()=>Er});var Z=h(6989),y=h(1184),F=h(5622),I=h(7066),N=h(687),W=h(4251),l=h(1257),w=h(5359),M=h(4195);const D=(0,M.op)({addN_:function T(Tt){w.hu(Array.isArray(Tt),()=>"The argument passed to tf.addN() must be a list of tensors"),w.hu(Tt.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${Tt.length}`);const yt=Tt.map((ut,Mt)=>(0,l._1)(ut,`tensors${Mt}`,"addN")),ht=yt[0];return yt.forEach(ut=>{if(ut.dtype!==ht.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),yt.forEach(ut=>{if(!w.cO(ut.shape,ht.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),N.BV.runKernel(W.Xze,yt)}});var G=h(1862),J=h(876),K=h(5784),_e=h(8340),Re=h(586),we=h(8355),We=h(7881),Oe=h(5825),ie=h(7932),Le=h(6903),De=h(3062),te=h(5551),de=h(5715);const oe=(0,M.op)({avgPool3d_:function P(Tt,yt,ht,vt,ut,Mt="NDHWC"){const Vt=(0,l._1)(Tt,"x","avgPool3d","float32");let un=Vt,Rn=!1;4===Vt.rank&&(Rn=!0,un=(0,de.X)(Vt,[1,Vt.shape[0],Vt.shape[1],Vt.shape[2],Vt.shape[3]])),w.hu(5===un.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${un.rank}.`),w.hu("NDHWC"===Mt,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${Mt}`),w.hu("number"==typeof ht&&ht>0||Array.isArray(ht)&&ht[0]>0&&ht[1]>0&&ht[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${ht}'`),(0,te.m)("avgPool3d",vt,ut);let is=N.BV.runKernel(W._k9,{x:un},{filterSize:yt,strides:ht,pad:vt,dimRoundingMode:ut,dataFormat:Mt});return is=(0,De.p)(is,un.dtype),Rn?(0,de.X)(is,[is.shape[1],is.shape[2],is.shape[3],is.shape[4]]):is}});var ye=h(4111),Te=h(5592),v=h(8737),at=h(6139),Xe=h(8317),Ue=h(5987);const Ct=(0,M.op)({basicLSTMCell_:function pt(Tt,yt,ht,vt,ut,Mt){const Vt=(0,l._1)(Tt,"forgetBias","basicLSTMCell"),un=(0,l._1)(yt,"lstmKernel","basicLSTMCell"),Rn=(0,l._1)(ht,"lstmBias","basicLSTMCell"),Mn=(0,l._1)(vt,"data","basicLSTMCell"),as=(0,l._1)(ut,"c","basicLSTMCell"),is=(0,l._1)(Mt,"h","basicLSTMCell"),js=(0,ye.z)([Mn,is],1),pr=(0,Te.O)(js,un),Ri=(0,I.I)(pr,Rn),Xr=Ri.shape[1]/4,Fn=[Ri.shape[0],Xr],Fr=(0,Xe.t)(Ri,[0,0],Fn),hr=(0,Xe.t)(Ri,[0,Xr],Fn),gs=(0,Xe.t)(Ri,[0,2*Xr],Fn),Ui=(0,Xe.t)(Ri,[0,3*Xr],Fn),Ni=(0,I.I)((0,v.d)((0,at.X)(Fr),(0,Ue.A)(hr)),(0,v.d)(as,(0,at.X)((0,I.I)(Vt,gs))));return[Ni,(0,v.d)((0,Ue.A)(Ni),(0,at.X)(Ui))]}});var It=h(2782),nn=h(5307);const bn=(0,M.op)({batchNorm2d_:function Bt(Tt,yt,ht,vt,ut,Mt){const Vt=(0,l._1)(Tt,"x","batchNorm"),un=(0,l._1)(yt,"mean","batchNorm"),Rn=(0,l._1)(ht,"variance","batchNorm");let Mn,as;return null!=ut&&(Mn=(0,l._1)(ut,"scale","batchNorm")),null!=vt&&(as=(0,l._1)(vt,"offset","batchNorm")),w.hu(2===Vt.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${Vt.rank}.`),w.hu(2===un.rank||1===un.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${un.rank}.`),w.hu(2===Rn.rank||1===Rn.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${Rn.rank}.`),null!=Mn&&w.hu(2===Mn.rank||1===Mn.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${Mn.rank}.`),null!=as&&w.hu(2===as.rank||1===as.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${as.rank}.`),(0,nn.t)(Vt,un,Rn,as,Mn,Mt)}}),Dn=(0,M.op)({batchNorm3d_:function Qn(Tt,yt,ht,vt,ut,Mt){const Vt=(0,l._1)(Tt,"x","batchNorm"),un=(0,l._1)(yt,"mean","batchNorm"),Rn=(0,l._1)(ht,"variance","batchNorm");let Mn,as;return null!=ut&&(Mn=(0,l._1)(ut,"scale","batchNorm")),null!=vt&&(as=(0,l._1)(vt,"offset","batchNorm")),w.hu(3===Vt.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${Vt.rank}.`),w.hu(3===un.rank||1===un.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${un.rank}.`),w.hu(3===Rn.rank||1===Rn.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${Rn.rank}.`),null!=Mn&&w.hu(3===Mn.rank||1===Mn.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${Mn.rank}.`),null!=as&&w.hu(3===as.rank||1===as.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${as.rank}.`),(0,nn.t)(Vt,un,Rn,as,Mn,Mt)}}),Es=(0,M.op)({batchNorm4d_:function ps(Tt,yt,ht,vt,ut,Mt){const Vt=(0,l._1)(Tt,"x","batchNorm"),un=(0,l._1)(yt,"mean","batchNorm"),Rn=(0,l._1)(ht,"variance","batchNorm");let Mn,as;return null!=ut&&(Mn=(0,l._1)(ut,"scale","batchNorm")),null!=vt&&(as=(0,l._1)(vt,"offset","batchNorm")),w.hu(4===Vt.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${Vt.rank}.`),w.hu(4===un.rank||1===un.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${un.rank}.`),w.hu(4===Rn.rank||1===Rn.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${Rn.rank}.`),null!=Mn&&w.hu(4===Mn.rank||1===Mn.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${Mn.rank}.`),null!=as&&w.hu(4===as.rank||1===as.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${as.rank}.`),(0,nn.t)(Vt,un,Rn,as,Mn,Mt)}}),Ts=(0,M.op)({bincount_:function Xn(Tt,yt,ht){const vt=(0,l._1)(Tt,"x","bincount"),ut=(0,l._1)(yt,"weights","bincount");return w.hu("int32"===vt.dtype,()=>`Error in bincount: input dtype must be int32, but got ${vt.dtype}`),w.hu(ht>=0,()=>`size must be non-negative, but got ${ht}.`),w.hu(ut.size===vt.size||0===ut.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${vt.shape}, weights shape: ${ut.shape}.`),N.BV.runKernel(W.zvY,{x:vt,weights:ut},{size:ht})}}),Ir=(0,M.op)({bitwiseAnd_:function or(Tt,yt){const ht=(0,l._1)(Tt,"x","bitwiseAnd"),vt=(0,l._1)(yt,"y","bitwiseAnd");if(!(0,w.cO)(ht.shape,vt.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${ht.shape}, y: ${vt.shape}`);if("int32"!==ht.dtype||"int32"!==vt.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${ht.dtype} and type of y: ${vt.dtype}`);return N.BV.runKernel(W.hCO,{a:ht,b:vt})}}),Qe=(0,M.op)({broadcastArgs_:function Ss(Tt,yt){const ht=(0,l._1)(Tt,"s0","broadcastArgs","int32"),vt=(0,l._1)(yt,"s1","broadcastArgs","int32");if(1!==ht.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${ht.rank}`);if(1!==vt.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${vt.rank}`);return N.BV.runKernel(W.eEB,{s0:ht,s1:vt})}});var Lt=h(983),Qt=h(582),Nn=h(9723),Os=h(6672),zs=h(7315),cr=h(3037);const $r=(0,M.op)({concat1d_:function xr(Tt){return(0,ye.z)(Tt,0)}}),oa=(0,M.op)({concat2d_:function eo(Tt,yt){return(0,ye.z)(Tt,yt)}}),Po=(0,M.op)({concat3d_:function aa(Tt,yt){return(0,ye.z)(Tt,yt)}}),za=(0,M.op)({concat4d_:function xa(Tt,yt){return(0,ye.z)(Tt,yt)}});var To=h(8577),lo=h(4451),Ao=h(8554);const sl=(0,M.op)({conv3d_:function Ho(Tt,yt,ht,vt,ut="NDHWC",Mt=[1,1,1]){const Vt=(0,l._1)(Tt,"x","conv3d"),un=(0,l._1)(yt,"filter","conv3d");let Rn=Vt,Mn=!1;4===Vt.rank&&(Mn=!0,Rn=(0,de.X)(Vt,[1,Vt.shape[0],Vt.shape[1],Vt.shape[2],Vt.shape[3]])),w.hu(5===Rn.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${Rn.rank}.`),w.hu(5===un.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${un.rank}.`),w.hu(Rn.shape[4]===un.shape[3],()=>`Error in conv3d: depth of input (${Rn.shape[4]}) must match input depth for filter ${un.shape[3]}.`),w.hu((0,te.jT)(ht,Mt),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${ht} and dilations '${Mt}'`),w.hu("NDHWC"===ut,()=>`Error in conv3d: got dataFormat of ${ut} but only NDHWC is currently supported.`),w.hu((0,te.U3)(Mt),()=>"Error in conv3D: Dilated rates should be larger than 0."),w.hu((0,te.U3)(ht),()=>"Error in conv3D: Strides should be larger than 0.");const js=N.BV.runKernel(W.x12,{x:Rn,filter:un},{strides:ht,pad:vt,dataFormat:ut,dilations:Mt});return Mn?(0,de.X)(js,[js.shape[1],js.shape[2],js.shape[3],js.shape[4]]):js}});var ka=h(7022);const rl=(0,M.op)({conv3dTranspose_:function to(Tt,yt,ht,vt,ut){const Mt=(0,l._1)(Tt,"x","conv3dTranspose"),Vt=(0,l._1)(yt,"filter","conv3dTranspose");return(0,ka._)(ht,Mt,Vt,vt,ut)}});var Wa=h(9018),Fo=h(3237),Ha=h(9267),qe=h(7157);const la=(0,M.op)({denseBincount_:function jo(Tt,yt,ht,vt=!1){const ut=(0,l._1)(Tt,"x","denseBincount"),Mt=(0,l._1)(yt,"weights","denseBincount");return w.hu("int32"===ut.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${ut.dtype}`),w.hu(ut.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${ut.rank}.`),w.hu(ht>=0,()=>`size must be non-negative, but got ${ht}.`),w.hu(Mt.size===ut.size||0===Mt.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${ut.shape}, weights shape: ${Mt.shape}.`),N.BV.runKernel(W.QRR,{x:ut,weights:Mt},{size:ht,binaryOutput:vt})}});var $s=h(3961),co=h(1172);const ja=(0,M.op)({diag_:function ui(Tt){const ht={x:(0,l._1)(Tt,"x","diag")};return N.BV.runKernel(W.$w,ht)}});var Go=h(2395),Li=h(3530),wa=h(4373),Ki=h(5106);const $i=(0,M.op)({einsum_:function Xi(Tt,...yt){const ht=yt.map((ut,Mt)=>(0,l._1)(ut,`tensors${Mt}`,"einsum"));return N.BV.runKernel(W.$g6,ht,{equation:Tt})}});var Bi=h(9529);const Jr=(0,M.op)({ensureShape_:function hl(Tt,yt){const ht=(0,l._1)(Tt,"x","ensureShape","string_or_numeric");if(!(0,w.DK)(ht.shape,yt))throw new Error(`EnsureShape: Shape of tensor ${ht.shape} is not compatible with expected shape ${yt}`);return Tt}});var Lo=h(4456),dc=h(4634),hc=h(4279),Ga=h(5109),Ko=h(7228),pc=h(5748),pl=h(2005);const fl=(0,M.op)({eye_:function ko(Tt,yt,ht,vt="float32"){null==yt&&(yt=Tt);const ut=(0,Qt.f)([Tt,yt],vt),Mt=Tt<=yt?Tt:yt;for(let un=0;un<Mt;++un)ut.set(1,un,un);const Vt=(0,de.X)(ut.toTensor(),[Tt,yt]);if(null==ht)return Vt;if(1===ht.length)return(0,pl.G)((0,Ko.d)(Vt,0),[ht[0],1,1]);if(2===ht.length)return(0,pl.G)((0,Ko.d)((0,Ko.d)(Vt,0),0),[ht[0],ht[1],1,1]);if(3===ht.length)return(0,pl.G)((0,Ko.d)((0,Ko.d)((0,Ko.d)(Vt,0),0),0),[ht[0],ht[1],ht[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${ht.length}D.`)}});var no=h(2787),Ka=h(8208),so=h(1030),il=h(6117),Yi=h(4803),fc=h(9886),zl=h(1844),ol=h(8821),Xa=h(8381),Js=h(6483),vi=h(9424),$o=h(2761),Pr=h(2223);function Oa(Tt,yt,ht){if(ht<=0)throw new Error("The number of values should be positive.");return N.BV.runKernel(W.e7N,{},{start:Tt,stop:yt,num:ht})}var Al=h(1523),uo=h(5919),Ra=h(4088),Zi=h(4034),Oo=h(6455),Hi=h(6735),ji=h(3080),Di=h(6399),Xs=h(2693),ro=h(4574);const pa=2147483648,al=(0,M.op)({searchSorted_:function Qi(Tt,yt,ht="left"){const vt=(0,l._1)(Tt,"sortedSequence","searchSorted"),ut=(0,l._1)(yt,"values","searchSorted"),Vt=ut.shape[ut.shape.length-1],un=(0,de.X)(vt,[-1,vt.shape[vt.shape.length-1]]),Rn=(0,de.X)(ut,[-1,Vt]);if(un.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(un.shape[0]!==Rn.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,w.NA)(Rn.shape)>=pa)throw new Error(`values tensor size must less than ${pa}`);if(un.shape[1]>=pa)throw new Error(`trailing dim_size must less than ${pa} for int32 output type, was ${un.shape[1]}`);return N.BV.runKernel(W.nr8,{sortedSequence:un,values:Rn},{side:ht})}});function fa(Tt,yt){return al(Tt,yt,"left")}var di=h(3043),ma=h(2444);const mi=(0,M.op)({maxPool3d_:function mo(Tt,yt=[1,1,1],ht,vt,ut,Mt="NDHWC"){const Vt=(0,l._1)(Tt,"x","maxPool3d");let un=Vt,Rn=!1;4===Vt.rank&&(Rn=!0,un=(0,de.X)(Vt,[1,Vt.shape[0],Vt.shape[1],Vt.shape[2],Vt.shape[3]])),w.hu(5===un.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${un.rank}.`),w.hu("NDHWC"===Mt,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${Mt}`),(0,te.m)("maxPool3d",vt,ut);const is=N.BV.runKernel(W.OAf,{x:un},{filterSize:yt,strides:ht,pad:vt,dimRoundingMode:ut,dataFormat:Mt});return Rn?(0,de.X)(is,[is.shape[1],is.shape[2],is.shape[3],is.shape[4]]):is}}),Br=(0,M.op)({maxPoolWithArgmax_:function ic(Tt,yt,ht,vt,ut=!1){const Vt={x:(0,l._1)(Tt,"x","maxPoolWithArgmax")},Rn=N.BV.runKernel(W.vFR,Vt,{filterSize:yt,strides:ht,pad:vt,includeBatchInIndex:ut});return{result:Rn[0],indexes:Rn[1]}}});var dr=h(765),Xo=h(9357),go=h(4968),ml=h(4945);function Na(Tt,yt,{indexing:ht="xy"}={}){if("xy"!==ht&&"ij"!==ht)throw new TypeError(`${ht} is not a valid third argument to meshgrid`);if(void 0===Tt)return[];let vt=(0,l._1)(Tt,"x","meshgrid",Tt instanceof ml.es?Tt.dtype:"float32");if(void 0===yt)return[vt];let ut=(0,l._1)(yt,"y","meshgrid",yt instanceof ml.es?yt.dtype:"float32");const Mt=(0,w.NA)(vt.shape),Vt=(0,w.NA)(ut.shape);return"xy"===ht?(vt=(0,de.X)(vt,[1,-1]),ut=(0,de.X)(ut,[-1,1]),[(0,Te.O)((0,go.i)([Vt,1],vt.dtype),vt),(0,Te.O)(ut,(0,go.i)([1,Mt],ut.dtype))]):(vt=(0,de.X)(vt,[-1,1]),ut=(0,de.X)(ut,[1,-1]),[(0,Te.O)(vt,(0,go.i)([1,Vt],vt.dtype)),(0,Te.O)((0,go.i)([Mt,1],ut.dtype),ut)])}var En=h(9602),ki=h(2684),wr=h(4639),ar=h(1612),Ma=h(929),gn=h(7527),qr=h(1191);const _o=(0,M.op)({moments_:function Wl(Tt,yt=null,ht=!1){Tt=(0,l._1)(Tt,"x","moments");const vt=(0,w.EC)(yt,Tt.shape),ut=(0,Xo.J)(Tt,vt,ht);let Mt=ut.shape;ht||(Mt=(0,Ma.rv)(ut.shape,vt));const Vt=(0,gn.h)((0,qr.l)((0,De.p)(Tt,"float32"),(0,de.X)(ut,Mt)));return{mean:ut,variance:(0,Xo.J)(Vt,vt,ht)}}}),Ro=(0,M.op)({multiRNNCell_:function mc(Tt,yt,ht,vt){const ut=(0,l._1)(yt,"data","multiRNNCell"),Mt=(0,l.sI)(ht,"c","multiRNNCell"),Vt=(0,l.sI)(vt,"h","multiRNNCell");let un=ut;const Rn=[];for(let is=0;is<Tt.length;is++){const js=Tt[is](un,Mt[is],Vt[is]);Rn.push(js[0]),Rn.push(js[1]),un=js[1]}const Mn=[],as=[];for(let is=0;is<Rn.length;is+=2)Mn.push(Rn[is]),as.push(Rn[is+1]);return[Mn,as]}}),Si=(0,M.op)({multinomial_:function ll(Tt,yt,ht,vt=!1){const ut=(0,l._1)(Tt,"logits","multinomial"),Mt=ut.size,Vt=ut.rank;if(Mt<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${Mt}.`);if(Vt>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${Vt}`);ht=ht||Math.random();const Rn={logits:1===Vt?(0,de.X)(ut,[1,-1]):ut},as=N.BV.runKernel(W.NZg,Rn,{numSamples:yt,seed:ht,normalized:vt});return 1===Vt?(0,de.X)(as,[as.size]):as}});var Ca=h(5048),Pa=h(4015),Ea=h(5618),gl=h(5034);const q=(0,M.op)({outerProduct_:function _l(Tt,yt){const ht=(0,l._1)(Tt,"v1","outerProduct"),vt=(0,l._1)(yt,"v2","outerProduct");w.hu(1===ht.rank&&1===vt.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${ht.rank} and ${vt.rank}.`);const ut=(0,de.X)(ht,[-1,1]),Mt=(0,de.X)(vt,[1,-1]);return(0,Te.O)(ut,Mt)}});var L=h(404);const Ae=(0,M.op)({pad1d_:function X(Tt,yt,ht=0){return(0,w.hu)(2===yt.length,()=>"Invalid number of paddings. Must be length of 2."),(0,L.v)(Tt,[yt],ht)}}),Ye=(0,M.op)({pad2d_:function He(Tt,yt,ht=0){return(0,w.hu)(2===yt.length&&2===yt[0].length&&2===yt[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,L.v)(Tt,yt,ht)}}),_t=(0,M.op)({pad3d_:function it(Tt,yt,ht=0){return(0,w.hu)(3===yt.length&&2===yt[0].length&&2===yt[1].length&&2===yt[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,L.v)(Tt,yt,ht)}}),kn=(0,M.op)({pad4d_:function wt(Tt,yt,ht=0){return(0,w.hu)(4===yt.length&&2===yt[0].length&&2===yt[1].length&&2===yt[2].length&&2===yt[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,L.v)(Tt,yt,ht)}});var pn=h(1640),qn=h(2962),os=h(1584),Ms=h(3006),Tr=h(794);const Is=(0,M.op)({raggedGather_:function Cr(Tt,yt,ht,vt){const ut=Tt.map((as,is)=>(0,l._1)(as,`tensors${is}`,"raggedGather","int32")),Mt=(0,l._1)(yt,"paramsDenseValues","raggedGather"),Vt=(0,l._1)(ht,"indices","raggedGather","int32"),Mn=N.BV.runKernel(W.dDz,{paramsNestedSplits:ut,paramsDenseValues:Mt,indices:Vt},{outputRaggedRank:vt});return{outputNestedSplits:Mn.slice(0,Mn.length-1),outputDenseValues:Mn[Mn.length-1]}}}),yo=(0,M.op)({raggedRange_:function lr(Tt,yt,ht){const vt=(0,l._1)(Tt,"starts","raggedRange"),ut=(0,l._1)(yt,"limits","raggedRange",vt.dtype),Mt=(0,l._1)(ht,"deltas","raggedRange",vt.dtype),un=N.BV.runKernel(W.CQl,{starts:vt,limits:ut,deltas:Mt});return{rtNestedSplits:un[0],rtDenseValues:un[1]}}}),Jt=(0,M.op)({raggedTensorToTensor_:function Da(Tt,yt,ht,vt,ut){const Mt=(0,l._1)(Tt,"shape","raggedTensorToTensor","int32"),Vt=(0,l._1)(yt,"values","raggedTensorToTensor"),un=(0,l._1)(ht,"defaultValue","raggedTensorToTensor",Vt.dtype),Rn=vt.map((is,js)=>(0,l._1)(is,`tensors${js}`,"raggedTensorToTensor","int32"));return N.BV.runKernel(W.BiW,{shape:Mt,values:Vt,defaultValue:un,rowPartitionTensors:Rn},{rowPartitionTypes:ut})}}),oc=(0,M.op)({rand_:function ai(Tt,yt,ht){(0,w.Mu)(Tt);const vt=(0,w.NA)(Tt);let ut=null;if(null==ht||"float32"===ht)ut=new Float32Array(vt);else if("int32"===ht)ut=new Int32Array(vt);else{if("bool"!==ht)throw new Error(`Unknown data type ${ht}`);ut=new Uint8Array(vt)}for(let Mt=0;Mt<vt;Mt++)ut[Mt]=yt();return N.BV.makeTensor(ut,Tt,ht)}});var wo=h(9128);class Fa{constructor(yt,ht,vt,ut,Mt){this.mean=yt,this.stdDev=ht,this.dtype=vt,this.nextVal=NaN,this.truncated=ut,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const Vt=Mt||Math.random();this.random=wo.alea(Vt.toString())}nextValue(){if(!isNaN(this.nextVal)){const ut=this.nextVal;return this.nextVal=NaN,ut}let yt,ht,vt=!1;for(;!vt;){let ut,Mt,Vt;do{ut=2*this.random()-1,Mt=2*this.random()-1,Vt=ut*ut+Mt*Mt}while(Vt>=1||0===Vt);const un=Math.sqrt(-2*Math.log(Vt)/Vt);yt=this.mean+this.stdDev*ut*un,ht=this.mean+this.stdDev*Mt*un,(!this.truncated||this.isValidTruncated(yt))&&(vt=!0)}return(!this.truncated||this.isValidTruncated(ht))&&(this.nextVal=this.convertValue(ht)),this.convertValue(yt)}convertValue(yt){return null==this.dtype||"float32"===this.dtype?yt:Math.round(yt)}isValidTruncated(yt){return yt<=this.upper&&yt>=this.lower}}class yl{constructor(yt,ht,vt,ut){this.alpha=yt,this.beta=1/ht,this.dtype=vt;const Mt=ut||Math.random();this.randu=wo.alea(Mt.toString()),this.randn=new Fa(0,1,vt,!1,this.randu()),this.d=yt<1?yt+2/3:yt-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let yt,ht,vt,ut,Mt,Vt;for(;;){do{ut=this.randn.nextValue(),Vt=1+this.c*ut}while(Vt<=0);if(Vt*=Vt*Vt,yt=ut*ut,ht=1-.331*yt*yt,vt=.5*yt+this.d*(1-Vt+Math.log(Vt)),Mt=this.randu(),Mt<ht||Math.log(Mt)<vt)break}return Vt*=1/this.beta*this.d,this.alpha<1&&(Vt*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(Vt)}convertValue(yt){return"float32"===this.dtype?yt:Math.round(yt)}}class Fi{constructor(yt=0,ht=1,vt,ut){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=yt,this.range=ht-yt,this.dtype=vt,null==ut&&(ut=Math.random()),"number"==typeof ut&&(ut=ut.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${yt} - ${ht} <= 1 and dtype is not float`);this.random=wo.alea(ut)}convertValue(yt){return this.canReturnFloat()?yt:Math.round(yt)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Qc=(0,M.op)({randomGamma_:function Fc(Tt,yt,ht=1,vt="float32",ut){if((0,w.Mu)(Tt),null==ht&&(ht=1),null==vt&&(vt="float32"),"float32"!==vt&&"int32"!==vt)throw new Error(`Unsupported data type ${vt}`);const Mt=new yl(yt,ht,vt,ut),Vt=(0,Qt.f)(Tt,vt);for(let un=0;un<Vt.values.length;un++)Vt.values[un]=Mt.nextValue();return Vt.toTensor()}}),Iu=(0,M.op)({randomNormal_:function Ai(Tt,yt=0,ht=1,vt,ut){if((0,w.Mu)(Tt),null!=vt&&"bool"===vt)throw new Error(`Unsupported data type ${vt}`);const Mt=new Fa(yt,ht,vt,!1,ut),Vt=(0,Qt.f)(Tt,vt);for(let un=0;un<Vt.values.length;un++)Vt.values[un]=Mt.nextValue();return Vt.toTensor()}}),ve=(0,M.op)({randomStandardNormal_:function B(Tt,yt,ht){if(null!=yt&&"bool"===yt)throw new Error(`Unsupported data type ${yt}`);return Iu(Tt,0,1,yt,ht)}}),ot=(0,M.op)({randomUniform_:function Be(Tt,yt=0,ht=1,vt="float32",ut){(0,w.Mu)(Tt);const Mt=(0,Qt.f)(Tt,vt),Vt=new Fi(yt,ht,null,ut);for(let un=0;un<Mt.values.length;un++)Mt.values[un]=Vt.nextValue();return Mt.toTensor()}}),Xt=(0,M.op)({randomUniformInt_:function st(Tt,yt,ht,vt){return ot(Tt,yt,ht,"int32",vt)}});function jt(Tt,yt,ht=1,vt="float32"){if(0===ht)throw new Error("Cannot have a step of zero");return N.BV.runKernel(W.e6w,{},{start:Tt,stop:yt,step:ht,dtype:vt})}var Yt=h(6027),xn=h(4831),ss=h(8586),Jn=h(4917),_r=h(6825);const As=(0,M.op)({reverse1d_:function Qs(Tt){const yt=(0,l._1)(Tt,"x","reverse");return w.hu(1===yt.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${yt.rank}.`),(0,_r.G)(yt,0)}}),Zr=(0,M.op)({reverse2d_:function cn(Tt,yt){const ht=(0,l._1)(Tt,"x","reverse");return w.hu(2===ht.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${ht.rank}.`),(0,_r.G)(ht,yt)}}),Oi=(0,M.op)({reverse3d_:function jn(Tt,yt){const ht=(0,l._1)(Tt,"x","reverse");return w.hu(3===ht.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${ht.rank}.`),(0,_r.G)(ht,yt)}}),Yo=(0,M.op)({reverse4d_:function ca(Tt,yt){const ht=(0,l._1)(Tt,"x","reverse");return w.hu(4===ht.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${ht.rank}.`),(0,_r.G)(ht,yt)}});var Bo,La=h(1974),hi=h(8893),ci=h(8661),qt=h(9614),jl=h(6762),oo=h(5861);const $a=function wi(Tt,yt){return(Bo=Bo||(0,oo.Z)(function*(ht,vt){const ut=(0,l._1)(ht,"x","setdiff1d"),Mt=(0,l._1)(vt,"y","setdiff1d");w.hu(ut.dtype===Mt.dtype,()=>`x and y should have the same dtype, but got x (${ut.dtype}) and y (${Mt.dtype}).`),w.hu(1===ut.rank,()=>`x should be 1D tensor, but got x (${ut.shape}).`),w.hu(1===Mt.rank,()=>`y should be 1D tensor, but got y (${Mt.shape}).`);const Vt=yield ut.data(),un=yield Mt.data(),Rn=new Set(un);let Mn=0;for(let js=0;js<Vt.length;js++)Rn.has(Vt[js])||Mn++;const as=new ml.YD([Mn],ut.dtype),is=new ml.YD([Mn],"int32");for(let js=0,pr=0;js<Vt.length;js++)Rn.has(Vt[js])||(as.values[pr]=Vt[js],is.values[pr]=js,pr++);return[as.toTensor(),is.toTensor()]})).apply(this,arguments)};var Gi=h(4058),uu=h(2438),an=h(319);const Gl=(0,M.op)({slice1d_:function kl(Tt,yt,ht){const vt=(0,l._1)(Tt,"x","slice1d");return w.hu(1===vt.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${vt.rank} tensor`),(0,Xe.t)(vt,[yt],[ht])}}),sd=(0,M.op)({slice2d_:function Tu(Tt,yt,ht){const vt=(0,l._1)(Tt,"x","slice2d");return w.hu(2===vt.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${vt.rank} tensor`),(0,Xe.t)(vt,yt,ht)}}),rd=(0,M.op)({slice3d_:function gc(Tt,yt,ht){const vt=(0,l._1)(Tt,"x","slice3d");return w.hu(3===vt.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${vt.rank} tensor`),(0,Xe.t)(vt,yt,ht)}}),V=(0,M.op)({slice4d_:function Au(Tt,yt,ht){const vt=(0,l._1)(Tt,"x","slice4d");return w.hu(4===vt.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${vt.rank} tensor`),(0,Xe.t)(vt,yt,ht)}});var O=h(8683),z=h(4487),pe=h(9619),Pe=h(9738),Ve=h(527),et=h(6065),mt=h(1638),Wt=h(8874),mn=h(930),rn=h(9539),$n=h(2494),zn=h(7958),Bs=h(6034),ur=h(5367),Rs=h(9929),Or=h(2500),zr=h(3905),sr=h(7431);function No(Tt,yt){(0,w.Cq)(Tt);const ht=(0,l.C)(Tt,yt);if(1!==ht.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,sr.H)(Tt,null,ht,yt)}function ho(Tt,yt,ht){if((0,w.Cq)(Tt),null!=yt&&2!==yt.length)throw new Error("tensor2d() requires shape to have two numbers");const vt=(0,l.C)(Tt,ht);if(2!==vt.length&&1!==vt.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===vt.length&&null==yt)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,sr.H)(Tt,yt,vt,ht)}var Rc=h(2786);function Vr(Tt,yt,ht){if((0,w.Cq)(Tt),null!=yt&&4!==yt.length)throw new Error("tensor4d() requires shape to have four numbers");const vt=(0,l.C)(Tt,ht);if(4!==vt.length&&1!==vt.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===vt.length&&null==yt)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,sr.H)(Tt,yt,vt,ht)}function Ec(Tt,yt,ht){if((0,w.Cq)(Tt),null!=yt&&5!==yt.length)throw new Error("tensor5d() requires shape to have five numbers");const vt=(0,l.C)(Tt,ht);if(5!==vt.length&&1!==vt.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===vt.length&&null==yt)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,sr.H)(Tt,yt,vt,ht)}function ku(Tt,yt,ht){if((0,w.Cq)(Tt),null!=yt&&6!==yt.length)throw new Error("tensor6d() requires shape to have six numbers");const vt=(0,l.C)(Tt,ht);if(6!==vt.length&&1!==vt.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===vt.length&&null==yt)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return(0,sr.H)(Tt,yt=yt||vt,vt,ht)}var Gn=h(1876);const Vi=(0,M.op)({tensorScatterUpdate_:function bl(Tt,yt,ht){const vt=(0,l._1)(Tt,"tensor","tensorScatterupdate"),ut=(0,l._1)(yt,"indices","tensorScatterupdate","int32"),Mt=(0,l._1)(ht,"updates","tensorScatterupdate");if(Gn.validateInput(Mt,ut,vt.shape),vt.dtype!==Mt.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${vt.dtype} and ${Mt.dtype}.`);return N.BV.runKernel(W.SIB,{tensor:vt,indices:ut,updates:Mt},{})}});var xl=h(4927);const bu=(0,M.op)({truncatedNormal_:function Kl(Tt,yt=0,ht=1,vt,ut){if((0,w.Mu)(Tt),null!=vt&&"bool"===vt)throw new Error("Unsupported data type $ { dtype }");const Mt=new Fa(yt,ht,vt,!0,ut),Vt=(0,Qt.f)(Tt,vt);for(let un=0;un<Vt.values.length;un++)Vt.values[un]=Mt.nextValue();return Vt.toTensor()}});var _c=h(8130),Ou=h(7715),xd=h(2219);function yc(Tt,yt){return al(Tt,yt,"right")}function Lc(Tt,yt=!0,ht,vt){return N.BV.makeVariable(Tt,yt,ht,vt)}var Ws,Ru=h(2190),Sa=h(7349);const Mo=function Wr(Tt){return(Ws=Ws||(0,oo.Z)(function*(yt){const ht=(0,l._1)(yt,"condition","whereAsync","bool"),vt=yield ht.data(),ut=(0,Sa.Z)(ht.shape,vt);return yt!==ht&&ht.dispose(),ut})).apply(this,arguments)};var ln,Eo=h(6467),Ol=h(3143);const ua=function ei(Tt,yt,ht){return(ln=ln||(0,oo.Z)(function*(vt,ut,Mt){const Vt=(0,l._1)(vt,"tensor","boolMask"),un=(0,l._1)(ut,"mask","boolMask","bool"),Rn=Mt??0,Mn=un.rank,as=Vt.shape;w.hu(Mn>0,()=>"mask cannot be scalar"),w.k5(as.slice(Rn,Rn+Mn),un.shape,"mask's shape must match the first K dimensions of tensor's shape,");let is=1;for(let Fr=Rn;Fr<Rn+Mn;Fr++)is*=as[Fr];const js=as.slice(0,Rn).concat([is],as.slice(Rn+Mn)),pr=(0,de.X)(Vt,js),Ri=(0,de.X)(un,[-1]),pi=yield Mo(Ri),Xr=(0,$n.L)(pi,[1]),Fn=(0,il.I)(pr,Xr,Rn);return vt!==Vt&&Vt.dispose(),ut!==un&&un.dispose(),Xr.dispose(),pr.dispose(),Ri.dispose(),pi.dispose(),Fn})).apply(this,arguments)};var Nc=h(9194),Mc=h(3717),Ur=h(7664);const wd=(0,M.op)({movingAverage_:function wl(Tt,yt,ht,vt,ut=!0){const Mt=(0,l._1)(Tt,"v","movingAverage"),Vt=(0,l._1)(yt,"x","movingAverage"),un=(0,l._1)(ht,"decay","movingAverage");(0,Ur.assertTypesMatch)(Mt,Vt),w.hu(w.cO(Mt.shape,Vt.shape),()=>"Shape mismatch in v and x");const Rn=(0,ci.i)(1),Mn=(0,qr.l)(Rn,un);let as=(0,v.d)((0,qr.l)(Vt,Mt),Mn);if(ut){w.hu(null!=vt,()=>"When using zeroDebias: true, step is required.");const is=(0,l._1)(vt,"step","movingAverage");as=(0,Li.h)(as,(0,qr.l)(Rn,(0,qn.s)(un,is)))}return(0,I.I)(Mt,as)}}),ks=(0,M.op)({scatterND_:function Do(Tt,yt,ht){(0,w.Mu)(ht);const vt=(0,l._1)(Tt,"indices","scatterND","int32"),ut=(0,l._1)(yt,"updates","scatterND");return Gn.validateInput(ut,vt,ht),N.BV.runKernel(W.xQA,{indices:vt,updates:ut},{shape:ht})}}),ge=(0,M.op)({sparseToDense_:function Me(Tt,yt,ht,vt=0){(0,w.Mu)(ht);const ut=(0,l._1)(Tt,"sparseIndices","sparseToDense","int32"),Mt=(0,l._1)(yt,"sparseValues","sparseToDense","string_or_numeric"),Vt=(0,l._1)(vt,"defaultValue","sparseToDense",Mt.dtype);return function Zo(Tt,yt,ht,vt){if("int32"!==Tt.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${Tt.dtype}.`);if(Tt.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${Tt.shape}.`);const ut=Tt.rank>0?Tt.shape[0]:1,Mt=Tt.rank>1?Tt.shape[1]:1;if(ht.length!==Mt)throw new Error(`outputShape has incorrect number of elements:, ${ht.length}, should be: ${Mt}.`);if(0!==yt.rank&&(1!==yt.rank||yt.size!==ut))throw new Error(`sparseValues has incorrect shape ${yt.shape}, should be [] or [${ut}]`);if(yt.dtype!==vt.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(ut,Mt,ht,Vt),N.BV.runKernel(W.D2d,{sparseIndices:ut,sparseValues:Mt,defaultValue:Vt},{outputShape:ht})}}),Ke=(0,M.op)({gatherND_:function ke(Tt,yt){const ht=(0,l._1)(yt,"indices","gatherND","int32"),ut={params:(0,l._1)(Tt,"x","gatherND","string_or_numeric"),indices:ht};return N.BV.runKernel(W.q1x,ut)}}),dn=(0,M.op)({dropout_:function $t(Tt,yt,ht,vt){const ut=(0,l._1)(Tt,"x","dropout");if(w.hu("float32"===ut.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${ut.dtype} tensor instead.`),w.hu(yt>=0&&yt<1,()=>`rate must be a float in the range [0, 1), but got ${yt}.`),0===yt)return Tt instanceof ml.es?ut.clone():ut;const Mt=function dt(Tt,yt){if(null==yt)return Tt.shape.slice();if(w.cO(Tt.shape,yt))return yt;if(Tt.shape.length===yt.length){const ht=[];for(let vt=0;vt<Tt.shape.length;vt++)ht.push(null==yt[vt]&&null!=Tt.shape[vt]?Tt.shape[vt]:yt[vt]);return ht}return yt}(ut,ht),Vt=1-yt,un=(0,Li.h)((0,Ka.G)((0,I.I)(ot(Mt,0,1,"float32",vt),Vt)),Vt);return(0,v.d)(ut,un)}});function Sn(Tt){return Math.floor(Math.pow(2,Math.ceil(Math.log(Tt)/Math.log(2))))}function en(Tt,yt,ht){const vt=1-Tt%2,ut=new Float32Array(Tt);for(let Mt=0;Mt<Tt;++Mt){const Vt=2*Math.PI*Mt/(Tt+vt-1);ut[Mt]=yt-ht*Math.cos(Vt)}return No(ut,"float32")}var re;const ee=function xe(Tt,yt){return(re=re||(0,oo.Z)(function*(ht,vt,ut=1){const Mt=(0,l._1)(ht,"predictions","inTopK"),Vt=(0,l._1)(vt,"targets","inTopK");(0,w.hu)(Mt.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${Mt.rank}`),(0,w.hu)(Mt.rank-1===Vt.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${Mt.rank} and targets rank ${Vt.rank}`),(0,w.k5)(Mt.shape.slice(0,Mt.shape.length-1),Vt.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const un=Mt.shape[Mt.shape.length-1];(0,w.hu)(ut>0&&ut<=un,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${un}), but got ${ut}`);const Rn=yield Mt.data(),Mn=yield Vt.data(),[as,is]=[Rn.length/un,un],js=(0,w.WP)("bool",as);for(let pr=0;pr<as;pr++){const Ri=pr*is,pi=Rn.subarray(Ri,Ri+is),Xr=[];for(let Fn=0;Fn<pi.length;Fn++)Xr.push({value:pi[Fn],index:Fn});Xr.sort((Fn,Fr)=>Fr.value-Fn.value),js[pr]=0;for(let Fn=0;Fn<ut;Fn++)if(Xr[Fn].index===Mn[pr]){js[pr]=1;break}}return ht!==Mt&&Mt.dispose(),vt!==Vt&&Vt.dispose(),(0,zr.X)(js,Vt.shape,"bool")})).apply(this,arguments)};var me=h(3537),Fe=h(3239),gt=h(443),At=h(5743),zt=h(6254);const On=(0,M.op)({fusedConv2d_:function Pn({x:Tt,filter:yt,strides:ht,pad:vt,dataFormat:ut="NHWC",dilations:Mt=[1,1],dimRoundingMode:Vt,bias:un,activation:Rn="linear",preluActivationWeights:Mn,leakyreluAlpha:as}){if(!1===(0,zt.uy)(N.BV.state.gradientDepth,Rn=Rn||"linear")){w.hu("NHWC"===ut,()=>`Error in fused conv2d: got dataFormat of ${ut} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Ni=(0,lo.T)(Tt,yt,ht,vt,ut,Mt,Vt);return null!=un&&(Ni=(0,I.I)(Ni,un)),(0,zt.QH)(Ni,Rn,Mn,as)}const is=(0,l._1)(Tt,"x","conv2d","float32"),js=(0,l._1)(yt,"filter","conv2d","float32");let pr=is,Ri=!1;3===is.rank&&(Ri=!0,pr=(0,de.X)(is,[1,is.shape[0],is.shape[1],is.shape[2]])),w.hu(4===pr.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${pr.rank}.`),w.hu(4===js.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${js.rank}.`),te.m("fused conv2d",vt,Vt);const pi="NHWC"===ut?pr.shape[3]:pr.shape[1];w.hu(js.shape[2]===pi,()=>`Error in conv2d: depth of input (${pi}) must match input depth for filter ${js.shape[2]}.`),w.hu(te.jT(ht,Mt),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${ht} and dilations '${Mt}'`);const Xr=te.Ix(pr.shape,js.shape,ht,Mt,vt,Vt);let Fn,Fr;if(null!=un&&(Fn=(0,l._1)(un,"bias","fused conv2d"),[Fn]=(0,Ur.makeTypesMatch)(Fn,is),"NHWC"===ut?Fe.assertAndGetBroadcastShape(Xr.outShape,Fn.shape):(w.hu(Fn.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${Fn.shape.length}.`),w.hu(0===Fn.shape.length||Fn.shape[0]===Xr.outChannels||1===Fn.shape[0],()=>`Error in fused conv2d: bias shape (${Fn.shape}) is not compatible with the number of output channels (${Xr.outChannels})`))),null!=Mn){const Ni=Mn.shape;if(w.hu(Ni.length<=1||3===Ni.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Ni.length}.`),1===Ni.length)w.hu(1===Ni[0]||Ni[0]===Xr.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Ni}) is not compatible with the number of output channels (${Xr.outChannels}).`);else if(3===Ni.length)try{Fe.assertAndGetBroadcastShape(Ni,Xr.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Ni}) is not compatible with the output shape of the conv2d (${Xr.outShape}).`)}Fr=(0,l._1)(Mn,"prelu weights","fused conv2d")}const hr=(Ni,ta)=>{w.hu("NHWC"===ut,()=>`Error in gradient of fused conv2D: got dataFormat of ${ut} but only NHWC is currently supported.`);const[Io,da,zo,Za]=ta,fu=(0,zt.Fr)(Ni,zo,Rn);w.hu(te.I0(Mt),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${Mt}'`);const El=[(0,At._)(da.shape,fu,Io,ht,vt),(0,gt.p)(da,fu,Io.shape,ht,vt)];if(null!=Za){const Sd=(0,zt.pf)(Za,fu);El.push(Sd)}return El},gs={x:pr,filter:js,bias:Fn,preluActivationWeights:Fr},Ui={strides:ht,pad:vt,dataFormat:ut,dilations:Mt,dimRoundingMode:Vt,activation:Rn,leakyreluAlpha:as};return null==un?(0,me.cb)((ta,Io,da)=>{let zo=N.BV.runKernel(W._V0,gs,Ui);return da([Io,ta,zo]),Ri&&(zo=(0,de.X)(zo,[zo.shape[1],zo.shape[2],zo.shape[3]])),{value:zo,gradFunc:hr}})(pr,js):(0,me.cb)((ta,Io,da,zo)=>{let Za=N.BV.runKernel(W._V0,gs,Ui);return zo([Io,ta,Za,da]),Ri&&(Za=(0,de.X)(Za,[Za.shape[1],Za.shape[2],Za.shape[3]])),{value:Za,gradFunc:hr}})(pr,js,Fn)}});var Kn=h(366),Ln=h(519);const vs=(0,M.op)({fusedDepthwiseConv2d_:function An({x:Tt,filter:yt,strides:ht,pad:vt,dataFormat:ut="NHWC",dilations:Mt=[1,1],dimRoundingMode:Vt,bias:un,activation:Rn="linear",preluActivationWeights:Mn,leakyreluAlpha:as}){if(!1===(0,zt.uy)(N.BV.state.gradientDepth,Rn)){let Ui=(0,co.B)(Tt,yt,ht,vt,ut,Mt,Vt);return null!=un&&(Ui=(0,I.I)(Ui,un)),(0,zt.QH)(Ui,Rn,Mn,as)}const is=(0,l._1)(Tt,"x","depthwiseConv2d","float32"),js=(0,l._1)(yt,"filter","depthwiseConv2d","float32");let pr=is,Ri=!1;3===is.rank&&(Ri=!0,pr=(0,de.X)(is,[1,is.shape[0],is.shape[1],is.shape[2]])),w.hu(4===pr.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${pr.rank}.`),w.hu(4===js.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${js.rank}.`),w.hu(pr.shape[3]===js.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${pr.shape[3]}) must match the inChannels dimension in filter ${js.shape[2]}.`),null==Mt&&(Mt=[1,1]),w.hu(te.jT(ht,Mt),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${ht} and dilations '${Mt}'`),te.m("fused depthwiseConv2d",vt,Vt);const pi=te.Ix(pr.shape,js.shape,ht,Mt,vt,Vt,!0);let Xr,Fn;null!=un&&(Xr=(0,l._1)(un,"bias","fused conv2d"),[Xr]=(0,Ur.makeTypesMatch)(Xr,is),Fe.assertAndGetBroadcastShape(pi.outShape,Xr.shape)),null!=Mn&&(Fn=(0,l._1)(Mn,"prelu weights","fused depthwiseConv2d"));const Fr=(Ui,Ni)=>{w.hu(te.I0(Mt),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${Mt}'`);const[ta,Io,da,zo]=Ni,Za=(0,zt.Fr)(Ui,da,Rn),fu=(0,Ln.v)(Io.shape,Za,ta,ht,vt,Mt,Vt),Cl=(0,Kn.z)(Io,Za,ta.shape,ht,vt,Mt,Vt);return null!=zo?[fu,Cl,(0,zt.pf)(Xr,Za)]:[fu,Cl]},hr={x:pr,filter:js,bias:Xr,preluActivationWeights:Fn},gs={strides:ht,pad:vt,dataFormat:ut,dilations:Mt,dimRoundingMode:Vt,activation:Rn,leakyreluAlpha:as};return null==un?(0,me.cb)((Ni,ta,Io)=>{let da=N.BV.runKernel(W.luS,hr,gs);return Io([ta,Ni,da]),Ri&&(da=(0,de.X)(da,[da.shape[1],da.shape[2],da.shape[3]])),{value:da,gradFunc:Fr}})(pr,js):(0,me.cb)((Ni,ta,Io,da)=>{let zo=N.BV.runKernel(W.luS,hr,gs);return da([ta,Ni,zo,Io]),Ri&&(zo=(0,de.X)(zo,[zo.shape[1],zo.shape[2],zo.shape[3]])),{value:zo,gradFunc:Fr}})(pr,js,Xr)}}),Er=(0,M.op)({fusedMatMul_:function ir({a:Tt,b:yt,transposeA:ht=!1,transposeB:vt=!1,bias:ut,activation:Mt="linear",preluActivationWeights:Vt,leakyreluAlpha:un=.2}){if(!1===(0,zt.uy)(N.BV.state.gradientDepth,Mt)){let Za=(0,Te.O)(Tt,yt,ht,vt);return null!=ut&&(Za=(0,I.I)(Za,ut)),(0,zt.QH)(Za,Mt,Vt,un)}let Rn=(0,l._1)(Tt,"a","fused matMul"),Mn=(0,l._1)(yt,"b","fused matMul");[Rn,Mn]=(0,Ur.makeTypesMatch)(Rn,Mn);const as=ht?Rn.shape[Rn.rank-2]:Rn.shape[Rn.rank-1],is=vt?Mn.shape[Mn.rank-1]:Mn.shape[Mn.rank-2],js=ht?Rn.shape[Rn.rank-1]:Rn.shape[Rn.rank-2],pr=vt?Mn.shape[Mn.rank-2]:Mn.shape[Mn.rank-1],Ri=Rn.shape.slice(0,-2),pi=Mn.shape.slice(0,-2),Xr=w.NA(Ri),Fn=w.NA(pi);w.hu(as===is,()=>`Error in fused matMul: inner shapes (${as}) and (${is}) of Tensors with shapes ${Rn.shape} and ${Mn.shape} and transposeA=${ht} and transposeB=${vt} must match.`);const hr=Fe.assertAndGetBroadcastShape(Rn.shape.slice(0,-2),Mn.shape.slice(0,-2)).concat([js,pr]),gs=(0,de.X)(Rn,ht?[Xr,as,js]:[Xr,js,as]),Ui=(0,de.X)(Mn,vt?[Fn,pr,is]:[Fn,is,pr]);let Ni,ta;null!=ut&&(Ni=(0,l._1)(ut,"bias","fused matMul"),[Ni]=(0,Ur.makeTypesMatch)(Ni,Rn),Fe.assertAndGetBroadcastShape(hr,Ni.shape)),null!=Vt&&(ta=(0,l._1)(Vt,"prelu weights","fused matMul"));const Io=(Za,fu)=>{const[Cl,Jo,El,Sd]=fu,Yl=(0,zt.Fr)((0,de.X)(Za,El.shape),El,Mt);let zc,Gd;return ht||vt?!ht&&vt?(zc=(0,Te.O)(Yl,Jo,!1,!1),Gd=(0,Te.O)(Yl,Cl,!0,!1)):ht&&!vt?(zc=(0,Te.O)(Jo,Yl,!1,!0),Gd=(0,Te.O)(Cl,Yl,!1,!1)):(zc=(0,Te.O)(Jo,Yl,!0,!0),Gd=(0,Te.O)(Yl,Cl,!0,!0)):(zc=(0,Te.O)(Yl,Jo,!1,!0),Gd=(0,Te.O)(Cl,Yl,!0,!1)),null!=ut?[zc,Gd,(0,zt.pf)(Sd,Yl)]:[zc,Gd]},da={a:gs,b:Ui,bias:Ni,preluActivationWeights:ta},zo={transposeA:ht,transposeB:vt,activation:Mt,leakyreluAlpha:un};return null==ut?(0,me.cb)((fu,Cl,Jo)=>{const El=N.BV.runKernel(W.usg,da,zo);return Jo([fu,Cl,El]),{value:(0,de.X)(El,hr),gradFunc:Io}})(gs,Ui):(0,me.cb)((fu,Cl,Jo,El)=>{const Sd=N.BV.runKernel(W.usg,da,zo);return El([fu,Cl,Sd,Jo]),{value:(0,de.X)(Sd,hr),gradFunc:Io}})(gs,Ui,Ni)}}),So=(0,M.op)({hammingWindow_:function gi(Tt){return en(Tt,.54,.46)}}),Nr=(0,M.op)({hannWindow_:function vc(Tt){return en(Tt,.5,.5)}}),Ci=(0,M.op)({frame_:function Qo(Tt,yt,ht,vt=!1,ut=0){let Mt=0;const Vt=[];for(;Mt+yt<=Tt.size;)Vt.push((0,Xe.t)(Tt,Mt,yt)),Mt+=ht;if(vt)for(;Mt<Tt.size;){const un=Mt+yt-Tt.size,Rn=(0,ye.z)([(0,Xe.t)(Tt,Mt,yt-un),(0,no.h)([un],ut)]);Vt.push(Rn),Mt+=ht}return 0===Vt.length?ho([],[0,yt]):(0,de.X)((0,ye.z)(Vt),[Vt.length,yt])}}),cl=(0,M.op)({stft_:function Rl(Tt,yt,ht,vt,ut=Nr){null==vt&&(vt=Sn(yt));const Mt=Ci(Tt,yt,ht),Vt=(0,v.d)(Mt,ut(yt));return(0,mt.Q)(Vt,vt)}}),Dc=(0,M.op)({cropAndResize_:function id(Tt,yt,ht,vt,ut="bilinear",Mt=0){const Vt=(0,l._1)(Tt,"image","cropAndResize"),un=(0,l._1)(yt,"boxes","cropAndResize","float32"),Rn=(0,l._1)(ht,"boxInd","cropAndResize","int32"),Mn=un.shape[0];return w.hu(4===Vt.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${Vt.rank}.`),w.hu(2===un.rank&&4===un.shape[1],()=>`Error in cropAndResize: boxes must be have size [${Mn},4] but had shape ${un.shape}.`),w.hu(1===Rn.rank&&Rn.shape[0]===Mn,()=>`Error in cropAndResize: boxInd must be have size [${Mn}] but had shape ${un.shape}.`),w.hu(2===vt.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${vt.length}.`),w.hu(vt[0]>=1&&vt[1]>=1,()=>`cropSize must be atleast [1,1], but was ${vt}`),w.hu("bilinear"===ut||"nearest"===ut,()=>`method must be bilinear or nearest, but was ${ut}`),N.BV.runKernel(W.VcC,{image:Vt,boxes:un,boxInd:Rn},{method:ut,extrapolationValue:Mt,cropSize:vt})}}),$c=(0,M.op)({flipLeftRight_:function Ud(Tt){const yt=(0,l._1)(Tt,"image","flipLeftRight","float32");return w.hu(4===yt.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${yt.rank}.`),N.BV.runKernel(W.Uyb,{image:yt},{})}}),Vf=(0,M.op)({grayscaleToRGB_:function Mh(Tt){const yt=(0,l._1)(Tt,"image","grayscaleToRGB"),ht=yt.rank-1,vt=yt.shape[ht];w.hu(yt.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${yt.rank}.`),w.hu(1===vt,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${vt}.`);const ut=new Array(yt.rank);return ut.fill(1,0,ht),ut[ht]=3,(0,pl.G)(yt,ut)}}),Km=(0,M.op)({rgbToGrayscale_:function Uf(Tt){const yt=(0,l._1)(Tt,"image","RGBToGrayscale"),vt=yt.shape[yt.rank-1];w.hu(yt.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${yt.rank}.`),w.hu(3===vt,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${vt}.`);const ut=yt.dtype,Mt=(0,De.p)(yt,"float32"),Vt=No([.2989,.587,.114]);let un;switch(yt.rank){case 2:un=$i("ij,j->i",Mt,Vt);break;case 3:un=$i("ijk,k->ij",Mt,Vt);break;case 4:un=$i("ijkl,l->ijk",Mt,Vt);break;case 5:un=$i("ijklm,m->ijkl",Mt,Vt);break;case 6:un=$i("ijklmn,n->ijklm",Mt,Vt);break;default:throw new Error("Not a valid tensor rank.")}return un=(0,Ko.d)(un,-1),(0,De.p)(un,ut)}}),Zp=(0,M.op)({rotateWithOffset_:function Ph(Tt,yt,ht=0,vt=.5){const ut=(0,l._1)(Tt,"image","rotateWithOffset","float32");return w.hu(4===ut.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${ut.rank}.`),N.BV.runKernel(W.b9H,{image:ut},{radians:yt,fillValue:ht,center:vt})}});function Sc(Tt,yt,ht,vt,ut,Mt){null==vt&&(vt=.5),null==ut&&(ut=Number.NEGATIVE_INFINITY),null==Mt&&(Mt=0);const Vt=Tt.shape[0];return ht=Math.min(ht,Vt),w.hu(0<=vt&&vt<=1,()=>`iouThreshold must be in [0, 1], but was '${vt}'`),w.hu(2===Tt.rank,()=>`boxes must be a 2D tensor, but was of rank '${Tt.rank}'`),w.hu(4===Tt.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${Tt.shape[1]}`),w.hu(1===yt.rank,()=>"scores must be a 1D tensor"),w.hu(yt.shape[0]===Vt,()=>`scores has incompatible shape with boxes. Expected ${Vt}, but was ${yt.shape[0]}`),w.hu(0<=Mt&&Mt<=1,()=>`softNmsSigma must be in [0, 1], but was '${Mt}'`),{maxOutputSize:ht,iouThreshold:vt,scoreThreshold:ut,softNmsSigma:Mt}}const Nu=(0,M.op)({nonMaxSuppression_:function dh(Tt,yt,ht,vt=.5,ut=Number.NEGATIVE_INFINITY){const Mt=(0,l._1)(Tt,"boxes","nonMaxSuppression","float32"),Vt=(0,l._1)(yt,"scores","nonMaxSuppression","float32"),un=Sc(Mt,Vt,ht,vt,ut);return N.BV.runKernel(W.uv1,{boxes:Mt,scores:Vt},{maxOutputSize:ht=un.maxOutputSize,iouThreshold:vt=un.iouThreshold,scoreThreshold:ut=un.scoreThreshold})}});var Hu,Qp=h(5672);const Ya=(0,M.op)({nonMaxSuppressionWithScore_:function Jc(Tt,yt,ht,vt=.5,ut=Number.NEGATIVE_INFINITY,Mt=0){const Vt=(0,l._1)(Tt,"boxes","nonMaxSuppression"),un=(0,l._1)(yt,"scores","nonMaxSuppression"),Rn=Sc(Vt,un,ht,vt,ut,Mt),is=N.BV.runKernel(W.W0H,{boxes:Vt,scores:un},{maxOutputSize:ht=Rn.maxOutputSize,iouThreshold:vt=Rn.iouThreshold,scoreThreshold:ut=Rn.scoreThreshold,softNmsSigma:Mt=Rn.softNmsSigma});return{selectedIndices:is[0],selectedScores:is[1]}}});var Ba;const zf=(0,M.op)({nonMaxSuppressionPadded_:function hh(Tt,yt,ht,vt=.5,ut=Number.NEGATIVE_INFINITY,Mt=!1){const Vt=(0,l._1)(Tt,"boxes","nonMaxSuppression"),un=(0,l._1)(yt,"scores","nonMaxSuppression"),Rn=Sc(Vt,un,ht,vt,ut,null),Ri=N.BV.runKernel(W.cye,{boxes:Vt,scores:un},{maxOutputSize:Rn.maxOutputSize,iouThreshold:Rn.iouThreshold,scoreThreshold:Rn.scoreThreshold,padToMaxOutputSize:Mt});return{selectedIndices:Ri[0],validOutputs:Ri[1]}}});var zd;var qc=h(1353),od=h(7373);const Wd=(0,M.op)({threshold_:function qp(Tt,yt="binary",ht=!1,vt=.5){const ut=(0,l._1)(Tt,"image","threshold"),Rn=ut.shape[0]*ut.shape[1];let as,is,js,pr,Mn=(0,v.d)(No([vt]),255);if(w.hu(3===ut.rank,()=>`Error in threshold: image must be rank 3,but got rank ${ut.rank}.`),w.hu(3===ut.shape[2]||1===ut.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${ut.shape[2]}.`),w.hu("int32"===ut.dtype||"float32"===ut.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${ut.dtype}.`),w.hu("otsu"===yt||"binary"===yt,()=>`Method must be binary or otsu, but was ${yt}`),3===ut.shape[2]){[as,is,js]=(0,Wt.V)(ut,[1,1,1],-1);const Xr=(0,v.d)(as,.2989),Fn=(0,v.d)(is,.587),Fr=(0,v.d)(js,.114);pr=(0,I.I)((0,I.I)(Xr,Fn),Fr)}else pr=Tt;"otsu"===yt&&(Mn=function Lh(Tt,yt){let Mt,Vt,un,Rn,Mn,as,ht=No([-1]),vt=No([0]),ut=No([0]);for(let is=0;is<Tt.size-1;is++){Mt=(0,Xe.t)(Tt,0,is+1),Vt=(0,Xe.t)(Tt,is+1),Mn=(0,Li.h)((0,Rs.S)(Mt),yt),as=(0,Li.h)((0,Rs.S)(Vt),yt);const js=(0,Rs.S)((0,v.d)(Mt,jt(0,Mt.size)));un=(0,Li.h)(js,(0,Rs.S)(Mt));const pr=(0,no.h)(Vt.shape,Mt.size),Ri=(0,I.I)(jt(0,Vt.size),pr),pi=(0,v.d)(Vt,Ri);Rn=(0,Li.h)((0,Rs.S)(pi),(0,Rs.S)(Vt));const Xr=(0,qr.l)(un,Rn),Fn=(0,qr.l)(un,Rn),Fr=(0,v.d)(Mn,as);ut=(0,v.d)((0,v.d)(Fr,Xr),Fn);const hr=(0,Yi.p)(ut,vt);vt=(0,Ru.a)(hr,ut,vt),ht=(0,Ru.a)(hr,No([is]),ht)}return ht}(Ts((0,De.p)((0,La.N)(pr),"int32"),(0,zr.X)([]),256),Rn));const Ri=ht?(0,Pr.z)(pr,Mn):(0,Yi.p)(pr,Mn);return(0,De.p)((0,v.d)(Ri,255),"int32")}}),xu=(0,M.op)({transform_:function Nl(Tt,yt,ht="nearest",vt="constant",ut=0,Mt){const Vt=(0,l._1)(Tt,"image","transform","float32"),un=(0,l._1)(yt,"transforms","transform","float32");return w.hu(4===Vt.rank,()=>`Error in transform: image must be rank 4,but got rank ${Vt.rank}.`),w.hu(2===un.rank&&(un.shape[0]===Vt.shape[0]||1===un.shape[0])&&8===un.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),w.hu(null==Mt||2===Mt.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${Mt}.`),N.BV.runKernel(W.wx7,{image:Vt,transforms:un},{interpolation:ht,fillMode:vt,fillValue:ut,outputShape:Mt})}}),$h=(0,M.op)({bandPart_:function ju(Tt,yt,ht){const vt=(0,l._1)(Tt,"a","bandPart");(0,w.hu)(vt.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${vt.rank}.`);const ut=vt.shape,[Mt,Vt]=vt.shape.slice(-2);let un,Rn;"number"==typeof yt?((0,w.hu)(yt%1==0,()=>`bandPart(): numLower must be an integer, got ${yt}.`),(0,w.hu)(yt<=Mt,()=>`bandPart(): numLower (${yt}) must not be greater than the number of rows (${Mt}).`),un=(0,l._1)(yt<0?Mt:yt,"numLower","bandPart")):((0,w.hu)("int32"===yt.dtype,()=>"bandPart(): numLower's dtype must be an int32."),un=(0,Ru.a)((0,$o.d)(yt,0),Mt,(0,ki.L)(yt,Mt))),"number"==typeof ht?((0,w.hu)(ht%1==0,()=>`bandPart(): numUpper must be an integer, got ${ht}.`),(0,w.hu)(ht<=Vt,()=>`bandPart(): numUpper (${ht}) must not be greater than the number of columns (${Vt}).`),Rn=(0,l._1)(ht<0?Vt:ht,"numUpper","bandPart")):((0,w.hu)("int32"===ht.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),Rn=(0,Ru.a)((0,$o.d)(ht,0),Vt,(0,ki.L)(ht,Vt)));const Mn=(0,de.X)(jt(0,Mt,1,"int32"),[-1,1]),as=jt(0,Vt,1,"int32"),is=(0,qr.l)(Mn,as),js=(0,ji.H)((0,Pr.z)(is,un),(0,fc.b)(is,(0,Ca.W)(Rn))),pr=(0,Eo.l)([Mt,Vt],vt.dtype);return(0,de.X)((0,zn.k)((0,xd.H)((0,de.X)(vt,[-1,Mt,Vt])).map(Ri=>(0,Ru.a)(js,Ri,pr))),ut)}}),ph=(0,M.op)({gramSchmidt_:function Hf(Tt){let yt;if(Array.isArray(Tt)){yt=!1,(0,w.hu)(null!=Tt&&Tt.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const ut=Tt[0].shape[0];for(let Mt=1;Mt<Tt.length;++Mt)(0,w.hu)(Tt[Mt].shape[0]===ut,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${Tt[Mt].shape[0]} vs. ${ut})`)}else yt=!0,Tt=(0,Wt.V)(Tt,Tt.shape[0],0).map(ut=>(0,$n.L)(ut,[0]));(0,w.hu)(Tt.length<=Tt[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${Tt.length}) exceeds number of dimensions (${Tt[0].shape[0]}).`);const ht=[],vt=Tt;for(let ut=0;ut<Tt.length;++ut)ht.push(N.BV.tidy(()=>{let Mt=vt[ut];if(ut>0)for(let Vt=0;Vt<ut;++Vt){const un=(0,v.d)((0,Rs.S)((0,v.d)(ht[Vt],Mt)),ht[Vt]);Mt=(0,qr.l)(Mt,un)}return(0,Li.h)(Mt,(0,Mc.K)(Mt,"euclidean"))}));return yt?(0,zn.k)(ht,0):ht}});var Hd=h(2773);function _p(Tt,yt=!1){return N.BV.tidy(()=>{(0,w.hu)(2===Tt.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${Tt.shape.length}D Tensor.`);const ht=Tt.shape[0],vt=Tt.shape[1];let ut=fl(ht),Mt=(0,zs.d)(Tt);const Vt=ho([[1]],[1,1]);let un=(0,zs.d)(Vt);const Rn=ht>=vt?vt:ht;for(let Mn=0;Mn<Rn;++Mn){const as=Mt,is=un,js=ut;[un,Mt,ut]=N.BV.tidy(()=>{const pr=(0,Xe.t)(Mt,[Mn,Mn],[ht-Mn,1]),Ri=(0,Mc.K)(pr),pi=(0,Xe.t)(Mt,[Mn,Mn],[1,1]),Xr=(0,Ru.a)((0,Yi.p)(pi,0),ho([[-1]]),ho([[1]])),Fn=(0,qr.l)(pi,(0,v.d)(Xr,Ri)),Fr=(0,Li.h)(pr,Fn);un=1===Fr.shape[0]?(0,zs.d)(Vt):(0,ye.z)([Vt,(0,Xe.t)(Fr,[1,0],[Fr.shape[0]-1,Fr.shape[1]])],0);const hr=(0,Ca.W)((0,Li.h)((0,Te.O)(Xr,Fn),Ri)),gs=(0,Xe.t)(Mt,[Mn,0],[ht-Mn,vt]),Ui=(0,v.d)(hr,un),Ni=(0,Nc.p)(un);if(0===Mn)Mt=(0,qr.l)(gs,(0,Te.O)(Ui,(0,Te.O)(Ni,gs)));else{const da=(0,qr.l)(gs,(0,Te.O)(Ui,(0,Te.O)(Ni,gs)));Mt=(0,ye.z)([(0,Xe.t)(Mt,[0,0],[Mn,vt]),da],0)}const ta=(0,Nc.p)(Ui),Io=(0,Xe.t)(ut,[0,Mn],[ht,ut.shape[1]-Mn]);if(0===Mn)ut=(0,qr.l)(Io,(0,Te.O)((0,Te.O)(Io,un),ta));else{const da=(0,qr.l)(Io,(0,Te.O)((0,Te.O)(Io,un),ta));ut=(0,ye.z)([(0,Xe.t)(ut,[0,0],[ht,Mn]),da],1)}return[un,Mt,ut]}),(0,Hd.B9)([as,is,js])}return!yt&&ht>vt&&(ut=(0,Xe.t)(ut,[0,0],[ht,vt]),Mt=(0,Xe.t)(Mt,[0,0],[vt,vt])),[ut,Mt]})}const b_=(0,M.op)({qr_:function bc(Tt,yt=!1){if((0,w.hu)(Tt.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${Tt.rank}`),2===Tt.rank)return _p(Tt,yt);{const ht=Tt.shape.slice(0,Tt.shape.length-2).reduce((Rn,Mn)=>Rn*Mn),vt=(0,xd.H)((0,de.X)(Tt,[ht,Tt.shape[Tt.shape.length-2],Tt.shape[Tt.shape.length-1]]),0),ut=[],Mt=[];return vt.forEach(Rn=>{const[Mn,as]=_p(Rn,yt);ut.push(Mn),Mt.push(as)}),[(0,de.X)((0,zn.k)(ut,0),Tt.shape),(0,de.X)((0,zn.k)(Mt,0),Tt.shape)]}}});var Pc=h(4839);const ad=(0,M.op)({computeWeightedLoss_:function Ed(Tt,yt,ht=Pc.I.SUM_BY_NONZERO_WEIGHTS){const vt=(0,l._1)(Tt,"losses","computeWeightedLoss");let ut=null;null!=yt&&(ut=(0,l._1)(yt,"weights","computeWeightedLoss"));const Mt=null==ut?vt:(0,v.d)(vt,ut);if(ht===Pc.I.NONE)return Mt;if(ht===Pc.I.SUM)return(0,Rs.S)(Mt);if(ht===Pc.I.MEAN){if(null==ut)return(0,Xo.J)(Mt);{const Vt=vt.size/ut.size,un=(0,Li.h)((0,Rs.S)(Mt),(0,Rs.S)(ut));return Vt>1?(0,Li.h)(un,(0,ci.i)(Vt)):un}}if(ht===Pc.I.SUM_BY_NONZERO_WEIGHTS){if(null==ut)return(0,Li.h)((0,Rs.S)(Mt),(0,ci.i)(vt.size));{const Vt=(0,v.d)(ut,(0,go.i)(vt.shape)),un=(0,De.p)((0,Rs.S)((0,Pa.Q)(Vt,(0,ci.i)(0))),"float32");return(0,Li.h)((0,Rs.S)(Mt),un)}}throw Error(`Unknown reduction: ${ht}`)}}),Mu=(0,M.op)({absoluteDifference_:function fh(Tt,yt,ht,vt=Pc.I.SUM_BY_NONZERO_WEIGHTS){const ut=(0,l._1)(Tt,"labels","absoluteDifference"),Mt=(0,l._1)(yt,"predictions","absoluteDifference");let Vt=null;null!=ht&&(Vt=(0,l._1)(ht,"weights","absoluteDifference")),(0,w.k5)(ut.shape,Mt.shape,"Error in absoluteDifference: ");const un=(0,Z.W)((0,qr.l)(ut,Mt));return ad(un,Vt,vt)}}),jf=(0,M.op)({cosineDistance_:function ef(Tt,yt,ht,vt,ut=Pc.I.SUM_BY_NONZERO_WEIGHTS){const Mt=(0,l._1)(Tt,"labels","cosineDistance"),Vt=(0,l._1)(yt,"predictions","cosineDistance");let un=null;null!=vt&&(un=(0,l._1)(vt,"weights","cosineDistance")),(0,w.k5)(Mt.shape,Vt.shape,"Error in cosineDistance: ");const Rn=(0,ci.i)(1),Mn=(0,qr.l)(Rn,(0,Rs.S)((0,v.d)(Mt,Vt),ht,!0));return ad(Mn,un,ut)}}),tf=(0,M.op)({hingeLoss_:function yp(Tt,yt,ht,vt=Pc.I.SUM_BY_NONZERO_WEIGHTS){let ut=(0,l._1)(Tt,"labels","hingeLoss");const Mt=(0,l._1)(yt,"predictions","hingeLoss");let Vt=null;null!=ht&&(Vt=(0,l._1)(ht,"weights","hingeLoss")),(0,w.k5)(ut.shape,Mt.shape,"Error in hingeLoss: ");const un=(0,ci.i)(1);ut=(0,qr.l)((0,v.d)((0,ci.i)(2),ut),un);const Rn=(0,ss.U)((0,qr.l)(un,(0,v.d)(ut,Mt)));return ad(Rn,Vt,vt)}}),Gf=(0,M.op)({huberLoss_:function jd(Tt,yt,ht,vt=1,ut=Pc.I.SUM_BY_NONZERO_WEIGHTS){const Mt=(0,l._1)(Tt,"labels","huberLoss"),Vt=(0,l._1)(yt,"predictions","huberLoss");let un=null;null!=ht&&(un=(0,l._1)(ht,"weights","huberLoss")),(0,w.k5)(Mt.shape,Vt.shape,"Error in huberLoss: ");const Rn=(0,ci.i)(vt),Mn=(0,Z.W)((0,qr.l)(Vt,Mt)),as=(0,ki.L)(Mn,Rn),is=(0,qr.l)(Mn,as),js=(0,I.I)((0,v.d)((0,ci.i)(.5),(0,gn.h)(as)),(0,v.d)(Rn,is));return ad(js,un,ut)}}),sf=(0,M.op)({logLoss_:function nf(Tt,yt,ht,vt=1e-7,ut=Pc.I.SUM_BY_NONZERO_WEIGHTS){const Mt=(0,l._1)(Tt,"labels","logLoss"),Vt=(0,l._1)(yt,"predictions","logLoss");let un=null;null!=ht&&(un=(0,l._1)(ht,"weights","logLoss")),(0,w.k5)(Mt.shape,Vt.shape,"Error in logLoss: ");const Rn=(0,ci.i)(1),Mn=(0,ci.i)(vt),as=(0,Ca.W)((0,v.d)(Mt,(0,uo.c)((0,I.I)(Vt,Mn)))),is=(0,v.d)((0,qr.l)(Rn,Mt),(0,uo.c)((0,I.I)((0,qr.l)(Rn,Vt),Mn))),js=(0,qr.l)(as,is);return ad(js,un,ut)}}),rf=(0,M.op)({meanSquaredError_:function Kf(Tt,yt,ht,vt=Pc.I.SUM_BY_NONZERO_WEIGHTS){const ut=(0,l._1)(Tt,"labels","meanSquaredError"),Mt=(0,l._1)(yt,"predictions","meanSquaredError");let Vt=null;null!=ht&&(Vt=(0,l._1)(ht,"weights","meanSquaredError")),(0,w.k5)(ut.shape,Mt.shape,"Error in meanSquaredError: ");const un=(0,rn.$)(ut,Mt);return ad(un,Vt,vt)}}),bp=(0,M.op)({sigmoidCrossEntropy_:function vp(Tt,yt,ht,vt=0,ut=Pc.I.SUM_BY_NONZERO_WEIGHTS){let Mt=(0,l._1)(Tt,"multiClassLabels","sigmoidCrossEntropy");const Vt=(0,l._1)(yt,"logits","sigmoidCrossEntropy");let un=null;if(null!=ht&&(un=(0,l._1)(ht,"weights","sigmoidCrossEntropy")),(0,w.k5)(Mt.shape,Vt.shape,"Error in sigmoidCrossEntropy: "),vt>0){const Mn=(0,ci.i)(vt),as=(0,ci.i)(1),is=(0,ci.i)(.5);Mt=(0,I.I)((0,v.d)(Mt,(0,qr.l)(as,Mn)),(0,v.d)(is,Mn))}const Rn=function Vc(Tt,yt){const ht=(0,l._1)(Tt,"labels","sigmoidCrossEntropyWithLogits"),vt=(0,l._1)(yt,"logits","sigmoidCrossEntropyWithLogits");(0,w.k5)(ht.shape,vt.shape,"Error in sigmoidCrossEntropyWithLogits: ");const ut=(0,ss.U)(vt),Mt=(0,v.d)(vt,ht),Vt=(0,Ra.K)((0,Ga.Q)((0,Ca.W)((0,Z.W)(vt))));return(0,I.I)((0,qr.l)(ut,Mt),Vt)}(Mt,Vt);return ad(Rn,un,ut)}}),Dd=(0,M.op)({softmaxCrossEntropy_:function xp(Tt,yt,ht,vt=0,ut=Pc.I.SUM_BY_NONZERO_WEIGHTS){let Mt=(0,l._1)(Tt,"onehotLabels","softmaxCrossEntropy");const Vt=(0,l._1)(yt,"logits","softmaxCrossEntropy");let un=null;if(null!=ht&&(un=(0,l._1)(ht,"weights","softmaxCrossEntropy")),(0,w.k5)(Mt.shape,Vt.shape,"Error in softmaxCrossEntropy: "),vt>0){const Mn=(0,ci.i)(vt),as=(0,ci.i)(1),is=(0,ci.i)(Mt.shape[1]);Mt=(0,I.I)((0,v.d)(Mt,(0,qr.l)(as,Mn)),(0,Li.h)(Mn,is))}const Rn=function Ia(Tt,yt,ht=-1){if(-1===ht&&(ht=yt.rank-1),ht!==yt.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${yt.rank} and dim was ${ht}`);return(0,me.cb)((ut,Mt,Vt)=>{const Rn=(0,Hi.l)(Mt,[ht],!0),Mn=(0,qr.l)((0,De.p)(Mt,"float32"),Rn);Vt([ut,Mn]);const as=(0,Ca.W)((0,v.d)(Mn,ut));return{value:(0,Rs.S)(as,[ht]),gradFunc:(pr,Ri)=>{const[pi,Xr]=Ri,Fn=(0,Ma.rv)(pr.shape,[ht]);return[(0,v.d)((0,de.X)(pr,Fn),(0,qr.l)((0,De.p)(pi,"float32"),(0,Ga.Q)(Xr))),(0,v.d)((0,de.X)(pr,Fn),(0,qr.l)((0,Ga.Q)(Xr),(0,De.p)(pi,"float32")))]}}})(Tt,yt)}(Mt,Vt);return ad(Rn,un,ut)}}),Tc={fft:Pe.k,ifft:Ve.S,rfft:mt.Q,irfft:et.w},li={hammingWindow:So,hannWindow:Nr,frame:Ci,stft:cl},ao={flipLeftRight:$c,grayscaleToRGB:Vf,resizeNearestNeighbor:od.j,resizeBilinear:qc.I,rgbToGrayscale:Km,rotateWithOffset:Zp,cropAndResize:Dc,nonMaxSuppression:Nu,nonMaxSuppressionAsync:function Cd(Tt,yt,ht){return(Hu=Hu||(0,oo.Z)(function*(vt,ut,Mt,Vt=.5,un=Number.NEGATIVE_INFINITY){const Rn=(0,l._1)(vt,"boxes","nonMaxSuppressionAsync"),Mn=(0,l._1)(ut,"scores","nonMaxSuppressionAsync"),as=Sc(Rn,Mn,Mt,Vt,un);Mt=as.maxOutputSize,Vt=as.iouThreshold,un=as.scoreThreshold;const is=yield Promise.all([Rn.data(),Mn.data()]),js=is[0],pr=is[1],{selectedIndices:Ri}=(0,Qp.GP)(js,pr,Mt,Vt,un);return Rn!==vt&&Rn.dispose(),Mn!==ut&&Mn.dispose(),No(Ri,"int32")})).apply(this,arguments)},nonMaxSuppressionWithScore:Ya,nonMaxSuppressionWithScoreAsync:function du(Tt,yt,ht){return(Ba=Ba||(0,oo.Z)(function*(vt,ut,Mt,Vt=.5,un=Number.NEGATIVE_INFINITY,Rn=0){const Mn=(0,l._1)(vt,"boxes","nonMaxSuppressionAsync"),as=(0,l._1)(ut,"scores","nonMaxSuppressionAsync"),is=Sc(Mn,as,Mt,Vt,un,Rn);Mt=is.maxOutputSize,Vt=is.iouThreshold,un=is.scoreThreshold,Rn=is.softNmsSigma;const js=yield Promise.all([Mn.data(),as.data()]),pr=js[0],Ri=js[1],{selectedIndices:pi,selectedScores:Xr}=(0,Qp.pA)(pr,Ri,Mt,Vt,un,Rn);return Mn!==vt&&Mn.dispose(),as!==ut&&as.dispose(),{selectedIndices:No(pi,"int32"),selectedScores:No(Xr)}})).apply(this,arguments)},nonMaxSuppressionPadded:zf,nonMaxSuppressionPaddedAsync:function Jp(Tt,yt,ht){return(zd=zd||(0,oo.Z)(function*(vt,ut,Mt,Vt=.5,un=Number.NEGATIVE_INFINITY,Rn=!1){const Mn=(0,l._1)(vt,"boxes","nonMaxSuppressionAsync"),as=(0,l._1)(ut,"scores","nonMaxSuppressionAsync"),is=Sc(Mn,as,Mt,Vt,un,null),js=is.maxOutputSize,pr=is.iouThreshold,Ri=is.scoreThreshold,[pi,Xr]=yield Promise.all([Mn.data(),as.data()]),{selectedIndices:Fn,validOutputs:Fr}=(0,Qp.qP)(pi,Xr,js,pr,Ri,Rn);return Mn!==vt&&Mn.dispose(),as!==ut&&as.dispose(),{selectedIndices:No(Fn,"int32"),validOutputs:(0,ci.i)(Fr,"int32")}})).apply(this,arguments)},threshold:Wd,transform:xu},Uh={bandPart:$h,gramSchmidt:ph,qr:b_},Pu={absoluteDifference:Mu,computeWeightedLoss:ad,cosineDistance:jf,hingeLoss:tf,huberLoss:Gf,logLoss:sf,meanSquaredError:rf,sigmoidCrossEntropy:bp,softmaxCrossEntropy:Dd},pu={sparseFillEmptyRows:(0,M.op)({sparseFillEmptyRows_:function af(Tt,yt,ht,vt){const ut=(0,l._1)(Tt,"indices","sparseFillEmptyRows","int32"),Mt=(0,l._1)(yt,"values","sparseFillEmptyRows"),Vt=(0,l._1)(ht,"denseShape","sparseFillEmptyRows","int32"),un=(0,l._1)(vt,"defaultValue","sparseFillEmptyRows",Mt.dtype);if(2!==ut.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${ut.shape}`);if(1!==Mt.rank)throw new Error(`Values should be Tensor1D but received shape ${Mt.shape}`);if(1!==Vt.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${Vt.shape}`);if(0!==un.rank)throw new Error(`Default value should be a scalar but received shape ${un.shape}`);const Mn=N.BV.runKernel(W.O3z,{indices:ut,values:Mt,denseShape:Vt,defaultValue:un});return{outputIndices:Mn[0],outputValues:Mn[1],emptyRowIndicator:Mn[2],reverseIndexMap:Mn[3]}}}),sparseReshape:(0,M.op)({sparseReshape_:function lf(Tt,yt,ht){const vt=(0,l._1)(Tt,"inputIndices","sparseReshape","int32"),ut=(0,l._1)(yt,"inputShape","sparseReshape","int32"),Mt=(0,l._1)(ht,"newShape","sparseReshape","int32");if(2!==vt.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${vt.shape}`);if(1!==ut.rank)throw new Error(`Input shape should be Tensor1D but received shape ${ut.shape}`);if(1!==Mt.rank)throw new Error(`New shape should be Tensor1D but received shape ${Mt.shape}`);const un=N.BV.runKernel(W.nhH,{inputIndices:vt,inputShape:ut,newShape:Mt});return{outputIndices:un[0],outputShape:un[1]}}}),sparseSegmentMean:(0,M.op)({sparseSegmentMean_:function mh(Tt,yt,ht){const vt=(0,l._1)(Tt,"data","sparseSegmentMean"),ut=(0,l._1)(yt,"indices","sparseSegmentMean","int32"),Mt=(0,l._1)(ht,"segmentIds","sparseSegmentMean","int32");if(vt.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==ut.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${ut.shape}`);if(1!==Mt.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${Mt.shape}`);return N.BV.runKernel(W.w3H,{data:vt,indices:ut,segmentIds:Mt})}}),sparseSegmentSum:(0,M.op)({sparseSegmentSum_:function hu(Tt,yt,ht){const vt=(0,l._1)(Tt,"data","sparseSegmentSum"),ut=(0,l._1)(yt,"indices","sparseSegmentSum","int32"),Mt=(0,l._1)(ht,"segmentIds","sparseSegmentSum","int32");if(vt.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==ut.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${ut.shape}`);if(1!==Mt.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${Mt.shape}`);return N.BV.runKernel(W.ZjV,{data:vt,indices:ut,segmentIds:Mt})}})},Xf={stringNGrams:(0,M.op)({stringNGrams_:function gh(Tt,yt,ht,vt,ut,Mt,Vt,un){const Rn=(0,l._1)(Tt,"data","stringNGrams","string");if("string"!==Rn.dtype)throw new Error("Data must be of datatype string");if(1!==Rn.shape.length)throw new Error(`Data must be a vector, saw: ${Rn.shape}`);const Mn=(0,l._1)(yt,"dataSplits","stringNGrams");if("int32"!==Mn.dtype)throw new Error("Data splits must be of datatype int32");const js=N.BV.runKernel(W._JP,{data:Rn,dataSplits:Mn},{separator:ht,nGramWidths:vt,leftPad:ut,rightPad:Mt,padWidth:Vt,preserveShortSequences:un});return{nGrams:js[0],nGramsSplits:js[1]}}}),stringSplit:(0,M.op)({stringSplit_:function _h(Tt,yt,ht=!0){const vt=(0,l._1)(Tt,"input","stringSplit","string"),ut=(0,l._1)(yt,"delimiter","stringSplit","string");if(1!==vt.rank)throw new Error(`Input should be Tensor1D but received shape ${vt.shape}`);if(0!==ut.rank)throw new Error(`Delimiter should be a scalar but received shape ${ut.shape}`);const un=N.BV.runKernel(W.s1s,{input:vt,delimiter:ut},{skipEmpty:ht});return{indices:un[0],values:un[1],shape:un[2]}}}),stringToHashBucketFast:(0,M.op)({stringToHashBucketFast_:function Ic(Tt,yt){const ht=(0,l._1)(Tt,"input","stringToHashBucketFast","string"),vt={numBuckets:yt};if(yt<=0)throw new Error("Number of buckets must be at least 1");return N.BV.runKernel(W.XkS,{input:ht},vt)}}),staticRegexReplace:(0,M.op)({staticRegexReplace_:function Uo(Tt,yt,ht,vt=!0){const ut=(0,l._1)(Tt,"input","staticRegexReplace","string");return N.BV.runKernel(W.e0R,{x:ut},{pattern:yt,rewrite:ht,replaceGlobal:vt})}})}},404:(Et,le,h)=>{"use strict";h.d(le,{v:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({pad_:function I(W,l,w=0){const M=(0,y._1)(W,"x","pad");if(0===M.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return U.BV.runKernel(Z.lyA,{x:M},{paddings:l,constantValue:w})}})},1640:(Et,le,h)=>{"use strict";h.d(le,{d:()=>G});var U=h(1257),Z=h(5359),y=h(6903),F=h(2782),I=h(5551),N=h(2444),W=h(4195),l=h(5715),w=h(9619);const G=(0,W.op)({pool_:function M(J,K,_e,Re,we,We,Oe){null==we&&(we=[1,1]),null==We&&(We=1),0===Re&&(Re="valid");const ie=(0,U._1)(J,"x","maxPool");let Le=ie,De=!1;3===ie.rank&&(De=!0,Le=(0,l.X)(ie,[1,ie.shape[0],ie.shape[1],ie.shape[2]])),Z.hu(I.jT(We,we),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${We} and dilations '${we}'`);const te=I.Xw(Le.shape,K,We,we,Re),de=[te.dilationHeight,te.dilationWidth];let P;P="same"===Re?function D(J,K){const Re=J.map((Oe,ie)=>Oe+(Oe-1)*(K[ie]-1)).map(Oe=>Oe-1),we=Re.map(Oe=>Math.floor(Oe/2)),We=Re.map((Oe,ie)=>Oe-we[ie]);return Re.map((Oe,ie)=>[we[ie],We[ie]])}([te.filterHeight,te.filterWidth],de):[[0,0],[0,0]];const oe=1===de[0]&&1===de[1],[ye,Te]=function T(J,K,_e){const Re=_e.map(te=>te[0]),we=_e.map(te=>te[1]),We=J.concat(Re,we),Oe=K.map((te,de)=>(te-We[de]%te)%te),ie=we.map((te,de)=>te+Oe[de]),Le=K.map((te,de)=>[Re[de],ie[de]]),De=K.map((te,de)=>[0,Oe[de]]);return[Le,De]}([te.inHeight,te.inWidth],de,P),v=oe?Re:"valid",at=oe?Le:(0,w.f)(Le,de,ye),Ue=("avg"===_e?()=>(0,y.w)(at,K,We,v,Oe):()=>(0,N._)(at,K,We,v,Oe))(),pt=oe?Ue:(0,F.E)(Ue,de,Te);return De?(0,l.X)(pt,[pt.shape[1],pt.shape[2],pt.shape[3]]):pt}})},2962:(Et,le,h)=>{"use strict";h.d(le,{s:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({pow_:function N(l,w){let M=(0,F._1)(l,"base","pow"),T=(0,F._1)(w,"exp","pow");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.pe_,{a:M,b:T})}})},1584:(Et,le,h)=>{"use strict";h.d(le,{A:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({prelu_:function I(W,l){const w=(0,y._1)(W,"x","prelu"),M=(0,y._1)(l,"alpha","prelu");return U.BV.runKernel(Z.o0g,{x:w,alpha:M})}})},3006:(Et,le,h)=>{"use strict";function U(Z,y=!1){console.log(Z.toString(y))}h.d(le,{S:()=>U})},794:(Et,le,h)=>{"use strict";h.d(le,{W:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(3062);const W=(0,h(4195).op)({prod_:function N(l,w=null,M=!1){let T=(0,y._1)(l,"x","prod");return"bool"===T.dtype&&(T=(0,F.p)(T,"int32")),U.BV.runKernel(Z.DlI,{x:T},{axis:w,keepDims:M})}})},6027:(Et,le,h)=>{"use strict";h.d(le,{k:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({real_:function I(W){const w={input:(0,y._1)(W,"input","real")};return U.BV.runKernel(Z.xJR,w)}})},4831:(Et,le,h)=>{"use strict";h.d(le,{M:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({reciprocal_:function I(W){const w={x:(0,y._1)(W,"x","reciprocal")};return U.BV.runKernel(Z.$HU,w)}})},8586:(Et,le,h)=>{"use strict";h.d(le,{U:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({relu_:function I(W){const w={x:(0,y._1)(W,"x","relu")};return U.BV.runKernel(Z.qkr,w)}})},4917:(Et,le,h)=>{"use strict";h.d(le,{b:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({relu6_:function I(W){const w={x:(0,y._1)(W,"x","relu6")};return U.BV.runKernel(Z.SbG,w)}})},5715:(Et,le,h)=>{"use strict";h.d(le,{X:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({reshape_:function I(W,l){const M={x:(0,y._1)(W,"x","reshape","string_or_numeric")};return U.BV.runKernel(Z.HZH,M,{shape:l})}})},6825:(Et,le,h)=>{"use strict";h.d(le,{G:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({reverse_:function I(W,l){const M={x:(0,y._1)(W,"x","reverse")};return U.BV.runKernel(Z.mKl,M,{dims:l})}})},1974:(Et,le,h)=>{"use strict";h.d(le,{N:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({round_:function I(W){const w={x:(0,y._1)(W,"x","round")};return U.BV.runKernel(Z.e07,w)}})},8893:(Et,le,h)=>{"use strict";h.d(le,{b:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({rsqrt_:function I(W){const w={x:(0,y._1)(W,"x","rsqrt","float32")};return U.BV.runKernel(Z.bV0,w)}})},8661:(Et,le,h)=>{"use strict";h.d(le,{i:()=>y});var U=h(1153),Z=h(7431);function y(F,I){if(((0,U.isTypedArray)(F)&&"string"!==I||Array.isArray(F))&&"complex64"!==I)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===I&&(0,U.isTypedArray)(F)&&!(F instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,Z.H)(F,[],[],I)}},1876:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{calculateShapes:()=>F,validateInput:()=>y,validateUpdateShape:()=>Z});var U=h(5359);function Z(I,N,W){const l=N.rank>1?N.shape[N.rank-1]:1,w=N.rank>1?N.rank-1:1,M=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${W.shape}, indices.shape: ${N.shape}, shape: ${I}, sliceDim: ${l}, and batchDim: ${w}.`;if(W.rank<w)throw new Error(M+` update.rank < ${w}. `);if(I.length<l+(W.rank-w))throw new Error(M+` Output shape length < ${l+(W.rank-w)}`);if(W.rank!==w+I.length-l)throw new Error(M+" update.rank != "+(w+I.length-l));for(let T=0;T<w;++T)if(W.shape[T]!==N.shape[T])throw new Error(M+` updates.shape[${T}] (${W.shape[T]}) != indices.shape[${T}] (${N.shape[T]}).`);for(let T=0;T<W.rank-w;++T)if(W.shape[T+w]!==I[T+l])throw new Error(M+` updates.shape[${T+w}] (${W.shape[T+w]}) != shape[${T+w}] (${I[T+w]})`)}function y(I,N,W){if(N.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${N.rank}.`);if(I.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${I.rank}.`);if("int32"!==N.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${N.dtype}`);if(W.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${W}`);if(0===W.length){if(0===N.size)throw new Error(`Indices specified for empty output. indices shape: ${N.shape}`);if(0===I.size)throw new Error(`Updates specified for empty output. updates shape: ${I.shape}`)}Z(W,N,I)}function F(I,N,W){const l=N.shape.length,w=l>1?N.shape[l-1]:1,M=W.length;let T=1;for(let _e=w;_e<M;++_e)T*=W[_e];const D=w<1?1:w;return{sliceRank:w,numUpdates:(0,U.NA)(N.shape)/D,sliceSize:T,strides:[...(0,U.e3)(W.slice(0,w)),1],outputSize:(0,U.NA)(W)}}},9614:(Et,le,h)=>{"use strict";h.d(le,{U:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({selu_:function I(W){const w={x:(0,y._1)(W,"x","selu")};return U.BV.runKernel(Z.oFR,w)}})},2152:(Et,le,h)=>{"use strict";h.d(le,{$:()=>Z,y:()=>U});const U=1.7580993408473768,Z=1.0507009873554805},6762:(Et,le,h)=>{"use strict";h.d(le,{U:()=>l});var U=h(1257),Z=h(5359),y=h(4451),F=h(1172),I=h(4195),N=h(5715);const l=(0,I.op)({separableConv2d_:function W(w,M,T,D,G,J=[1,1],K="NHWC"){const _e=(0,U._1)(w,"x","separableConv2d"),Re=(0,U._1)(M,"depthwiseFilter","separableConv2d"),we=(0,U._1)(T,"pointwiseFilter","separableConv2d");let We=_e,Oe=!1;if(3===_e.rank&&(Oe=!0,We=(0,N.X)(_e,[1,_e.shape[0],_e.shape[1],_e.shape[2]])),"NCHW"===K)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Z.hu(4===We.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${We.rank}.`),Z.hu(4===Re.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${Re.rank}.`),Z.hu(4===we.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${Re.rank}.`),Z.hu(1===we.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${we.shape[0]}.`),Z.hu(1===we.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${we.shape[1]}.`);const ie=Re.shape[2],Le=Re.shape[3];Z.hu(we.shape[2]===ie*Le,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${ie*Le}, but got ${we.shape[2]}.`);const De=(0,F.B)(We,Re,D,G,K,J),de=(0,y.T)(De,we,1,"valid",K);return Oe?(0,N.X)(de,[de.shape[1],de.shape[2],de.shape[3]]):de}})},6139:(Et,le,h)=>{"use strict";h.d(le,{X:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({sigmoid_:function I(W){const w={x:(0,y._1)(W,"x","sigmoid","float32")};return U.BV.runKernel(Z.a5O,w)}})},4058:(Et,le,h)=>{"use strict";h.d(le,{X:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({sign_:function I(W){const w={x:(0,y._1)(W,"x","sign")};return U.BV.runKernel(Z.i5y,w)}})},2438:(Et,le,h)=>{"use strict";h.d(le,{O:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({sin_:function I(W){const w={x:(0,y._1)(W,"x","sin","float32")};return U.BV.runKernel(Z.RQH,w)}})},319:(Et,le,h)=>{"use strict";h.d(le,{R:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({sinh_:function I(W){const w={x:(0,y._1)(W,"x","sinh")};return U.BV.runKernel(Z.wYB,w)}})},8317:(Et,le,h)=>{"use strict";h.d(le,{t:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({slice_:function I(W,l,w){const M=(0,y._1)(W,"x","slice","string_or_numeric");if(0===M.rank)throw new Error("Slicing scalar is not possible");return U.BV.runKernel(Z.p2w,{x:M},{begin:l,size:w})}})},2320:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{assertParamsValid:()=>F,computeFlatOffset:()=>Re,computeOutShape:()=>N,getNormalizedAxes:()=>M,isSliceContinous:()=>_e,maskToAxes:()=>I,parseSliceParams:()=>we,sliceInfo:()=>We,startForAxis:()=>J,startIndicesWithElidedDims:()=>T,stopForAxis:()=>K,stopIndicesWithElidedDims:()=>D,stridesForAxis:()=>G,stridesWithElidedDims:()=>W});var U=h(5359);const Z=-2,y=-1;function F(Le,De,te){const de=Le.shape.length;U.hu(de===De.length,()=>`Error in slice${de}D: Length of begin ${De} must match the rank of the array (${de}).`),U.hu(de===te.length,()=>`Error in slice${de}D: Length of size ${te} must match the rank of the array (${de}).`);for(let P=0;P<de;++P)U.hu(De[P]+te[P]<=Le.shape[P],()=>`Error in slice${de}D: begin[${P}] + size[${P}] (${De[P]+te[P]}) would overflow input.shape[${P}] (${Le.shape[P]})`)}function I(Le){const De=[];let te=0;for(;Le>0;)1&Le&&De.push(te),Le/=2,te++;return De}function N(Le,De,te){const de=[];for(let P=0;P<Le.length;P++)de[P]=Math.ceil((De[P]-Le[P])/te[P]);return de}function W(Le,De,te,de){const P=[...Le];for(let oe=P.length;oe<de.length;oe++)P.push(1);for(let oe=0;oe<te;oe++)0===oe?P[De]=1:(P.splice(De,0,1),P.pop());return P}function l(Le,De,te){return te<=Le?te:te-(De-1)}function w(Le,De){const te=[];for(let de=0;de<Le;de++)te.push(De+de);return te}function M(Le,De,te,de,P,oe,ye,Te,v){const at=Le.length;let Xe=new Array(at),Ue=new Array(at),pt=new Array(at);if(De.length&&te>0){const Ct=De[0],It=te+1;Xe=T(ye,Ct,It,de,Le),Ue=D(Te,Ct,It,P,Le),pt=W(oe,Ct,It,Le)}else for(let Ct=0;Ct<at;Ct++)Xe[Ct]=J(ye,de,oe,Le,Ct,v),Ue[Ct]=K(Te,P,oe,Le,Ct,v),pt[Ct]=G(oe,Ct,v);return{begin:Xe,end:Ue,strides:pt}}function T(Le,De,te,de,P){const oe=[...P],ye=w(te,De);for(let Te=0;Te<oe.length;Te++)if(ye.indexOf(Te)>-1)oe[Te]=0;else{const v=l(De,te,Te);let at=de[v];Le&1<<v&&(at=0),oe[Te]=at}return oe}function D(Le,De,te,de,P){const oe=[...P],ye=w(te,De);for(let Te=0;Te<oe.length;Te++)if(ye.indexOf(Te)>-1)oe[Te]=Number.MAX_SAFE_INTEGER;else{const v=l(De,te,Te);let at=de[v];Le&1<<v&&(at=Number.MAX_SAFE_INTEGER),oe[Te]=at}for(let Te=0;Te<oe.length;Te++)oe[Te]<0&&(oe[Te]+=P[Te]),oe[Te]=U.uZ(0,oe[Te],P[Te]);return oe}function G(Le,De,te){let de=Le[De];return(te&1<<De||null==de)&&(de=1),de}function J(Le,De,te,de,P,oe){let ye=De[P];(Le&1<<P||oe&1<<P||null==ye)&&(ye=(te[P]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const v=de[P];return ye<0&&(ye+=v),ye=U.uZ(0,ye,v-1),ye}function K(Le,De,te,de,P,oe){let ye=De[P];const Te=te[P]||1;(Le&1<<P||oe&1<<P||null==ye)&&(ye=Te>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const v=de[P];return ye<0&&(ye+=v),ye=Te>0?U.uZ(0,ye,v):U.uZ(-1,ye,v-1),ye}function _e(Le,De,te){let de=te.length;for(let P=0;P<te.length;P++)if(te[P]>1){de=P;break}for(let P=de+1;P<te.length;P++)if(De[P]>0||te[P]!==Le[P])return!1;return!0}function Re(Le,De){let te=Le.length>0?Le[Le.length-1]:1;for(let de=0;de<Le.length-1;de++)te+=Le[de]*De[de];return te}function we(Le,De,te){let de;const P=Le.shape.length;let oe;return de="number"==typeof De?[De,...new Array(P-1).fill(0)]:De.length<P?De.concat(new Array(P-De.length).fill(0)):De.slice(),de.forEach(ye=>{U.hu(-1!==ye,()=>"slice() does not support negative begin indexing.")}),oe=null==te?new Array(P).fill(-1):"number"==typeof te?[te,...new Array(P-1).fill(-1)]:te.length<P?te.concat(new Array(P-te.length).fill(-1)):te,oe=oe.map((ye,Te)=>ye>=0?ye:(U.hu(-1===ye,()=>`Negative size values should be exactly -1 but got ${ye} for the slice() size at index ${Te}.`),Le.shape[Te]-de[Te])),[de,oe]}function We(Le,De,te,de,P,oe,ye,Te,v){let at;if(null==de?(at=new Array(De.length),at.fill(1)):at=de,null!=ye&&ye&ye-1)throw new Error("Multiple ellipses in slice is not allowed.");let Xe=!1;const Ue={dims:at.length,numAddAxisAfterEllipsis:0,begin:De.slice(),end:te.slice(),strides:at.slice(),beginMask:P,endMask:oe,ellipsisMask:ye,newAxisMask:Te,shrinkAxisMask:v};for(let Dn=0;Dn<Ue.dims;Dn++)Xe&&1<<Dn&Te&&Ue.numAddAxisAfterEllipsis++,1<<Dn&ye&&(Xe=!0);Xe||(Ue.ellipsisMask|=1<<Ue.dims,Ue.dims++);const pt={dims:Le.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function Oe(Le,De){De.beginMask=0,De.endMask=0,De.shrinkAxisMask=0;let te=0;De.beginValid=null!=Le.begin,De.endValid=null!=Le.end,De.begin=new Array(De.dims),De.end=new Array(De.dims),De.strides=new Array(De.dims),De.finalShapeGatherIndices=[],De.finalShapeGatherIndicesSparse=[],De.inputShapeGatherIndicesSparse=new Array(De.dims);for(let de=0;de<Le.dims;de++)if(1<<de&Le.ellipsisMask){const P=Math.min(De.dims-(Le.dims-de)+1+Le.numAddAxisAfterEllipsis,De.dims);for(;te<P;te++)De.begin[te]=0,De.end[te]=0,De.strides[te]=1,De.beginMask|=1<<te,De.endMask|=1<<te,De.finalShapeGatherIndices.push(te),De.finalShapeGatherIndicesSparse.push(-1),De.inputShapeGatherIndicesSparse[te]=de}else if(1<<de&Le.newAxisMask)De.finalShapeGatherIndices.push(Z),De.finalShapeGatherIndicesSparse.push(-1);else{if(te===De.begin.length)throw Error(`Index out of range using input dim ${te}; input has only ${De.dims} dims, ${De.begin.length}.`);null!=Le.begin&&(De.begin[te]=Le.begin[de]),null!=Le.end&&(De.end[te]=Le.end[de]),De.strides[te]=Le.strides[de],Le.beginMask&1<<de&&(De.beginMask|=1<<te),Le.endMask&1<<de&&(De.endMask|=1<<te),Le.shrinkAxisMask&1<<de?(De.finalShapeGatherIndices.push(y),De.finalShapeGatherIndicesSparse.push(-1),De.shrinkAxisMask|=1<<te):(De.finalShapeGatherIndices.push(te),De.finalShapeGatherIndicesSparse.push(de)),De.inputShapeGatherIndicesSparse[te]=de,te++}}(Ue,pt);let Ct=!0,It=!0,nn=!0;const Bt=[],bn=[];for(let Dn=0;Dn<Le.length;++Dn){if(0===pt.strides[Dn])throw Error(`strides[${Dn}] must be non-zero`);const ps=!!(pt.shrinkAxisMask&1<<Dn),Es=Le[Dn];if(-1===Es){Bt.push(ps?1:-1);continue}const Xn=[pt.beginMask&1<<Dn,pt.endMask&1<<Dn],Ts=[pt.strides[Dn]>0?0:-1,pt.strides[Dn]>0?Es:Es-1];if(ps&&pt.strides[Dn]<=0)throw Error("only stride 1 allowed on non-range indexing.");nn=nn&&1===pt.strides[Dn];const or=!!(pt.beginMask&1<<Dn&&pt.endMask&1<<Dn);if(pt.beginValid&&pt.endValid){if(ps){const Lt=pt.begin[Dn]<0?Es+pt.begin[Dn]:pt.begin[Dn];if(pt.begin[Dn]=Lt,pt.end[Dn]=pt.begin[Dn]+1,Lt<0||Lt>=Es)throw Error(`slice index ${pt.begin[Dn]} of dimension ${Dn} out of bounds.`)}else pt.begin[Dn]=ie(pt.begin[Dn],0,pt.strides[Dn],Es,Xn,Ts),pt.end[Dn]=ie(pt.end[Dn],1,pt.strides[Dn],Es,Xn,Ts);const Qe=1===pt.strides[Dn]&&0===pt.begin[Dn]&&pt.end[Dn]===Es;Ct=Ct&&Qe,It=It&&(0===Dn&&1===pt.strides[Dn]||Qe)}else Ct=Ct&&1===pt.strides[Dn]&&or,It=It&&(0===Dn&&1===pt.strides[Dn]||or);let Ir,Ss=!1;if(pt.beginValid&&pt.endValid?(Ir=pt.end[Dn]-pt.begin[Dn],Ss=!0):ps?(Ir=1,Ss=!0):or&&Es>=0&&(Ir=pt.strides[Dn]<0?-Es:Es,Ss=!0),Ss){let Qe;Qe=0===Ir||Ir<0!=pt.strides[Dn]<0?0:Math.trunc(Ir/pt.strides[Dn])+(Ir%pt.strides[Dn]!=0?1:0),Bt.push(Qe)}else Bt.push(-1)}for(let Dn=0;Dn<pt.finalShapeGatherIndices.length;++Dn){const ps=pt.finalShapeGatherIndices[Dn];ps>=0?bn.push(Bt[ps]):ps===Z&&bn.push(1)}return{finalShapeSparse:bn.filter((Dn,ps)=>pt.finalShapeGatherIndices[ps]!==Z),finalShape:bn,isIdentity:Ct,sliceDim0:It,isSimpleSlice:nn,begin:pt.begin,end:pt.end,strides:pt.strides}}function ie(Le,De,te,de,P,oe){if(P[De])return te>0?oe[De]:oe[De+1&1];{const ye=Le<0?de+Le:Le;return ye<oe[0]?oe[0]:ye>oe[1]?oe[1]:ye}}},8683:(Et,le,h)=>{"use strict";h.d(le,{X:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({softmax_:function I(W,l=-1){const w=(0,y._1)(W,"logits","softmax","float32");if(-1===l&&(l=w.rank-1),l!==w.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${w.rank} and dim was ${l}`);return U.BV.runKernel(Z.Gcp,{logits:w},{dim:l})}})},4487:(Et,le,h)=>{"use strict";h.d(le,{W:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({softplus_:function I(W){const w={x:(0,y._1)(W,"x","softplus")};return U.BV.runKernel(Z.MRv,w)}})},9619:(Et,le,h)=>{"use strict";h.d(le,{f:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({spaceToBatchND_:function N(l,w,M){const T=(0,y._1)(l,"x","spaceToBatchND");return F.hu(T.rank>=1+w.length,()=>`input rank ${T.rank} should be > than [blockShape] ${w.length}`),F.hu(M.length===w.length,()=>`paddings.shape[0] ${M.length} must be equal to [blockShape] ${w.length}`),F.hu(T.shape.reduce((J,K,_e)=>_e>0&&_e<=w.length?J&&(K+M[_e-1][0]+M[_e-1][1])%w[_e-1]==0:J,!0),()=>`input spatial dimensions ${T.shape.slice(1)} with paddings ${M.toString()} must be divisible by blockShapes ${w.toString()}`),U.BV.runKernel(Z.TQc,{x:T},{blockShape:w,paddings:M})}})},9738:(Et,le,h)=>{"use strict";h.d(le,{k:()=>N});var U=h(687),Z=h(4251),y=h(5359);const N=(0,h(4195).op)({fft_:function I(W){return(0,y.hu)("complex64"===W.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${W.dtype}.`),U.BV.runKernel(Z.vwp,{input:W})}})},527:(Et,le,h)=>{"use strict";h.d(le,{S:()=>N});var U=h(687),Z=h(4251),y=h(5359);const N=(0,h(4195).op)({ifft_:function I(W){return(0,y.hu)("complex64"===W.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${W.dtype}.`),U.BV.runKernel(Z.Qg5,{input:W})}})},6065:(Et,le,h)=>{"use strict";h.d(le,{w:()=>G});var U=h(3037),Z=h(4111),y=h(1844),F=h(8737),I=h(4195),N=h(6027),W=h(5715),l=h(6825),w=h(8661),M=h(8317),T=h(527);const G=(0,I.op)({irfft_:function D(J){const K=J.shape[J.shape.length-1],_e=J.size/K;let Re;if(K<=2){const we=(0,W.X)(J,[_e,K]);Re=(0,T.S)(we)}else{const we=[_e,2*(K-1)],We=(0,W.X)((0,N.k)(J),[_e,K]),Oe=(0,W.X)((0,y.a)(J),[_e,K]),ie=(0,l.G)((0,M.t)(We,[0,1],[_e,K-2]),1),Le=(0,F.d)((0,l.G)((0,M.t)(Oe,[0,1],[_e,K-2]),1),(0,w.i)(-1)),De=(0,Z.z)([We,ie],1),te=(0,Z.z)([Oe,Le],1),de=(0,W.X)((0,U.P)(De,te),[we[0],we[1]]);Re=(0,T.S)(de)}if(Re=(0,N.k)(Re),3===J.rank&&0!==J.shape[0]){const we=Re,We=J.shape[0];Re=(0,W.X)(Re,[We,Re.shape[0]/We,Re.shape[1]]),we.dispose()}return Re}})},1638:(Et,le,h)=>{"use strict";h.d(le,{Q:()=>J});var U=h(5359),Z=h(3037),y=h(4111),F=h(1844),I=h(4195),N=h(6027),W=h(5715),l=h(8317),w=h(8874),M=h(6467),T=h(3143),D=h(9738);const J=(0,I.op)({rfft_:function G(K,_e){(0,U.hu)("float32"===K.dtype,()=>`The dtype for rfft() must be real value but got ${K.dtype}`);let Re=K.shape[K.shape.length-1];const we=K.size/Re;let We;if(null!=_e&&_e<Re){const Te=K.shape.map(at=>0),v=K.shape.map(at=>at);v[K.shape.length-1]=_e,We=(0,l.t)(K,Te,v),Re=_e}else if(null!=_e&&_e>Re){const Te=K.shape.map(v=>v);Te[K.shape.length-1]=_e-Re,We=(0,y.z)([K,(0,M.l)(Te)],K.shape.length-1),Re=_e}else We=K;const Oe=(0,T.P)(We),ie=(0,W.X)((0,Z.P)(We,Oe),[we,Re]),Le=(0,D.k)(ie),De=Math.floor(Re/2)+1,te=(0,N.k)(Le),de=(0,F.a)(Le),P=(0,w.V)(te,[De,Re-De],te.shape.length-1),oe=(0,w.V)(de,[De,Re-De],de.shape.length-1),ye=We.shape.slice();return ye[We.shape.length-1]=De,(0,W.X)((0,Z.P)(P[0],oe[0]),ye)}})},8874:(Et,le,h)=>{"use strict";h.d(le,{V:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({split_:function I(W,l,w=0){const T={x:(0,y._1)(W,"x","split")};return U.BV.runKernel(Z.L8s,T,{numOrSizeSplits:l,axis:w})}})},930:(Et,le,h)=>{"use strict";h.d(le,{_:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({sqrt_:function I(W){const w={x:(0,y._1)(W,"x","sqrt","float32")};return U.BV.runKernel(Z.FKq,w)}})},7527:(Et,le,h)=>{"use strict";h.d(le,{h:()=>I});var U=h(687),Z=h(1257);const I=(0,h(4195).op)({square_:function F(N){const W=(0,Z._1)(N,"x","square");return U.BV.runKernel("Square",{x:W},{})}})},9539:(Et,le,h)=>{"use strict";h.d(le,{$:()=>l});var U=h(687),Z=h(4251),y=h(7664),F=h(1257),I=h(3239);const l=(0,h(4195).op)({squaredDifference_:function W(w,M){let T=(0,F._1)(w,"a","squaredDifference"),D=(0,F._1)(M,"b","squaredDifference");return[T,D]=(0,y.makeTypesMatch)(T,D),(0,I.assertAndGetBroadcastShape)(T.shape,D.shape),U.BV.runKernel(Z._tC,{a:T,b:D},{})}})},2494:(Et,le,h)=>{"use strict";h.d(le,{L:()=>N});var U=h(1257),Z=h(5359),y=h(4195),F=h(5715);const N=(0,y.op)({squeeze_:function I(W,l){const w=(0,U._1)(W,"x","squeeze","string_or_numeric");return(0,F.X)(w,(0,Z.bp)(w.shape,l).newShape)}})},7958:(Et,le,h)=>{"use strict";h.d(le,{k:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({stack_:function N(l,w=0){const M=(0,y.sI)(l,"tensors","stack","string_or_numeric");return F.hu(M.length>=1,()=>"Pass at least one tensor to tf.stack"),M.length>0&&F.hu(w<=M[0].rank,()=>"Axis must be <= rank of the tensor"),U.BV.runKernel(Z.QiL,M,{axis:w})}})},6034:(Et,le,h)=>{"use strict";h.d(le,{N:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({step_:function I(W,l=0){const M={x:(0,y._1)(W,"x","step")};return U.BV.runKernel(Z.h8e,M,{alpha:l})}})},5367:(Et,le,h)=>{"use strict";h.d(le,{N:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({stridedSlice_:function I(W,l,w,M,T=0,D=0,G=0,J=0,K=0){const Re={x:(0,y._1)(W,"x","stridedSlice","string_or_numeric")};return U.BV.runKernel(Z.jQk,Re,{begin:l,end:w,strides:M,beginMask:T,endMask:D,ellipsisMask:G,newAxisMask:J,shrinkAxisMask:K})}})},1191:(Et,le,h)=>{"use strict";h.d(le,{l:()=>W});var U=h(687),Z=h(4251),y=h(7664),F=h(1257);const W=(0,h(4195).op)({sub_:function N(l,w){let M=(0,F._1)(l,"a","sub"),T=(0,F._1)(w,"b","sub");return[M,T]=(0,y.makeTypesMatch)(M,T),U.BV.runKernel(Z.Tr8,{a:M,b:T})}})},9929:(Et,le,h)=>{"use strict";h.d(le,{S:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(3062);const W=(0,h(4195).op)({sum_:function N(l,w=null,M=!1){let T=(0,y._1)(l,"x","sum");return"bool"===T.dtype&&(T=(0,F.p)(T,"int32")),U.BV.runKernel(Z.GBy,{x:T},{axis:w,keepDims:M})}})},2500:(Et,le,h)=>{"use strict";h.d(le,{O:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({tan_:function I(W){const w={x:(0,y._1)(W,"x","tan","float32")};return U.BV.runKernel(Z.sEM,w)}})},5987:(Et,le,h)=>{"use strict";h.d(le,{A:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({tanh_:function I(W){const w={x:(0,y._1)(W,"x","tanh","float32")};return U.BV.runKernel(Z.MIZ,w)}})},3905:(Et,le,h)=>{"use strict";h.d(le,{X:()=>y});var U=h(1257),Z=h(7431);function y(F,I,N){const W=(0,U.C)(F,N);return(0,Z.H)(F,I,W,N)}},2786:(Et,le,h)=>{"use strict";h.d(le,{w:()=>F});var U=h(1257),Z=h(5359),y=h(7431);function F(I,N,W){if((0,Z.Cq)(I),null!=N&&3!==N.length)throw new Error("tensor3d() requires shape to have three numbers");const l=(0,U.C)(I,W);if(3!==l.length&&1!==l.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===l.length&&null==N)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,y.H)(I,N,l,W)}},7431:(Et,le,h)=>{"use strict";h.d(le,{H:()=>I});var U=h(687),Z=h(1216),y=h(5359),F=h(1153);function I(N,W,l,w){if(null==w)w=(0,y.D2)(N);else if("complex64"===w)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,Z.$F)(N)||(0,Z.Oq)(N)){if("float32"!==w&&"int32"!==w)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${w}.`);return U.BV.backend.createTensorFromGPUData(N,W||l,w)}if(!(0,F.isTypedArray)(N)&&!Array.isArray(N)&&"number"!=typeof N&&"boolean"!=typeof N&&"string"!=typeof N)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=W){(0,y.Mu)(W);const M=(0,y.NA)(W),T=(0,y.NA)(l);(0,y.hu)(M===T,()=>`Based on the provided shape, [${W}], the tensor should have ${M} values but has ${T}`);for(let D=0;D<l.length;++D){const J=D!==l.length-1||l[D]!==(0,y.NA)(W.slice(D));(0,y.hu)(l[D]===W[D]||!J,()=>`Error creating a new Tensor. Inferred shape (${l}) does not match the provided shape (${W}). `)}}return!(0,F.isTypedArray)(N)&&!Array.isArray(N)&&(N=[N]),W=W||l,N="string"!==w?(0,F.toTypedArray)(N,w):(0,F.flatten)(N,[],!0),U.BV.makeTensor(N,W,w)}},2005:(Et,le,h)=>{"use strict";h.d(le,{G:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({tile_:function N(l,w){const M=(0,y._1)(l,"x","tile","string_or_numeric");return F.hu(M.rank===w.length,()=>`Error in transpose: rank of input ${M.rank} must match length of reps ${w}.`),U.BV.runKernel(Z.n9L,{x:M},{reps:w})}})},4927:(Et,le,h)=>{"use strict";h.d(le,{h:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({topk_:function I(W,l=1,w=!0){const M=(0,y._1)(W,"x","topk");if(0===M.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const T=M.shape[M.shape.length-1];if(l<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${l}`);if(l>T)throw new Error(`'k' passed to topk() must be <= the last dimension (${T}) but got ${l}`);const D={x:M},G={k:l,sorted:w},[J,K]=U.BV.runKernel(Z.cWu,D,G);return{values:J,indices:K}}})},9194:(Et,le,h)=>{"use strict";h.d(le,{p:()=>D});var U=h(687),Z=h(2773),y=h(4251),F=h(1257),I=h(5359),N=h(3037),W=h(1844),l=h(5048),w=h(4195),M=h(6027);const D=(0,w.op)({transpose_:function T(G,J,K){const _e=(0,F._1)(G,"x","transpose");if(null==J&&(J=_e.shape.map((We,Oe)=>Oe).reverse()),I.hu(_e.rank===J.length,()=>`Error in transpose: rank of input ${_e.rank} must match length of perm ${J}.`),J.forEach(We=>{I.hu(We>=0&&We<_e.rank,()=>`All entries in 'perm' must be between 0 and ${_e.rank-1} but got ${J}`)}),_e.rank<=1)return _e.clone();const Re={x:_e},we={perm:J};return"complex64"===_e.dtype?(0,Z.lu)(()=>{let We=(0,M.k)(_e),Oe=(0,W.a)(_e);return We=U.BV.runKernel(y.G3Y,{x:We},we),Oe=U.BV.runKernel(y.G3Y,{x:Oe},we),K&&(Oe=(0,l.W)(Oe)),(0,N.P)(We,Oe)}):U.BV.runKernel(y.G3Y,Re,we)}})},8130:(Et,le,h)=>{"use strict";h.d(le,{T:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({unique_:function N(l,w=0){const M=(0,y._1)(l,"x","unique","string_or_numeric");(0,F.hu)(M.rank>0,()=>"The input tensor must be at least 1D");const T={x:M},D={axis:w},[G,J]=U.BV.runKernel(Z.kpP,T,D);return{values:G,indices:J}}})},7715:(Et,le,h)=>{"use strict";h.d(le,{p:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({unsortedSegmentSum_:function N(l,w,M){const T=(0,y._1)(l,"x","unsortedSegmentSum"),D=(0,y._1)(w,"segmentIds","unsortedSegmentSum","int32");return(0,F.hu)((0,F.GN)(M),()=>"numSegments must be of dtype int"),U.BV.runKernel(Z.Qvg,{x:T,segmentIds:D},{numSegments:M})}})},2219:(Et,le,h)=>{"use strict";h.d(le,{H:()=>W});var U=h(687),Z=h(4251),y=h(1257),F=h(5359);const W=(0,h(4195).op)({unstack_:function N(l,w=0){const M=(0,y._1)(l,"x","unstack","string_or_numeric");return F.hu(w>=-M.shape.length&&w<M.shape.length,()=>`Axis = ${w} is not in [-${M.shape.length}, ${M.shape.length})`),U.BV.runKernel(Z.ToN,{value:M},{axis:w})}})},2190:(Et,le,h)=>{"use strict";h.d(le,{a:()=>l});var U=h(687),Z=h(4251),y=h(1257),F=h(983),I=h(3239);const l=(0,h(4195).op)({where_:function W(w,M,T){const D=(0,y._1)(M,"a","where"),G=(0,y._1)(T,"b","where"),J=(0,y._1)(w,"condition","where","bool"),K=(0,I.assertAndGetBroadcastShape)((0,I.assertAndGetBroadcastShape)(J.shape,D.shape),G.shape),_e=(0,F.U)(J,K),Re=(0,F.U)(D,K),we=(0,F.U)(G,K);return U.BV.runKernel(Z.PhF,{condition:_e,t:Re,e:we})}})},6467:(Et,le,h)=>{"use strict";h.d(le,{l:()=>F});var U=h(687),Z=h(5359),y=h(3037);function F(I,N="float32"){if((0,Z.Mu)(I),"complex64"===N){const l=F(I,"float32"),w=F(I,"float32");return(0,y.P)(l,w)}const W=(0,Z.wT)((0,Z.NA)(I),N);return U.BV.makeTensor(W,I,N)}},3143:(Et,le,h)=>{"use strict";h.d(le,{P:()=>N});var U=h(687),Z=h(4251),y=h(1257);const N=(0,h(4195).op)({zerosLike_:function I(W){const w={x:(0,y._1)(W,"x","zerosLike")};return U.BV.runKernel(Z.RuY,w)}})},4705:(Et,le,h)=>{"use strict";function U(Z){return Z instanceof Float32Array||Z instanceof Int32Array||Z instanceof Uint8Array||Z instanceof Uint8ClampedArray}h.d(le,{j:()=>U})},4945:(Et,le,h)=>{"use strict";h.d(le,{es:()=>ie,YD:()=>J,_w:()=>De,t3:()=>Le,FZ:()=>Oe,Vp:()=>We,Vi:()=>we});var U=h(5861),Z=h(2918),y=h(5359);const F=20,I=3,N=7;function W(te,de,P,oe){const ye=(0,y.e3)(de),Te=function l(te,de,P,oe){const ye=(0,y.NA)(de),Te=oe[oe.length-1],v=new Array(Te).fill(0),at=de.length,Xe="complex64"===P?D(te):te;if(at>1)for(let Ue=0;Ue<ye/Te;Ue++){const pt=Ue*Te;for(let Ct=0;Ct<Te;Ct++)v[Ct]=Math.max(v[Ct],w(Xe[pt+Ct],0,P).length)}return v}(te,de,P,ye),v=de.length,at=T(te,de,P,ye,Te),Xe=["Tensor"];return oe&&(Xe.push(`  dtype: ${P}`),Xe.push(`  rank: ${v}`),Xe.push(`  shape: [${de}]`),Xe.push("  values:")),Xe.push(at.map(Ue=>"    "+Ue).join("\n")),Xe.join("\n")}function w(te,de,P){let oe;return oe=Array.isArray(te)?`${parseFloat(te[0].toFixed(N))} + ${parseFloat(te[1].toFixed(N))}j`:(0,y.HD)(te)?`'${te}'`:"bool"===P?M(te):parseFloat(te.toFixed(N)).toString(),(0,y.oj)(oe,de)}function M(te){return 0===te?"false":"true"}function T(te,de,P,oe,ye,Te=!0){const v="complex64"===P?2:1,at=de[0],Xe=de.length;if(0===Xe)return"complex64"===P?[w(D(te)[0],0,P)]:"bool"===P?[M(te[0])]:[te[0].toString()];if(1===Xe){if(at>F){let Dn=Array.from(te.slice(0,I*v)),ps=Array.from(te.slice((at-I)*v,at*v));return"complex64"===P&&(Dn=D(Dn),ps=D(ps)),["["+Dn.map((Es,Xn)=>w(Es,ye[Xn],P)).join(", ")+", ..., "+ps.map((Es,Xn)=>w(Es,ye[at-I+Xn],P)).join(", ")+"]"]}return["["+("complex64"===P?D(te):Array.from(te)).map((Qn,Dn)=>w(Qn,ye[Dn],P)).join(", ")+"]"]}const Ue=de.slice(1),pt=oe.slice(1),Ct=oe[0]*v,It=[];if(at>F){for(let bn=0;bn<I;bn++){const Qn=bn*Ct;It.push(...T(te.slice(Qn,Qn+Ct),Ue,P,pt,ye,!1))}It.push("...");for(let bn=at-I;bn<at;bn++){const Qn=bn*Ct;It.push(...T(te.slice(Qn,Qn+Ct),Ue,P,pt,ye,bn===at-1))}}else for(let bn=0;bn<at;bn++){const Qn=bn*Ct;It.push(...T(te.slice(Qn,Qn+Ct),Ue,P,pt,ye,bn===at-1))}const nn=2===Xe?",":"";It[0]="["+(at>0?It[0]+nn:"");for(let bn=1;bn<It.length-1;bn++)It[bn]=" "+It[bn]+nn;let Bt=",\n";for(let bn=2;bn<Xe;bn++)Bt+="\n";return It[It.length-1]=" "+It[It.length-1]+"]"+(Te?"":Bt),It}function D(te){const de=[];for(let P=0;P<te.length;P+=2)de.push([te[P],te[P+1]]);return de}var G=h(1153);class J{constructor(de,P,oe){if(this.dtype=P,this.shape=de.slice(),this.size=y.NA(de),null!=oe){const ye=oe.length;y.hu(ye===this.size,()=>`Length of values '${ye}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===P)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=oe||y.rQ(P,this.size),this.strides=(0,y.e3)(de)}set(de,...P){0===P.length&&(P=[0]),y.hu(P.length===this.rank,()=>`The number of provided coordinates (${P.length}) must match the rank (${this.rank})`);const oe=this.locToIndex(P);this.values[oe]=de}get(...de){0===de.length&&(de=[0]);let P=0;for(const ye of de){if(ye<0||ye>=this.shape[P])throw new Error(`Requested out of range element at ${de}.   Buffer shape=${this.shape}`);P++}let oe=de[de.length-1];for(let ye=0;ye<de.length-1;++ye)oe+=this.strides[ye]*de[ye];return this.values[oe]}locToIndex(de){if(0===this.rank)return 0;if(1===this.rank)return de[0];let P=de[de.length-1];for(let oe=0;oe<de.length-1;++oe)P+=this.strides[oe]*de[oe];return P}indexToLoc(de){if(0===this.rank)return[];if(1===this.rank)return[de];const P=new Array(this.shape.length);for(let oe=0;oe<P.length-1;++oe)P[oe]=Math.floor(de/this.strides[oe]),de-=P[oe]*this.strides[oe];return P[P.length-1]=de,P}get rank(){return this.shape.length}toTensor(){return K().makeTensor(this.values,this.shape,this.dtype)}}let K=null,_e=null,Re=null;function we(te){K=te}function We(te){_e=te}function Oe(te){Re=te}class ie{constructor(de,P,oe,ye){this.kept=!1,this.isDisposedInternal=!1,this.shape=de.slice(),this.dtype=P||"float32",this.size=y.NA(de),this.strides=(0,y.e3)(de),this.dataId=oe,this.id=ye,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var de=this;return(0,U.Z)(function*(){const P=yield de.data();return _e.buffer(de.shape,de.dtype,P)})()}bufferSync(){return _e.buffer(this.shape,this.dtype,this.dataSync())}array(){var de=this;return(0,U.Z)(function*(){const P=yield de.data();return(0,y.GX)(de.shape,P,"complex64"===de.dtype)})()}arraySync(){return(0,y.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var de=this;return(0,U.Z)(function*(){de.throwIfDisposed();const P=K().read(de.dataId);if("string"===de.dtype){const oe=yield P;try{return oe.map(ye=>G.decodeString(ye))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return P})()}dataToGPU(de){return this.throwIfDisposed(),K().readToGPU(this.dataId,de)}dataSync(){this.throwIfDisposed();const de=K().readSync(this.dataId);if("string"===this.dtype)try{return de.map(P=>G.decodeString(P))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return de}bytes(){var de=this;return(0,U.Z)(function*(){de.throwIfDisposed();const P=yield K().read(de.dataId);return"string"===de.dtype?P:new Uint8Array(P.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),K().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(de=!1){return _e.print(this,de)}clone(){return this.throwIfDisposed(),_e.clone(this)}toString(de=!1){return W(this.dataSync(),this.shape,this.dtype,de)}cast(de){return this.throwIfDisposed(),_e.cast(this,de)}variable(de=!0,P,oe){return this.throwIfDisposed(),K().makeVariable(this,de,P,oe)}}function Le(){return(0,Z.R)("Tensor",()=>ie)}Object.defineProperty(ie,Symbol.hasInstance,{value:te=>!!te&&null!=te.data&&null!=te.dataSync&&null!=te.throwIfDisposed}),Le();class De extends ie{constructor(de,P,oe,ye){super(de.shape,de.dtype,de.dataId,ye),this.trainable=P,this.name=oe}assign(de){if(de.dtype!==this.dtype)throw new Error(`dtype of the new value (${de.dtype}) and previous value (${this.dtype}) must match`);if(!y.cO(de.shape,this.shape))throw new Error(`shape of the new value (${de.shape}) and previous value (${this.shape}) must match`);K().disposeTensor(this),this.dataId=de.dataId,K().incRef(this,null)}dispose(){K().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(De,Symbol.hasInstance,{value:te=>te instanceof ie&&null!=te.assign&&te.assign instanceof Function})},7664:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{assertTypesMatch:()=>I,getTensorsInContainer:()=>W,isTensorInList:()=>N,makeTypesMatch:()=>F});var U=h(4945),Z=h(1216),y=h(5359);function F(M,T){if(M.dtype===T.dtype)return[M,T];const D=(0,Z.x8)(M.dtype,T.dtype);return[M.cast(D),T.cast(D)]}function I(M,T){(0,y.hu)(M.dtype===T.dtype,()=>`The dtypes of the first(${M.dtype}) and second(${T.dtype}) input must match`)}function N(M,T){return T.some(D=>D.id===M.id)}function W(M){const T=[];return l(M,T,new Set),T}function l(M,T,D){if(null==M)return;if(M instanceof U.es)return void T.push(M);if(!function w(M){return Array.isArray(M)||"object"==typeof M}(M))return;const G=M;for(const J in G){const K=G[J];D.has(K)||(D.add(K),l(K,T,D))}}},1257:(Et,le,h)=>{"use strict";h.d(le,{C:()=>W,_1:()=>M,sI:()=>T});var U=h(687),Z=h(5527),y=h(4945),F=h(1216),I=h(1153),N=h(5359);function W(D,G){let J=D;if((0,I.isTypedArray)(D))return"string"===G?[]:[D.length];if((0,F.Oq)(D))return[D.height,D.width*(D.channels||"RGBA").length];if((0,F.$F)(D))return[D.buffer.size/(null==G?4:(0,N.bT)(G))];if(!Array.isArray(D))return[];const K=[];for(;Array.isArray(J)||(0,I.isTypedArray)(J)&&"string"!==G;)K.push(J.length),J=J[0];return Array.isArray(D)&&(0,Z.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&l(D,K,[]),K}function l(D,G,J){if(J=J||[],!Array.isArray(D)&&!(0,I.isTypedArray)(D))return void(0,N.hu)(0===G.length,()=>`Element arr[${J.join("][")}] is a primitive, but should be an array/TypedArray of ${G[0]} elements`);(0,N.hu)(G.length>0,()=>`Element arr[${J.join("][")}] should be a primitive, but is an array of ${D.length} elements`),(0,N.hu)(D.length===G[0],()=>`Element arr[${J.join("][")}] should have ${G[0]} elements, but has ${D.length} elements`);const K=G.slice(1);for(let _e=0;_e<D.length;++_e)l(D[_e],K,J.concat(_e))}function w(D,G,J,K){if("string_or_numeric"!==D){if(null==D)throw new Error("Expected dtype cannot be null.");if("numeric"!==D&&D!==G||"numeric"===D&&"string"===G)throw new Error(`Argument '${J}' passed to '${K}' must be ${D} tensor, but got ${G} tensor`)}}function M(D,G,J,K="numeric"){if(D instanceof y.es)return w(K,D.dtype,G,J),D;let _e=(0,N.D2)(D);if("string"!==_e&&["bool","int32","float32"].indexOf(K)>=0&&(_e=K),w(K,_e,G,J),null==D||!(0,I.isTypedArray)(D)&&!Array.isArray(D)&&"number"!=typeof D&&"boolean"!=typeof D&&"string"!=typeof D)throw new Error(`Argument '${G}' passed to '${J}' must be a Tensor or TensorLike, but got '${null==D?"null":D.constructor.name}'`);const Re=W(D,_e);!(0,I.isTypedArray)(D)&&!Array.isArray(D)&&(D=[D]);const We="string"!==_e?(0,I.toTypedArray)(D,_e):(0,I.flatten)(D,[],!0);return U.BV.makeTensor(We,Re,_e)}function T(D,G,J,K="numeric"){if(!Array.isArray(D))throw new Error(`Argument ${G} passed to ${J} must be a \`Tensor[]\` or \`TensorLike[]\``);return D.map((Re,we)=>M(Re,`${G}[${we}]`,J,K))}},1216:(Et,le,h)=>{"use strict";h.d(le,{$F:()=>M,Oq:()=>w,x8:()=>W,yw:()=>U,z4:()=>l});var U=function(T){return T.R0="R0",T.R1="R1",T.R2="R2",T.R3="R3",T.R4="R4",T.R5="R5",T.R6="R6",T}(U||{}),Z=function(T){return T.float32="float32",T.int32="int32",T.bool="int32",T.complex64="complex64",T}(Z||{}),y=function(T){return T.float32="float32",T.int32="int32",T.bool="bool",T.complex64="complex64",T}(y||{}),F=function(T){return T.float32="float32",T.int32="float32",T.bool="float32",T.complex64="complex64",T}(F||{}),I=function(T){return T.float32="complex64",T.int32="complex64",T.bool="complex64",T.complex64="complex64",T}(I||{});const N={float32:F,int32:Z,bool:y,complex64:I};function W(T,D){if("string"===T||"string"===D){if("string"===T&&"string"===D)return"string";throw new Error(`Can not upcast ${T} with ${D}`)}return N[T][D]}function l(T){return W(T,"int32")}function w(T){return null!=T&&"object"==typeof T&&"texture"in T&&T.texture instanceof WebGLTexture}function M(T){return typeof GPUBuffer<"u"&&null!=T&&"object"==typeof T&&"buffer"in T&&T.buffer instanceof GPUBuffer}},1153:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{arraysEqual:()=>y.cO,arraysEqualWithNull:()=>y.DK,assert:()=>y.hu,assertNonNegativeIntegerDimensions:()=>y.Mu,assertNonNull:()=>y.Cq,assertShapesMatch:()=>y.k5,bytesFromStringArray:()=>y.Ub,bytesPerElement:()=>y.bT,checkConversionForErrors:()=>y.D5,clamp:()=>y.uZ,computeStrides:()=>y.e3,convertBackendValuesAndArrayBuffer:()=>y.KS,createScalarValue:()=>De,createShuffledIndices:()=>y.U$,decodeString:()=>Te,distSquared:()=>y.E7,encodeString:()=>ye,fetch:()=>oe,fingerPrint64:()=>Le,flatten:()=>at,getArrayFromDType:()=>y.rQ,getTypedArrayFromDType:()=>y.WP,hasEncodingLoss:()=>y.QB,hexToLong:()=>W,indexToLoc:()=>y.NE,inferDtype:()=>y.D2,inferFromImplicitShape:()=>y.JZ,isBoolean:()=>y.jn,isFunction:()=>y.mf,isInt:()=>y.GN,isNumber:()=>y.hj,isPromise:()=>y.tI,isScalarShape:()=>y.xH,isString:()=>y.HD,isTypedArray:()=>v,isValidDtype:()=>y.LP,locToIndex:()=>y.qy,makeOnesTypedArray:()=>y.p8,makeZerosNestedTypedArray:()=>y.l6,makeZerosTypedArray:()=>y.wT,nearestDivisor:()=>y.jP,nearestLargerEven:()=>y.nY,now:()=>P,parseAxisParam:()=>y.EC,randUniform:()=>y.bj,repeatedTry:()=>y.WD,rightPad:()=>y.oj,shuffle:()=>y.TV,shuffleCombo:()=>y.d7,sizeFromShape:()=>y.NA,sizeToSquarishShape:()=>y.YP,squeezeShape:()=>y.bp,sum:()=>y.Sm,swap:()=>y.LF,tanh:()=>y.AE,toNestedArray:()=>y.GX,toTypedArray:()=>de});var U=h(5527),Z=h(4705),y=h(5359),F=h(186);const N=h.n(F)()||F;function W(Xe){return N.fromString(Xe,!0,16)}const l=W("c3a5c85c97cb3127"),w=W("b492b66fbe98f273"),M=W("9ae16a3b2f90404f");function T(Xe){return Xe.xor(Xe.shru(47))}function D(Xe,Ue,pt){const Ct=Xe.slice(Ue,Ue+pt);return N.fromBytes(Array.from(Ct),!0,!0)}function G(Xe,Ue){return D(Xe,Ue,8)}function J(Xe,Ue){return D(Xe,Ue,4)}function K(Xe,Ue){return 0===Ue?Xe:Xe.shru(Ue).or(Xe.shl(64-Ue))}function _e(Xe,Ue,pt=W("9ddfea08eb382d69")){let Ct=Xe.xor(Ue).mul(pt);Ct=Ct.xor(Ct.shru(47));let It=Ue.xor(Ct).mul(pt);return It=It.xor(It.shru(47)),It=It.mul(pt),It}function we(Xe,Ue,pt,Ct){return function Re(Xe,Ue,pt,Ct,It,nn){It=It.add(Xe),nn=K(nn.add(It).add(Ct),21);const Bt=It;return It=(It=It.add(Ue)).add(pt),nn=nn.add(K(It,44)),[It.add(Ct),nn.add(Bt)]}(G(Xe,Ue),G(Xe,Ue+8),G(Xe,Ue+16),G(Xe,Ue+24),pt,Ct)}function Le(Xe,Ue=Xe.length){const pt=N.fromNumber(81,!0);if(Ue<=32)return Ue<=16?function We(Xe,Ue=Xe.length){if(Ue>=8){const pt=M.add(2*Ue),Ct=G(Xe,0).add(M),It=G(Xe,Ue-8);return _e(K(It,37).mul(pt).add(Ct),K(Ct,25).add(It).mul(pt),pt)}if(Ue>=4){const pt=M.add(2*Ue);return _e(J(Xe,0).shl(3).add(Ue),J(Xe,Ue-4),pt)}if(Ue>0){const Bt=Ue+(Xe[Ue-1]<<2);return T(M.mul(Xe[0]+(Xe[Ue>>1]<<8)).xor(l.mul(Bt))).mul(M)}return M}(Xe,Ue):function Oe(Xe,Ue=Xe.length){const pt=M.add(2*Ue),Ct=G(Xe,0).mul(w),It=G(Xe,8),nn=G(Xe,Ue-8).mul(pt),Bt=G(Xe,Ue-16).mul(M);return _e(K(Ct.add(It),43).add(K(nn,30)).add(Bt),Ct.add(K(It.add(M),18)).add(nn),pt)}(Xe,Ue);if(Ue<=64)return function ie(Xe,Ue=Xe.length){const pt=M.add(2*Ue),Ct=G(Xe,0).mul(M),It=G(Xe,8),nn=G(Xe,Ue-8).mul(pt),Bt=G(Xe,Ue-16).mul(M),bn=K(Ct.add(It),43).add(K(nn,30)).add(Bt),Qn=_e(bn,Ct.add(K(It.add(M),18)).add(nn),pt),Dn=G(Xe,16).mul(pt),ps=G(Xe,24),Es=bn.add(G(Xe,Ue-32)).mul(pt),Xn=Qn.add(G(Xe,Ue-24)).mul(pt);return _e(K(Dn.add(ps),43).add(K(Es,30)).add(Xn),Dn.add(K(ps.add(Ct),18)).add(Es),pt)}(Xe,Ue);let Ct=pt,It=pt.mul(w).add(113),nn=T(It.mul(M).add(113)).mul(M),Bt=[N.UZERO,N.UZERO],bn=[N.UZERO,N.UZERO];Ct=Ct.mul(M).add(G(Xe,0));let Qn=0;const Dn=64*(Ue-1>>6),ps=Dn+(Ue-1&63)-63;do{Ct=K(Ct.add(It).add(Bt[0]).add(G(Xe,Qn+8)),37).mul(w),It=K(It.add(Bt[1]).add(G(Xe,Qn+48)),42).mul(w),Ct=Ct.xor(bn[1]),It=It.add(Bt[0]).add(G(Xe,Qn+40)),nn=K(nn.add(bn[0]),33).mul(w),Bt=we(Xe,Qn,Bt[1].mul(w),Ct.add(bn[0])),bn=we(Xe,Qn+32,nn.add(bn[1]),It.add(G(Xe,Qn+16))),[nn,Ct]=[Ct,nn],Qn+=64}while(Qn!==Dn);const Es=w.add(nn.and(255).shl(1));return Qn=ps,bn[0]=bn[0].add(Ue-1&63),Bt[0]=Bt[0].add(bn[0]),bn[0]=bn[0].add(Bt[0]),Ct=K(Ct.add(It).add(Bt[0]).add(G(Xe,Qn+8)),37).mul(Es),It=K(It.add(Bt[1]).add(G(Xe,Qn+48)),42).mul(Es),Ct=Ct.xor(bn[1].mul(9)),It=It.add(Bt[0].mul(9).add(G(Xe,Qn+40))),nn=K(nn.add(bn[0]),33).mul(Es),Bt=we(Xe,Qn,Bt[1].mul(Es),Ct.add(bn[0])),bn=we(Xe,Qn+32,nn.add(bn[1]),It.add(G(Xe,Qn+16))),[nn,Ct]=[Ct,nn],_e(_e(Bt[0],bn[0],Es).add(T(It).mul(l)).add(nn),_e(Bt[1],bn[1],Es).add(Ct),Es)}function De(Xe,Ue){return"string"===Ue?ye(Xe):de([Xe],Ue)}function de(Xe,Ue){if("string"===Ue)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(Xe)&&(Xe=at(Xe)),(0,U.OB)().getBool("DEBUG")&&y.D5(Xe,Ue),function te(Xe,Ue){return Xe instanceof Float32Array&&"float32"===Ue||Xe instanceof Int32Array&&"int32"===Ue||Xe instanceof Uint8Array&&"bool"===Ue}(Xe,Ue))return Xe;if(null==Ue||"float32"===Ue||"complex64"===Ue)return new Float32Array(Xe);if("int32"===Ue)return new Int32Array(Xe);if("bool"===Ue){const pt=new Uint8Array(Xe.length);for(let Ct=0;Ct<pt.length;++Ct)0!==Math.round(Xe[Ct])&&(pt[Ct]=1);return pt}throw new Error(`Unknown data type ${Ue}`)}function P(){return(0,U.OB)().platform.now()}function oe(Xe,Ue){return(0,U.OB)().platform.fetch(Xe,Ue)}function ye(Xe,Ue="utf-8"){return Ue=Ue||"utf-8",(0,U.OB)().platform.encode(Xe,Ue)}function Te(Xe,Ue="utf-8"){return Ue=Ue||"utf-8",(0,U.OB)().platform.decode(Xe,Ue)}function v(Xe){return null!=(0,U.OB)().platform.isTypedArray?(0,U.OB)().platform.isTypedArray(Xe):(0,Z.j)(Xe)}function at(Xe,Ue=[],pt=!1){if(null==Ue&&(Ue=[]),"boolean"==typeof Xe||"number"==typeof Xe||"string"==typeof Xe||y.tI(Xe)||null==Xe||v(Xe)&&pt)Ue.push(Xe);else if(Array.isArray(Xe)||v(Xe))for(let Ct=0;Ct<Xe.length;++Ct)at(Xe[Ct],Ue,pt);else{let Ct=-1;for(const It of Object.keys(Xe))/^([1-9]+[0-9]*|0)$/.test(It)&&(Ct=Math.max(Ct,Number(It)));for(let It=0;It<=Ct;It++)at(Xe[It],Ue,pt)}return Ue}},5359:(Et,le,h)=>{"use strict";function U(Qe){let Lt=Qe.length,Qt=0;for(;Lt>0;)Qt=Math.random()*Lt|0,Lt--,I(Qe,Lt,Qt)}function Z(Qe,Lt){if(Qe.length!==Lt.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${Qe.length}Second array length was ${Lt.length}`);let Qt=Qe.length,Nn=0;for(;Qt>0;)Nn=Math.random()*Qt|0,Qt--,I(Qe,Qt,Nn),I(Lt,Qt,Nn)}function y(Qe,Lt,Qt){return Math.max(Qe,Math.min(Lt,Qt))}function F(Qe){return Qe%2==0?Qe:Qe+1}function I(Qe,Lt,Qt){const Nn=Qe[Lt];Qe[Lt]=Qe[Qt],Qe[Qt]=Nn}function N(Qe){let Lt=0;for(let Qt=0;Qt<Qe.length;Qt++)Lt+=Qe[Qt];return Lt}function W(Qe,Lt){const Qt=Math.random();return Lt*Qt+(1-Qt)*Qe}function l(Qe,Lt){let Qt=0;for(let Nn=0;Nn<Qe.length;Nn++){const Os=Number(Qe[Nn])-Number(Lt[Nn]);Qt+=Os*Os}return Qt}function w(Qe,Lt){if(!Qe)throw new Error("string"==typeof Lt?Lt:Lt())}function M(Qe,Lt,Qt=""){w(K(Qe,Lt),()=>Qt+` Shapes ${Qe} and ${Lt} must match`)}function T(Qe){w(null!=Qe,()=>"The input to the tensor constructor must be a non-null value.")}function D(Qe){if(0===Qe.length)return 1;let Lt=Qe[0];for(let Qt=1;Qt<Qe.length;Qt++)Lt*=Qe[Qt];return Lt}function G(Qe){return 0===Qe.length}function J(Qe,Lt){if(Qe===Lt)return!0;if(null==Qe||null==Lt||Qe.length!==Lt.length)return!1;for(let Qt=0;Qt<Qe.length;Qt++)if(null!==Qe[Qt]&&null!==Lt[Qt]&&Qe[Qt]!==Lt[Qt])return!1;return!0}function K(Qe,Lt){if(Qe===Lt)return!0;if(null==Qe||null==Lt||Qe.length!==Lt.length)return!1;for(let Qt=0;Qt<Qe.length;Qt++)if(Qe[Qt]!==Lt[Qt])return!1;return!0}function _e(Qe){return Qe%1==0}function Re(Qe){if(null!=Math.tanh)return Math.tanh(Qe);if(Qe===1/0)return 1;if(Qe===-1/0)return-1;{const Lt=Math.exp(2*Qe);return(Lt-1)/(Lt+1)}}function we(Qe){const Lt=Math.ceil(Math.sqrt(Qe));return[Lt,Math.ceil(Qe/Lt)]}function We(Qe){const Lt=new Uint32Array(Qe);for(let Qt=0;Qt<Qe;++Qt)Lt[Qt]=Qt;return U(Lt),Lt}function Oe(Qe,Lt){return Lt<=Qe.length?Qe:Qe+" ".repeat(Lt-Qe.length)}function ie(Qe,Lt=(Os=>0),Qt,Nn){return new Promise((Os,zs)=>{let cr=0;const xr=()=>{if(Qe())return void Os();cr++;const $r=Lt(cr);null!=Qt&&cr>=Qt?zs():null!=Nn?Nn(xr,$r):setTimeout(xr,$r)};xr()})}function Le(Qe,Lt){let Qt=1,Nn=-1;for(let zs=0;zs<Qe.length;++zs)if(Qe[zs]>=0)Qt*=Qe[zs];else if(-1===Qe[zs]){if(-1!==Nn)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Nn} and dim ${zs}`);Nn=zs}else if(Qe[zs]<0)throw Error(`Shapes can not be < 0. Found ${Qe[zs]} at dim ${zs}`);if(-1===Nn){if(Lt>0&&Lt!==Qt)throw Error(`Size(${Lt}) must match the product of shape ${Qe}`);return Qe}if(0===Qt)throw Error(`Cannot infer the missing size in [${Qe}] when there are 0 elements`);if(Lt%Qt!=0)throw Error(`The implicit shape can't be a fractional number. Got ${Lt} / ${Qt}`);const Os=Qe.slice();return Os[Nn]=Lt/Qt,Os}function De(Qe,Lt){const Qt=Lt.length;return w((Qe=null==Qe?Lt.map((Nn,Os)=>Os):[].concat(Qe)).every(Nn=>Nn>=-Qt&&Nn<Qt),()=>`All values in axis param must be in range [-${Qt}, ${Qt}) but got axis ${Qe}`),w(Qe.every(Nn=>_e(Nn)),()=>`All values in axis param must be integers but got axis ${Qe}`),Qe.map(Nn=>Nn<0?Qt+Nn:Nn)}function te(Qe,Lt){const Qt=[],Nn=[],Os=null!=Lt&&Array.isArray(Lt)&&0===Lt.length,zs=null==Lt||Os?null:De(Lt,Qe).sort();let cr=0;for(let xr=0;xr<Qe.length;++xr){if(null!=zs){if(zs[cr]===xr&&1!==Qe[xr])throw new Error(`Can't squeeze axis ${xr} since its dim '${Qe[xr]}' is not 1`);(null==zs[cr]||zs[cr]>xr)&&1===Qe[xr]&&(Qt.push(Qe[xr]),Nn.push(xr)),zs[cr]<=xr&&cr++}1!==Qe[xr]&&(Qt.push(Qe[xr]),Nn.push(xr))}return{newShape:Qt,keptDims:Nn}}function de(Qe,Lt){return P(Qe,Lt)}function P(Qe,Lt){let Qt=null;if(null==Qe||"float32"===Qe)Qt=new Float32Array(Lt);else if("int32"===Qe)Qt=new Int32Array(Lt);else if("bool"===Qe)Qt=new Uint8Array(Lt);else{if("string"!==Qe)throw new Error(`Unknown data type ${Qe}`);Qt=new Array(Lt)}return Qt}function oe(Qe,Lt){for(let Qt=0;Qt<Qe.length;Qt++){const Nn=Qe[Qt];if(isNaN(Nn)||!isFinite(Nn))throw Error(`A tensor of type ${Lt} being uploaded contains ${Nn}.`)}}function ye(Qe){return"bool"===Qe||"complex64"===Qe||"float32"===Qe||"int32"===Qe||"string"===Qe}function Te(Qe,Lt){return!("complex64"===Lt||"float32"===Lt&&"complex64"!==Qe||"int32"===Lt&&"float32"!==Qe&&"complex64"!==Qe||"bool"===Lt&&"bool"===Qe)}function v(Qe){if("float32"===Qe||"int32"===Qe)return 4;if("complex64"===Qe)return 8;if("bool"===Qe)return 1;throw new Error(`Unknown dtype ${Qe}`)}function at(Qe){if(null==Qe)return 0;let Lt=0;return Qe.forEach(Qt=>Lt+=Qt.length),Lt}function Xe(Qe){return"string"==typeof Qe||Qe instanceof String}function Ue(Qe){return"boolean"==typeof Qe}function pt(Qe){return"number"==typeof Qe}function Ct(Qe){return Array.isArray(Qe)?Ct(Qe[0]):Qe instanceof Float32Array?"float32":Qe instanceof Int32Array||Qe instanceof Uint8Array||Qe instanceof Uint8ClampedArray?"int32":pt(Qe)?"float32":Xe(Qe)?"string":Ue(Qe)?"bool":"float32"}function It(Qe){return!!(Qe&&Qe.constructor&&Qe.call&&Qe.apply)}function nn(Qe,Lt){for(let Qt=Lt;Qt<Qe;++Qt)if(Qe%Qt==0)return Qt;return Qe}function Bt(Qe){const Lt=Qe.length;if(Lt<2)return[];const Qt=new Array(Lt-1);Qt[Lt-2]=Qe[Lt-1];for(let Nn=Lt-3;Nn>=0;--Nn)Qt[Nn]=Qt[Nn+1]*Qe[Nn+1];return Qt}function bn(Qe,Lt,Qt,Nn=!1){const Os=new Array;if(1===Lt.length){const zs=Lt[0]*(Nn?2:1);for(let cr=0;cr<zs;cr++)Os[cr]=Qt[Qe+cr]}else{const zs=Lt[0],cr=Lt.slice(1),xr=cr.reduce(($r,eo)=>$r*eo)*(Nn?2:1);for(let $r=0;$r<zs;$r++)Os[$r]=bn(Qe+$r*xr,cr,Qt,Nn)}return Os}function Qn(Qe,Lt,Qt=!1){if(0===Qe.length)return Lt[0];const Nn=Qe.reduce((Os,zs)=>Os*zs)*(Qt?2:1);if(0===Nn)return[];if(Nn!==Lt.length)throw new Error(`[${Qe}] does not match the input size ${Lt.length}${Qt?" for a complex tensor":""}.`);return bn(0,Qe,Lt,Qt)}function Dn(Qe,Lt){if(Array.isArray(Qe))return Qe;if("float32"===Lt)return Qe instanceof Float32Array?Qe:new Float32Array(Qe);if("int32"===Lt)return Qe instanceof Int32Array?Qe:new Int32Array(Qe);if("bool"===Lt||"string"===Lt)return Uint8Array.from(new Int32Array(Qe));throw new Error(`Unknown dtype ${Lt}`)}function ps(Qe,Lt){const Qt=Es(Qe,Lt);for(let Nn=0;Nn<Qt.length;Nn++)Qt[Nn]=1;return Qt}function Es(Qe,Lt){if(null==Lt||"float32"===Lt||"complex64"===Lt)return new Float32Array(Qe);if("int32"===Lt)return new Int32Array(Qe);if("bool"===Lt)return new Uint8Array(Qe);throw new Error(`Unknown data type ${Lt}`)}function Xn(Qe,Lt){const Qt=Qe.reduce((Nn,Os)=>Nn*Os,1);if(null==Lt||"float32"===Lt)return Qn(Qe,new Float32Array(Qt));if("int32"===Lt)return Qn(Qe,new Int32Array(Qt));if("bool"===Lt)return Qn(Qe,new Uint8Array(Qt));throw new Error(`Unknown data type ${Lt}`)}function Ts(Qe){Qe.forEach(Lt=>{w(Number.isInteger(Lt)&&Lt>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${Qe}].`)})}function or(Qe,Lt,Qt){if(0===Lt)return 0;if(1===Lt)return Qe[0];let Nn=Qe[Qe.length-1];for(let Os=0;Os<Qe.length-1;++Os)Nn+=Qt[Os]*Qe[Os];return Nn}function Ir(Qe,Lt,Qt){if(0===Lt)return[];if(1===Lt)return[Qe];const Nn=new Array(Lt);for(let Os=0;Os<Nn.length-1;++Os)Nn[Os]=Math.floor(Qe/Qt[Os]),Qe-=Nn[Os]*Qt[Os];return Nn[Nn.length-1]=Qe,Nn}function Ss(Qe){return Qe&&Qe.then&&"function"==typeof Qe.then}h.d(le,{AE:()=>Re,Cq:()=>T,D2:()=>Ct,D5:()=>oe,DK:()=>J,E7:()=>l,EC:()=>De,GN:()=>_e,GX:()=>Qn,HD:()=>Xe,JZ:()=>Le,KS:()=>Dn,LF:()=>I,LP:()=>ye,Mu:()=>Ts,NA:()=>D,NE:()=>Ir,QB:()=>Te,Sm:()=>N,TV:()=>U,U$:()=>We,Ub:()=>at,WD:()=>ie,WP:()=>de,YP:()=>we,bT:()=>v,bj:()=>W,bp:()=>te,cO:()=>K,d7:()=>Z,e3:()=>Bt,hj:()=>pt,hu:()=>w,jP:()=>nn,jn:()=>Ue,k5:()=>M,l6:()=>Xn,mf:()=>It,nY:()=>F,oj:()=>Oe,p8:()=>ps,qy:()=>or,rQ:()=>P,tI:()=>Ss,uZ:()=>y,wT:()=>Es,xH:()=>G})},7494:(Et,le,h)=>{"use strict";h.r(le),h.d(le,{Abs:()=>l.SYM,Acos:()=>l.VGw,Acosh:()=>l.SpW,AdadeltaOptimizer:()=>l.zJI,AdagradOptimizer:()=>l.HeW,AdamOptimizer:()=>l.a4z,AdamaxOptimizer:()=>l.DBS,Add:()=>l.mm_,AddN:()=>l.Xze,All:()=>l.oT6,Any:()=>l.IKK,ArgMax:()=>l.sJF,ArgMin:()=>l.aJk,Asin:()=>l.M2y,Asinh:()=>l.qw7,Atan:()=>l.jMg,Atan2:()=>l.QCc,Atanh:()=>l.Oyi,AvgPool:()=>l.JhU,AvgPool3D:()=>l._k9,AvgPool3DGrad:()=>l.IMb,AvgPoolGrad:()=>l.ROF,BatchMatMul:()=>l.XLW,BatchToSpaceND:()=>l.zws,Bincount:()=>l.zvY,BitwiseAnd:()=>l.hCO,BroadcastArgs:()=>l.eEB,BroadcastTo:()=>l.Ly9,Callback:()=>Ti,CallbackList:()=>D_,Cast:()=>l.RFZ,Ceil:()=>l.gJX,ClipByValue:()=>l.xnO,Complex:()=>l.Zz9,ComplexAbs:()=>l.yj2,Concat:()=>l.Eh3,Conv2D:()=>l.mhS,Conv2DBackpropFilter:()=>l.wUP,Conv2DBackpropInput:()=>l.wm,Conv3D:()=>l.x12,Conv3DBackpropFilterV2:()=>l.o2y,Conv3DBackpropInputV2:()=>l.ik2,Cos:()=>l.mc4,Cosh:()=>l.TR1,CropAndResize:()=>l.VcC,Cumprod:()=>l.Byc,Cumsum:()=>l.iHb,CustomCallback:()=>eg,DataStorage:()=>l.JLz,DenseBincount:()=>l.QRR,DepthToSpace:()=>l.T0n,DepthwiseConv2dNative:()=>l.cie,DepthwiseConv2dNativeBackpropFilter:()=>l.sL$,DepthwiseConv2dNativeBackpropInput:()=>l.y7R,Diag:()=>l.$w,Dilation2D:()=>l.p4S,Dilation2DBackpropFilter:()=>l.Vn9,Dilation2DBackpropInput:()=>l.ekb,Draw:()=>l.hGc,ENV:()=>l.ViN,EarlyStopping:()=>cd,Einsum:()=>l.$g6,Elu:()=>l.SX0,EluGrad:()=>l.HEU,Environment:()=>l.qAh,Equal:()=>l.hdR,Erf:()=>l.Omj,Exp:()=>l.NEP,ExpandDims:()=>l.YFo,Expm1:()=>l.Y0y,FFT:()=>l.vwp,Fill:()=>l.deh,FlipLeftRight:()=>l.Uyb,Floor:()=>l.OR,FloorDiv:()=>l.jeX,FromPixels:()=>l.eBW,FusedBatchNorm:()=>l.sHE,FusedConv2D:()=>l._V0,FusedDepthwiseConv2D:()=>l.luS,GPGPUContext:()=>cp.Af,GatherNd:()=>l.q1x,GatherV2:()=>l.qi_,GraphModel:()=>su.g_,Greater:()=>l.iZT,GreaterEqual:()=>l.Acj,History:()=>S_,IFFT:()=>l.Qg5,Identity:()=>l.iJz,Imag:()=>l.J_u,InputSpec:()=>pi,IsFinite:()=>l.avt,IsInf:()=>l.iWB,IsNan:()=>l.r7n,KernelBackend:()=>l.Zuw,LRN:()=>l.eZ0,LRNGrad:()=>l.Hhh,LayerVariable:()=>pu,LayersModel:()=>Jd,LeakyRelu:()=>l.J$2,Less:()=>l.vtC,LessEqual:()=>l.CAk,LinSpace:()=>l.e7N,Log:()=>l.ZbH,Log1p:()=>l.kU,LogSoftmax:()=>l.qCd,LogicalAnd:()=>l.PYm,LogicalNot:()=>l.VfG,LogicalOr:()=>l.MZg,LogicalXor:()=>l.w6g,LowerBound:()=>l.qIC,MathBackendCPU:()=>Sy,MathBackendWebGL:()=>cp.QC,MatrixBandPart:()=>l.J7O,Max:()=>l.YoZ,MaxPool:()=>l.mTV,MaxPool3D:()=>l.OAf,MaxPool3DGrad:()=>l.OU7,MaxPoolGrad:()=>l.OV7,MaxPoolWithArgmax:()=>l.vFR,Maximum:()=>l.BMI,Mean:()=>l.q2K,Min:()=>l.c17,Minimum:()=>l.q8u,MirrorPad:()=>l.jQs,Mod:()=>l.Vbg,MomentumOptimizer:()=>l.rIn,Multinomial:()=>l.NZg,Multiply:()=>l.wYn,Neg:()=>l.kuV,NonMaxSuppressionV3:()=>l.uv1,NonMaxSuppressionV4:()=>l.cye,NonMaxSuppressionV5:()=>l.W0H,NotEqual:()=>l.yQU,OP_SCOPE_SUFFIX:()=>l.zvA,OneHot:()=>l.we_,OnesLike:()=>l.qWM,Optimizer:()=>l.gaJ,OptimizerConstructors:()=>l.eEe,Pack:()=>l.QiL,PadV2:()=>l.lyA,Pool:()=>l.Kgp,Pow:()=>l.pe_,Prelu:()=>l.o0g,Prod:()=>l.DlI,RMSPropOptimizer:()=>l.gVI,RNN:()=>Yh,RaggedGather:()=>l.dDz,RaggedRange:()=>l.CQl,RaggedTensorToTensor:()=>l.BiW,Range:()=>l.e6w,Rank:()=>l.yw1,Real:()=>l.xJR,RealDiv:()=>l.oHH,Reciprocal:()=>l.$HU,Reduction:()=>l.IH3,Relu:()=>l.qkr,Relu6:()=>l.SbG,Reshape:()=>l.HZH,ResizeBilinear:()=>l._Yw,ResizeBilinearGrad:()=>l.zbQ,ResizeNearestNeighbor:()=>l.dpD,ResizeNearestNeighborGrad:()=>l.Hmb,Reverse:()=>l.mKl,RotateWithOffset:()=>l.b9H,Round:()=>l.e07,Rsqrt:()=>l.bV0,SGDOptimizer:()=>l.DYp,ScatterNd:()=>l.xQA,SearchSorted:()=>l.nr8,Select:()=>l.PhF,Selu:()=>l.oFR,Sequential:()=>am,Sigmoid:()=>l.a5O,Sign:()=>l.i5y,Sin:()=>l.RQH,Sinh:()=>l.wYB,Slice:()=>l.p2w,Softmax:()=>l.Gcp,Softplus:()=>l.MRv,SpaceToBatchND:()=>l.TQc,SparseFillEmptyRows:()=>l.O3z,SparseReshape:()=>l.nhH,SparseSegmentMean:()=>l.w3H,SparseSegmentSum:()=>l.ZjV,SparseToDense:()=>l.D2d,SplitV:()=>l.L8s,Sqrt:()=>l.FKq,Square:()=>l.bK0,SquaredDifference:()=>l._tC,StaticRegexReplace:()=>l.e0R,Step:()=>l.h8e,StridedSlice:()=>l.jQk,StringNGrams:()=>l._JP,StringSplit:()=>l.s1s,StringToHashBucketFast:()=>l.XkS,Sub:()=>l.Tr8,Sum:()=>l.GBy,SymbolicTensor:()=>Xr,Tan:()=>l.sEM,Tanh:()=>l.MIZ,Tensor:()=>l.esB,TensorBuffer:()=>l.YDk,TensorScatterUpdate:()=>l.SIB,Tile:()=>l.n9L,TopK:()=>l.cWu,Transform:()=>l.wx7,Transpose:()=>l.G3Y,Unique:()=>l.kpP,Unpack:()=>l.ToN,UnsortedSegmentSum:()=>l.Qvg,UpperBound:()=>l.XDQ,Variable:()=>l._wD,ZerosLike:()=>l.RuY,_FusedMatMul:()=>l.usg,abs:()=>l.WnP,acos:()=>l.Khb,acosh:()=>l.__u,add:()=>l.IHx,addN:()=>l.QBD,all:()=>l.$6P,any:()=>l.YjB,argMax:()=>l.NqF,argMin:()=>l.vHJ,asin:()=>l.ZRM,asinh:()=>l.VfV,atan:()=>l.z4N,atan2:()=>l.fvJ,atanh:()=>l.C80,avgPool:()=>l.wS1,avgPool3d:()=>l.uR5,backend:()=>l.y3$,backend_util:()=>l.backend_util,basicLSTMCell:()=>l.zEQ,batchNorm:()=>l.tgs,batchNorm2d:()=>l.Dxk,batchNorm3d:()=>l.JY5,batchNorm4d:()=>l.p3b,batchToSpaceND:()=>l.E4h,bincount:()=>l.yE8,bitwiseAnd:()=>l.ycw,booleanMaskAsync:()=>l.anm,broadcastArgs:()=>l.XsQ,broadcastTo:()=>l.UFq,broadcast_util:()=>l.Jyw,browser:()=>l.Xhn,buffer:()=>l.f3b,callbacks:()=>Bu,cast:()=>l.pju,ceil:()=>l.mDi,clipByValue:()=>l.iUl,clone:()=>l.d9v,complex:()=>l.PYB,concat:()=>l.zoF,concat1d:()=>l.gME,concat2d:()=>l.Izb,concat3d:()=>l.MNy,concat4d:()=>l.ZaL,constraints:()=>U,conv1d:()=>l.PAt,conv2d:()=>l.Tek,conv2dTranspose:()=>l.bc,conv3d:()=>l.pdZ,conv3dTranspose:()=>l.$QV,copyRegisteredKernels:()=>l.T3b,cos:()=>l.mCk,cosh:()=>l.f9Y,cosineWindow:()=>l.mew,cumprod:()=>l.$Gn,cumsum:()=>l.zbp,customGrad:()=>l.cbc,data:()=>W,denseBincount:()=>l.ppE,deprecationWarn:()=>l.MXe,depthToSpace:()=>l.nTT,depthwiseConv2d:()=>l.B10,deregisterOp:()=>su.Ue,device_util:()=>l.C2$,diag:()=>l.Ka3,dilation2d:()=>l.WmZ,disableDeprecationWarnings:()=>l.cFr,dispose:()=>l.B90,disposeVariables:()=>l.N8o,div:()=>l.hiC,divNoNan:()=>l.NTj,dot:()=>l.AKD,dropout:()=>l.rvX,einsum:()=>l.WYO,elu:()=>l.pyx,enableDebugMode:()=>l.Ra$,enableProdMode:()=>l.G48,enclosingPowerOfTwo:()=>l.GRh,engine:()=>l.SRH,ensureShape:()=>l.EDe,env:()=>l.OBj,equal:()=>l.DgJ,erf:()=>l.qNN,euclideanNorm:()=>l.d2q,exp:()=>l.Qqt,expandDims:()=>l.dt4,expm1:()=>l.t$B,eye:()=>l.iyy,fft:()=>l.kp_,fill:()=>l.hlL,findBackend:()=>l.x3e,findBackendFactory:()=>l.zel,floor:()=>l.GWj,floorDiv:()=>l.qPi,forceHalfFloat:()=>cp.kS,fused:()=>l.imm,gather:()=>l.Iqj,gatherND:()=>l.dbB,gather_util:()=>l.DaI,getBackend:()=>l.N_N,getGradient:()=>l.ukX,getKernel:()=>l.pIF,getKernelsForBackend:()=>l.trD,gpgpu_util:()=>cp.lz,grad:()=>l.UQy,grads:()=>l.tiA,greater:()=>l.pjt,greaterEqual:()=>l.brS,ifft:()=>l.Sxn,imag:()=>l.asL,image:()=>l.image,inTopKAsync:()=>l.V3u,initializers:()=>Z,input:()=>lm,io:()=>l.io,irfft:()=>l.wx0,isFinite:()=>l.xVT,isInf:()=>l.UWc,isNaN:()=>l.i2d,keep:()=>l.CnY,kernel_impls:()=>l.GDt,layers:()=>y,leakyRelu:()=>l.hi7,less:()=>l.d9m,lessEqual:()=>l.zN1,linalg:()=>l.$r2,linspace:()=>l.SX3,loadGraphModel:()=>su.YL,loadGraphModelSync:()=>su.fM,loadLayersModel:()=>YC,localResponseNormalization:()=>l.G9k,log:()=>l.cM7,log1p:()=>l.Krr,logSigmoid:()=>l.e_t,logSoftmax:()=>l.CmS,logSumExp:()=>l.l_t,logicalAnd:()=>l.HvI,logicalNot:()=>l.hJK,logicalOr:()=>l.K5V,logicalXor:()=>l.egP,losses:()=>l.MB5,lowerBound:()=>l.eab,matMul:()=>l.OI3,math:()=>l.mAU,max:()=>l.Fp7,maxPool:()=>l._sB,maxPool3d:()=>l.YQQ,maxPoolWithArgmax:()=>l.Ip$,maximum:()=>l.gWQ,mean:()=>l.J69,memory:()=>l.sq6,meshgrid:()=>l.ry_,metrics:()=>F,min:()=>l.VV$,minimum:()=>l.LTh,mirrorPad:()=>l.VdP,mod:()=>l.wQq,model:()=>ZC,models:()=>I,moments:()=>l.Gi7,movingAverage:()=>l.p_,mul:()=>l.dC7,multiRNNCell:()=>l.rq4,multinomial:()=>l.SJ_,neg:()=>l.W76,nextFrame:()=>l.glt,norm:()=>l.KOy,notEqual:()=>l.Quu,oneHot:()=>l.lfX,ones:()=>l.iUs,onesLike:()=>l.JpU,op:()=>l.op,outerProduct:()=>l.N2O,pad:()=>l.vku,pad1d:()=>l.pNR,pad2d:()=>l.koy,pad3d:()=>l.t1L,pad4d:()=>l.lGY,pool:()=>l.d_R,pow:()=>l.sQ3,prelu:()=>l.AL3,print:()=>l.S0v,prod:()=>l.WVs,profile:()=>l.N5s,raggedGather:()=>l.$gW,raggedRange:()=>l.VT$,raggedTensorToTensor:()=>l.N89,rand:()=>l.TN_,randomGamma:()=>l.wzB,randomNormal:()=>l.nGf,randomStandardNormal:()=>l.ruB,randomUniform:()=>l.LGj,randomUniformInt:()=>l.pe5,range:()=>l.w6H,ready:()=>l.Cd_,real:()=>l.kwC,reciprocal:()=>l.M25,registerBackend:()=>l.jqO,registerCallbackConstructor:()=>JC,registerGradient:()=>l.LiG,registerKernel:()=>l.wCN,registerOp:()=>su.iw,regularizers:()=>N,relu:()=>l.UYe,relu6:()=>l.btT,removeBackend:()=>l.cjG,reshape:()=>l.XLQ,reverse:()=>l.GYS,reverse1d:()=>l.SDf,reverse2d:()=>l.diP,reverse3d:()=>l.sx7,reverse4d:()=>l.mG2,rfft:()=>l.QEs,round:()=>l.NMM,rsqrt:()=>l.bp0,scalar:()=>l.iD$,scatterND:()=>l.snQ,scatter_util:()=>l.yV1,searchSorted:()=>l.zcT,selu:()=>l.U8D,separableConv2d:()=>l.U_I,sequential:()=>QC,serialization:()=>l.m7h,setBackend:()=>l.CQI,setPlatform:()=>l.VYu,setWebGLContext:()=>cp.nd,setdiff1dAsync:()=>l.ODp,shared:()=>iM,sigmoid:()=>l.XD2,sign:()=>l.Xxe,signal:()=>l.tdS,sin:()=>l.O$l,sinh:()=>l.R_K,slice:()=>l.tPi,slice1d:()=>l.jZU,slice2d:()=>l.SmN,slice3d:()=>l.CnO,slice4d:()=>l.p0P,slice_util:()=>l.kuN,softmax:()=>l.XAC,softplus:()=>l.Wvh,spaceToBatchND:()=>l.fBT,sparse:()=>l.rVs,sparseToDense:()=>l.ers,spectral:()=>l.uN7,split:()=>l.Vl2,sqrt:()=>l._b3,square:()=>l.h62,squaredDifference:()=>l.$i,squeeze:()=>l.L9e,stack:()=>l.knu,step:()=>l.Nbs,stridedSlice:()=>l.NXj,string:()=>l.Z_8,sub:()=>l.luU,sum:()=>l.Smz,sumOutType:()=>l.z4k,tan:()=>l.ORZ,tanh:()=>l.AEp,tensor:()=>l.XeE,tensor1d:()=>l.RRF,tensor2d:()=>l.odF,tensor3d:()=>l.wOQ,tensor4d:()=>l.yXz,tensor5d:()=>l.Bfx,tensor6d:()=>l.xZs,tensorScatterUpdate:()=>l.Pg0,tensor_util:()=>l.piX,test_util:()=>l.p3L,tidy:()=>l.lub,tile:()=>l.Gg6,time:()=>l.XVJ,topk:()=>l.hg7,train:()=>l.p_j,transpose:()=>l.p4s,truncatedNormal:()=>l.Xu6,unique:()=>l.Two,unregisterGradient:()=>l.bt3,unregisterKernel:()=>l.nEe,unsortedSegmentSum:()=>l.pUJ,unstack:()=>l.HHK,upcastType:()=>l.x8V,upperBound:()=>l.GaM,util:()=>l.D5U,valueAndGrad:()=>l.h76,valueAndGrads:()=>l.fNQ,variable:()=>l.VD$,variableGrads:()=>l.pnJ,version:()=>Mk,version_converter:()=>su.gJ,version_core:()=>l.jTM,version_cpu:()=>Kx,version_layers:()=>R_,version_webgl:()=>cp.ic,webgl:()=>cp.yO,webgl_util:()=>cp.fZ,where:()=>l.arb,whereAsync:()=>l.itS,zeros:()=>l.lls,zerosLike:()=>l.P84});var U={};h.r(U),h.d(U,{maxNorm:()=>Ym,minMaxNorm:()=>Zm,nonNeg:()=>Sp,unitNorm:()=>qf});var Z={};h.r(Z),h.d(Z,{constant:()=>Wo,glorotNormal:()=>uf,glorotUniform:()=>Jm,heNormal:()=>Xd,heUniform:()=>E_,identity:()=>C_,leCunNormal:()=>Tp,leCunUniform:()=>Ap,ones:()=>Kd,orthogonal:()=>df,randomNormal:()=>w_,randomUniform:()=>Gu,truncatedNormal:()=>Ip,varianceScaling:()=>Qm,zeros:()=>ga});var y={};h.r(y),h.d(y,{Layer:()=>gs,RNN:()=>Yh,RNNCell:()=>Zh,activation:()=>yv,add:()=>py,alphaDropout:()=>b,average:()=>Sx,averagePooling1d:()=>Pg,averagePooling2d:()=>vm,averagePooling3d:()=>bm,avgPool1d:()=>Bp,avgPool2d:()=>gy,avgPool3d:()=>_y,avgPooling1d:()=>Tx,avgPooling2d:()=>Ax,avgPooling3d:()=>Yu,batchNormalization:()=>Ix,bidirectional:()=>Mx,categoryEncoding:()=>Q,centerCrop:()=>k,concatenate:()=>bv,conv1d:()=>nu,conv2d:()=>vx,conv2dTranspose:()=>bx,conv3d:()=>uy,conv3dTranspose:()=>_v,convLstm2d:()=>qh,convLstm2dCell:()=>f1,cropping2D:()=>wx,dense:()=>Dx,depthwiseConv2d:()=>Ex,dot:()=>fy,dropout:()=>h1,elu:()=>_x,embedding:()=>hy,flatten:()=>Zn,gaussianDropout:()=>C,gaussianNoise:()=>wy,globalAveragePooling1d:()=>Fg,globalAveragePooling2d:()=>yy,globalMaxPool1d:()=>g1,globalMaxPool2d:()=>Lg,globalMaxPooling1d:()=>Cv,globalMaxPooling2d:()=>Ev,gru:()=>Ox,gruCell:()=>Rx,input:()=>lm,inputLayer:()=>d1,layerNormalization:()=>my,leakyReLU:()=>Ng,lstm:()=>Eh,lstmCell:()=>Sf,masking:()=>_,maxPool1d:()=>Px,maxPool2d:()=>xy,maxPooling1d:()=>vy,maxPooling2d:()=>Jh,maxPooling3d:()=>kx,maximum:()=>xv,minimum:()=>Mg,multiply:()=>p1,permute:()=>dy,prelu:()=>gv,randomWidth:()=>ue,reLU:()=>mv,repeatVector:()=>ym,rescaling:()=>S,reshape:()=>vv,resizing:()=>H,rnn:()=>ac,separableConv2d:()=>xx,simpleRNN:()=>Nx,simpleRNNCell:()=>Dv,softmax:()=>cy,spatialDropout1d:()=>_m,stackedRNNCells:()=>by,thresholdedReLU:()=>yx,timeDistributed:()=>m1,upSampling2d:()=>Cx,zeroPadding2d:()=>wv});var F={};h.r(F),h.d(F,{MAPE:()=>hn,MSE:()=>Us,binaryAccuracy:()=>ae,binaryCrossentropy:()=>Se,categoricalAccuracy:()=>Je,categoricalCrossentropy:()=>rt,cosineProximity:()=>Kt,mape:()=>ts,meanAbsoluteError:()=>tn,meanAbsolutePercentageError:()=>Zt,meanSquaredError:()=>us,mse:()=>_i,precision:()=>ft,recall:()=>Ot,sparseCategoricalAccuracy:()=>Ne});var I={};h.r(I),h.d(I,{modelFromJSON:()=>L0});var N={};h.r(N),h.d(N,{l1:()=>Sr,l1l2:()=>ii,l2:()=>vo});var W={};h.r(W),h.d(W,{CSVDataset:()=>E1,Dataset:()=>Tv,FileDataSource:()=>T1,TextLineDataset:()=>Av,URLDataSource:()=>A1,array:()=>lT,csv:()=>R1,func:()=>tM,generator:()=>pT,microphone:()=>sM,version_data:()=>Gx,webcam:()=>nM,zip:()=>Wx});var l=h(9075),w=h(4251),M=h(3062),T=h(8737),D=h(6034);const G={kernelName:w.SYM,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)(u,(0,D.N)((0,M.p)(o,"float32"),-1))}}};var J=h(3530),K=h(5048),_e=h(8661),Re=h(930),we=h(7527),We=h(1191);const Oe={kernelName:w.VGw,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>{const p=(0,we.h)((0,M.p)(o,"float32")),m=(0,Re._)((0,We.l)((0,_e.i)(1),p));return(0,K.W)((0,J.h)(u,m))}}}},ie={kernelName:w.SpW,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>{const p=(0,Re._)((0,We.l)((0,we.h)((0,M.p)(o,"float32")),1));return(0,J.h)(u,p)}}}};var Le=h(3239),De=h(5715),te=h(9929);const de={kernelName:w.mm_,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=Le.assertAndGetBroadcastShape(o.shape,p.shape);return{a:()=>{let $=u;const j=Le.getReductionAxes(o.shape,m);return j.length>0&&($=(0,te.S)($,j)),(0,De.X)($,o.shape)},b:()=>{let $=u;const j=Le.getReductionAxes(p.shape,m);return j.length>0&&($=(0,te.S)($,j)),(0,De.X)($,p.shape)}}}},P={kernelName:w.Xze,saveAllInputs:!0,gradFunc:(u,d)=>{const o={};return d.forEach((p,m)=>{o[m]=()=>u.clone()}),o}};var oe=h(3143);const ye={kernelName:w.sJF,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,oe.P)(o)}}},Te={kernelName:w.aJk,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,oe.P)(o)}}},v={kernelName:w.M2y,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,Re._)((0,We.l)((0,_e.i)(1),(0,we.h)((0,M.p)(o,"float32")))))}}};var at=h(7066);const Xe={kernelName:w.qw7,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>{const p=(0,Re._)((0,at.I)((0,_e.i)(1),(0,we.h)((0,M.p)(o,"float32"))));return(0,J.h)(u,p)}}}},Ue={kernelName:w.QCc,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=(0,Le.assertAndGetBroadcastShape)(o.shape,p.shape);return{a:()=>{const $=(0,at.I)((0,we.h)(o),(0,we.h)(p));let j=(0,T.d)(u,(0,J.h)(p,$));const ce=(0,Le.getReductionAxes)(o.shape,m);return ce.length>0&&(j=(0,te.S)(j,ce)),(0,De.X)(j,o.shape)},b:()=>{const $=(0,at.I)((0,we.h)(o),(0,we.h)(p));let j=(0,K.W)((0,T.d)(u,(0,J.h)(o,$)));const ce=(0,Le.getReductionAxes)(p.shape,m);return ce.length>0&&(j=(0,te.S)(j,ce)),(0,De.X)(j,p.shape)}}}},pt={kernelName:w.jMg,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,at.I)((0,we.h)((0,M.p)(o,"float32")),1))}}},Ct={kernelName:w.Oyi,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,We.l)((0,_e.i)(1),(0,we.h)((0,M.p)(o,"float32"))))}}};var It=h(687),nn=h(1257),Bt=h(5359),bn=h(5551),Qn=h(4195);const ps=(0,Qn.op)({avgPool3dGrad_:function Dn(u,d,o,p,m,x){const R=(0,nn._1)(u,"dy","avgPool3dGrad"),$=(0,nn._1)(d,"input","avgPool3dGrad");let j=R,ce=$,fe=!1;4===$.rank&&(fe=!0,j=(0,De.X)(R,[1,R.shape[0],R.shape[1],R.shape[2],R.shape[3]]),ce=(0,De.X)($,[1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]])),Bt.hu(5===j.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${j.rank}.`),Bt.hu(5===ce.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${ce.rank}.`),(0,bn.m)("avgPool3dGrad",m,x);const nt=It.BV.runKernel(w.IMb,{dy:j,input:ce},{filterSize:o,strides:p,pad:m,dimRoundingMode:x});return fe?(0,De.X)(nt,[nt.shape[1],nt.shape[2],nt.shape[3],nt.shape[4]]):nt}}),Es={kernelName:w._k9,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{filterSize:m,strides:x,pad:R,dimRoundingMode:$}=o;return{x:()=>ps(u,p,m,x,R,$)}}},Ts=(0,Qn.op)({avgPoolGrad_:function Xn(u,d,o,p,m){const x=(0,nn._1)(u,"dy","avgPoolGrad"),R=(0,nn._1)(d,"input","avgPoolGrad");Bt.hu(R.rank===x.rank,()=>`Rank of input (${R.rank}) does not match rank of dy (${x.rank})`);let $=R,j=x,ce=!1;3===R.rank&&(ce=!0,$=(0,De.X)(R,[1,R.shape[0],R.shape[1],R.shape[2]]),j=(0,De.X)(x,[1,x.shape[0],x.shape[1],x.shape[2]])),Bt.hu(4===j.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${j.rank}.`),Bt.hu(4===$.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${$.rank}.`);const ze=It.BV.runKernel(w.ROF,{dy:j,input:$},{filterSize:o,strides:p,pad:m});return ce?(0,De.X)(ze,[ze.shape[1],ze.shape[2],ze.shape[3]]):ze}}),or={kernelName:w.JhU,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{filterSize:m,strides:x,pad:R}=o;return{x:()=>Ts(u,p,m,x,R)}}};var Ir=h(5592);const Ss={kernelName:w.XLW,inputsToSave:["a","b"],gradFunc:(u,d,o)=>{const[p,m]=d,{transposeA:x,transposeB:R}=o;return x||R?!x&&R?{a:()=>(0,Ir.O)(u,m,!1,!1),b:()=>(0,Ir.O)(u,p,!0,!1)}:x&&!R?{a:()=>(0,Ir.O)(m,u,!1,!0),b:()=>(0,Ir.O)(p,u,!1,!1)}:{a:()=>(0,Ir.O)(m,u,!0,!0),b:()=>(0,Ir.O)(u,p,!0,!0)}:{a:()=>(0,Ir.O)(u,m,!1,!0),b:()=>(0,Ir.O)(p,u,!0,!1)}}};var Qe=h(9619);const Lt={kernelName:w.zws,gradFunc:(u,d,o)=>{const{blockShape:p,crops:m}=o;return{x:()=>(0,Qe.f)(u,p,m)}}},Qt={kernelName:w.Ly9,gradFunc:(u,d,o)=>{const m=o.inputShape,x=o.shape,R=Array.from(x);for(let j=m.length-1;j>=0;j--)if(m[j]===x[j])R[j]=1;else if(1!==m[j])throw new Error(`broadcastTo(): [${m}] cannot be broadcast to [${x}].`);const $=[];for(let j=0;j<R.length;j++)R[j]>1&&$.push(j);return{x:()=>(0,te.S)(u,$,!0)}}},Nn={kernelName:w.RFZ,gradFunc:u=>({x:()=>u.clone()})},Os={kernelName:w.gJX,gradFunc:u=>({x:()=>(0,oe.P)(u)})};var zs=h(9886),cr=h(2223),xr=h(3080),$r=h(2190);const eo={kernelName:w.xnO,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{clipValueMin:m,clipValueMax:x}=o;return{x:()=>(0,$r.a)((0,xr.H)((0,zs.b)(p,m),(0,cr.z)(p,x)),u,(0,oe.P)(u))}}},oa={kernelName:w.yj2,inputsToSave:["x"],gradFunc:G.gradFunc};var aa=h(8874);const Po={kernelName:w.Eh3,saveAllInputs:!0,gradFunc:(u,d,o)=>{const p=d.map(j=>j.shape),{axis:m}=o,x=(0,Bt.EC)(m,d[0].shape)[0],R=p.map(j=>j[x]);return(0,aa.V)(u,R,x).map(j=>()=>j)}};var xa=h(443),za=h(5743);const To={kernelName:w.mhS,inputsToSave:["x","filter"],gradFunc:(u,d,o)=>{const[p,m]=d,{dilations:x,strides:R,pad:$,dataFormat:j}=o;return Bt.hu(bn.I0(x),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${x}'`),{x:()=>(0,za._)(p.shape,u,m,R,$,j),filter:()=>(0,xa.p)(p,u,m.shape,R,$,j)}}};var lo=h(4451);const Ao={kernelName:w.wm,inputsToSave:["dy","filter"],gradFunc:(u,d,o)=>{const[p,m]=d,{strides:x,pad:R,dataFormat:$,dimRoundingMode:j}=o;return{dy:()=>(0,lo.T)(u,m,x,R,$,1,j),filter:()=>(0,xa.p)(u,p,m.shape,x,R,$,j)}}},sl=(0,Qn.op)({conv3DBackpropFilter_:function Ho(u,d,o,p,m){let x=u;4===u.rank&&(x=(0,De.X)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]));let R=d;return 4===R.rank&&(R=(0,De.X)(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),Bt.hu(5===x.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${x.shape}.`),Bt.hu(5===R.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${R.shape}.`),Bt.hu(5===o.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${o}.`),Bt.hu(x.shape[4]===o[3],()=>`Error in conv3dDerFilter: depth of input ${x.shape[4]}) must match input depth in filter (${o[3]}.`),Bt.hu(R.shape[4]===o[4],()=>`Error in conv3dDerFilter: depth of dy (${R.shape[4]}) must match output depth for filter (${o[4]}).`),It.BV.runKernel(w.o2y,{x,dy:R},{strides:p,pad:m,filterShape:o})}});var ka=h(7022);const to={kernelName:w.x12,inputsToSave:["x","filter"],gradFunc:(u,d,o)=>{const{dilations:p,strides:m,pad:x}=o;Bt.hu((0,bn.I0)(p),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${p}'`);const[R,$]=d;return{x:()=>(0,ka._)(R.shape,u,$,m,x),filter:()=>sl(R,u,$.shape,m,x)}}};var rl=h(2438);const Wa={kernelName:w.mc4,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)((0,K.W)((0,rl.O)((0,M.p)(o,"float32"))),u)}}};var Fo=h(319);const Ha={kernelName:w.TR1,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)((0,Fo.R)((0,M.p)(o,"float32")),u)}}};var qe=h(929),jo=h(7157),la=h(9194);const $s={kernelName:w.iHb,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{axis:m,exclusive:x,reverse:R}=o;return{x:()=>{const $=(0,qe.Q3)([m],p.rank);let j=(0,jo.z)(u,m,x,!R);return null!=$&&(j=(0,la.p)(j,$)),j}}}};var co=h(366),ui=h(519);const ja={kernelName:w.cie,inputsToSave:["x","filter"],gradFunc:(u,d,o)=>{const{dilations:p,strides:m,pad:x,dimRoundingMode:R}=o,$=p??[1,1];Bt.hu(bn.I0($),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${$}'`);const[j,ce]=d;return Bt.hu(4===j.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${j.rank}.`),Bt.hu(4===ce.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${ce.rank}.`),Bt.hu(j.shape[3]===ce.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${j.shape[3]}) must match the inChannels dimension in filter ${ce.shape[2]}.`),Bt.hu(bn.jT(m,$),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${m} and dilations '${$}'.`),bn.m("depthwiseConv2d",x,R),{x:()=>(0,ui.v)(j.shape,u,ce,m,x,$,R),filter:()=>(0,co.z)(j,u,ce.shape,m,x,$,R)}}},Go={kernelName:w.p4S,inputsToSave:["x","filter"],gradFunc:(u,d,o)=>{const[p,m]=d,x={x:p,filter:m,dy:u},R={x:p,filter:m,dy:u};return{x:()=>It.BV.runKernel(w.ekb,x,o),filter:()=>It.BV.runKernel(w.Vn9,R,o)}}},Li={kernelName:w.SX0,outputsToSave:[!0],gradFunc:(u,d)=>{const[o]=d,p={dy:u,y:o};return{x:()=>It.BV.runKernel(w.HEU,p)}}};var wa=h(5109);const Ki={kernelName:w.Omj,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d,p=(0,T.d)((0,wa.Q)((0,K.W)((0,we.h)(o))),2/Math.sqrt(Math.PI));return{x:()=>(0,T.d)(u,p)}}},Xi={kernelName:w.NEP,outputsToSave:[!0],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)(u,o)}}},$i={kernelName:w.YFo,inputsToSave:["input"],gradFunc:(u,d)=>{const[o]=d;return{input:()=>(0,De.X)(u,o.shape)}}},Bi={kernelName:w.Y0y,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)(u,(0,wa.Q)(o))}}},hl={kernelName:w.OR,gradFunc:u=>({x:()=>(0,oe.P)(u)})},Jr={kernelName:w.jeX,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=(0,Le.assertAndGetBroadcastShape)(o.shape,p.shape);return{a:()=>{const $=(0,J.h)(u,(0,M.p)(p,"float32")),j=(0,Le.getReductionAxes)(o.shape,m);return j.length>0?(0,De.X)((0,te.S)($,j),o.shape):$},b:()=>{let $=(0,T.d)(u,(0,M.p)(o,"float32"));const j=(0,Le.getReductionAxes)(p.shape,m);j.length>0&&($=(0,De.X)((0,te.S)($,j),p.shape));const ce=(0,we.h)(p);return(0,K.W)((0,J.h)($,(0,M.p)(ce,"float32")))}}}};var Lo=h(8893),dc=h(2005);const hc={kernelName:w.sHE,inputsToSave:["x","mean","variance","scale"],gradFunc:(u,d,o)=>{const{varianceEpsilon:p}=o,[m,x,R,$]=d,j=$??(0,_e.i)(1),ce=(0,Le.getReductionAxes)(x.shape,m.shape),fe=[];if(1===x.rank){for(let Ft=0;Ft<m.shape.length-1;++Ft)fe.push(m.shape[Ft]);fe.push(1)}const je=(0,We.l)(m,x),ze=(0,T.d)(u,j),nt=(0,Lo.b)((0,at.I)(R,(0,_e.i)(p))),Rt=(0,T.d)((0,T.d)((0,T.d)(nt,nt),nt),(0,_e.i)(-.5));return{x:()=>(0,De.X)((0,T.d)((0,T.d)(u,1===x.rank?(0,dc.G)((0,De.X)(nt,[1,1,1,x.shape[0]]),fe):nt),j),m.shape),mean:()=>{let Ft=(0,T.d)((0,T.d)(nt,(0,_e.i)(-1)),ze);return 1===x.rank&&(Ft=(0,te.S)(Ft,ce)),(0,De.X)(Ft,x.shape)},variance:()=>{let Ft=(0,T.d)((0,T.d)(Rt,je),ze);return 1===x.rank&&(Ft=(0,te.S)(Ft,ce)),(0,De.X)(Ft,x.shape)},scale:()=>{const Ft=(0,T.d)(je,nt);let sn=(0,T.d)(u,Ft);return 1===x.rank&&(sn=(0,te.S)(sn,ce)),(0,De.X)(sn,x.shape)},offset:()=>{let Ft=u;return 1===x.rank&&(Ft=(0,te.S)(Ft,ce)),(0,De.X)(Ft,x.shape)}}}};var Ga=h(7958),Ko=h(7715);const pc={kernelName:w.qi_,inputsToSave:["x","indices"],gradFunc:(u,d,o)=>{const[p,m]=d,{axis:x,batchDims:R}=o,$=(0,Bt.EC)(x,p.shape)[0],j=(ce,fe,je)=>()=>{const ze=ce.shape,nt=fe.size,Rt=ze.slice(0,$),bt=Rt.length,xt=ze.slice(x,ze.length).slice(1),Pt=xt.length,St=pl(0,bt),Ut=pl(bt+1,bt+1+Pt),Ft=ko([Rt,[nt],xt]),sn=(0,De.X)(je,Ft),_n=(0,De.X)(fe,[nt]),Cn=ko([[bt],St,Ut]),Bn=(0,la.p)(sn,Cn);let Vn=(0,Ko.p)(Bn,_n,ce.shape[$]);const es=(0,qe.LJ)(Cn);return Vn=(0,la.p)(Vn,es),Vn};if(1===R){const fe=p.split(p.shape[0],0);return{x:()=>(0,Ga.k)(fe.map((nt,Rt)=>j(nt,m.slice(Rt,1),u.slice(Rt,1))())).reshape(p.shape),indices:()=>m}}return{x:j(p,m,u),indices:()=>m}}};function pl(u,d){const o=[];for(let p=u;p<d;++p)o.push(p);return o}function ko(u){const d=[];for(let o=0;o<u.length;++o)for(let p=0;p<u[o].length;++p)d.push(u[o][p]);return d}const fl={kernelName:w.Acj,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d;return{a:()=>(0,oe.P)(o),b:()=>(0,oe.P)(p)}}},no={kernelName:w.iJz,gradFunc:u=>({x:()=>(0,M.p)(u,"float32")})},Ka={kernelName:w.avt,gradFunc:u=>({x:()=>(0,oe.P)(u)})},so={kernelName:w.iWB,gradFunc:u=>({x:()=>(0,oe.P)(u)})},il={kernelName:w.r7n,gradFunc:u=>({x:()=>(0,oe.P)(u)})};var Yi=h(4803);const fc={kernelName:w.J$2,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{alpha:m}=o,x=(0,Yi.p)(p,0);return{x:()=>(0,$r.a)(x,u,(0,T.d)(u,m))}}},zl={kernelName:w.kU,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,at.I)(o,1))}}},ol={kernelName:w.ZbH,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,M.p)(o,"float32"))}}},Xa={kernelName:w.qCd,inputsToSave:[],outputsToSave:[!0],gradFunc:(u,d,o)=>{const[p]=d,{axis:m}=o;return{logits:()=>{const R=(0,wa.Q)(p);return(0,We.l)(u,(0,T.d)((0,te.S)(u,m,!0),R))}}}},vi=(0,Qn.op)({localResponseNormalizationBackprop_:function Js(u,d,o,p=5,m=1,x=1,R=.5){return It.BV.runKernel(w.Hhh,{x:u,y:d,dy:o},{depthRadius:p,bias:m,alpha:x,beta:R})}}),$o={kernelName:w.eZ0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(u,d,o)=>{const[p,m]=d,{depthRadius:x,bias:R,alpha:$,beta:j}=o;return{x:()=>vi(p,m,u,x,R,$,j)}}};var Pr=h(4456);function Oa(u,d,o,p){return d.rank<o.rank&&(d=(0,De.X)(d,qe.rv(d.shape,p))),u.rank<o.rank&&(u=(0,De.X)(u,qe.rv(u.shape,p))),{x:()=>(0,T.d)(u,(0,M.p)((0,Pr.D)(o,d),u.dtype))}}const Al={kernelName:w.YoZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(u,d,o)=>{const p=o,{reductionIndices:m}=p,x=d[0],j=Oa(u,d[1],x,Bt.EC(m,x.shape));return{x:()=>j.x()}}};var uo=h(2761);const Ra={kernelName:w.BMI,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d;return{a:()=>(0,T.d)(u,(0,M.p)((0,zs.b)(o,p),"float32")),b:()=>(0,T.d)(u,(0,M.p)((0,uo.d)(o,p),"float32"))}}},Oo=(0,Qn.op)({maxPool3dGrad_:function Zi(u,d,o,p,m,x,R){const $=(0,nn._1)(u,"dy","maxPool3dGrad"),j=(0,nn._1)(d,"input","maxPool3dGrad"),ce=(0,nn._1)(o,"output","maxPool3dGrad");let fe=$,je=j,ze=ce,nt=!1;4===j.rank&&(nt=!0,fe=(0,De.X)($,[1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]]),je=(0,De.X)(j,[1,j.shape[0],j.shape[1],j.shape[2],j.shape[3]]),ze=(0,De.X)(ce,[1,ce.shape[0],ce.shape[1],ce.shape[2],ce.shape[3]])),Bt.hu(5===fe.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${fe.rank}.`),Bt.hu(5===je.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${je.rank}.`),Bt.hu(5===ze.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${ze.rank}.`),(0,bn.m)("maxPool3dGrad",x,R);const xt=It.BV.runKernel(w.OU7,{dy:fe,input:je,output:ze},{filterSize:p,strides:m,pad:x,dimRoundingMode:R});return nt?(0,De.X)(xt,[xt.shape[1],xt.shape[2],xt.shape[3],xt.shape[4]]):xt}}),Hi={kernelName:w.OAf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(u,d,o)=>{const[p,m]=d,{filterSize:x,strides:R,pad:$,dimRoundingMode:j}=o;return{x:()=>Oo(u,p,m,x,R,$,j)}}},Di=(0,Qn.op)({maxPoolGrad_:function ji(u,d,o,p,m,x,R){const $=(0,nn._1)(u,"dy","maxPoolGrad"),j=(0,nn._1)(d,"input","maxPoolGrad"),ce=(0,nn._1)(o,"output","maxPoolGrad");return Bt.hu(j.rank===$.rank,()=>`Rank of input (${j.rank}) does not match rank of dy (${$.rank})`),Bt.hu(4===$.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${$.rank}.`),Bt.hu(4===j.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${j.rank}.`),bn.m("maxPoolGrad",x,R),It.BV.runKernel(w.OV7,{dy:$,input:j,output:ce},{filterSize:p,strides:m,pad:x,dimRoundingMode:R})}}),Xs={kernelName:w.mTV,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(u,d,o)=>{const[p,m]=d,{filterSize:x,strides:R,pad:$}=o;return{x:()=>Di(u,p,m,x,R,$)}}};var ro=h(4968);const pa={kernelName:w.q2K,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{axis:m}=o,x=Bt.EC(m,p.shape),$=(0,qe.kz)(p.shape,x)[1],j=Bt.NA($);return{x:()=>{const fe=p.shape.slice();x.forEach(nt=>{fe[nt]=1});const je=(0,De.X)(u,fe);return(0,J.h)((0,T.d)(je,(0,ro.i)(p.shape,"float32")),j)}}}},Qi={kernelName:w.c17,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(u,d,o)=>{const p=o,{axis:m}=p,[x,R]=d,j=Oa(u,R,x,Bt.EC(m,x.shape));return{x:()=>j.x()}}},al={kernelName:w.q8u,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d;return{a:()=>(0,T.d)(u,(0,M.p)((0,cr.z)(o,p),"float32")),b:()=>(0,T.d)(u,(0,M.p)((0,Yi.p)(o,p),"float32"))}}};var fa=h(8317);const di={kernelName:w.jQs,inputsToSave:["x"],gradFunc:(u,d,o)=>{const p=d[0],{paddings:m}=o,x=m.map(R=>R[0]);return{x:()=>(0,fa.t)(u,x,p.shape)}}};var ma=h(8208);const mo={kernelName:w.Vbg,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=(0,Le.assertAndGetBroadcastShape)(o.shape,p.shape);return{a:()=>{const $=(0,Le.getReductionAxes)(o.shape,m);return $.length>0?(0,De.X)((0,te.S)(u,$),o.shape):u},b:()=>{const $=(0,T.d)(u,(0,K.W)((0,ma.G)((0,J.h)(o,p)))),j=(0,Le.getReductionAxes)(p.shape,m);return j.length>0?(0,De.X)((0,te.S)($,j),p.shape):$}}}},mi={kernelName:w.wYn,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=(0,Le.assertAndGetBroadcastShape)(o.shape,p.shape);return{a:()=>{const $=(0,T.d)(u,(0,M.p)(p,"float32")),j=(0,Le.getReductionAxes)(o.shape,m);return j.length>0?(0,De.X)((0,te.S)($,j),o.shape):$},b:()=>{const $=(0,T.d)(u,(0,M.p)(o,"float32")),j=(0,Le.getReductionAxes)(p.shape,m);return j.length>0?(0,De.X)((0,te.S)($,j),p.shape):$}}}},ic={kernelName:w.kuV,gradFunc:u=>({x:()=>(0,K.W)(u)})};var Br=h(6467);const dr={kernelName:w.we_,inputsToSave:["indices"],gradFunc:(u,d)=>{const o=d[0];return{indices:()=>(0,Br.l)(o.shape,"float32")}}},Xo={kernelName:w.qWM,gradFunc:u=>({x:()=>(0,oe.P)(u)})};var go=h(2219);const ml={kernelName:w.QiL,saveAllInputs:!0,gradFunc:(u,d,o)=>{const{axis:p}=o;return(0,go.H)(u,p).map(x=>()=>x)}},Na={kernelName:w.lyA,inputsToSave:["x"],gradFunc:(u,d,o)=>{const p=d[0],{paddings:m}=o,x=m.map(R=>R[0]);return{x:()=>(0,fa.t)(u,x,p.shape)}}};var En=h(5919),ki=h(2962);const wr={kernelName:w.pe_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(u,d)=>{const[o,p,m]=d,x=o,R=p,$=Le.assertAndGetBroadcastShape(x.shape,R.shape);return{a:()=>{const fe=(0,M.p)(R,"float32");let je=(0,T.d)(u,(0,T.d)(fe,(0,ki.s)(x,(0,We.l)(fe,(0,_e.i)(1)))));const ze=Le.getReductionAxes(x.shape,$);return ze.length>0&&(je=(0,te.S)(je,ze)),(0,De.X)(je,x.shape)},b:()=>{const fe=(0,Yi.p)(x,0),je=(0,$r.a)(fe,(0,En.c)(x),(0,oe.P)(x));let ze=(0,T.d)(u,(0,T.d)(m,je));const nt=Le.getReductionAxes(R.shape,$);return nt.length>0&&(ze=(0,te.S)(ze,nt)),(0,De.X)(ze,R.shape)}}}},ar={kernelName:w.o0g,inputsToSave:["x","alpha"],gradFunc:(u,d)=>{const[o,p]=d,m=(0,Yi.p)(o,0);return{x:()=>(0,$r.a)(m,u,(0,T.d)(u,p)),alpha:()=>{let x=(0,$r.a)(m,(0,oe.P)(u),(0,T.d)(u,o));const R=(0,Le.getReductionAxes)(p.shape,u.shape);return R.length>0&&(x=(0,te.S)(x,R)),(0,De.X)(x,p.shape)}}}};var Ma=h(9267);const Wl={kernelName:w.DlI,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{axis:m}=o;let x=[];return x=null==m?p.shape.map((R,$)=>$):"number"==typeof m?[m]:m,{x:()=>function qr(u,d,o){const p=u.shape.length,m=p-o.length,x=qe.Q3(o,p);let R=u;null!=x&&(R=(0,la.p)(u,x));const $=R.shape.slice(),ce=$.splice(p-o.length,o.length).reduce((ze,nt)=>ze*nt,1);$.push(ce);let je=function gn(u,d,o){const p=u.shape.slice();p[o]=1;const m=(0,De.X)(d,p),x=(0,Ma.$)(u,o,!0,!1),R=(0,Ma.$)(u,o,!0,!0),$=(0,T.d)(x,R);return(0,T.d)(m,$)}(R.reshape($),d,m);if(je=je.reshape(R.shape),null!=x){const ze=qe.LJ(x);je=(0,la.p)(je,ze)}return je}(p,u,x)}}},_o={kernelName:w.oHH,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=Le.assertAndGetBroadcastShape(o.shape,p.shape);return{a:()=>{const $=(0,J.h)(u,(0,M.p)(p,"float32")),j=Le.getReductionAxes(o.shape,m);return j.length>0?(0,De.X)((0,te.S)($,j),o.shape):$},b:()=>{let $=(0,T.d)(u,(0,M.p)(o,"float32"));const j=Le.getReductionAxes(p.shape,m);j.length>0&&($=(0,De.X)((0,te.S)($,j),p.shape));const ce=(0,we.h)(p);return(0,K.W)((0,J.h)($,(0,M.p)(ce,"float32")))}}}},mc={kernelName:w.$HU,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,K.W)((0,we.h)(o)))}}},Ro={kernelName:w.SbG,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d,p=(0,T.d)((0,cr.z)(o,6),(0,D.N)(o));return{x:()=>(0,T.d)(u,(0,M.p)(p,"float32"))}}},ll={kernelName:w.qkr,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)(u,(0,M.p)((0,D.N)(o),"float32"))}}},Si={kernelName:w.HZH,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,De.X)(u,o.shape)}}},Ca={kernelName:w._Yw,inputsToSave:["images"],gradFunc:(u,d,o)=>{const[p]=d,m={dy:u,images:p};return{images:()=>It.BV.runKernel(w.zbQ,m,o)}}},Pa={kernelName:w.dpD,inputsToSave:["images"],gradFunc:(u,d,o)=>{const[p]=d,m={dy:u,images:p};return{images:()=>It.BV.runKernel(w.Hmb,m,o)}}};var Ea=h(6825);const gl={kernelName:w.mKl,gradFunc:(u,d,o)=>{const{dims:p}=o,m=(0,Bt.EC)(p,u.shape);return{x:()=>(0,Ea.G)(u,m)}}},_l={kernelName:w.e07,gradFunc:u=>({x:()=>(0,oe.P)(u)})},q={kernelName:w.bV0,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,K.W)((0,J.h)(u,(0,T.d)((0,ki.s)(o,1.5),2)))}}};var L=h(6399);const X={kernelName:w.PhF,inputsToSave:["condition"],gradFunc:(u,d)=>{const[o]=d;return{condition:()=>(0,M.p)((0,oe.P)(o),"float32"),t:()=>(0,T.d)(u,(0,M.p)(o,u.dtype)),e:()=>(0,T.d)(u,(0,M.p)((0,L.h)(o),u.dtype))}}};var Ae=h(2152);const He={kernelName:w.oFR,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>{const p=(0,Yi.p)(o,(0,_e.i)(0)),m=(0,_e.i)(Ae.y),x=(0,_e.i)(Ae.$),R=(0,T.d)(u,x),$=(0,T.d)((0,T.d)(u,m),(0,wa.Q)((0,M.p)(o,"float32")));return(0,$r.a)(p,R,$)}}}},Ye={kernelName:w.a5O,outputsToSave:[!0],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)(u,(0,T.d)(o,(0,We.l)((0,_e.i)(1),o)))}}},it={kernelName:w.i5y,gradFunc:u=>({x:()=>(0,oe.P)(u)})};var _t=h(9018);const wt={kernelName:w.RQH,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)((0,_t.m)((0,M.p)(o,"float32")),u)}}};var kn=h(3237);const pn={kernelName:w.wYB,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)((0,kn.f)((0,M.p)(o,"float32")),u)}}};var qn=h(404),os=h(2320);const Ms={kernelName:w.p2w,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{begin:m,size:x}=o,R=p.shape,[$,j]=(0,os.parseSliceParams)(p,m,x),ce=[];for(let fe=0;fe<u.rank;fe++)ce.push([$[fe],R[fe]-$[fe]-j[fe]]);return{x:()=>(0,qn.v)(u,ce)}}},Tr={kernelName:w.Gcp,outputsToSave:[!0],gradFunc:(u,d,o)=>{const[p]=d,{dim:m}=o,R=(0,T.d)(u,p);return{logits:()=>(0,We.l)(R,(0,T.d)((0,te.S)(R,[m],!0),p))}}};var Cr=h(6139);const Is={kernelName:w.MRv,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)(u,(0,Cr.X)(o))}}};var lr=h(2782);const yo={kernelName:w.TQc,gradFunc:(u,d,o)=>{const{blockShape:p,paddings:m}=o;return{x:()=>(0,lr.E)(u,p,m)}}};var Da=h(4111);const Jt={kernelName:w.L8s,gradFunc:(u,d,o)=>{const{axis:p}=o;return{x:()=>(0,Da.z)(u,p)}}},ai={kernelName:w.FKq,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,T.d)((0,Re._)((0,M.p)(o,"float32")),2))}}},oc={kernelName:w.bK0,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)(u,(0,T.d)((0,M.p)(o,"float32"),2))}}},wo={kernelName:w._tC,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=(0,_e.i)(2);return{a:()=>(0,T.d)(u,(0,T.d)(m,(0,We.l)(o,p))),b:()=>(0,T.d)(u,(0,T.d)(m,(0,We.l)(p,o)))}}},Fa={kernelName:w.h8e,gradFunc:u=>({x:()=>(0,oe.P)(u)})},yl={kernelName:w.Tr8,inputsToSave:["a","b"],gradFunc:(u,d)=>{const[o,p]=d,m=Le.assertAndGetBroadcastShape(o.shape,p.shape);return{a:()=>{let $=u;const j=Le.getReductionAxes(o.shape,m);return j.length>0&&($=(0,te.S)($,j)),(0,De.X)($,o.shape)},b:()=>{let $=u;const j=Le.getReductionAxes(p.shape,m);return j.length>0&&($=(0,te.S)($,j)),(0,De.X)((0,K.W)($),p.shape)}}}},Fi={kernelName:w.GBy,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,m=p.shape.slice(),{axis:x}=o;(0,Bt.EC)(x,p.shape).forEach(ce=>{m[ce]=1});const $=(0,De.X)(u,m),j=(0,T.d)($,(0,ro.i)(p.shape,"float32"));return{x:()=>j}}},Yc={kernelName:w.sEM,inputsToSave:["x"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,J.h)(u,(0,we.h)((0,_t.m)(o)))}}},Wu={kernelName:w.MIZ,outputsToSave:[!0],gradFunc:(u,d)=>{const[o]=d;return{x:()=>(0,T.d)((0,We.l)((0,_e.i)(1),(0,we.h)(o)),u)}}},vl={kernelName:w.n9L,inputsToSave:["x"],gradFunc:(u,d,o)=>{const[p]=d,{reps:m}=o;return{x:()=>{let R=(0,oe.P)(p);if(1===p.rank)for(let $=0;$<m[0];++$)R=(0,at.I)(R,(0,fa.t)(u,[$*p.shape[0]],[p.shape[0]]));else if(2===p.rank)for(let $=0;$<m[0];++$)for(let j=0;j<m[1];++j)R=(0,at.I)(R,(0,fa.t)(u,[$*p.shape[0],j*p.shape[1]],[p.shape[0],p.shape[1]]));else if(3===p.rank)for(let $=0;$<m[0];++$)for(let j=0;j<m[1];++j)for(let ce=0;ce<m[2];++ce)R=(0,at.I)(R,(0,fa.t)(u,[$*p.shape[0],j*p.shape[1],ce*p.shape[2]],[p.shape[0],p.shape[1],p.shape[2]]));else{if(4!==p.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${p.rank} tensors yet.`);for(let $=0;$<m[0];++$)for(let j=0;j<m[1];++j)for(let ce=0;ce<m[2];++ce)for(let fe=0;fe<m[3];++fe)R=(0,at.I)(R,(0,fa.t)(u,[$*p.shape[0],j*p.shape[1],ce*p.shape[2],fe*p.shape[3]],[p.shape[0],p.shape[1],p.shape[2],p.shape[3]]))}return R}}}},Hl={kernelName:w.G3Y,gradFunc:(u,d,o)=>{const p=o,{perm:m}=p,x=qe.LJ(m);return{x:()=>(0,la.p)(u,x)}}},Zc={kernelName:w.ToN,gradFunc:(u,d,o)=>{const p=o,{axis:m}=p;return{value:()=>(0,Ga.k)(u,m)}}};var Oc=h(7228),Fc=h(6117),Qc=h(765);const Ai={kernelName:w.Qvg,inputsToSave:["segmentIds"],gradFunc:(u,d)=>{const[o]=d;return{x:()=>function Iu(u,d){const o=(0,Qc.g)(d,(0,oe.P)(d)),p=(0,Fc.I)(u,o);let m=(0,zs.b)(d,(0,_e.i)(0,"int32"));const x=p.rank-m.rank;for(let $=0;$<x;++$)m=(0,Oc.d)(m,$+1);m=(0,xr.H)(m,(0,ro.i)(p.shape,"bool"));const R=(0,oe.P)(p);return(0,$r.a)(m,p,R)}(u,o)}}},B={kernelName:w.RuY,gradFunc:u=>({x:()=>(0,oe.P)(u)})};var ve=h(8987);const Be=[G,Oe,ie,de,P,ye,Te,v,Xe,Ue,pt,Ct,Es,or,Ss,Lt,Qt,Nn,Os,eo,oa,Po,Ao,To,to,Wa,Ha,$s,ja,Go,_o,Li,Ki,Xi,$i,Bi,Jr,hl,hc,pc,fl,no,Ka,so,il,fc,zl,ol,Xa,$o,Al,Al,Ra,Hi,Xs,pa,Qi,al,di,mo,mi,ic,dr,Xo,ml,Na,Na,wr,ar,Wl,mc,Ro,ll,Si,Ca,Pa,gl,_l,q,X,He,Ye,it,wt,pn,Ms,Tr,Is,yo,yo,Jt,Jt,ai,wo,oc,Fa,yl,Fi,Yc,Wu,vl,Hl,Zc,Ai,B];for(const u of Be)(0,ve.Li)(u);var ot=h(6989),st=h(4945);(0,st.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,ot.W)(this)};var Xt=h(1184);(0,st.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,Xt.K)(this)};var jt=h(5622);(0,st.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,jt._)(this)},(0,st.t3)().prototype.add=function(u){return this.throwIfDisposed(),(0,at.I)(this,u)};var Yt=h(1862);(0,st.t3)().prototype.all=function(u,d){return this.throwIfDisposed(),(0,Yt.$)(this,u,d)};var xn=h(876);(0,st.t3)().prototype.any=function(u,d){return this.throwIfDisposed(),(0,xn.Y)(this,u,d)};var ss=h(5784);(0,st.t3)().prototype.argMax=function(u){return this.throwIfDisposed(),(0,ss.N)(this,u)};var Jn=h(8340);(0,st.t3)().prototype.argMin=function(u){return this.throwIfDisposed(),(0,Jn.v)(this,u)},(0,st.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,Bt.hu)(1===this.size,()=>"The array must have only 1 element."),(0,De.X)(this,[])},(0,st.t3)().prototype.asType=function(u){return this.throwIfDisposed(),(0,M.p)(this,u)},(0,st.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,De.X)(this,[this.size])},(0,st.t3)().prototype.as2D=function(u,d){return this.throwIfDisposed(),(0,De.X)(this,[u,d])},(0,st.t3)().prototype.as3D=function(u,d,o){return this.throwIfDisposed(),(0,De.X)(this,[u,d,o])},(0,st.t3)().prototype.as4D=function(u,d,o,p){return this.throwIfDisposed(),(0,De.X)(this,[u,d,o,p])},(0,st.t3)().prototype.as5D=function(u,d,o,p,m){return this.throwIfDisposed(),(0,De.X)(this,[u,d,o,p,m])};var _r=h(586);(0,st.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,_r.Z)(this)};var Qs=h(8355);(0,st.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,Qs.V)(this)};var As=h(7881);(0,st.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,As.z)(this)};var cn=h(5825);(0,st.t3)().prototype.atan2=function(u){return this.throwIfDisposed(),(0,cn.f)(this,u)};var Zr=h(7932);(0,st.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,Zr.C)(this)};var jn=h(6903);(0,st.t3)().prototype.avgPool=function(u,d,o,p){return this.throwIfDisposed(),(0,jn.w)(this,u,d,o,p)},(0,st.t3)().prototype.batchToSpaceND=function(u,d){return this.throwIfDisposed(),(0,lr.E)(this,u,d)};var Oi=h(5307);(0,st.t3)().prototype.batchNorm=function(u,d,o,p,m){return this.throwIfDisposed(),(0,Oi.t)(this,u,d,o,p,m)};var ca=h(983);(0,st.t3)().prototype.broadcastTo=function(u){return this.throwIfDisposed(),(0,ca.U)(this,u)},(0,st.t3)().prototype.cast=function(u){return this.throwIfDisposed(),(0,M.p)(this,u)};var Yo=h(9723);(0,st.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,Yo.m)(this)};var La=h(6672);(0,st.t3)().prototype.clipByValue=function(u,d){return this.throwIfDisposed(),(0,La.i)(this,u,d)},(0,st.t3)().prototype.concat=function(u,d){return this.throwIfDisposed(),u instanceof st.es&&(u=[u]),(0,Da.z)([this,...u],d)};var hi=h(8577);(0,st.t3)().prototype.conv1d=function(u,d,o,p,m,x){return this.throwIfDisposed(),(0,hi.P)(this,u,d,o,p,m,x)};var ci=h(8554);(0,st.t3)().prototype.conv2dTranspose=function(u,d,o,p,m){return this.throwIfDisposed(),(0,ci.b)(this,u,d,o,p,m)},(0,st.t3)().prototype.conv2d=function(u,d,o,p,m,x){return this.throwIfDisposed(),(0,lo.T)(this,u,d,o,p,m,x)},(0,st.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,_t.m)(this)},(0,st.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,kn.f)(this)},(0,st.t3)().prototype.cumprod=function(u,d,o){return this.throwIfDisposed(),(0,Ma.$)(this,u,d,o)},(0,st.t3)().prototype.cumsum=function(u,d,o){return this.throwIfDisposed(),(0,jo.z)(this,u,d,o)};var qt=h(3961);(0,st.t3)().prototype.depthToSpace=function(u,d){return this.throwIfDisposed(),(0,qt.n)(this,u,d)};var jl=h(1172);(0,st.t3)().prototype.depthwiseConv2d=function(u,d,o,p,m,x){return this.throwIfDisposed(),(0,jl.B)(this,u,d,o,p,m,x)};var oo=h(2395);(0,st.t3)().prototype.dilation2d=function(u,d,o,p,m){return this.throwIfDisposed(),(0,oo.W)(this,u,d,o,p,m)};var Bo=h(4373);(0,st.t3)().prototype.divNoNan=function(u){return this.throwIfDisposed(),(0,Bo.N)(this,u)},(0,st.t3)().prototype.div=function(u){return this.throwIfDisposed(),(0,J.h)(this,u)};var wi=h(5106);(0,st.t3)().prototype.dot=function(u){return this.throwIfDisposed(),(0,wi.A)(this,u)};var $a=h(9529);(0,st.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,$a.p)(this)},(0,st.t3)().prototype.equal=function(u){return this.throwIfDisposed(),(0,Pr.D)(this,u)};var Gi=h(4634);(0,st.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,Gi.q)(this)};var uu=h(4279);(0,st.t3)().prototype.euclideanNorm=function(u,d){return this.throwIfDisposed(),(0,uu.d)(this,u,d)},(0,st.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,wa.Q)(this)},(0,st.t3)().prototype.expandDims=function(u){return this.throwIfDisposed(),(0,Oc.d)(this,u)};var an=h(5748);(0,st.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,an.t)(this)};var kl=h(9738);(0,st.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,kl.k)(this)},(0,st.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,De.X)(this,[this.size])},(0,st.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,ma.G)(this)};var Gl=h(1030);(0,st.t3)().prototype.floorDiv=function(u){return this.throwIfDisposed(),(0,Gl.q)(this,u)},(0,st.t3)().prototype.gather=function(u,d,o){return this.throwIfDisposed(),(0,Fc.I)(this,u,d,o)},(0,st.t3)().prototype.greaterEqual=function(u){return this.throwIfDisposed(),(0,zs.b)(this,u)},(0,st.t3)().prototype.greater=function(u){return this.throwIfDisposed(),(0,Yi.p)(this,u)};var Tu=h(527);(0,st.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,Tu.S)(this)};var sd=h(6065);(0,st.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,sd.w)(this)};var gc=h(8821);(0,st.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,gc.x)(this)};var rd=h(8381);(0,st.t3)().prototype.isInf=function(){return this.throwIfDisposed(),(0,rd.U)(this)};var Au=h(6483);(0,st.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,Au.i)(this)};var V=h(9424);(0,st.t3)().prototype.leakyRelu=function(u){return this.throwIfDisposed(),(0,V.h)(this,u)},(0,st.t3)().prototype.lessEqual=function(u){return this.throwIfDisposed(),(0,cr.z)(this,u)},(0,st.t3)().prototype.less=function(u){return this.throwIfDisposed(),(0,uo.d)(this,u)};var O=h(1523);(0,st.t3)().prototype.localResponseNormalization=function(u,d,o,p){return this.throwIfDisposed(),(0,O.G)(this,u,d,o,p)};var z=h(4034);(0,st.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,z.e)(this)};var pe=h(6455);(0,st.t3)().prototype.logSoftmax=function(u){return this.throwIfDisposed(),(0,pe.C)(this,u)};var Pe=h(6735);(0,st.t3)().prototype.logSumExp=function(u,d){return this.throwIfDisposed(),(0,Pe.l)(this,u,d)},(0,st.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,En.c)(this)};var Ve=h(4088);(0,st.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,Ve.K)(this)},(0,st.t3)().prototype.logicalAnd=function(u){return this.throwIfDisposed(),(0,xr.H)(this,u)},(0,st.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,L.h)(this)};var et=h(2693);(0,st.t3)().prototype.logicalOr=function(u){return this.throwIfDisposed(),(0,et.K)(this,u)};var mt=h(4574);(0,st.t3)().prototype.logicalXor=function(u){return this.throwIfDisposed(),(0,mt.e)(this,u)},(0,st.t3)().prototype.matMul=function(u,d,o){return this.throwIfDisposed(),(0,Ir.O)(this,u,d,o)};var Wt=h(2444);(0,st.t3)().prototype.maxPool=function(u,d,o,p){return this.throwIfDisposed(),(0,Wt._)(this,u,d,o,p)};var mn=h(3043);(0,st.t3)().prototype.max=function(u,d){return this.throwIfDisposed(),(0,mn.F)(this,u,d)},(0,st.t3)().prototype.maximum=function(u){return this.throwIfDisposed(),(0,Qc.g)(this,u)};var rn=h(9357);(0,st.t3)().prototype.mean=function(u,d){return this.throwIfDisposed(),(0,rn.J)(this,u,d)};var $n=h(9602);(0,st.t3)().prototype.min=function(u,d){return this.throwIfDisposed(),(0,$n.V)(this,u,d)};var zn=h(2684);(0,st.t3)().prototype.minimum=function(u){return this.throwIfDisposed(),(0,zn.L)(this,u)};var Bs=h(4639);(0,st.t3)().prototype.mirrorPad=function(u,d){return this.throwIfDisposed(),(0,Bs.V)(this,u,d)};var ur=h(1612);(0,st.t3)().prototype.mod=function(u){return this.throwIfDisposed(),(0,ur.w)(this,u)},(0,st.t3)().prototype.mul=function(u){return this.throwIfDisposed(),(0,T.d)(this,u)},(0,st.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,K.W)(this)};var Rs=h(3717);(0,st.t3)().prototype.norm=function(u,d,o){return this.throwIfDisposed(),(0,Rs.K)(this,u,d,o)};var Or=h(4015);(0,st.t3)().prototype.notEqual=function(u){return this.throwIfDisposed(),(0,Or.Q)(this,u)};var zr=h(5618);(0,st.t3)().prototype.oneHot=function(u,d=1,o=0){return this.throwIfDisposed(),(0,zr.l)(this,u,d,o)};var sr=h(5034);(0,st.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,sr.J)(this)},(0,st.t3)().prototype.pad=function(u,d){return this.throwIfDisposed(),(0,qn.v)(this,u,d)};var No=h(1640);(0,st.t3)().prototype.pool=function(u,d,o,p,m,x){return this.throwIfDisposed(),(0,No.d)(this,u,d,o,p,m,x)},(0,st.t3)().prototype.pow=function(u){return this.throwIfDisposed(),(0,ki.s)(this,u)};var ho=h(1584);(0,st.t3)().prototype.prelu=function(u){return this.throwIfDisposed(),(0,ho.A)(this,u)};var Rc=h(794);(0,st.t3)().prototype.prod=function(u,d){return this.throwIfDisposed(),(0,Rc.W)(this,u,d)};var Vr=h(4831);(0,st.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,Vr.M)(this)};var Ec=h(8586);(0,st.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,Ec.U)(this)};var ku=h(4917);(0,st.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,ku.b)(this)},(0,st.t3)().prototype.reshapeAs=function(u){return this.throwIfDisposed(),(0,De.X)(this,u.shape)},(0,st.t3)().prototype.reshape=function(u){return this.throwIfDisposed(),(0,De.X)(this,u)};var Gn=h(1353);(0,st.t3)().prototype.resizeBilinear=function(u,d,o){return this.throwIfDisposed(),(0,Gn.I)(this,u,d,o)};var bl=h(7373);(0,st.t3)().prototype.resizeNearestNeighbor=function(u,d,o){return this.throwIfDisposed(),(0,bl.j)(this,u,d,o)},(0,st.t3)().prototype.reverse=function(u){return this.throwIfDisposed(),(0,Ea.G)(this,u)};var Vi=h(1638);(0,st.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,Vi.Q)(this)};var xl=h(1974);(0,st.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,xl.N)(this)},(0,st.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,Lo.b)(this)};var Kl=h(9614);(0,st.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,Kl.U)(this)};var bu=h(6762);(0,st.t3)().prototype.separableConv2d=function(u,d,o,p,m,x){return this.throwIfDisposed(),(0,bu.U)(this,u,d,o,p,m,x)},(0,st.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,Cr.X)(this)};var _c=h(4058);(0,st.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,_c.X)(this)},(0,st.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,rl.O)(this)},(0,st.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,Fo.R)(this)},(0,st.t3)().prototype.slice=function(u,d){return this.throwIfDisposed(),(0,fa.t)(this,u,d)};var Ou=h(8683);(0,st.t3)().prototype.softmax=function(u){return this.throwIfDisposed(),(0,Ou.X)(this,u)};var xd=h(4487);(0,st.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,xd.W)(this)},(0,st.t3)().prototype.spaceToBatchND=function(u,d){return this.throwIfDisposed(),(0,Qe.f)(this,u,d)},(0,st.t3)().prototype.split=function(u,d){return this.throwIfDisposed(),(0,aa.V)(this,u,d)},(0,st.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,Re._)(this)},(0,st.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,we.h)(this)};var yc=h(9539);(0,st.t3)().prototype.squaredDifference=function(u){return this.throwIfDisposed(),(0,yc.$)(this,u)};var Lc=h(2494);(0,st.t3)().prototype.squeeze=function(u){return this.throwIfDisposed(),(0,Lc.L)(this,u)},(0,st.t3)().prototype.stack=function(u,d){this.throwIfDisposed();const o=u instanceof st.es?[this,u]:[this,...u];return(0,Ga.k)(o,d)},(0,st.t3)().prototype.step=function(u){return this.throwIfDisposed(),(0,D.N)(this,u)};var Ru=h(5367);(0,st.t3)().prototype.stridedSlice=function(u,d,o,p,m,x,R,$){return this.throwIfDisposed(),(0,Ru.N)(this,u,d,o,p,m,x,R,$)},(0,st.t3)().prototype.sub=function(u){return this.throwIfDisposed(),(0,We.l)(this,u)},(0,st.t3)().prototype.sum=function(u,d){return this.throwIfDisposed(),(0,te.S)(this,u,d)};var Sa=h(2500);(0,st.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,Sa.O)(this)};var Ws=h(5987);(0,st.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,Ws.A)(this)},(0,st.t3)().prototype.tile=function(u){return this.throwIfDisposed(),(0,dc.G)(this,u)},(0,st.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,M.p)(this,"bool")},(0,st.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,M.p)(this,"float32")},(0,st.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,M.p)(this,"int32")};var Wr=h(4927);(0,st.t3)().prototype.topk=function(u,d){return this.throwIfDisposed(),(0,Wr.h)(this,u,d)},(0,st.t3)().prototype.transpose=function(u){return this.throwIfDisposed(),(0,la.p)(this,u)};var Mo=h(8130);(0,st.t3)().prototype.unique=function(u){return this.throwIfDisposed(),(0,Mo.T)(this,u)},(0,st.t3)().prototype.unsortedSegmentSum=function(u,d){return this.throwIfDisposed(),(0,Ko.p)(this,u,d)},(0,st.t3)().prototype.unstack=function(u){return this.throwIfDisposed(),(0,go.H)(this,u)},(0,st.t3)().prototype.where=function(u,d){return this.throwIfDisposed(),(0,$r.a)(u,this,d)},(0,st.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,oe.P)(this)};class Eo extends Error{constructor(d){super(d),Object.setPrototypeOf(this,Eo.prototype)}}class Ol extends Error{constructor(d){super(d),Object.setPrototypeOf(this,Ol.prototype)}}class ln extends Error{constructor(d){super(d),Object.setPrototypeOf(this,ln.prototype)}}class ei extends Error{constructor(d){super(d),Object.setPrototypeOf(this,ei.prototype)}}class ua extends Error{constructor(d){super(d),Object.setPrototypeOf(this,ua.prototype)}}class Mc{constructor(d){this.maxEntries=d||100,this.cache=new Map}get(d){let o;return this.cache.has(d)&&(o=this.cache.get(d),this.cache.delete(d),this.cache.set(d,o)),o}put(d,o){if(this.cache.has(d))this.cache.delete(d);else if(this.cache.size>=this.maxEntries){const p=this.cache.keys().next().value;this.cache.delete(p)}this.cache.set(d,o)}getMaxEntries(){return this.maxEntries}setMaxEntries(d){if(d<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${d}.`);if(this.maxEntries>d)for(let o=0;o<this.maxEntries-d;o++){const p=this.cache.keys().next().value;this.cache.delete(p)}this.maxEntries=d}}function Ur(u,d){if(Array.isArray(u)){let o=[];for(let p=0;p<d;p++)o=o.concat(u);return o}{const o=new Array(d);return o.fill(u),o}}function wl(u,d){if(!u)throw new ua(d)}function wd(u,d){let o=0;for(const p of u)p===d&&o++;return o}function Do(u){return 1===u.length?u[0]:u}function ks(u){return Array.isArray(u)?u:[u]}function Me(u){const o=u.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==o[0]?o:"private"+o}function ge(u){return u.length<=1||-1===u.indexOf("_")?u:u.replace(/[_]+(\w|$)/g,(d,o)=>o.toUpperCase())}let ke={};function Ke(u){if(null==u)return null;const d={};return d.className=u.getClassName(),d.config=u.getConfig(),d}function dt(u){if(null!=u&&"object"==typeof u)if(Array.isArray(u))u.forEach(d=>dt(d));else{const d=Object.keys(u);for(const o of d){const p=u[o];null!=p&&"object"==typeof p&&(Array.isArray(p)||"ndarray"!==p.type||"number"!=typeof p.value?dt(p):u[o]=p.value)}}}function $t(u,d={},o={},p="object",m=!1){if("string"==typeof u){let R;if(u in o)R=o[u];else if(u in ke)R=ke[u];else if(R=d[u],null==R)throw new ln(`Unknown ${p}: ${u}. This may be due to one of the following reasons:\n1. The ${p} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${p} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return R}{const x=u;if(null==x.className||null==x.config)throw new ln(`${p}: Improper config format: ${JSON.stringify(x)}.\n'className' and 'config' must set.`);const R=x.className;let $,j;if(R in o?[$,j]=o[R]:R in ke?[$,j]=ke.className:R in d&&([$,j]=d[R]),null==$)throw new ln(`Unknown ${p}: ${R}. This may be due to one of the following reasons:\n1. The ${p} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${p} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=j){const ce={};for(const nt of Object.keys(ke))ce[nt]=ke[nt];for(const nt of Object.keys(o))ce[nt]=o[nt];x.config.customObjects=ce;const je=Object.assign({},ke);for(const nt of Object.keys(o))ke[nt]=o[nt];dt(x.config);const ze=j($,x.config,o,m);return ke=Object.assign({},je),ze}{const ce=Object.assign({},ke);for(const je of Object.keys(o))ke[je]=o[je];const fe=new $(x.config);return ke=Object.assign({},ce),fe}}}function Sn(u,d){return-1*function dn(u,d){return u<d?-1:u>d?1:0}(u,d)}function xe(u){if(null==u)return u;const d=[];for(const o of u)-1===d.indexOf(o)&&d.push(o);return d}function ee(u){if(null==u)throw new ln(`Invalid value in obj: ${JSON.stringify(u)}`);for(const d in u)if(u.hasOwnProperty(d))return!1;return!0}function me(u,d,o){if(null!=o&&u.indexOf(o)<0)throw new ln(`${o} is not a valid ${d}.  Valid values are ${u} or null/undefined.`)}function Fe(u,d,o=0,p=1/0){return wl(o>=0),wl(p>=o),Array.isArray(u)&&u.length>=o&&u.length<=p&&u.every(m=>typeof m===d)}function gt(u,d){Array.isArray(u)?(l.D5U.assert(u.length>0,()=>`${d} is unexpectedly an empty array.`),u.forEach((o,p)=>gt(o,`element ${p+1} of ${d}`))):l.D5U.assert(Number.isInteger(u)&&u>0,()=>`Expected ${d} to be a positive integer, but got ${At(u)}.`)}function At(u){return null===u?"null":Array.isArray(u)?"["+u.map(d=>At(d)).join(",")+"]":"string"==typeof u?`"${u}"`:`${u}`}function Pn(u){return"relu"===u?"relu":"linear"===u?"linear":"elu"===u?"elu":null}let Kn=0;function Ln(){return Kn++}const An={};function vs(u=""){return u in An||(An[u]=0),An[u]+=1,u+An[u].toString()}const ir=["channelsFirst","channelsLast"],Er=["nearest","bilinear"],gi=["valid","same","causal"],So=["max","avg"],vc=["sum","mul","concat","ave"],Qo=new Map;function Ci(u){me(ir,"DataFormat",u)}function cl(u){me(gi,"PaddingMode",u)}function id(u){me(So,"PoolMode",u)}const Dc=[];function $c(u,d){Dc.push(u);try{const o=d();return Dc.pop(),o}catch(o){throw Dc.pop(),o}}function Vf(u){if(!Ph(u))throw new Error("Not a valid tensor name: '"+u+"'");return function Mh(){return 0===Dc.length?"":Dc.join("/")+"/"}()+u}function Uf(u){if(!Ph(u))throw new Error("Not a valid tensor name: '"+u+"'");Qo.has(u)||Qo.set(u,0);const d=Qo.get(u);if(Qo.set(u,Qo.get(u)+1),d>0){const o=`${u}_${d}`;return Qo.set(o,1),o}return u}const Km=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Ph(u){return!!u.match(Km)}function Zp(u){return u===parseInt(u.toString(),10)}function Sc(u,d,o){null==d&&(d=0),null==o&&(o=u.length);let p=1;for(let m=d;m<o;++m)p*=u[m];return p}function dh(u){if(0===u.length)return Number.NaN;let d=Number.POSITIVE_INFINITY;for(let o=0;o<u.length;o++){const p=u[o];p<d&&(d=p)}return d}function Nu(u){if(0===u.length)return Number.NaN;let d=Number.NEGATIVE_INFINITY;for(let o=0;o<u.length;o++){const p=u[o];p>d&&(d=p)}return d}function Jc(u,d){if(d<u)throw new ln(`end (${d}) < begin (${u}) is forbidden.`);const o=[];for(let p=u;p<d;++p)o.push(p);return o}let Ya;function Ba(){return null==Ya&&(Ya=(0,l.y3$)().epsilon()),Ya}function qc(u,d){return l.pju(u,d)}function od(u,d=-1){const o=u.shape.slice();return d<0&&(d=o.length+d+1),o.splice(d,0,1),l.XLQ(u,o)}function Nl(u,d,o){return(0,l.lub)(()=>{switch(u.rank){case 1:return l.jZU(u,d,o);case 2:return l.SmN(u,[d,0],[o,u.shape[1]]);case 3:return l.CnO(u,[d,0,0],[o,u.shape[1],u.shape[2]]);case 4:return l.p0P(u,[d,0,0,0],[o,u.shape[1],u.shape[2],u.shape[3]]);case 5:return l.tPi(u,[d,0,0,0,0],[o,u.shape[1],u.shape[2],u.shape[3],u.shape[4]]);case 6:return l.tPi(u,[d,0,0,0,0,0],[o,u.shape[1],u.shape[2],u.shape[3],u.shape[4],u.shape[5]]);default:throw new ln(`sliceAlongFirstAxis() received an unsupported tensor rank: ${u.rank}`)}})}function xu(u,d,o){return(0,l.lub)(()=>{switch(u.rank){case 1:return l.jZU(u,d,o);case 2:return l.SmN(u,[0,d],[u.shape[0],o]);case 3:return l.CnO(u,[0,0,d],[u.shape[0],u.shape[1],o]);case 4:return l.p0P(u,[0,0,0,d],[u.shape[0],u.shape[1],u.shape[2],o]);default:throw new ln(`sliceAlongLastAxis() received an unsupported tensor rank: ${u.rank}`)}})}function ju(u,d,o,p){return(0,l.lub)(()=>{switch(u.rank){case 1:return l.jZU(u,d,o);case 2:switch(p){case 1:return Nl(u,d,o);case 2:return xu(u,d,o);default:throw new ln(`The axis is not within the rank of the tensor ${p}`)}case 3:switch(p){case 1:return Nl(u,d,o);case 2:return l.CnO(u,[0,d,0],[u.shape[0],o,u.shape[2]]);case 3:return xu(u,d,o);default:throw new ln(`The axis is not within the rank of the tensor ${p}`)}case 4:switch(p){case 1:return Nl(u,d,o);case 2:return l.p0P(u,[0,d,0,0],[u.shape[0],o,u.shape[2],u.shape[3]]);case 3:return l.p0P(u,[0,0,d,0],[u.shape[0],u.shape[1],o,u.shape[3]]);case 4:return xu(u,d,o);default:throw new ln(`The axis is not within the rank of the tensor ${p}`)}default:throw new ln(`sliceAlongLastAxis() received an unsupported tensor rank: ${u.rank}`)}})}function $h(u,d=-1){let o;return d<0&&(o=u[0].rank,d=0!==o?o:0),d===u[0].rank&&(d=-1),l.zoF(u,d)}function Hf(u,d){switch(u.rank){case 1:return l.gME([u,d]);case 2:return l.Izb([u,d],0);case 3:return l.MNy([u,d],0);case 4:return l.ZaL([u,d],0);default:throw new ln(`concatAlongFirstAxis() received an unsupported tensor rank: ${u.rank}`)}}function ph(u,d){if(Array.isArray(d)||(d=[d]),u.rank!==d.length)throw new ln(`The length of input n (${d.length}) does not match the number of dimensions in input x (${u.rank})`);return l.Gg6(u,d)}function Hd(u,d=0,o=1,p,m){return l.nGf(u,d,o,p,m)}function bc(u,d,o,p){if(u.rank<2||d.rank<2)throw new ei(`dot requires both inputs to be rank >= 2 but got x shape = ${u.shape} and y shape = ${d.shape}`);if(d.rank>=3&&u.shape.slice(-1)[0]!==d.shape.slice(-2)[0])throw new ei(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${u.shape} and  y shape = ${d.shape}`);if(2===u.rank&&2===d.rank)return l.imm.matMul({a:u,b:d,transposeA:!1,transposeB:!1,bias:p?fh(u.rank,p,"channelsLast"):null,activation:o});{const m=u.shape.slice(),x=m.pop();u=l.XLQ(u,[-1,x]);const R=d.shape.slice(),$=R.pop(),j=R.pop(),ce=[...R,$],fe=Array.from({length:d.rank},(Rt,bt)=>0===bt?d.rank-2:bt<=d.rank-2?bt-1:bt);d=l.XLQ(l.p4s(d,fe),[j,-1]);const je=[...m,...ce];return l.XLQ(l.imm.matMul({a:u,b:d,transposeA:!1,transposeB:!1,bias:p?fh(u.rank,p,"channelsLast"):null,activation:o}),je)}}function Pc(u,d,o){return(0,l.lub)(()=>(d=Array.isArray(d)?(0,l.RRF)(d,"int32"):l.pju(d,"int32"),l.Iqj(u,d,o)))}function Ed(u){return l.dC7(u,u)}function fh(u,d,o){const p=d.shape;if(1!==d.rank&&d.rank!==u)throw new ln(`Unexpected bias dimensions: ${d.rank}; expected it to be 1 or ${u}`);if(5===u){if("channelsFirst"===o)return l.XLQ(d,1===p.length?[1,p[0],1,1,1]:[1,p[3],p[0],p[1],p[2]]);if("channelsLast"===o)return l.XLQ(d,1===p.length?[1,1,1,1,p[0]]:[1].concat(p))}else if(4===u){if("channelsFirst"===o)return l.XLQ(d,1===p.length?[1,p[0],1,1]:[1,p[2],p[0],p[1]]);if("channelsLast"===o)return l.XLQ(d,1===p.length?[1,1,1,p[0]]:[1].concat(p))}else if(3===u){if("channelsFirst"===o)return l.XLQ(d,1===p.length?[1,p[0],1]:[1,p[1],p[0]]);if("channelsLast"===o)return l.XLQ(d,1===p.length?[1,1,p[0]]:[1].concat(p))}else if(u<3)return d;throw new ln(`Unsupported input rank by biasAdd: ${d.rank}`)}function Mu(u,d,o){return(0,l.lub)(()=>(null==o&&(o="channelsLast"),Ci(o),l.IHx(u,fh(u.rank,d,o))))}function yp(u,d,o,p){return(0,l.lub)(()=>l.rvX(u,d,o,p))}function jd(u,d,o=!1){return o?u():d()}const Gf=["fanIn","fanOut","fanAvg"],nf=["normal","uniform","truncatedNormal"];class Vc extends l.m7h.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}let vp=(()=>{class u extends Vc{apply(o,p){return(0,l.lls)(o,p)}}return u.className="Zeros",u})();l.m7h.registerClass(vp);let bp=(()=>{class u extends Vc{apply(o,p){return(0,l.iUs)(o,p)}}return u.className="Ones",u})();l.m7h.registerClass(bp);let Ia=(()=>{class u extends Vc{constructor(o){if(super(),"object"!=typeof o)throw new ln(`Expected argument of type ConstantConfig but got ${o}`);if(void 0===o.value)throw new ln(`config must have value set but got ${o}`);this.value=o.value}apply(o,p){return(0,l.lub)(()=>(0,l.dC7)((0,l.iD$)(this.value),(0,l.iUs)(o,p)))}getConfig(){return{value:this.value}}}return u.className="Constant",u})();l.m7h.registerClass(Ia);let xp=(()=>{class u extends Vc{constructor(o){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=o.minval||this.DEFAULT_MINVAL,this.maxval=o.maxval||this.DEFAULT_MAXVAL,this.seed=o.seed}apply(o,p){return(0,l.LGj)(o,this.minval,this.maxval,p,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return u.className="RandomUniform",u})();l.m7h.registerClass(xp);let Dd=(()=>{class u extends Vc{constructor(o){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=o.mean||this.DEFAULT_MEAN,this.stddev=o.stddev||this.DEFAULT_STDDEV,this.seed=o.seed}apply(o,p){if("float32"!==(p=p||"float32")&&"int32"!==p)throw new ei(`randomNormal does not support dType ${p}.`);return Hd(o,this.mean,this.stddev,p,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return u.className="RandomNormal",u})();l.m7h.registerClass(Dd);let af=(()=>{class u extends Vc{constructor(o){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=o.mean||this.DEFAULT_MEAN,this.stddev=o.stddev||this.DEFAULT_STDDEV,this.seed=o.seed}apply(o,p){if("float32"!==(p=p||"float32")&&"int32"!==p)throw new ei(`truncatedNormal does not support dType ${p}.`);return(0,l.Xu6)(o,this.mean,this.stddev,p,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return u.className="TruncatedNormal",u})();l.m7h.registerClass(af);let wp=(()=>{class u extends Vc{constructor(o){super(),this.gain=null!=o.gain?o.gain:1}apply(o,p){return(0,l.lub)(()=>{if(2!==o.length||o[0]!==o[1])throw new ln("Identity matrix initializer can only be used for 2D square matrices.");return(0,l.dC7)(this.gain,(0,l.iyy)(o[0]))})}getConfig(){return{gain:this.gain}}}return u.className="Identity",u})();l.m7h.registerClass(wp);let Uc=(()=>{class u extends Vc{constructor(o){if(super(),o.scale<0)throw new ln(`scale must be a positive float. Got: ${o.scale}`);this.scale=null==o.scale?1:o.scale,this.mode=null==o.mode?"fanIn":o.mode,function Kf(u){me(Gf,"FanMode",u)}(this.mode),this.distribution=null==o.distribution?"normal":o.distribution,function rf(u){me(nf,"Distribution",u)}(this.distribution),this.seed=o.seed}apply(o,p){const m=function lf(u,d="channelsLast"){let o,p;if(Ci(d),2===u.length)o=u[0],p=u[1];else if(-1!==[3,4,5].indexOf(u.length)){if("channelsFirst"===d){const m=Sc(u,2);o=u[1]*m,p=u[0]*m}else if("channelsLast"===d){const m=Sc(u,0,u.length-2);o=u[u.length-2]*m,p=u[u.length-1]*m}}else{const m=Sc(u);o=Math.sqrt(m),p=Math.sqrt(m)}return[o,p]}(o),x=m[0],R=m[1];let $=this.scale;if($/="fanIn"===this.mode?Math.max(1,x):"fanOut"===this.mode?Math.max(1,R):Math.max(1,(x+R)/2),"normal"===this.distribution){const j=Math.sqrt($);if("float32"!==(p=p||"float32")&&"int32"!==p)throw new ei(`${this.getClassName()} does not support dType ${p}.`);return(0,l.Xu6)(o,0,j,p,this.seed)}{const j=Math.sqrt(3*$);return(0,l.LGj)(o,-j,j,p,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return u.className="VarianceScaling",u})();l.m7h.registerClass(Uc);let mh=(()=>{class u extends Uc{constructor(o){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==o?null:o.seed})}getClassName(){return Uc.className}}return u.className="GlorotUniform",u})();l.m7h.registerClass(mh);let Cp=(()=>{class u extends Uc{constructor(o){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==o?null:o.seed})}getClassName(){return Uc.className}}return u.className="GlorotNormal",u})();l.m7h.registerClass(Cp);let hu=(()=>{class u extends Uc{constructor(o){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==o?null:o.seed})}getClassName(){return Uc.className}}return u.className="HeNormal",u})();l.m7h.registerClass(hu);let Bh=(()=>{class u extends Uc{constructor(o){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==o?null:o.seed})}getClassName(){return Uc.className}}return u.className="HeUniform",u})();l.m7h.registerClass(Bh);let gh=(()=>{class u extends Uc{constructor(o){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==o?null:o.seed})}getClassName(){return Uc.className}}return u.className="LeCunNormal",u})();l.m7h.registerClass(gh);let Vo=(()=>{class u extends Uc{constructor(o){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==o?null:o.seed})}getClassName(){return Uc.className}}return u.className="LeCunUniform",u})();l.m7h.registerClass(Vo);let _h=(()=>{class u extends Vc{constructor(o){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==o.gain?this.DEFAULT_GAIN:o.gain,this.seed=o.seed}apply(o,p){return(0,l.lub)(()=>{if(o.length<2)throw new ei("Shape must be at least 2D.");if("int32"!==p&&"float32"!==p&&void 0!==p)throw new TypeError(`Unsupported data type ${p}.`);const m=l.D5U.sizeFromShape(o.slice(0,-1)),x=o[o.length-1],R=m*x;R>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${R}) elements: Slowness may result.`);const j=Hd([Math.max(x,m),Math.min(x,m)],0,1,p,this.seed),ce=l.$r2.qr(j,!1);let fe=ce[0];const ze=ce[1].flatten().stridedSlice([0],[Math.min(x,m)*Math.min(x,m)],[Math.min(x,m)+1]);return fe=(0,l.dC7)(fe,ze.sign()),m<x&&(fe=fe.transpose()),(0,l.dC7)((0,l.iD$)(this.gain),fe.reshape(o))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return u.className="Orthogonal",u})();l.m7h.registerClass(_h);const Vh={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Ic(u,d={}){return $t(u,l.m7h.SerializationMap.getMap().classNameMap,d,"initializer")}function Va(u){return Ke(u)}function Uo(u){if("string"==typeof u){const d=u in Vh?Vh[u]:u;if("GlorotNormal"===d)return new Cp;if("GlorotUniform"===d)return new mh;if("HeNormal"===d)return new hu;if("HeUniform"===d)return new Bh;if("LeCunNormal"===d)return new gh;if("LeCunUniform"===d)return new Vo;{const o={};return o.className=d,o.config={},Ic(o)}}return u instanceof Vc?u:Ic(u)}function Xl(u){return Array.isArray(u)&&Array.isArray(u[0])}function Tc(u){return 0===u.length?[]:Array.isArray(u[0])?u:[u]}function li(u){let d;if(Array.isArray(u)){if(1!==u.length)throw new ln(`Expected Tensor length to be 1; got ${u.length}`);d=u[0]}else d=u;return d}function ao(u){if(Array.isArray(u)&&Array.isArray(u[0])){if(1===u.length)return u[0];throw new ln(`Expected exactly 1 Shape; got ${u.length}`)}return u}function Uh(u){let d=0;for(const o of u)d+=0===o.shape.length?1:o.shape.reduce((p,m)=>p*m);return d}const Pu="Variable";class pu{constructor(d,o="float32",p=Pu,m=!0,x=null){this.dtype=o??"float32",this.shape=d.shape,this.id=Ln(),this.originalName=Vf(p=p??Pu),this.name=Uf(this.originalName),this.trainable_=m,this.constraint=x,this.val=l.VD$(d,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(d){return this.assertNotDisposed(),function Xf(u,d){if(u.shape.toString()!==d.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(u.shape)+" vs. "+JSON.stringify(d.shape))}(this.val,d),this.val.id!==d.id&&(this.val.assign(d),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(d){this.trainable_=d,this.val.trainable=d}}function js(u){return u.map(d=>d.read())}function pr(u){u.forEach(d=>{d[0].write(d[1])})}class pi{constructor(d){this.dtype=d.dtype,this.shape=d.shape,this.ndim=null!=d.shape?d.shape.length:d.ndim,this.maxNDim=d.maxNDim,this.minNDim=d.minNDim,this.axes=d.axes||{}}}class Xr{constructor(d,o,p,m,x,R,$){this.dtype=d,this.shape=o,this.sourceLayer=p,this.inputs=m,this.callArgs=x,this.outputTensorIndex=$,this.id=Ln(),null!=R&&(this.originalName=Vf(R),this.name=Uf(this.originalName)),this.rank=o.length}}let Fn=0;class Fr{constructor(d,o){this.callArgs=o,this.id=Fn++,this.outboundLayer=d.outboundLayer,this.inboundLayers=d.inboundLayers,this.nodeIndices=d.nodeIndices,this.tensorIndices=d.tensorIndices,this.inputTensors=d.inputTensors,this.outputTensors=d.outputTensors,this.inputMasks=d.inputMasks,this.outputMasks=d.outputMasks,this.inputShapes=d.inputShapes,this.outputShapes=d.outputShapes;for(const p of d.inboundLayers)p?.outboundNodes.push(this);d.outboundLayer.inboundNodes.push(this)}getConfig(){const d=[];for(const o of this.inboundLayers)d.push(null!=o?o.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:d,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let hr=0;class gs extends l.m7h.Serializable{constructor(d={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hr++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let o=d.name;if(!o){const p=this.getClassName();o=Me(p)+"_"+vs(p)}if(this.name=o,this.trainable_=null==d.trainable||d.trainable,null!=d.inputShape||null!=d.batchInputShape){let p;if(null!=d.batchInputShape)p=d.batchInputShape;else if(null!=d.inputShape){let x=null;null!=d.batchSize&&(x=d.batchSize),p=[x].concat(d.inputShape)}this.batchInputShape=p;let m=d.dtype;null==m&&(m=d.inputDType),null==m&&(m="float32"),this.dtype=m}this.initialWeights=null!=d.weights?d.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(d,o){return d.name+"_ib-"+o.toString()}getNodeAtIndex(d,o){if(0===this.inboundNodes.length)throw new Ol(`The layer has never been called and thus has no defined ${o}.`);if(this.inboundNodes.length<=d)throw new ln(`Asked to get ${o} at node ${d}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[d]}getInputAt(d){return Do(this.getNodeAtIndex(d,"input").inputTensors)}getOutputAt(d){return Do(this.getNodeAtIndex(d,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Eo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Eo(`Layer ${this.name} is not connected, no input to return.`);return Do(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Eo(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Eo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Do(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(d=>d())}get updates(){return this._updates}get built(){return this._built}set built(d){this._built=d}get trainable(){return this.trainable_}set trainable(d){this._trainableWeights.forEach(o=>o.trainable=d),this.trainable_=d}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(d=>d.trainable):[]}set trainableWeights(d){this._trainableWeights=d}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(d=>!d.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(d){this._nonTrainableWeights=d}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(d){const o=ks(d);if(null==this.inputSpec||0===this.inputSpec.length)return;const p=ks(this.inputSpec);if(o.length!==p.length)throw new ln(`Layer ${this.name} expects ${p.length} inputs, but it received ${o.length} input tensors. Input received: ${d}`);for(let m=0;m<o.length;m++){const x=o[m],R=p[m];if(null==R)continue;const $=x.rank;if(null!=R.ndim&&$!==R.ndim)throw new ln(`Input ${m} is incompatible with layer ${this.name}: expected ndim=${R.ndim}, found ndim=${$}`);if(null!=R.maxNDim&&$>R.maxNDim)throw new ln(`Input ${m} is incompatible with layer ${this.name}: expected max_ndim=${R.maxNDim}, found ndim=${$}`);if(null!=R.minNDim&&$<R.minNDim)throw new ln(`Input ${m} is incompatible with layer ${this.name}: expected min_ndim=${R.minNDim}, found ndim=${$}.`);if(null!=R.dtype&&x.dtype!==R.dtype)throw new ln(`Input ${m} is incompatible with layer ${this.name} : expected dtype=${R.dtype}, found dtype=${x.dtype}.`);if(R.axes){const j=x.shape;for(const ce in R.axes){const fe=Number(ce),je=R.axes[ce];if(null!=je&&-1===[je,null].indexOf(fe>=0?j[fe]:j[j.length+fe]))throw new ln(`Input ${m} is incompatible with layer ${this.name}: expected axis ${fe} of input shape to have value ${je} but got shape ${j}.`)}}if(null!=R.shape)for(let j=0;j<R.shape.length;++j){const ce=R.shape[j],fe=x.shape[j];if(null!=ce&&null!=fe&&ce!==fe)throw new ln(`Input ${m} is incompatible with layer ${this.name}: expected shape=${R.shape}, found shape=${x.shape}.`)}}}call(d,o){return d}invokeCallHook(d,o){null!=this._callHook&&this._callHook(d,o)}setCallHook(d){this._callHook=d}clearCallHook(){this._callHook=null}apply(d,o){o=o||{},this.assertNotDisposed();const p=ks(d),m=function Io(u){let d=!0;for(const o of ks(u))if(!(o instanceof Xr)){d=!1;break}return d}(d),x=function da(u){let d=!0;for(const o of ks(u))if(o instanceof Xr){d=!1;break}return d}(d);if(m===x)throw new ln("Arguments to apply() must be all SymbolicTensors or all Tensors");return $c(this.name,()=>{if(!this.built){this.assertInputCompatibility(d);const R=[];for(const $ of ks(d))R.push($.shape);this.build(Do(R)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&x&&(this._refCount=1)}if(this.assertInputCompatibility(d),x){let R=this.call(d,o);this.supportsMasking&&this.setMaskMetadata(d,R);const $=ks(R),j=[];for(let ce of $)-1!==p.indexOf(ce)&&(ce=ce.clone()),j.push(ce);if(R=Do(j),null!=this.activityRegularizer)throw new ei("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return R}{const R=function Ui(u){u=ks(u);const d=[];for(const o of u)d.push(o.shape);return Do(d)}(d),$=this.computeOutputShape(R);let j;const ce="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(d)?R[0]:R),j=null!=$&&$.length>0&&Array.isArray($[0])?$.map((fe,je)=>new Xr(ce,fe,this,ks(d),o,this.name,je)):new Xr(ce,$,this,ks(d),o,this.name),this.addInboundNode(d,j,null,null,R,$,o),this._refCount++,null!=this.activityRegularizer)throw new ei("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return j}})}warnOnIncompatibleInputShape(d){if(null!=this.batchInputShape)if(d.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(d)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let o=!1;this.batchInputShape.forEach((p,m)=>{null!=p&&null!=d[m]&&d[m]!==p&&(o=!0)}),o&&console.warn(`The shape of the input tensor (${JSON.stringify(d)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Eo(`The layer ${this.name} has never been called and thus has no defined output shape.`);const d=[];for(const o of this.inboundNodes){const p=JSON.stringify(o.outputShapes);-1===d.indexOf(p)&&d.push(p)}if(1===d.length){const o=this.inboundNodes[0].outputShapes;return Array.isArray(o)&&Array.isArray(o[0])&&1===o.length?o[0]:o}throw new Eo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ol(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Uh(this.weights)}build(d){this.built=!0}getWeights(d=!1){return js(d?this.trainableWeights:this.weights)}setWeights(d){(0,l.lub)(()=>{const o=this.weights;if(o.length!==d.length)throw new ln(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${d.length}, but the layer was expecting ${o.length} weights. Provided weights: ${d}...`);if(0===o.length)return;const p=[],m=js(o);for(let x=0;x<m.length;++x){const R=m[x],$=o[x],j=d[x];if(!l.D5U.arraysEqual(R.shape,j.shape))throw new ln(`Layer weight shape ${R.shape} not compatible with provided weight shape ${j.shape}`);p.push([$,j])}pr(p)})}addWeight(d,o,p,m,x,R,$,j){if(-1!==this._addedWeightNames.indexOf(d))throw new ln(`Duplicate weight name ${d} for layer ${this.name}`);this._addedWeightNames.push(d),null==p&&(p="float32"),this.fastWeightInitDuringBuild&&(m=null!=j?j():Uo("zeros"));const ce=m.apply(o,p),fe=new pu(ce,p,d,R,$);return ce.dispose(),null!=x&&this.addLoss(()=>x.apply(fe.read())),null==R&&(R=!0),R?this._trainableWeights.push(fe):this._nonTrainableWeights.push(fe),fe}setFastWeightInitDuringBuild(d){this.fastWeightInitDuringBuild=d}addLoss(d){null==d||Array.isArray(d)&&0===d.length||(d=ks(d),null!=this._losses&&this.losses.push(...d))}computeOutputShape(d){return d}computeMask(d,o){if(!this.supportsMasking){if(null!=o){if(!Array.isArray(o))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);o.forEach(p=>{if(null!=p)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return o}setMaskMetadata(d,o,p){if(!this.supportsMasking)return;const m=this.computeMask(d,p);if(o instanceof Array&&m instanceof Array){if(o.length!==m.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${m.length} masks for those tensors`);for(let x=0;x<o.length;x++)o[x].kerasMask=m[x]}else{if(m instanceof Array)throw new Error(`{this.name} outputs a single tensor but ${m.length} masks`);if(o instanceof Array)throw new Error(`{this.name} outputs ${o.length} tensors but only one mask`);o.kerasMask=m}}addInboundNode(d,o,p,m,x,R,$=null){const j=ks(d);o=ks(o),p=ks(p),m=ks(m),x=Tc(x),R=Tc(R);const ce=[],fe=[],je=[];for(const ze of j)ce.push(ze.sourceLayer),fe.push(ze.nodeIndex),je.push(ze.tensorIndex);new Fr({outboundLayer:this,inboundLayers:ce,nodeIndices:fe,tensorIndices:je,inputTensors:j,outputTensors:o,inputMasks:p,outputMasks:m,inputShapes:x,outputShapes:R},$);for(let ze=0;ze<o.length;ze++)o[ze].sourceLayer=this,o[ze].nodeIndex=this.inboundNodes.length-1,o[ze].tensorIndex=ze}getConfig(){const d={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(d.batchInputShape=this.batchInputShape),null!=this.dtype&&(d.dtype=this.dtype),d}disposeWeights(){return this.weights.forEach(d=>d.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let d=0;return 0==--this._refCount&&(d=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:d}}}function ta(u,d,o){if((null==d||null!=o&&o>0)&&(d=u.sourceLayer,o=u.nodeIndex),0===d.inboundNodes.length)return[u];{const p=d.inboundNodes[o];if(0===p.inboundLayers.length)return p.inputTensors;{const m=[];for(let x=0;x<p.inboundLayers.length;x++){const ce=ta(p.inputTensors[x],p.inboundLayers[x],p.nodeIndices[x]);for(const fe of ce)-1===m.indexOf(fe)&&m.push(fe)}return m}}}let zo=(()=>{class u extends gs{constructor(o){if(super({dtype:o.dtype,name:null!=o.name?o.name:vs("input").toString()}),null==o.batchSize&&(o.batchSize=null),null==o.sparse&&(o.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=o.sparse,null!=o.inputShape&&null!=o.batchInputShape)throw new ln("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let p=o.batchInputShape;if(null==p){if(null==o.inputShape)throw new ln("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");p=[o.batchSize].concat(o.inputShape)}else if(null!=o.batchSize)throw new ln("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const m=o.dtype||"float32";this.batchInputShape=p,this.dtype=m,this.inputSpec=[{shape:p}];const x=new Xr(this.dtype,this.batchInputShape,this,[],{},this.name);x.nodeIndex=0,x.tensorIndex=0,new Fr({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[x],outputTensors:[x],inputMasks:[null],outputMasks:[null],inputShapes:[p],outputShapes:[p]})}apply(o,p){throw new ln(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return u.className="InputLayer",u})();function Za(u){if(null==u.batchShape&&null==u.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=u.batchShape&&null!=u.shape)throw new ln("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let d=u.batchShape;null!=u.shape&&null==d&&(d=[null].concat(u.shape));let o=u.dtype;return null==o&&(o="float32"),new zo({batchInputShape:d,name:u.name,dtype:o,sparse:u.sparse}).inboundNodes[0].outputTensors[0]}l.m7h.registerClass(zo);class Cl{constructor(d){if(this.id2Value={},this.id2Mask={},this.name2Id={},d instanceof Cl)for(const o in d.id2Value)this.id2Value[o]=d.id2Value[o],o in d.id2Mask&&(this.id2Mask[o]=d.id2Mask[o]);else{if(null==d)return;for(const o of d)this.add(o.key,o.value)}}add(d,o,p){if(null!=this.id2Value[d.id])throw new ln(`Duplicate key: name=${d.name}, id=${d.id}`);return this.id2Value[d.id]=function fu(u,d){if(null==u.dtype||u.dtype===d.dtype)return d;try{return(0,l.pju)(d,u.dtype)}catch{throw new ln(`The dtype of the feed (${d.dtype}) can not be cast to the dtype of the key '${u.name}' (${u.dtype}).`)}}(d,o),this.name2Id[d.name]=d.id,null!=p&&(this.id2Mask[d.id]=p),this}addFeed(d){this.add(d.key,d.value)}hasKey(d){return null!=this.id2Value[d.id]}names(){return Object.keys(this.name2Id)}getValue(d){if(d instanceof Xr){if(null==this.id2Value[d.id])throw new ln(`Nonexistent key: ${d.name}`);return this.id2Value[d.id]}{const o=this.name2Id[d];if(null==o)throw new ln(`Feed dict has no SymbolicTensor name: ${d}`);return this.id2Value[o]}}getMask(d){if(d instanceof Xr){if(null==this.id2Value[d.id])throw new ln(`Nonexistent key: ${d.name}`);return this.id2Mask[d.id]}{const o=this.name2Id[d];if(null==o)throw new ln(`Feed dict has no SymbolicTensor name: ${d}`);return this.id2Mask[o]}}disposeMasks(){null!=this.id2Mask&&(0,l.B90)(this.id2Mask)}}const Jo=new Mc,El=new Mc;function Yl(u,d,o,p){const m=null!=o&&o.training,x=Array.isArray(u),R=x?u:[u],$=R.map(Rt=>Rt.name),j=[],ce=d.names();for(const Rt of $)-1!==ce.indexOf(Rt)?j.push(d.getValue(Rt)):j.push(null);null!=p&&(p.maxNumTensors=-1/0,p.minNumTensors=1/0);const fe=$.join(",")+"|"+d.names().sort().join(",");let ze,je=Jo.get(fe);if(null==je){const Rt=function zc(u,d){l.D5U.assert(null!=u&&u.length>0,()=>"Expected at least one fetch, got none");let o=[],p={};if(1===u.length){const m=Ep(u[0],d);o=m.sorted,p=m.recipientMap}else{const m=new Set;for(const x of u){const{sorted:R,recipientMap:$}=Ep(x,d);for(const j of R)m.has(j.name)||(o.push(j),m.add(j.name));for(const j in $)null==p[j]&&(p[j]=new Set),$[j].forEach(ce=>p[j].add(ce))}}return{sorted:o,recipientCounts:Gd(p)}}(R,d);je=Rt.sorted,ze=Rt.recipientCounts,Jo.put(fe,je),El.put(fe,ze)}ze={},m||Object.assign(ze,El.get(fe));const nt=new Cl(d);for(let Rt=0;Rt<je.length;++Rt){if(null!=p){const Vn=(0,l.sq6)().numTensors;Vn>p.maxNumTensors&&(p.maxNumTensors=Vn),Vn<p.minNumTensors&&(p.minNumTensors=Vn)}const bt=je[Rt],xt=bt.sourceLayer;if(xt instanceof zo)continue;const Pt=[],St=[],Ut=[];let Ft=!1;for(const Vn of bt.inputs){const es=nt.getValue(Vn),ls=nt.getMask(Vn);Pt.push(es),St.push(ls),null!=ls&&(Ft=!0),m||(ze[Vn.name]--,0===ze[Vn.name]&&!d.hasKey(Vn)&&-1===$.indexOf(Vn.name)&&!es.isDisposed&&!0!==Vn.sourceLayer.stateful&&Ut.push(es))}Ft&&((o=o||{}).mask=St[0]);const sn=ks(xt.apply(Pt,o));let _n=null;xt.supportsMasking&&(_n=xt.computeMask(Pt,St));const Cn=x_(bt),Bn=Array.isArray(Cn)?Cn:[Cn];for(let Vn=0;Vn<Bn.length;++Vn){nt.hasKey(Bn[Vn])||nt.add(Bn[Vn],sn[Vn],Array.isArray(_n)?_n[0]:_n);const es=$.indexOf(Bn[Vn].name);-1!==es&&(j[es]=sn[Vn])}m||(0,l.B90)(Ut)}return nt.disposeMasks(),x?j:j[0]}function Gd(u){const d={};for(const o in u)d[o]=u[o].size;return d}function Ep(u,d){const o=new Set,p=[],m={};for(const $ of d.names())o.add($);const x=[],R=[];for(x.push(u);x.length>0;){const $=x[x.length-1];if(o.has($.name)){x.pop();continue}const j=R[R.length-1]===x.length-1;if(0===$.inputs.length||j)x.pop(),p.push($),o.add($.name),j&&R.pop();else{R.push(x.length-1);for(const ce of $.inputs)null==m[ce.name]&&(m[ce.name]=new Set),m[ce.name].add($.name),!o.has(ce.name)&&x.push(ce)}}return{sorted:p,recipientMap:m}}function x_(u){let d;if(1===u.sourceLayer.inboundNodes.length)d=u.sourceLayer.output;else{let o=null;for(let p=0;p<u.sourceLayer.inboundNodes.length;++p)for(const m of u.sourceLayer.inboundNodes[p].outputTensors)if(m.id===u.id){o=p;break}d=u.sourceLayer.getOutputAt(o)}return d}function Dp(u,d){return(0,l.lub)(()=>l._b3(l.Smz(l.dC7(u,u),d,!0)))}(0,l.OBj)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function Sd(u){Jo?.setMaxEntries(u),El?.setMaxEntries(u)});class yh extends l.m7h.Serializable{getConfig(){return{}}}let Yf=(()=>{class u extends yh{constructor(o){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=o.maxValue?o.maxValue:this.defaultMaxValue,this.axis=null!=o.axis?o.axis:this.defaultAxis}apply(o){return(0,l.lub)(()=>{const p=Dp(o,this.axis),m=l.iUl(p,0,this.maxValue);return l.dC7(o,l.hiC(m,l.IHx(Ba(),p)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return u.className="MaxNorm",u})();l.m7h.registerClass(Yf);let cf=(()=>{class u extends yh{constructor(o){super(),this.defaultAxis=0,this.axis=null!=o.axis?o.axis:this.defaultAxis}apply(o){return(0,l.lub)(()=>l.hiC(o,l.IHx(Ba(),Dp(o,this.axis))))}getConfig(){return{axis:this.axis}}}return u.className="UnitNorm",u})();l.m7h.registerClass(cf);let Xm=(()=>{class u extends yh{apply(o){return l.UYe(o)}}return u.className="NonNeg",u})();l.m7h.registerClass(Xm);let Zf=(()=>{class u extends yh{constructor(o){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=o.minValue?o.minValue:this.defaultMinValue,this.maxValue=null!=o.maxValue?o.maxValue:this.defaultMaxValue,this.rate=null!=o.rate?o.rate:this.defaultRate,this.axis=null!=o.axis?o.axis:this.defaultAxis}apply(o){return(0,l.lub)(()=>{const p=Dp(o,this.axis),m=l.IHx(l.dC7(this.rate,l.iUl(p,this.minValue,this.maxValue)),l.dC7(1-this.rate,p));return l.dC7(o,l.hiC(m,l.IHx(Ba(),p)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return u.className="MinMaxNorm",u})();l.m7h.registerClass(Zf);const Qf={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Zl(u){return Ke(u)}function Jf(u,d={}){return $t(u,l.m7h.SerializationMap.getMap().classNameMap,d,"constraint")}function Ql(u){return null==u?null:"string"==typeof u?Jf({className:u in Qf?Qf[u]:u,config:{}}):u instanceof yh?u:Jf(u)}function Ym(u){return new Yf(u)}function qf(u){return new cf(u)}function Sp(){return new Xm}function Zm(u){return new Zf(u)}function ga(){return new vp}function Kd(){return new bp}function Wo(u){return new Ia(u)}function Gu(u){return new xp(u)}function w_(u){return new Dd(u)}function Ip(u){return new af(u)}function C_(u){return new wp(u)}function Qm(u){return new Uc(u)}function Jm(u){return new mh(u)}function uf(u){return new Cp(u)}function Xd(u){return new hu(u)}function E_(u){return new Bh(u)}function Tp(u){return new gh(u)}function Ap(u){return new Vo(u)}function df(u){return new _h(u)}var em,ns=h(5861);function Id(u){return(em=em||(0,ns.Z)(function*(d){if(null==d)return;const o=[],p=[],m=[];for(const x in d){const R=d[x];if("number"!=typeof R){const $=R;o.push($.data()),p.push(x),m.push($)}}if(o.length>0){const x=yield Promise.all(o);for(let R=0;R<x.length;++R)d[p[R]]=x[R][0];(0,l.B90)(m)}})).apply(this,arguments)}function qm(u){if(null!=u)for(const d in u){const o=u[d];"number"!=typeof o&&o.dispose()}}class Wh{constructor(){this.validationData=null}setParams(d){this.params=d}onEpochBegin(d,o){return(0,ns.Z)(function*(){})()}onEpochEnd(d,o){return(0,ns.Z)(function*(){})()}onBatchBegin(d,o){return(0,ns.Z)(function*(){})()}onBatchEnd(d,o){return(0,ns.Z)(function*(){})()}onTrainBegin(d){return(0,ns.Z)(function*(){})()}onTrainEnd(d){return(0,ns.Z)(function*(){})()}setModel(d){}}class D_{constructor(d,o=10){null==d&&(d=[]),this.callbacks=d,this.queueLength=o}append(d){this.callbacks.push(d)}setParams(d){for(const o of this.callbacks)o.setParams(d)}setModel(d){for(const o of this.callbacks)o.setModel(d)}onEpochBegin(d,o){var p=this;return(0,ns.Z)(function*(){null==o&&(o={});for(const m of p.callbacks)yield m.onEpochBegin(d,o)})()}onEpochEnd(d,o){var p=this;return(0,ns.Z)(function*(){null==o&&(o={});for(const m of p.callbacks)yield m.onEpochEnd(d,o)})()}onBatchBegin(d,o){var p=this;return(0,ns.Z)(function*(){null==o&&(o={});for(const m of p.callbacks)yield m.onBatchBegin(d,o)})()}onBatchEnd(d,o){var p=this;return(0,ns.Z)(function*(){null==o&&(o={});for(const m of p.callbacks)yield m.onBatchEnd(d,o)})()}onTrainBegin(d){var o=this;return(0,ns.Z)(function*(){null==d&&(d={});for(const p of o.callbacks)yield p.onTrainBegin(d)})()}onTrainEnd(d){var o=this;return(0,ns.Z)(function*(){null==d&&(d={});for(const p of o.callbacks)yield p.onTrainEnd(d)})()}}class tm extends Wh{constructor(){super()}onEpochBegin(d){var o=this;return(0,ns.Z)(function*(){o.seen=0,o.totals={}})()}onBatchEnd(d,o){var p=this;return(0,ns.Z)(function*(){null==o&&(o={});const m=null==o.size?0:o.size;p.seen+=m;for(const x in o){const R=o[x];if("number"==typeof R)p.totals.hasOwnProperty(x)||(p.totals[x]=0),p.totals[x]=p.totals[x]+R*m;else{let $;x in p.totals?$=p.totals[x]:p.totals[x]=0;const j=(0,l.lub)(()=>(0,l.IHx)(p.totals[x],(0,l.dC7)(R,m)));p.totals[x]=j,$?.dispose()}}})()}onEpochEnd(d,o){var p=this;return(0,ns.Z)(function*(){if(null!=o)for(const m of p.params.metrics)null!=p.totals[m]&&("number"==typeof p.totals[m]?o[m]=p.totals[m]/p.seen:(0,l.lub)(()=>{const x=(0,l.dC7)((0,l.hiC)(1,p.seen),p.totals[m]);o[m]=x,p.totals[m].dispose(),(0,l.CnY)(o[m])}))})()}}class S_ extends Wh{onTrainBegin(d){var o=this;return(0,ns.Z)(function*(){o.epoch=[],o.history={}})()}onEpochEnd(d,o){var p=this;return(0,ns.Z)(function*(){null==o&&(o={}),p.epoch.push(d);for(const m in o)null==p.history[m]&&(p.history[m]=[]),p.history[m].push(o[m])})()}syncData(){var d=this;return(0,ns.Z)(function*(){const o=[],p=[],m=[];for(const R in d.history){const $=d.history[R];for(let j=0;j<$.length;++j)"number"!=typeof $[j]&&(o.push($[j].data()),p.push(R),m.push(j))}const x=yield Promise.all(o);for(let R=0;R<x.length;++R)d.history[p[R]][m[R]].dispose(),d.history[p[R]][m[R]]=x[R][0]})()}}class eg extends Wh{constructor(d,o){if(super(),this.currentEpoch=0,this.nowFunc=d.nowFunc,this.nextFrameFunc=d.nextFrameFunc||l.glt,this.yieldEvery=o||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=d.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");l.D5U.isNumber(this.yieldEvery)&&(this.maybeWait=function zt(u,d,o){let m,p=null!=o?o():l.D5U.now();return(...R)=>{const $=null!=o?o():l.D5U.now();return $-p<d||(p=$,m=u(...R)),m}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=d.onTrainBegin,this.trainEnd=d.onTrainEnd,this.epochBegin=d.onEpochBegin,this.epochEnd=d.onEpochEnd,this.batchBegin=d.onBatchBegin,this.batchEnd=d.onBatchEnd,this.yield=d.onYield}maybeWait(d,o,p){var m=this;return(0,ns.Z)(function*(){const x=[];null!=m.yield&&(yield Id(p),x.push(m.yield(d,o,p))),x.push(m.nextFrameFunc()),yield Promise.all(x)})()}onEpochBegin(d,o){var p=this;return(0,ns.Z)(function*(){p.currentEpoch=d,null!=p.epochBegin&&(yield Id(o),yield p.epochBegin(d,o))})()}onEpochEnd(d,o){var p=this;return(0,ns.Z)(function*(){const m=[];null!=p.epochEnd&&(yield Id(o),m.push(p.epochEnd(d,o))),"epoch"===p.yieldEvery&&m.push(p.nextFrameFunc()),yield Promise.all(m)})()}onBatchBegin(d,o){var p=this;return(0,ns.Z)(function*(){null!=p.batchBegin&&(yield Id(o),yield p.batchBegin(d,o))})()}onBatchEnd(d,o){var p=this;return(0,ns.Z)(function*(){const m=[];null!=p.batchEnd&&(yield Id(o),m.push(p.batchEnd(d,o))),"batch"===p.yieldEvery?m.push(p.nextFrameFunc()):l.D5U.isNumber(p.yieldEvery)&&m.push(p.maybeWait(p.currentEpoch,d,o)),yield Promise.all(m)})()}onTrainBegin(d){var o=this;return(0,ns.Z)(function*(){null!=o.trainBegin&&(yield Id(d),yield o.trainBegin(d))})()}onTrainEnd(d){var o=this;return(0,ns.Z)(function*(){null!=o.trainEnd&&(yield Id(d),yield o.trainEnd(d))})()}}function tg(u,d){return null==u&&(u={}),u instanceof Wh?[u]:Array.isArray(u)&&u[0]instanceof Wh?u:ks(u).map(p=>new eg(p,d))}let I_=(()=>{class u{constructor(){}static registerCallbackConstructor(o,p){l.D5U.assert(o>=0&&Number.isInteger(o),()=>`Verbosity level is expected to be an integer >= 0, but got ${o}`),u.checkForDuplicate(p),null==u.constructors[o]&&(u.constructors[o]=[]),u.constructors[o].push(p)}static checkForDuplicate(o){for(const p in u.constructors)u.constructors[+p].forEach(x=>{if(x===o)throw new ln("Duplicate callback constructor.")})}static clear(){u.constructors={}}static createCallbacks(o){const p=[];for(const m in u.constructors){const x=+m;o>=x&&p.push(...u.constructors[x])}return p.map(m=>new m)}}return u.constructors={},u})();function T_(u,d,o,p,m,x,R,$,j){const ce=new S_,fe=[new tm,...I_.createCallbacks(d)];null!=u&&fe.push(...u),fe.push(ce);const je=new D_(fe);return je.setParams({epochs:o,initialEpoch:p,samples:m,steps:x,batchSize:R,verbose:d,doValidation:$,metrics:j}),{callbackList:je,history:ce}}function wu(u,d={},o=!1){return $t(u,l.m7h.SerializationMap.getMap().classNameMap,d,"layer",o)}function vh(u,d){return(0,l.lub)(()=>{"float32"!==u.dtype&&(u=l.pju(u,"float32"));const o=l.Smz(Ed(u),d,!0),p=l.hlL(o.shape,Ba()),m=l._b3(l.gWQ(o,p));return l.hiC(u,m)})}function Hh(u,d){return(0,l.lub)(()=>l.J69(Ed(l.luU(d,u)),-1))}function Yd(u,d){return(0,l.lub)(()=>l.J69(l.WnP(l.luU(d,u)),-1))}function Zd(u,d){return(0,l.lub)(()=>{const o=l.luU(u,d),p=l.iUl(l.WnP(u),Ba(),Number.MAX_VALUE),m=l.WnP(l.hiC(o,p));return l.dC7(100,l.J69(m,-1))})}function Cu(u,d,o=!1){return(0,l.lub)(()=>{if(o)d=l.XAC(d);else{const p=l.Smz(d,d.shape.length-1,!0);d=l.hiC(d,p)}return d=l.iUl(d,Ba(),1-Ba()),l.W76(l.Smz(l.dC7(l.pju(u,"float32"),l.cM7(d)),d.shape.length-1))})}function pf(u,d,o=!1){return(0,l.lub)(()=>{const p=l.pju(l.GWj(function Lh(u){const d=[Sc(u.shape)];return l.XLQ(u,d)}(u)),"int32"),m=(d=l.iUl(d,Ba(),1-Ba())).shape;return Cu(l.XLQ(l.lfX(p,m[m.length-1]),m),d,o)})}function be(u,d){return(0,l.lub)(()=>{let o;return o=l.iUl(d,Ba(),1-Ba()),o=l.cM7(l.hiC(o,l.luU(1,o))),l.J69(function ff(u,d){if(!l.D5U.arraysEqual(u.shape,d.shape))throw new ln(`logits and labels must have the same shape, but got shapes ${JSON.stringify(u.shape)} and ${JSON.stringify(d.shape)}`);return(0,l.lub)(()=>{const o=l.UYe(d),p=l.W76(l.WnP(d));return l.IHx(l.luU(o,l.dC7(d,u)),l.Krr(l.Qqt(p)))})}(u,o),-1)})}function Ie(u,d){return(0,l.lub)(()=>{const o=vh(u,-1),p=vh(d,-1),m=l.dC7(o,p);return l.W76(l.Smz(m,-1))})}const Ii={meanSquaredError:Hh,meanAbsoluteError:Yd,meanAbsolutePercentageError:Zd,meanSquaredLogarithmicError:function hf(u,d){return(0,l.lub)(()=>{const o=l.iUl(d,Ba(),Number.MAX_VALUE),p=l.cM7(l.IHx(1,o)),m=l.iUl(u,Ba(),Number.MAX_VALUE),x=l.cM7(l.IHx(1,m));return l.J69(Ed(l.luU(p,x)),-1)})},squaredHinge:function D0(u,d){return(0,l.lub)(()=>{const o=l.gWQ(0,l.luU(1,l.dC7(u,d)));return l.J69(Ed(o),-1)})},hinge:function ng(u,d){return(0,l.lub)(()=>{const o=l.gWQ(0,l.luU(1,l.dC7(u,d)));return l.J69(o,-1)})},categoricalHinge:function sg(u,d){return(0,l.lub)(()=>{const o=l.Smz(l.dC7(u,d),-1),p=l.Fp7(l.dC7(l.luU(1,u),d),-1);return l.gWQ(0,l.IHx(1,l.luU(p,o)))})},logcosh:function S0(u,d){return(0,l.lub)(()=>{const o=Math.log(2),p=l.luU(d,u),m=l.luU(l.IHx(p,l.Wvh(l.dC7(-2,p))),o);return l.J69(m,-1)})},categoricalCrossentropy:Cu,sparseCategoricalCrossentropy:pf,binaryCrossentropy:be,kullbackLeiblerDivergence:function he(u,d){return(0,l.lub)(()=>{const o=l.iUl(u,Ba(),1),p=l.iUl(d,Ba(),1);return l.Smz(l.dC7(u,l.cM7(l.hiC(o,p))),-1)})},poisson:function se(u,d){return(0,l.lub)(()=>{const o=l.cM7(l.IHx(Ba(),d));return l.J69(l.luU(d,l.dC7(u,o)),-1)})},cosineProximity:Ie};function Dr(u){if("string"==typeof u){if(u in Ii)return Ii[u];let d=`Unknown loss ${u}`;throw u.toLowerCase().includes("softmaxcrossentropy")&&(d=`Unknown loss ${u}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ln(d)}return u}function mr(u,d){return(0,l.lub)(()=>{const o=l.dC7(.5,l.JpU(d)),p=qc(l.pjt(d,o),u.dtype);return l.J69(l.DgJ(u,p),-1)})}function _a(u,d){return(0,l.lub)(()=>qc(l.DgJ(l.NqF(u,-1),l.NqF(d,-1)),"float32"))}function Gr(u,d){return(0,l.lub)(()=>l.pju(l.Smz(l.HvI(l.DgJ(u,1),l.DgJ(d,1))),"float32"))}function Ji(u,d){return(0,l.lub)(()=>{const o=Gr(u,d),p=function Jl(u,d){return(0,l.lub)(()=>l.pju(l.Smz(l.HvI(l.DgJ(u,0),l.DgJ(d,1))),"float32"))}(u,d),m=l.IHx(o,p);return l.pju(l.arb(l.pjt(m,0),l.hiC(o,m),0),"float32")})}function ya(u,d){return be(u,d)}function sa(u,d){return u.rank===d.rank&&(u=l.L9e(u,[u.rank-1])),(d=l.NqF(d,-1)).dtype!==u.dtype&&(d=l.pju(d,u.dtype)),l.pju(l.DgJ(u,d),"float32")}const xh=Cu,A_=pf,k_={binaryAccuracy:mr,categoricalAccuracy:_a,precision:Ji,categoricalCrossentropy:xh,sparseCategoricalCrossentropy:A_,mse:Hh,MSE:Hh,mae:Yd,MAE:Yd,mape:Zd,MAPE:Zd,cosine:Ie};function mf(u){if("string"==typeof u&&u in k_)return k_[u];if("string"!=typeof u&&null!=u)return u;throw new ln(`Unknown metric ${u}`)}function rg(u){if(wl(null!==u,`Unknown LossOrMetricFn ${u}`),"string"==typeof u)return u;{let d;for(const o of Object.keys(Ii))if(Ii[o]===u){d=o;break}if(void 0!==d)return d;for(const o of Object.keys(k_))if(k_[o]===u){d=o;break}return void 0!==d?d:u.name}}function I0(u,d,o=!1){if(null==u||"object"!=typeof u||Object.getPrototypeOf(u)!==Object.prototype||!jh(u))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(o){const p=JSON.stringify(u);p.length>1048576&&console.warn(`User-defined metadata of model "${d}" is too large in size (length=${p.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function jh(u){if(null===u)return!0;if("object"==typeof u){if(Object.getPrototypeOf(u)===Object.prototype){const d=Object.keys(u);for(const o of d)if("string"!=typeof o||!jh(u[o]))return!1;return!0}if(Array.isArray(u)){for(const d of u)if(!jh(d))return!1;return!0}return!1}{const d=typeof u;return"string"===d||"number"===d||"boolean"===d}}function sm(u,d,o=console.log){let p="";for(let m=0;m<u.length;++m)m>0&&(p=p.slice(0,p.length-1)+" "),p+=u[m],p=p.slice(0,d[m]),p+=" ".repeat(d[m]-p.length);o(p)}function ig(u,d,o){let p,m;try{m=u.inboundNodes.map(j=>JSON.stringify(j.inputShapes)).join(",")}catch{m="multiple"}try{p=JSON.stringify(u.outputShape)}catch{p="multiple"}sm([`${u.name} (${u.getClassName()})`,m,p,u.countParams().toString()],d,o)}function og(u,d,o,p){let m,x;try{x=u.inboundNodes.map(je=>JSON.stringify(je.inputShapes)).join(",")}catch{x="multiple"}try{m=JSON.stringify(u.outputShape)}catch{m="multiple"}const R=[];for(const je of u.inboundNodes)if(!(null!=o&&o.length>0&&-1===o.indexOf(je)))for(let ze=0;ze<je.inboundLayers.length;++ze)R.push(`${je.inboundLayers[ze].name}[${je.nodeIndices[ze]}][${je.tensorIndices[ze]}]`);const $=u.name,j=u.getClassName(),ce=0===R.length?"":R[0];sm([`${$} (${j})`,x,m,u.countParams().toString(),ce],d,p);for(let je=1;je<R.length;++je)sm(["","","","",R[je]],d,p)}function Gb(u,d,o){return("inboundNodes"===u||"outputLayers"===u||"inputLayers"===u)&&0===d&&"string"==typeof o}function ag(u,d){if(null===u)return null;if("string"==typeof u)return ge(u);if("number"==typeof u||"boolean"==typeof u)return u;if(u instanceof Array){const o=[],p=u.length;for(let m=0;m<p;++m){const x=u[m];Gb(d,m,x)?o.push(x):o.push(ag(x,d))}return o}{const o={};for(const p of Object.keys(u)){const m=u[p];if("name"===p&&"string"==typeof m)o[p]=m;else{const x=ge(p);o[x]=ag(m,x)}}return o}}function O_(u,d){if(null==u)return null;if("string"==typeof u)return Me(u);if("number"==typeof u||"boolean"==typeof u)return u;if(u instanceof Array){const o=[],p=u.length;for(let m=0;m<p;++m){const x=u[m];Gb(d,m,x)?o.push(x):o.push(O_(x,d))}return o}{const o={};for(const p of Object.keys(u)){const m=u[p];o[Me(p)]="name"!==p&&"className"!==p||"string"!=typeof m?O_(m,p):m}return o}}const R_="4.11.0";class ld extends gs{constructor(d){if(super({}),this.containerNodes=new Set,this.name=d.name,null==this.name){const St=this.getClassName().toLowerCase();this.name=vs(St)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(d.inputs)?d.inputs.slice():[d.inputs],this.outputs=Array.isArray(d.outputs)?d.outputs.slice():[d.outputs],xe(this.inputs).length!==this.inputs.length)throw new ln(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(St=>St.name)}`);xe(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(St=>St.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const St of this.outputs){const Ft=St.nodeIndex,sn=St.tensorIndex;this.outputLayers.push(St.sourceLayer),this.outputLayersNodeIndices.push(Ft),this.outputLayersTensorIndices.push(sn)}for(const St of this.inputs){const Ut=St.sourceLayer,Ft=St.nodeIndex,sn=St.tensorIndex;wl(0===Ft,"input layer has >1 nodes"),wl(0===sn,"input layer has >1 tensors"),this.inputLayers.push(Ut),this.inputLayersNodeIndices.push(Ft),this.inputLayersTensorIndices.push(sn)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let St=0;St<this.inputLayers.length;St++){const Ut=this.inputLayers[St];if(!(Ut instanceof zo))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${d.inputs}. Input ${St} (0-based) originates from layer type ${Ut.getClassName()}.`);this.inputNames.push(Ut.name),this.feedInputShapes.push(Ut.batchInputShape),this.feedInputNames.push(Ut.name)}for(const St of this.outputLayers)this.outputNames.push(St.name);this.internalInputShapes=this.inputs.map(St=>St.shape),this.internalOutputShapes=this.outputs.map(St=>St.shape);const o={},p={},m={},x={},R={},$=[],j=(St,Ut,Ft,sn,_n,Cn)=>{(null==sn||null==_n||null==Cn)&&(sn=St.sourceLayer,_n=St.nodeIndex,Cn=St.tensorIndex);const Bn=sn.inboundNodes[_n];if(-1!==Ft.indexOf(Bn))throw new Ol(`The tensor ${St.name} at layer "${sn.name}" is part of a cycle.`);if(-1!==Ut.indexOf(Bn))return;this.containerNodes.add(ld.nodeKey(sn,_n)),sn.id in R||(R[sn.id]=Object.keys(R).length),-1===Ft.indexOf(Bn)&&Ft.push(Bn);const Vn=Bn.inboundLayers.length;for(let es=0;es<Vn;es++)j(Bn.inputTensors[es],Ut,Ft,Bn.inboundLayers[es],Bn.nodeIndices[es],Bn.tensorIndices[es]);for(Ut.push(Bn);Ft.indexOf(Bn)>=0;)Ft.splice(Ft.indexOf(Bn),1);$.push(Bn)},ce=[],fe=[];for(const St of this.outputs)j(St,ce,fe);const je=$.slice().reverse();for(const St of je){p[St.id]=St,St.id in o||(o[St.id]=0);let Ut=o[St.id];Ut=Math.max(Ut,null==m[St.outboundLayer.id]?0:m[St.outboundLayer.id]),m[St.outboundLayer.id]=Ut,x[St.outboundLayer.id]=St.outboundLayer,o[St.id]=Ut;for(let sn=0;sn<St.inboundLayers.length;sn++){const Bn=St.inboundLayers[sn].inboundNodes[St.nodeIndices[sn]];o[Bn.id]=Math.max(Ut+1,null==o[Bn.id]?0:o[Bn.id]),p[Bn.id]=Bn}}const ze={};for(const St in o){const Ut=o[St];Ut in ze||(ze[Ut]=[]),ze[Ut].push(p[St])}const nt={};for(const St in m){const Ut=m[St];Ut in nt||(nt[Ut]=[]),nt[Ut].push(x[St])}let Rt=Object.keys(nt).map(St=>parseInt(St,10)).sort(Sn);this.layers=[];for(const St of Rt){const Ut=nt[St];Ut.sort((Ft,sn)=>{const _n=R[Ft.id],Cn=R[sn.id];return _n<Cn?-1:_n>Cn?1:0});for(const Ft of Ut)Ft instanceof ld&&this.internalContainerRefs.push(Ft),this.layers.push(Ft)}this.layersByDepth=nt,Rt=Object.keys(ze).map(St=>parseInt(St,10)).sort(Sn);const bt=this.inputs.slice(),xt=[];for(const St of Rt)for(const Ut of ze[St]){const Ft=Ut.outboundLayer;if(null!=Ft){for(const sn of Ut.inputTensors)if(-1===bt.indexOf(sn))throw new Ol(`Graph disconnected: cannot obtain value for tensor ${sn} at layer "${Ft.name}". The following previous layers were accessed without issue: ${xt}`);for(const sn of Ut.outputTensors)bt.push(sn);xt.push(Ft.name)}}this.nodesByDepth=ze;const Pt=this.layers.map(St=>St.name);for(const St of Pt){const Ut=Pt.filter(Ft=>Ft===St).length;if(1!==Ut)throw new Ol(`The name "${St}" is used ${Ut} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(Pt))}this.outboundNodes=[],this.inboundNodes=[],new Fr({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(St=>null),outputMasks:this.outputs.map(St=>null),inputShapes:this.inputs.map(St=>St.shape),outputShapes:this.outputs.map(St=>St.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const d={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const o of this.layers)d.numDisposedVariables+=o.dispose().numDisposedVariables;for(const o of this.internalContainerRefs)d.numDisposedVariables+=o.dispose().numDisposedVariables}return d.refCountAfterDispose=this._refCount,d}get trainable(){return this.trainable_}set trainable(d){this.layers.forEach(o=>{o._trainableWeights.forEach(p=>p.trainable=d)}),this.trainable_=d}get trainableWeights(){if(this._trainableWeights.length>0)throw new ln("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let d=[];for(const o of this.layers)d=d.concat(o.trainableWeights);return d}get nonTrainableWeights(){const d=[];for(const o of this.layers)d.push(...o.nonTrainableWeights);if(!this.trainable){const o=[];for(const p of this.layers)o.push(...p.trainableWeights);return o.concat(d)}return d}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(d,o=!0){const p={};let m=0;const x=(u=>{const d=Object.keys(u);if(0===d.length)return!1;const o=d[0].split("/");return!isNaN(parseInt(o[o.length-1],10))})(d);x&&this.parseWeights(d);for(const $ of this.layers)for(const[j,ce]of $.weights.entries()){const fe=x?`${ce.name.split("/").slice(0,-1).join("/")+"/"}${j}`:ce.originalName;if(null!=p[fe])throw new ln(`Duplicate weight name: ${fe}`);p[fe]=ce,m++}const R=[];for(const $ in d){let j=$;if(null==p[$]){const ce=$.split("/");j=ce.slice(0,-2).concat([ce[ce.length-1]]).join("/")}if(null!=p[j])R.push([p[j],d[$]]);else if(o)throw new ln(`Provided weight data has no target variable: ${$}`);delete p[j]}if(o){const $=[];for(const j in p)$.push(j);if($.length>0)throw new ln(`${$.length} of ${m} weights are not set: ${$}`)}pr(R)}parseWeights(d){for(const o in Object.keys(d)){const p=o.split("/"),m=["vars","layer_checkpoint_dependencies"],x=p.map(R=>R.startsWith("_")?R.slice(1):R).filter(R=>!m.includes(R)).join("/");x!==o&&(d[x]=d[o],delete d[o])}}updatedConfig(){const d=this.getConfig(),o={};return o.className=this.getClassName(),o.config=d,o.kerasVersion=`tfjs-layers ${R_}`,o.backend="TensorFlow.js",o}toJSON(d,o=!0){const p=O_(this.updatedConfig());return o?JSON.stringify(p):p}call(d,o){return(0,l.lub)(()=>{d=ks(d);const p=new Cl;for(let m=0;m<this.inputs.length;++m)p.add(this.inputs[m],d[m]);return Yl(this.outputs,p,o)})}computeMask(d,o){return(0,l.lub)(()=>{let p;return d=ks(d),p=null==o?Ur(null,d.length):ks(o),this.runInternalGraph(d,p)[1]})}computeOutputShape(d){const o=Tc(d);if(o.length!==this.inputLayers.length)throw new ln(`Invalid inputShape argument ${d}: model has ${this.inputLayers.length} tensor inputs.`);const p={};for(let $=0;$<o.length;$++)p[this.inputLayers[$].name+"_0_0"]=o[$];const m=Object.keys(this.nodesByDepth).map($=>parseInt($,10)).sort(Sn);if(m.length>1)for(const $ of m){const j=this.nodesByDepth[$];for(const ce of j){const fe=ce.outboundLayer;if(-1!==this.inputLayers.map(bt=>bt.id).indexOf(fe.id))continue;const je=[];for(let bt=0;bt<ce.inboundLayers.length;bt++)je.push(p[`${ce.inboundLayers[bt].name}_${ce.nodeIndices[bt]}_${ce.tensorIndices[bt]}`]);const nt=Tc(fe.computeOutputShape(Do(je))),Rt=fe.inboundNodes.indexOf(ce);for(let bt=0;bt<nt.length;bt++)p[`${fe.name}_${Rt}_${bt}`]=nt[bt]}}const x=[],R=[];for(let $=0;$<this.outputLayers.length;$++)R.push(`${this.outputLayers[$].name}_${this.outputLayersNodeIndices[$]}_${this.outputLayersTensorIndices[$]}`);for(let $=0;$<R.length;$++){const j=R[$];wl(j in p),x.push(p[j])}return Do(x)}runInternalGraph(d,o){null==o&&(o=Ur(null,d.length));const p={};for(let j=0;j<this.inputs.length;++j)p[this.inputs[j].id]=[d[j],o[j]];const m=Object.keys(this.nodesByDepth).map(j=>parseInt(j,10)).sort(Sn);for(const j of m){const ce=this.nodesByDepth[j];for(const fe of ce){const je=fe.outboundLayer,ze=fe.inputTensors,nt=fe.outputTensors,Rt=new Array;for(const bt of ze)bt.id in p&&Rt.push(p[bt.id]);if(Rt.length===ze.length){let xt,Pt,St,Ut,bt={};if(null!=fe.callArgs&&(bt=fe.callArgs),1===Rt.length){const[Ft,sn]=Rt[0];null==bt.mask&&(bt.mask=sn),St=ks(je.call(Ft,bt)),Ut=ks(je.computeMask(Ft,sn)),xt=[Ft],Pt=[sn]}else xt=Rt.map(Ft=>Ft[0]),Pt=Rt.map(Ft=>Ft[1]),null==bt.mask&&(bt.mask=Pt),St=ks(je.call(xt,bt)),Ut=ks(je.computeMask(xt,Pt));if(je.activityRegularizer)throw new ei("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let Ft=0;Ft<nt.length;++Ft)p[nt[Ft].id]=[St[Ft],Ut[Ft]]}}}const x=[],R=[],$=[];for(const j of this.outputs){wl(j.id in p,`Could not compute output ${j.name} : ${j.id}`);const[ce,fe]=p[j.id];$.push(ce.shape),x.push(ce),R.push(fe)}return[x,R,$]}buildNodeConversionMap(d){const o={};let p;for(const m of this.layers){p=m instanceof ld?1:0;for(let x=0;x<m.inboundNodes.length;x++){const R=ld.nodeKey(m,x);this.containerNodes.has(R)&&(o[R]=p,p+=1)}}return o}getLayer(d,o){if(null!=o)return this.findLayer(o);if(null==d)throw new ln("Provide either a layer name or layer index");if("number"==typeof d)return this.findLayer(d);for(const p of this.layers)if(p.name===d)return p;throw new ln(`No such layer: ${d}`)}findLayer(d){if(this.layers.length<=d)throw new ln(`Was asked to retrieve layer at index ${d}, but model only has ${this.layers.length} layer(s).`);return this.layers[d]}calculateLosses(){return(0,l.lub)(()=>{const d=[];for(const o of this.layers)for(let p=0;p<o.inboundNodes.length;++p){const m=ld.nodeKey(o,p);this.containerNodes.has(m)&&d.push(...o.calculateLosses())}return d})}getConfig(){const d={name:this.name},o=this.buildNodeConversionMap(this.layers),p=[];for(const R of this.layers){const $=R.getClassName(),j=R.getConfig(),ce=[];for(let je=0;je<R.inboundNodes.length;je++){const ze=R.inboundNodes[je],nt=ld.nodeKey(R,je);let Rt={};if(this.containerNodes.has(nt)){if(ze.callArgs)try{JSON.stringify(ze.callArgs),Rt=ze.callArgs}catch{console.warn(`Layer ${R.name} was passed non-serializable keyword arguments: ${ze.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),Rt={}}if(ze.inboundLayers.length>0){const bt=[];for(let xt=0;xt<ze.inboundLayers.length;xt++){const Pt=ze.inboundLayers[xt],Ut=ze.tensorIndices[xt];let sn=o[ld.nodeKey(Pt,ze.nodeIndices[xt])];null==sn&&(sn=0),bt.push([Pt.name,sn,Ut,Rt])}ce.push(bt)}}}const fe={};fe.name=R.name,fe.className=$,fe.config=j,fe.inboundNodes=ce,p.push(fe)}d.layers=p;const m=[];for(let R=0;R<this.inputLayers.length;R++){const $=this.inputLayers[R],ce=ld.nodeKey($,this.inputLayersNodeIndices[R]);if(!this.containerNodes.has(ce))continue;let fe=o[ce];null==fe&&(fe=0),m.push([$.name,fe,this.inputLayersTensorIndices[R]])}d.inputLayers=m;const x=[];for(let R=0;R<this.outputLayers.length;R++){const $=this.outputLayers[R],ce=ld.nodeKey($,this.outputLayersNodeIndices[R]);if(!this.containerNodes.has(ce))continue;let fe=o[ce];null==fe&&(fe=0),x.push([$.name,fe,this.outputLayersTensorIndices[R]])}return d.outputLayers=x,d}static fromConfig(d,o,p={},m=!1){const x={},R={};function $(xt,Pt){xt.name in R?R[xt.name].push(Pt):R[xt.name]=[Pt]}function j(xt,Pt){const St=[];let Ut;for(const Ft of Pt){const sn=Ft[0],_n=Ft[1],Cn=Ft[2];if(Ut=null==Ft[3]?{}:Ft[3],!(sn in x))return void $(xt,Pt);const Bn=x[sn];if(Bn.inboundNodes.length<=_n)return void $(xt,Pt);St.push(Bn.inboundNodes[_n].outputTensors[Cn])}St.length>0&&xt.apply(Do(St),Ut)}function ce(xt){const Pt=xt.name,St=wu(xt,null!=o.customObjects?o.customObjects:{});St.setFastWeightInitDuringBuild(m),x[Pt]=St,xt.inboundNodes.forEach(Ft=>{if(!(Ft instanceof Array))throw new ln(`Corrupted configuration, expected array for nodeData: ${Ft}`);$(St,Ft)})}const fe=o.name,je=o.layers;for(const xt of je)ce(xt);for(;!ee(R);)for(const xt of je){const Pt=x[xt.name];if(Pt.name in R){const St=R[Pt.name];delete R[Pt.name];for(const Ut of St)j(Pt,Ut)}}const ze=[],nt=[],Rt=o.inputLayers;for(const xt of Rt){const Pt=xt[0],St=xt[1],Ut=xt[2];wl(Pt in x),ze.push(x[Pt].inboundNodes[St].outputTensors[Ut])}const bt=o.outputLayers;for(const xt of bt){const Pt=xt[0],St=xt[1],Ut=xt[2];wl(Pt in x),nt.push(x[Pt].inboundNodes[St].outputTensors[Ut])}return new d({inputs:ze,outputs:nt,name:fe})}get stateful(){if(this._stateful)throw new ln("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const d of this.layers)if(d.stateful)return!0;return!1}resetStates(){(0,l.lub)(()=>{this.layers.forEach(d=>{d.stateful&&d.resetStates()})})}}var Rp,k0,O0;function T0(u,d){return function Kb(u,d,o){const p=d.length;if(null==u||Array.isArray(u)&&0===u.length)return d.map(m=>null);if(1===p)return Array.isArray(u)&&1===u.length?u:"object"==typeof u&&d[0]in u?[u[d[0]]]:[u];if(Array.isArray(u)){if(u.length!==p)throw new Error(`Provided ${o} is an array of ${u.length} element(s), but the model has ${p} outputs. Make sure a set of weights is provided for each model output.`);return u}if("object"==typeof u&&Object.keys(u).length>0&&"object"==typeof u[Object.keys(u)[0]]){const m=[];return d.forEach(x=>{m.push(x in u?u[x]:null)}),m}throw new Error(`The model has multiple (${p}) outputs, so ${o} must be either an array with ${p} elements or an object with ${d} keys. Provided ${o} not understood: ${JSON.stringify(u)}`)}(u,d,"classWeight")}function A0(u,d,o,p){return(Rp=Rp||(0,ns.Z)(function*(m,x,R,$){if(null!=x||null!=$)throw new Error("Support sampleWeight is not implemented yet");if(null!=R){const j=(0,l.lub)(()=>{if(1===m.shape.length)return(0,l.d9v)(m);if(2===m.shape.length){if(m.shape[1]>1)return(0,l.NqF)(m,1);if(1===m.shape[1])return(0,l.XLQ)(m,[m.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${m.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${m.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),ce=Array.from(yield j.data());(0,l.B90)(j);const fe=[];return ce.forEach(je=>{if(null==R[je])throw new Error(`classWeight must contain all classes in the training data. The class ${je} exists in the data but not in classWeight`);fe.push(R[je])}),(0,l.RRF)(fe,"float32")}return null})).apply(this,arguments)}function HC(u,d){return(0,l.dC7)(u,d)}function N_(u,d){let o,p;o=d.xs,p=d.ys,l.D5U.assert(null!=o&&null!=p,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${d}`);const x=rm("input",u.inputNames,o),R=rm("output",u.outputNames,p),$=x[0].shape[0];l.D5U.assert(x.length===u.inputs.length,()=>`LayersModel has ${u.inputs.length} inputs, but the dataset provides ${x.length} inputs.  (Expected input keys: ${JSON.stringify(u.inputNames)})`),l.D5U.assert(R.length===u.outputs.length,()=>`LayersModel has ${u.outputs.length} outputs, but the dataset provides ${R.length} outputs.  (Expected output keys: ${JSON.stringify(u.outputNames)})`);for(let j=0;j<x.length;j++)l.D5U.assert(x[j].shape[0]===$,()=>`Batch size mismatch: input ${u.inputNames[j]} has ${x[j].shape[0]}; expected  ${$} based on input ${u.inputNames[0]}.`);for(let j=0;j<R.length;j++)l.D5U.assert(R[j].shape[0]===$,()=>`Batch size mismatch: output ${u.outputNames[j]} has ${R[j].shape[0]}; expected  ${$} based on input ${u.inputNames[0]}.`);return{xs:x,ys:R}}function rm(u,d,o){if(o instanceof l.esB)return[o];if(Array.isArray(o))return l.D5U.assert(o.length===d.length,()=>`Received an array of ${o.length} Tensors, but expected ${d.length} to match the ${u} keys ${d}.`),o;{const p=[];for(const m of d){if(null==o[m])throw new ln(`The feature data generated by the dataset lacks the required ${u} key '${m}'.`);p.push(o[m])}return p}}function Gh(u){return"function"==typeof u.iterator}function im(u){l.D5U.assert(u>0&&Number.isInteger(u),()=>`batchSize is required to be a positive integer, but got ${u}`)}function Kh(u,d,o){return null==u?[null]:Array.isArray(u)?u.map(p=>Nl(p,d,o-d)):Nl(u,d,o-d)}function M_(u,d){return l.lub(()=>null==u?null:Array.isArray(u)?u.map(o=>M_(o,d)):Pc(u,"int32"===d.dtype?d:l.pju(d,"int32")))}function P_(u,d){const o=[];let p=0,m=null;for(;p<u;)m=p+d,m>=u&&(m=u),o.push([p,m]),p=m;return o}function M0(u){const d=[];u instanceof l.esB&&(u=[u]);for(let o=0;o<u.length;++o){const p=u[o];if(1===p.rank)d.push(od(p,1));else{if(0===p.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");d.push(p)}}return d}function gu(u,d){if(null==u)return;const o=[];if(d instanceof l.esB)o.push(d.id);else if(Array.isArray(d))d.forEach(m=>o.push(m.id));else if(null!=d)for(const m in d)o.push(d[m].id);const p=[];if(u instanceof l.esB)-1===o.indexOf(u.id)&&p.push(u);else if(Array.isArray(u))u.forEach(m=>{-1===o.indexOf(m.id)&&p.push(m)});else if(null!=u)for(const m in u){const x=u[m];-1===o.indexOf(x.id)&&p.push(x)}p.forEach(m=>{m.isDisposed||m.dispose()})}function F_(u){return Array.isArray(u)}function KC(u){return!function om(u){return u instanceof l.esB}(u)&&!F_(u)}function P0(u,d,o,p=!0,m=""){if(null==d||0===d.length){if(null!=u){let R=!1;if(F_(u)&&u.length>0)R=!0;else if(KC(u)){for(const $ in u)if(u.hasOwnProperty($)){R=!0;break}}else R=!0;if(R)throw new ln(`Error when checking model ${m} expected no data, but got ${u}`)}return[]}if(null==u)return d.map(R=>null);let x;if(KC(u)){x=[];for(const R of d){if(null==u[R])throw new ln(`No data provided for "${R}". Need data for each key in: ${d}`);x.push(u[R])}}else if(F_(u)){if(u.length!==d.length)throw new ln(`Error when checking model ${m}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${d.length} Tensor(s), but instead got the following list of Tensor(s): ${u}`);x=u}else{if(d.length>1)throw new ln(`The model ${m} expects ${d.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${u.shape}`);x=[u]}if(x=M0(x),null!=o)for(let R=0;R<d.length;++R){if(null==o[R])continue;const $=x[R];if($.shape.length!==o[R].length)throw new ln(`Error when checking ${m}: expected ${d[R]} to have ${o[R].length} dimension(s). but got array with shape ${$.shape}`);for(let j=0;j<o[R].length;++j){if(0===j&&!p)continue;const fe=o[R][j];if(null!=fe&&fe>=0&&$.shape[j]!==fe)throw new ln(`${m} expected a batch of elements where each example has shape [${o[R].slice(1,o[R].length)}] (i.e.,tensor shape [*,${o[R].slice(1,o[R].length)}]) but the ${m} received an input with ${$.shape[0]} examples, each with shape [${$.shape.slice(1,$.shape.length)}] (tensor shape [${$.shape}])`)}}return x}function Zb(u,d,o,p=!0,m=""){let x;if(Array.isArray(u)){if(u.length!==d.length)throw new ln(`Error when checking model ${m}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${d.length} Tensor(s), but instead got ${u.length} Tensors(s).`);x=u}else{if(d.length>1)throw new ln(`The model expects ${d.length} ${m} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(u.shape)}.`);x=[u]}if(null!=o)for(let R=0;R<d.length;++R){if(null==o[R])continue;const $=x[R];if($.shape.length!==o[R].length)throw new ln(`Error when checking ${m}: expected ${d[R]} to have ${o[R].length} dimension(s), but got array with shape ${JSON.stringify($.shape)}`);for(let j=0;j<o[R].length;++j){if(0===j&&!p)continue;const fe=o[R][j];if(null!=fe&&fe!==$.shape[j])throw new ln(`Error when checking ${m}: expected ${d[R]} to have shape ${JSON.stringify(o[R])} but got array with shape ${JSON.stringify($.shape)}.`)}}}let Jd=(()=>{class u extends ld{constructor(o){super(o),this.isTraining=!1}summary(o,p,m=console.log){if(!this.built)throw new ln("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function jb(u,d,o,p=console.log){const m=function nm(u){let d=!0;const o=[],p=[];for(const m in u.nodesByDepth)o.push(u.nodesByDepth[m]);for(const m of o){if(m.length>1||1===m.length&&m[0].inboundLayers.length>1){d=!1;break}p.push(...m)}if(d)for(const m of u.layers){let x=!1;for(const R of m.inboundNodes)if(-1!==p.indexOf(R)){if(x){d=!1;break}x=!0}if(!d)break}return d}(u),x=["Layer (type)","Input Shape","Output shape","Param #"];let R;if(m?(d=d||90,o=o||[.32,.61,.89,1]):(d=d||115,o=o||[.24,.48,.7,.8,1]),o[o.length-1]<=1&&(o=o.map(fe=>Math.floor(d*fe))),!m){x.push("Receives inputs"),R=[];for(const fe in u.nodesByDepth)R.push(...u.nodesByDepth[fe])}p("_".repeat(d)),sm(x,o,p),p("=".repeat(d));const $=u.layers;for(let fe=0;fe<$.length;++fe)m?ig($[fe],o,p):og($[fe],o,R,p),p((fe===$.length-1?"=":"_").repeat(d));u.checkTrainableWeightsConsistency();const j=function Td(u){let d;return d=Uh(null!=u.collectedTrainableWeights?u.collectedTrainableWeights:u.trainableWeights),d}(u),ce=Uh(u.nonTrainableWeights);p(`Total params: ${j+ce}`),p(`Trainable params: ${j}`),p(`Non-trainable params: ${ce}`),p("_".repeat(d))}(this,o,p,m)}compile(o){if(null==o.loss&&(o.loss=[]),this.loss=o.loss,"string"==typeof o.optimizer)this.optimizer_=function Hb(u){const d={Adagrad:()=>l.p_j.adagrad(.01),Adadelta:()=>l.p_j.adadelta(1,.95,Ba()),Adam:()=>l.p_j.adam(.001,.9,.999,Ba()),Adamax:()=>l.p_j.adamax(.002,.9,.999,Ba(),0),RMSProp:()=>l.p_j.rmsprop(.001,.9,0,Ba()),SGD:()=>l.p_j.sgd(.01)};if(d.adagrad=d.Adagrad,d.adadelta=d.Adadelta,d.adam=d.Adam,d.adamax=d.Adamax,d.rmsprop=d.RMSProp,d.sgd=d.SGD,u in d)return d[u]();throw new ln(`Unknown Optimizer ${u}`)}(o.optimizer),this.isOptimizerOwned=!0;else{if(!(o.optimizer instanceof l.gaJ))throw new ln("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=o.optimizer,this.isOptimizerOwned=!1}let p=[];if(Array.isArray(o.loss)||"string"==typeof o.loss||"function"==typeof o.loss)if(Array.isArray(o.loss)){if(o.loss.length!==this.outputs.length)throw new ln(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${o.loss}.`);p=o.loss.map(j=>Dr(j))}else{const $=Dr(o.loss);this.outputs.forEach(j=>{p.push($)})}else{o.loss=o.loss;for(const $ in o.loss)if(-1===this.outputNames.indexOf($))throw new ln(`Unknown entry in loss dictionary: "${$}". Only expected the following keys: ${this.outputNames}`);for(const $ of this.outputNames)null==o.loss[$]&&console.warn(`Output "${$}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${$} during training`),p.push(Dr(o.loss[$]))}this.lossFunctions=p,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let $=0;$<this.outputs.length;++$){const j=this.internalOutputShapes[$];this.feedOutputNames.push(this.outputNames[$]),this.feedOutputShapes.push(j),this.feedLossFns.push(this.lossFunctions[$])}const m=[];this.metrics=o.metrics,this.metricsNames=["loss"],this.metricsTensors=[],$c("loss",()=>{for(let $=0;$<this.outputs.length;++$)-1===m.indexOf($)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[$],$]),this.metricsNames.push(this.outputNames[$]+"_loss"))});const x=function Qb(u,d){if(null==u||Array.isArray(u)&&0===u.length)return d.map(p=>[]);let o;if("string"==typeof u||"function"==typeof u)o=[u];else{if(!Array.isArray(u)&&"object"!=typeof u)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${u}`);o=u}if(Array.isArray(o))return d.map(p=>o);{const p=[];for(const m of d){let x=o.hasOwnProperty(m)?o[m]:[];Array.isArray(x)||(x=[x]),p.push(x)}return p}}(o.metrics,this.outputNames),R=($,j,ce)=>{this.outputNames.length>1&&(j=this.outputNames[$]+"_"+j),this.metricsNames.push(j),this.metricsTensors.push([ce,$])};$c("metric",()=>{for(let $=0;$<this.outputs.length;++$)-1===m.indexOf($)&&(fe=>{let ze,nt,Rt;for(const bt of fe){if("string"==typeof bt&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(bt)){const Pt=this.internalOutputShapes[$];let St;1===Pt[Pt.length-1]||this.lossFunctions[$]===be?-1!==["accuracy","acc"].indexOf(bt)?nt=mr:-1!==["crossentropy","ce"].indexOf(bt)&&(nt=ya):this.lossFunctions[$]===pf?-1!==["accuracy","acc"].indexOf(bt)?nt=sa:-1!==["crossentropy","ce"].indexOf(bt)&&(nt=A_):-1!==["accuracy","acc"].indexOf(bt)?nt=_a:-1!==["crossentropy","ce"].indexOf(bt)&&(nt=xh),-1!==["accuracy","acc"].indexOf(bt)?St="acc":-1!==["crossentropy","ce"].indexOf(bt)&&(St="ce"),Rt=nt,ze=""+St}else Rt=mf(bt),ze=""+rg(bt);let xt;$c(ze,()=>{xt=Rt}),R($,ze,xt)}})(x[$])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(o,p,m={}){const x=null==m.batchSize?32:m.batchSize;im(x);const $=this.standardizeUserDataXY(o,p,!0,x);try{const j=$[0].concat($[1]);return this.makeTestFunction(),Do(this.testLoop(this.testFunction,j,x,m.verbose,m.steps))}finally{gu($[0],o),gu($[1],p)}}evaluateDataset(o,p){var m=this;return(0,ns.Z)(function*(){return m.makeTestFunction(),function N0(u,d,o){return(O0=O0||(0,ns.Z)(function*(p,m,x){const R=null!=(x=x||{}).batches,$=p.testFunction;let j=[];if(x.verbose>0)throw new ei("Verbose mode is not implemented yet.");l.D5U.assert(!R||x.batches>0&&Number.isInteger(x.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(x.batches)}`);const ce=function Xb(u){return"function"==typeof u.next}(m)?m:yield m.iterator();let fe=0,je=0;for(;!R||je<x.batches;){const ze=yield ce.next();if(j=l.lub(()=>{if(ze.value){const{xs:nt,ys:Rt}=N_(p,ze.value),bt=nt.concat(Rt),xt=l.lub(()=>$(bt));if(l.B90(bt),0===je)for(let St=0;St<xt.length;++St)j.push((0,l.iD$)(0));const Pt=bt[0].shape[0];for(let St=0;St<xt.length;++St){const Ut=xt[St],Ft=j[St];j[St]=l.lub(()=>l.IHx(j[St],l.dC7(Pt,Ut))),je>0&&l.B90(Ft)}l.B90(xt),fe+=Pt,++je}return j}),ze.done){R&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${x.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let ze=0;ze<j.length;++ze){const nt=j[ze];j[ze]=l.hiC(j[ze],fe),l.B90(nt)}return Do(j)})).apply(this,arguments)}(m,o,p)})()}checkNumSamples(o,p,m,x="steps"){let R;if(null!=m){if(R=null,null!=p)throw new ln(`If ${x} is set, batchSize must be null or undefined.Got batchSize = ${p}`)}else{if(null==o)throw new ln(`Either the input data should have a defined shape, or ${x} shoud be specified.`);R=Array.isArray(o)?o[0].shape[0]:o.shape[0]}return R}execute(o,p){if(Array.isArray(p)&&0===p.length)throw new ln("`outputs` is an empty Array, which is not allowed.");const m=Array.isArray(p),R=this.retrieveSymbolicTensors(m?p:[p]),$=new Cl;if(o instanceof l.esB&&(o=[o]),Array.isArray(o)){if(o.length!==this.inputs.length)throw new ln(`The number of inputs provided (${o.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let ce=0;ce<this.inputs.length;++ce)$.add(this.inputs[ce],o[ce])}else for(const ce of this.inputs){const fe=o[ce.name];if(null==fe)throw new ln(`No value is provided for the model's input ${ce.name}`);$.add(ce,fe)}const j=Yl(R,$);return m?j:j[0]}retrieveSymbolicTensors(o){const p=Ur(null,o.length);let m=o.length;for(const x of this.layers){const R=Array.isArray(x.output)?x.output:[x.output],$=R.map(j=>j.name);for(let j=0;j<o.length;++j){const ce=$.indexOf(o[j]);if(-1!==ce&&(p[j]=R[ce],m--),0===m)break}if(0===m)break}if(m>0){const x=[];throw p.forEach((R,$)=>{null==R&&x.push(o[$])}),new ln(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(x)}`)}return p}predictLoop(o,p=32,m=!1){return l.lub(()=>{const x=this.checkNumSamples(o);if(m)throw new ei("Verbose predictLoop() is not implemented yet.");const R=P_(x,p),$=this.outputs.map(j=>[]);for(let j=0;j<R.length;++j)l.lub(()=>{const ze=Kh(o,R[j][0],R[j][1]),nt=[];if(Array.isArray(ze))for(let bt=0;bt<ze.length;++bt)nt.push({key:this.inputs[bt],value:ze[bt]});else nt.push({key:this.inputs[0],value:ze});const Rt=new Cl(nt);return Yl(this.outputs,Rt)}).forEach((fe,je)=>$[je].push(fe));return Do($.map(j=>l.zoF(j,0)))})}predict(o,p={}){const m=M0(o);Zb(m,this.inputNames,this.feedInputShapes,!1);try{const x=null==p.batchSize?32:p.batchSize;return im(x),this.predictLoop(m,x)}finally{gu(m,o)}}predictOnBatch(o){Zb(o,this.inputNames,this.feedInputShapes,!0);const p=(Array.isArray(o)?o[0]:o).shape[0];return this.predictLoop(o,p)}standardizeUserDataXY(o,p,m=!0,x){if(null==this.optimizer_)throw new Ol("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const R=[];for(let $=0;$<this.feedOutputShapes.length;++$){const j=this.feedOutputShapes[$];R.push(this.feedLossFns[$]===pf?j.slice(0,j.length-1).concat([1]):j)}if(function Yb(u,d,o){const p=xe(u.map(x=>x.shape[0]));p.sort();const m=xe(d.map(x=>x.shape[0]));if(m.sort(),p.length>1)throw new ln(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(u.map(x=>x.shape))}`);if(m.length>1)throw new ln(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(d.map(x=>x.shape))}`);if(p.length>0&&m.length>0&&!l.D5U.arraysEqual(p,m))throw new ln(`Input Tensors should have the same number of samples as target Tensors. Found ${p[0]} input sample(s) and ${m[0]} target sample(s).`)}(o=P0(o,this.feedInputNames,this.feedInputShapes,!1,"input"),p=P0(p,this.feedOutputNames,R,!1,"target")),function XC(u,d,o){const p=[Hh,be,Cu];for(let m=0;m<u.length;++m){const x=u[m],R=d[m],$=o[m];if(null!=R){if(R===Cu&&1===x.shape[x.shape.length-1])throw new ln(`You are passing a target array of shape ${x.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==p.indexOf(R)){const j=x.shape.slice(1),ce=$.slice(1);for(let fe=0;fe<j.length;++fe){const ze=ce[fe];if(null!=ze&&j[fe]!==ze)throw new ln(`A target Tensor with shape ${x.shape} was passed for an output of shape ${$}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(p,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=x&&x>0&&o[0].shape[0]%x!=0)throw new ln(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${x}. Found: ${o[0].shape[0]} sample(s).`);return[o,p]}standardizeUserData(o,p,m,x,R=!0,$){var j=this;return(0,ns.Z)(function*(){const[ce,fe]=j.standardizeUserDataXY(o,p,R,$);if(null!=m)throw new Error("sample weight is not supported yet.");let je=null;if(null!=x){const ze=T0(x,j.outputNames);je=[];for(let nt=0;nt<ze.length;++nt)je.push(yield A0(fe[nt],null,ze[nt]))}return[ce,fe,je]})()}testLoop(o,p,m,x=0,R){return l.lub(()=>{const $=this.checkNumSamples(p,m,R,"steps"),j=[];if(x>0)throw new ei("Verbose mode is not implemented yet.");if(null!=R)throw new ei("steps mode in testLoop() is not implemented yet");{const ce=P_($,m),fe=(0,l.RRF)(Jc(0,$));for(let je=0;je<ce.length;++je){const ze=ce[je][0],nt=ce[je][1],Rt=Nl(fe,ze,nt-ze),bt=M_(p,Rt),xt=o(bt);if(0===je)for(let Pt=0;Pt<xt.length;++Pt)j.push((0,l.iD$)(0));for(let Pt=0;Pt<xt.length;++Pt)j[Pt]=l.IHx(j[Pt],l.dC7(nt-ze,xt[Pt]))}for(let je=0;je<j.length;++je)j[je]=l.hiC(j[je],$)}return j})}getDedupedMetricsNames(){const o=this.metricsNames,p=[];for(let m=0;m<o.length;++m){const x=o[m];let R=x;wd(o,x)>1&&(R+=`_${wd(o.slice(0,m),x)}`),p.push(R)}return p}makeTrainFunction(){return o=>{const p=[],m=o.slice(0,this.inputs.length),x=o.slice(this.inputs.length,this.inputs.length+this.outputs.length),R=o.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),$=[],ce=this.collectedTrainableWeights.map(ze=>ze.read());return[this.optimizer_.minimize(()=>{const ze=[];for(let xt=0;xt<this.inputs.length;++xt)ze.push({key:this.inputs[xt],value:m[xt]});const nt=new Cl(ze),Rt=Yl(this.outputs,nt,{training:!0});let bt;for(let xt=0;xt<this.lossFunctions.length;++xt){let St=(0,this.lossFunctions[xt])(x[xt],Rt[xt]);null!=R[xt]&&(St=HC(St,R[xt]));const Ut=l.J69(St);p.push(Ut),bt=0===xt?St:l.IHx(bt,St)}for(let xt=0;xt<this.metricsTensors.length;++xt){let Pt;if(this.outputs.length>1&&xt<this.outputs.length)Pt=p[xt];else{const Ut=this.metricsTensors[xt][1];Pt=l.J69((0,this.metricsTensors[xt][0])(x[Ut],Rt[Ut]))}l.CnY(Pt),$.push(Pt)}return bt=l.J69(bt),this.calculateLosses().forEach(xt=>{bt=l.IHx(bt,xt)}),bt},!0,ce)].concat($)}}makeTestFunction(){this.testFunction=o=>l.lub(()=>{const p=[];let m;const x=o.slice(0,this.inputs.length),R=o.slice(this.inputs.length,this.inputs.length+this.outputs.length),$=[];for(let fe=0;fe<this.inputs.length;++fe)$.push({key:this.inputs[fe],value:x[fe]});const j=new Cl($),ce=Yl(this.outputs,j);for(let fe=0;fe<this.lossFunctions.length;++fe){const ze=l.J69((0,this.lossFunctions[fe])(R[fe],ce[fe]));m=0===fe?ze:l.IHx(m,ze),p.push(m)}for(let fe=0;fe<this.metricsTensors.length;++fe){const ze=this.metricsTensors[fe][1],nt=l.J69((0,this.metricsTensors[fe][0])(R[ze],ce[ze]));p.push(nt)}return p})}fit(o,p,m={}){var x=this;return(0,ns.Z)(function*(){if(x.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let R,$,j,ce,fe,je,ze,nt,Rt;x.isTraining=!0;try{const bt=null==m.batchSize?32:m.batchSize;im(bt);const xt=!1,Pt=yield x.standardizeUserData(o,p,m.sampleWeight,m.classWeight,xt,bt);R=Pt[0],$=Pt[1],Rt=Pt[2];let Ut,St=!1;if(null!=m.validationData&&m.validationData.length>0){if(St=!0,2!==m.validationData.length)throw 3===m.validationData.length?new ei("validationData including sample weights is not supported yet."):new ln(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${m.validationData} is invalid.`);fe=m.validationData[0],je=m.validationData[1];const ls=!0,Cs=yield x.standardizeUserData(fe,je,null,null,ls,bt);ze=Cs[0],nt=Cs[1],Ut=ze.concat(nt)}else if(null!=m.validationSplit&&m.validationSplit>0&&m.validationSplit<1){St=!0;const ls=Math.floor(R[0].shape[0]*(1-m.validationSplit)),Cs=R[0].shape[0];ze=Kh(R,ls,Cs),j=R,R=Kh(R,0,ls),nt=Kh($,ls,Cs),ce=$,$=Kh($,0,ls),Ut=ze.concat(nt)}else null!=m.validationSteps&&(St=!0);const Ft=R.concat($).concat(Rt);x.checkTrainableWeightsConsistency();const sn=x.makeTrainFunction(),_n=x.getDedupedMetricsNames();let Cn,Bn;St?(x.makeTestFunction(),Cn=x.testFunction,Bn=_n.slice().concat(_n.map(ls=>"val_"+ls))):(Cn=null,Ut=[],Bn=_n.slice());const Vn=tg(m.callbacks,m.yieldEvery);return yield x.fitLoop(sn,Ft,_n,bt,m.epochs,m.verbose,Vn,Cn,Ut,m.shuffle,Bn,m.initialEpoch,null,null)}finally{x.isTraining=!1,gu(R,o),gu($,p),gu(j,o),gu(ce,p),gu(ze,fe),gu(nt,je),null!=Rt&&l.B90(Rt)}})()}fitLoop(o,p,m,x,R,$,j,ce,fe,je,ze,nt,Rt,bt){var xt=this;return(0,ns.Z)(function*(){null==x&&(x=32),null==R&&(R=1),null==je&&(je=!0),null==nt&&(nt=0);let Pt=!1;if(null!=ce&&null!=fe&&(Pt=!0),null!=bt&&(Pt=!0,null==Rt))throw new ln("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const St=xt.checkNumSamples(p,x,Rt,"steps_per_epoch");let Ut;null!=St&&(Ut=Jc(0,St)),null==$&&($=1);const{callbackList:Ft,history:sn}=T_(j,$,R,nt,St,Rt,x,Pt,ze);Ft.setModel(xt),xt.history=sn,yield Ft.onTrainBegin(),xt.stopTraining_=!1;for(let _n=nt;_n<R;++_n){yield Ft.onEpochBegin(_n);const Cn={};if(null!=Rt)throw new ei("stepsPerEpoch mode is not implemented yet.");{if("batch"===je)throw new ei("batch shuffling is not implemneted yet");je&&l.D5U.shuffle(Ut);const Bn=(0,l.RRF)(Ut),Vn=P_(St,x);for(let es=0;es<Vn.length;++es){const ls={};if(yield Ft.onBatchBegin(es,ls),l.lub(()=>{const Cs=Vn[es][0],rs=Vn[es][1],hs=Nl(Bn,Cs,rs-Cs);ls.batch=es,ls.size=rs-Cs;const ms=M_(p,hs),_s=o(ms);for(let Ds=0;Ds<m.length;++Ds){const ys=_s[Ds];ls[m[Ds]]=ys,l.CnY(ys)}if(es===Vn.length-1&&Pt){const Ds=xt.testLoop(ce,fe,x);for(let ds=0;ds<m.length;++ds){const ys=m[ds],Ns=Ds[ds];l.CnY(Ns),Cn["val_"+ys]=Ns}}}),yield Ft.onBatchEnd(es,ls),qm(ls),xt.stopTraining_)break}Bn.dispose()}if(yield Ft.onEpochEnd(_n,Cn),xt.stopTraining_)break}return yield Ft.onTrainEnd(),yield xt.history.syncData(),xt.history})()}fitDataset(o,p){var m=this;return(0,ns.Z)(function*(){return function wh(u,d,o){return(k0=k0||(0,ns.Z)(function*(p,m,x){const R=null!=x.batchesPerEpoch;if(l.D5U.assert(null!=p.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),l.D5U.assert(null!=x,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),l.D5U.assert(null!=x.epochs&&x.epochs>0&&Number.isInteger(x.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${x.epochs}`),l.D5U.assert(!R||x.batchesPerEpoch>0&&Number.isInteger(x.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${x.batchesPerEpoch}`),l.D5U.assert(null==x.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),p.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");p.isTraining=!0;try{const $=null!=x.validationData;let j,ce;if($)if(Gh(x.validationData))l.D5U.assert(null==x.validationBatches||x.validationBatches>0&&Number.isInteger(x.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${x.validationBatches}`);else{const Ut=function R0(u){if(3===u.length)throw new ei("Validation with sample weights is not implemented yet.");return{xs:u[0],ys:u[1]}}(x.validationData);j=Ut.xs,ce=Ut.ys}const fe=p.makeTrainFunction(),je=p.getDedupedMetricsNames();let ze;ze=$?je.slice().concat(je.map(Ut=>"val_"+Ut)):je.slice();const nt=tg(x.callbacks,x.yieldEvery),Rt=null==x.verbose?1:x.verbose,{callbackList:bt,history:xt}=T_(nt,Rt,x.epochs,null,null,function GC(u,d){let o=null;return null!=d.batchesPerEpoch?o=d.batchesPerEpoch:Number.isFinite(u.size)&&(o=u.size),o}(m,x),null,$,ze);bt.setModel(p),p.history=xt,yield bt.onTrainBegin(),p.stopTraining_=!1;let Pt=null==x.initialEpoch?0:x.initialEpoch,St=yield m.iterator();for(;Pt<x.epochs;){const Ut={};yield bt.onEpochBegin(Pt);let Ft=0,sn=0;for(R||(St=yield m.iterator());!R||Ft<x.batchesPerEpoch;){const _n=yield St.next();if(R&&_n.done){console.warn(`You provided \`batchesPerEpoch\` as ${x.batchesPerEpoch}, but your dataset iterator ran out of data after ${Ft} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${x.batchesPerEpoch*x.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=_n.value){const{xs:Cn,ys:Bn}=N_(p,_n.value),Vn={};Vn.batch=sn,Vn.size=Cn[0].shape[0],yield bt.onBatchBegin(sn,Vn);const es=[];if(null!=x.classWeight){const rs=T0(x.classWeight,p.outputNames);for(let hs=0;hs<rs.length;++hs)es.push(yield A0(Bn[hs],null,rs[hs]))}const ls=Cn.concat(Bn).concat(es),Cs=fe(ls);l.B90(ls);for(let rs=0;rs<je.length;++rs){const ms=Cs[rs];Vn[je[rs]]=ms,l.CnY(ms)}yield bt.onBatchEnd(sn,Vn),qm(Vn),sn++,Ft++}if(R?Ft>=x.batchesPerEpoch:_n.done){if($){let Cn;Cn=Gh(x.validationData)?ks(yield p.evaluateDataset(x.validationData,{batches:x.validationBatches})):ks(p.evaluate(j,ce,{batchSize:null==x.validationBatchSize?32:x.validationBatchSize,verbose:0}));for(let Bn=0;Bn<p.metricsNames.length;++Bn)Ut[`val_${p.metricsNames[Bn]}`]=Cn[Bn]}break}if(p.stopTraining_)break}if(yield bt.onEpochEnd(Pt,Ut),Pt++,p.stopTraining_)break}return yield bt.onTrainEnd(),yield p.history.syncData(),p.history}finally{p.isTraining=!1}})).apply(this,arguments)}(m,o,p)})()}trainOnBatch(o,p){var m=this;return(0,ns.Z)(function*(){const x=yield m.standardizeUserData(o,p),R=x[0],$=x[1],ce=m.makeTrainFunction()(R.concat($)),fe=[];for(const je of ce){const ze=yield je.data();fe.push(ze[0])}return l.B90(ce),gu(x[0],o),gu(x[1],p),Do(fe)})()}getNamedWeights(o){const p=[],m=null!=o&&o.trainableOnly,x=m?this.trainableWeights:this.weights,R=this.getWeights(m);for(let $=0;$<x.length;++$)m&&!x[$].trainable||p.push({name:x[$].originalName,tensor:R[$]});return p}set stopTraining(o){this.stopTraining_=o}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(o){this.optimizer_!==o&&(this.optimizer_=o,this.isOptimizerOwned=!1)}dispose(){const o=super.dispose();if(0===o.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const p=l.sq6().numTensors;this.optimizer_.dispose(),o.numDisposedVariables+=p-l.sq6().numTensors}return o}getLossIdentifiers(){let o;if("string"==typeof this.loss)o=Me(this.loss);else if(Array.isArray(this.loss)){for(const p of this.loss)if("string"!=typeof p)throw new Error("Serialization of non-string loss is not supported.");o=this.loss.map(p=>Me(p))}else{const p=Object.keys(this.loss);o={};const m=this.loss;for(const x of p){if("string"!=typeof m[x])throw new Error("Serialization of non-string loss is not supported.");o[x]=Me(m[x])}}return o}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Me(rg(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(o=>Me(rg(o)));{const o={};for(const p in this.metrics)o[p]=Me(rg(this.metrics[p]));return o}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(o){if(null!=o.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=o.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=o.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const m=wu(ag(o.optimizer_config));let x,R;if("string"==typeof o.loss)x=ge(o.loss);else if(Array.isArray(o.loss))x=o.loss.map($=>ge($));else if(null!=o.loss){x={};for(const $ in o.loss)x[$]=ge(o.loss[$])}if(Array.isArray(o.metrics))R=o.metrics.map($=>ge($));else if(null!=o.metrics){R={};for(const $ in o.metrics)R[$]=ge(o.metrics[$])}this.compile({loss:x,metrics:R,optimizer:m})}save(o,p){var m=this;return(0,ns.Z)(function*(){if("string"==typeof o){const je=l.io.getSaveHandlers(o);if(0===je.length)throw new ln(`Cannot find any save handlers for URL '${o}'`);if(je.length>1)throw new ln(`Found more than one (${je.length}) save handlers for URL '${o}'`);o=je[0]}if(null==o.save)throw new ln("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const x=yield l.io.encodeWeights(m.getNamedWeights(p)),ce={modelTopology:m.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${R_}`,convertedBy:null};if(null!=p&&p.includeOptimizer&&null!=m.optimizer){ce.trainingConfig=m.getTrainingConfig();const je="optimizer",{data:ze,specs:nt}=yield l.io.encodeWeights(yield m.optimizer.getWeights(),je);x.specs.push(...nt),x.data=l.io.concatenateArrayBuffers([x.data,ze])}return null!=m.userDefinedMetadata&&(I0(m.userDefinedMetadata,m.name,!0),ce.userDefinedMetadata=m.userDefinedMetadata),ce.weightData=x.data,ce.weightSpecs=x.specs,o.save(ce)})()}setUserDefinedMetadata(o){I0(o,this.name),this.userDefinedMetadata=o}getUserDefinedMetadata(){return this.userDefinedMetadata}}return u.className="Model",u})();var F0,L_,ex;function L0(u,d){return(F0=F0||(0,ns.Z)(function*(o,p){"modelTopology"in o||(o={modelTopology:o});let m=o.modelTopology;null!=m.model_config&&(m=m.model_config);const R=wu(ag(m),p);if(null!=o.weightsManifest){const $=yield l.io.loadWeights(o.weightsManifest,o.pathPrefix,R.weights.map(ce=>ce.originalName)),j={};for(const ce of R.weights)j[ce.originalName]=$[ce.originalName];R.loadWeights(j),(0,l.B90)($)}return R})).apply(this,arguments)}function YC(u,d){return(L_=L_||(0,ns.Z)(function*(o,p){if(null==p&&(p={}),"string"==typeof o){const m=l.io.getLoadHandlers(o,p);if(0===m.length)m.push(l.io.browserHTTPRequest(o,p));else if(m.length>1)throw new ln(`Found more than one (${m.length}) load handlers for URL '${o}'`);o=m[0]}return function tx(u,d,o){return(ex=ex||(0,ns.Z)(function*(p,m,x){if(null==x&&(x={}),null==p.load)throw new ln("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const R=yield p.load();let $=R.modelTopology;null!=$.model_config&&($=$.model_config);const j=null==x.strict||x.strict,ce=null!=R.weightData&&null!=R.weightSpecs&&j,fe=wu(ag($),m,ce),je=R.trainingConfig;if(null!=je&&fe.loadTrainingConfig(je),null!=R.userDefinedMetadata&&fe.setUserDefinedMetadata(R.userDefinedMetadata),null!=R.weightData){if(null==R.weightSpecs)throw new ln("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:ze,optimizerWeights:nt}=function nx(u,d){const o=l.io.decodeWeights(u,d),p={},m=[];return d.forEach(x=>{"optimizer"===x.group?m.push({name:x.name,tensor:o[x.name]}):p[x.name]=o[x.name]}),{modelWeights:p,optimizerWeights:m}}(R.weightData,R.weightSpecs);fe.loadWeights(ze,j),null!=fe.optimizer&&nt.length>0&&(yield fe.optimizer.setWeights(nt)),(0,l.B90)(ze),(0,l.B90)(nt.map(Rt=>Rt.tensor))}return fe})).apply(this,arguments)}(o,void 0,p)})).apply(this,arguments)}l.m7h.registerClass(Jd),l.m7h.registerClass((()=>{class u extends Jd{}return u.className="Functional",u})());let am=(()=>{class u extends Jd{constructor(o){if(super({inputs:[],outputs:[]}),o=o||{},this.trainable=!0,this.built=!1,this.name=null!=o.name?o.name:vs("sequential_"),null!=o.layers)for(const p of o.layers)this.add(p)}checkShape(o){if(o.inboundNodes[0].outputTensors[0].shape.some(m=>m<0))throw new ln(`Negative dimension size caused by adding layer ${o.name} with input shape [${o.inboundNodes[0].inputTensors[0].shape}]`)}add(o){const p=o instanceof u||o instanceof Jd;let m;if(p){if(m=o,1!==m.outputs.length)throw new ln("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==m.inputs.length)throw new ln("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===o.inboundNodes.length){if(null==o.batchInputShape)throw new ln("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const x=Za({batchShape:o.batchInputShape,dtype:o.dtype,name:o.name+"_input"});o.apply(x)}if(p)this.outputs=m.outputs,this.inputs=m.inputs;else{if(1!==o.inboundNodes.length)throw new ln(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${o.name} which has ${o.inboundNodes.length} pre-existing inbound connections.`);if(1!==o.inboundNodes[0].outputTensors.length)throw new ln("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(o),this.outputs=[o.inboundNodes[0].outputTensors[0]],this.inputs=ta(this.outputs[0])}this.inboundNodes=[],new Fr({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ur(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs[0].shape})}else{const x=o.apply(this.outputs[0]);if(Array.isArray(x))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(o),this.outputs=[x],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(o),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const o=this.layers.length-1;this.layers[o].outboundNodes=[],this.outputs=[this.layers[o].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(o,p){return null==this.model&&this.build(),this.model.call(o,p)}build(o){if(ao(o),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Jd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(o,p,m=console.log){this.built||this.build(),super.summary(o,p,m)}setWeights(o){null==this.model&&this.build(),this.model.setWeights(o)}evaluate(o,p,m={}){if(!this.built)throw new Ol("The model needs to be compiled before being used.");return this.model.evaluate(o,p,m)}evaluateDataset(o,p){var m=this;return(0,ns.Z)(function*(){if(!m.built)throw new Ol("The model needs to be compiled before being used.");return m.model.evaluateDataset(o,p)})()}predict(o,p={}){return null==this.model&&this.build(),this.model.predict(o,p)}predictOnBatch(o){return null==this.model&&this.build(),this.model.predictOnBatch(o)}compile(o){this.build(),this.model.compile(o),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(o){this.model.optimizer=o}fit(o,p,m={}){var x=this;return(0,ns.Z)(function*(){if(!x.built)throw new Ol("The model needs to be compiled before being used.");return x.model.fit(o,p,m)})()}fitDataset(o,p){var m=this;return(0,ns.Z)(function*(){if(!m.built)throw new Ol("The model needs to be compiled before being used.");return m.model.fitDataset(o,p)})()}trainOnBatch(o,p){var m=this;return(0,ns.Z)(function*(){return m.model.trainOnBatch(o,p)})()}static fromConfig(o,p,m={},x=!1){let R,$={};if(p instanceof Array){if(null==p[0].className||"Merge"===p[0].className)throw new ln("Legacy serialization format not supported yet.");R=p}else l.D5U.assert(null!=p.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),R=p.layers,delete p.layers,$=p;const j=new o($);if(!(j instanceof u))throw new ei(`Sequential.fromConfig called on non-Sequential input: ${j}`);for(const ce of R){const je=wu(ce,void 0,x);x&&je.setFastWeightInitDuringBuild(!0),j.add(je)}return j}set stopTraining(o){if(null==this.model)throw new ln("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=o}get stopTraining(){if(null==this.model)throw new ln("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const o=[];for(const p of this.layers){const m={};m.className=p.getClassName(),m.config=p.getConfig(),o.push(m)}return{name:this.name,layers:o}}}return u.className="Sequential",u})();function ZC(u){return new Jd(u)}function QC(u){return new am(u)}function lm(u){return Za(u)}function JC(u,d){I_.registerCallbackConstructor(u,d)}l.m7h.registerClass(am);class Fu extends l.m7h.Serializable{getConfig(){return{}}}let qC=(()=>{class u extends Fu{apply(o,p=1){return function ef(u,d=1){if(1!==d)throw new ei(`Support for alpha values other than 1 (${d}) is not implemented yet.`);return l.pyx(u)}(o,p)}}return u.className="elu",u})();l.m7h.registerClass(qC);let e1=(()=>{class u extends Fu{apply(o){return l.U8D(o)}}return u.className="selu",u})();l.m7h.registerClass(e1);let t1=(()=>{class u extends Fu{apply(o){return l.UYe(o)}}return u.className="relu",u})();l.m7h.registerClass(t1);let sx=(()=>{class u extends Fu{apply(o){return(0,l.lub)(()=>l.LTh(6,l.UYe(o)))}}return u.className="relu6",u})();l.m7h.registerClass(sx),l.m7h.registerClass((()=>{class u extends Fu{apply(o){return o}}return u.className="linear",u})());let cg=(()=>{class u extends Fu{apply(o){return l.XD2(o)}}return u.className="sigmoid",u})();l.m7h.registerClass(cg);let $0=(()=>{class u extends Fu{apply(o){return function tf(u){return(0,l.lub)(()=>{const d=l.IHx(.5,l.dC7(.2,u));return l.iUl(d,0,1)})}(o)}}return u.className="hardSigmoid",u})();l.m7h.registerClass($0);let B0=(()=>{class u extends Fu{apply(o){return l.Wvh(o)}}return u.className="softplus",u})();l.m7h.registerClass(B0);let V0=(()=>{class u extends Fu{apply(o){return function jf(u){return(0,l.lub)(()=>l.hiC(u,l.IHx(l.WnP(u),1)))}(o)}}return u.className="softsign",u})();l.m7h.registerClass(V0);let gf=(()=>{class u extends Fu{apply(o){return l.AEp(o)}}return u.className="tanh",u})();l.m7h.registerClass(gf);let $_=(()=>{class u extends Fu{apply(o,p=-1){return l.XAC(o,p)}}return u.className="softmax",u})();l.m7h.registerClass($_);let U0=(()=>{class u extends Fu{apply(o,p=-1){return l.CmS(o,p)}}return u.className="logSoftmax",u})();l.m7h.registerClass(U0);let ug=(()=>{class u extends Fu{apply(o,p=1){return(0,l.lub)(()=>l.dC7(l.XD2(l.dC7(o,p)),o))}}return u.className="swish",u})();l.m7h.registerClass(ug);let dg=(()=>{class u extends Fu{apply(o){return(0,l.lub)(()=>l.dC7(o,l.AEp(l.Wvh(o))))}}return u.className="mish",u})();function Eu(u){return u.getClassName()}function B_(u,d={}){return $t(u,l.m7h.SerializationMap.getMap().classNameMap,d,"activation")}function Xh(u){if(null==u){return B_({className:"linear",config:{}})}if("string"==typeof u){const d={};return d.className=u,d.config={},B_(d)}return u instanceof Fu?u:B_(u)}function V_(u){if(null!=u&&"object"!=typeof u)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${u}`)}l.m7h.registerClass(dg);class U_ extends l.m7h.Serializable{}let _f=(()=>{class u extends U_{constructor(o){super(),V_(o),this.l1=null==o||null==o.l1?.01:o.l1,this.l2=null==o||null==o.l2?.01:o.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(o){return(0,l.lub)(()=>{let p=(0,l.lls)([1]);return this.hasL1&&(p=(0,l.IHx)(p,(0,l.Smz)(l.dC7(this.l1,(0,l.WnP)(o))))),this.hasL2&&(p=(0,l.IHx)(p,(0,l.Smz)(l.dC7(this.l2,Ed(o))))),l.XLQ(p,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(o,p){return new o({l1:p.l1,l2:p.l2})}}return u.className="L1L2",u})();l.m7h.registerClass(_f);const z0={l1l2:"L1L2"};function Ta(u){return Ke(u)}function W0(u,d={}){return $t(u,l.m7h.SerializationMap.getMap().classNameMap,d,"regularizer")}function Dl(u){return null==u?null:"string"==typeof u?W0({className:u in z0?z0[u]:u,config:{}}):u instanceof U_?u:W0(u)}let Du=(()=>{class u extends gs{constructor(o){super(o??{}),this.supportsMasking=!0,null!=o&&(this.maxValue=o.maxValue)}call(o,p){o=li(o);let m=(0,l.UYe)(o);return null!=this.maxValue&&(m=(0,l.iUl)(m,0,this.maxValue)),m}computeOutputShape(o){return o}getConfig(){const o={maxValue:this.maxValue},p=super.getConfig();return Object.assign(o,p),o}}return u.className="ReLU",u})();l.m7h.registerClass(Du);let hg=(()=>{class u extends gs{constructor(o){super(o??{}),this.DEFAULT_ALPHA=.3,null==o&&(o={}),this.alpha=null==o.alpha?this.DEFAULT_ALPHA:o.alpha}call(o,p){const m=li(o);return(0,l.hi7)(m,this.alpha)}computeOutputShape(o){return o}getConfig(){const o={alpha:this.alpha},p=super.getConfig();return Object.assign(o,p),o}}return u.className="LeakyReLU",u})();l.m7h.registerClass(hg);let z_=(()=>{class u extends gs{constructor(o){if(super(o??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==o&&(o={}),this.supportsMasking=!0,this.alphaInitializer=Uo(o.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Dl(o.alphaRegularizer),this.alphaConstraint=Ql(o.alphaConstraint),null==o.sharedAxes)this.sharedAxes=null;else if(Array.isArray(o.sharedAxes))this.sharedAxes=o.sharedAxes;else{if("number"!=typeof o.sharedAxes)throw new ln(`Expected sharedAxes to be a number or an array of numbers, but got ${o.sharedAxes}`);this.sharedAxes=[o.sharedAxes]}}build(o){const p=(o=ao(o)).slice(1);if(null!=this.sharedAxes)for(const x of this.sharedAxes)p[x-1]=1;this.alpha=this.addWeight("alpha",p,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const m={};if(null!=this.sharedAxes)for(let x=1;x<o.length;++x)m[x]=o[x];this.inputSpec=[new pi({ndim:o.length,axes:m})],this.built=!0}call(o,p){return o=li(o),(0,l.AL3)(o,this.alpha.read())}getConfig(){const o={alphaInitializer:Va(this.alphaInitializer),alphaRegularizer:Ta(this.alphaRegularizer),alphaConstraint:Zl(this.alphaConstraint),sharedAxes:this.sharedAxes},p=super.getConfig();return Object.assign(o,p),o}}return u.className="PReLU",u})();l.m7h.registerClass(z_);let pg=(()=>{class u extends gs{constructor(o){if(super(o??{}),this.DEFAULT_ALPHA=1,null==o&&(o={}),null!=o.alpha&&o.alpha!==this.DEFAULT_ALPHA)throw new ei(`Non-default alpha value (${o.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==o.alpha?this.DEFAULT_ALPHA:o.alpha}call(o,p){const m=li(o);return(0,l.pyx)(m)}computeOutputShape(o){return o}getConfig(){const o={alpha:this.alpha},p=super.getConfig();return Object.assign(o,p),o}}return u.className="ELU",u})();l.m7h.registerClass(pg);let tu=(()=>{class u extends gs{constructor(o){super(o??{}),this.DEFAULT_THETA=1,null==o&&(o={}),this.theta=null==o.theta?this.DEFAULT_THETA:o.theta}call(o,p){const m=li(o);return(0,l.dC7)(m,(0,l.pju)((0,l.pjt)(m,this.theta),"float32"))}computeOutputShape(o){return o}getConfig(){const o={theta:this.theta},p=super.getConfig();return Object.assign(o,p),o}}return u.className="ThresholdedReLU",u})();l.m7h.registerClass(tu);let yf=(()=>{class u extends gs{constructor(o){super(o??{}),this.DEFAULT_AXIS=1,null==o&&(o={}),this.softmax=(new $_).apply,this.axis=null==o.axis?this.DEFAULT_AXIS:o.axis}call(o,p){return(0,l.lub)(()=>{let m=li(o);const x=p.mask;if(null!=x){const R=(0,l.dC7)((0,l.luU)((0,l.iUs)(m.shape),(0,l.pju)(x,m.dtype)),(0,l.iD$)(-1e9));m=(0,l.IHx)(m,R)}return this.axis instanceof Array?this.axis.length>1?(0,l.Qqt)((0,l.luU)(m,(0,l.l_t)(m,this.axis,!0))):this.softmax(m,this.axis[0]):this.softmax(m,this.axis)})}computeOutputShape(o){return o}getConfig(){const o={axis:this.axis},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Softmax",u})();function vf(u,d,o){if("number"==typeof u)return Ur(u,d);if(u.length!==d)throw new ln(`The ${o} argument must be an integer or tuple of ${d} integers. Received: ${u.length} elements.`);for(let p=0;p<d;++p){const m=u[p];if(!Zp(m))throw new ln(`The ${o} argument must be an integer or tuple of ${d} integers. Received: ${JSON.stringify(u)} including a non-integer number ${m}`)}return u}function Ad(u,d,o,p,m=1){if(null==u)return u;let R;return R="same"===o?u:u-(d+(d-1)*(m-1))+1,Math.floor((R+p-1)/p)}function kd(u,d,o,p){if(null==u)return null;if("valid"===p)u=u*d+Nu([o-d,0]);else{if("same"!==p)throw new ln(`Unsupport padding mode: ${p}.`);u*=d}return u}function fg(u,d){return(0,l.lub)(()=>(Ci(d),"channelsFirst"===d?l.p4s(u,[0,2,3,1]):u))}function W_(u,d){return(0,l.lub)(()=>(Ci(d),"channelsFirst"===d?l.p4s(u,[0,2,3,4,1]):u))}function H_(u,d,o,p=[1,1],m="valid",x,R,$=null){return(0,l.lub)(()=>{if(null==x&&(x="channelsLast"),Ci(x),3!==u.rank&&4!==u.rank)throw new ln(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${u.rank}.`);if(3!==d.rank&&4!==d.rank)throw new ln(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${u.rank}.`);let j=fg(u,x);if("causal"===m)throw new ei("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return j=l.imm.conv2d({x:j,filter:d,strides:p,pad:"same"===m?"same":"valid",dilations:R,dataFormat:"NHWC",bias:o,activation:$}),"channelsFirst"===x&&(j=l.p4s(j,[0,3,1,2])),j})}l.m7h.registerClass(yf);class bf extends gs{constructor(d,o){if(super(o),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",bf.verifyArgs(o),this.rank=d,gt(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new ei(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=vf(o.kernelSize,d,"kernelSize"),this.strides=vf(null==o.strides?1:o.strides,d,"strides"),this.padding=null==o.padding?"valid":o.padding,cl(this.padding),this.dataFormat=null==o.dataFormat?"channelsLast":o.dataFormat,Ci(this.dataFormat),this.activation=Xh(o.activation),this.useBias=null==o.useBias||o.useBias,this.biasInitializer=Uo(o.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ql(o.biasConstraint),this.biasRegularizer=Dl(o.biasRegularizer),this.activityRegularizer=Dl(o.activityRegularizer),this.dilationRate=vf(null==o.dilationRate?1:o.dilationRate,d,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new ln(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new ln(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new ln(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(d){if(wl("kernelSize"in d,"required key 'kernelSize' not in config"),"number"!=typeof d.kernelSize&&!Fe(d.kernelSize,"number",1,3))throw new ln(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(d.kernelSize)}.`)}getConfig(){const d={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Eu(this.activation),useBias:this.useBias,biasInitializer:Va(this.biasInitializer),biasRegularizer:Ta(this.biasRegularizer),activityRegularizer:Ta(this.activityRegularizer),biasConstraint:Zl(this.biasConstraint)},o=super.getConfig();return Object.assign(d,o),d}}class xf extends bf{constructor(d,o){super(d,o),this.kernel=null,xf.verifyArgs(o),this.filters=o.filters,gt(this.filters,"filters"),this.kernelInitializer=Uo(o.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ql(o.kernelConstraint),this.kernelRegularizer=Dl(o.kernelRegularizer)}build(d){d=ao(d);const o="channelsFirst"===this.dataFormat?1:d.length-1;if(null==d[o])throw new ln(`The channel dimension of the input should be defined. Found ${d[o]}`);const p=d[o],m=this.kernelSize.concat([p,this.filters]);this.kernel=this.addWeight("kernel",m,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[o]:p}}],this.built=!0}call(d,o){return(0,l.lub)(()=>{let p;d=li(d);const m=null==this.bias?null:this.bias.read(),x=Pn(this.activation.getClassName());if(null!=x&&2===this.rank)p=H_(d,this.kernel.read(),m,this.strides,this.padding,this.dataFormat,this.dilationRate,x);else{if(1===this.rank)p=function mg(u,d,o,p=1,m="valid",x,R=1){return(0,l.lub)(()=>{if(null==x&&(x="channelsLast"),Ci(x),3!==u.shape.length)throw new ln(`The input of a conv1dWithBias operation should be 3, but is ${u.shape.length} instead.`);if(3!==d.shape.length)throw new ln(`The kernel for a conv1dWithBias operation should be 3, but is ${d.shape.length} instead`);if(null!=o&&1!==o.shape.length)throw new ln(`The bias for a conv1dWithBias operation should be 1, but is ${d.shape.length} instead`);if("channelsFirst"===x&&(u=l.p4s(u,[0,2,1])),"causal"===m)throw new ei("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let $=l.PAt(u,d,p,"same"===m?"same":"valid","NWC",R);return null!=o&&($=Mu($,o)),$})}(d,this.kernel.read(),m,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)p=H_(d,this.kernel.read(),m,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new ei("convolutions greater than 3D are not implemented yet.");p=function gg(u,d,o,p=[1,1,1],m="valid",x,R){return(0,l.lub)(()=>{if(null==x&&(x="channelsLast"),Ci(x),4!==u.rank&&5!==u.rank)throw new ln(`conv3dWithBias expects input to be of rank 4 or 5, but received ${u.rank}.`);if(4!==d.rank&&5!==d.rank)throw new ln(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${u.rank}.`);let $=W_(u,x);if("causal"===m)throw new ei("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return $=l.pdZ($,d,p,"same"===m?"same":"valid","NDHWC",R),null!=o&&($=Mu($,o)),"channelsFirst"===x&&($=l.p4s($,[0,4,1,2,3])),$})}(d,this.kernel.read(),m,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(p=this.activation.apply(p))}return p})}computeOutputShape(d){d=ao(d);const o=[],p="channelsLast"===this.dataFormat?d.slice(1,d.length-1):d.slice(2);for(let x=0;x<p.length;++x){const R=Ad(p[x],this.kernelSize[x],this.padding,this.strides[x],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[x]);o.push(R)}let m=[d[0]];return"channelsLast"===this.dataFormat?(m=m.concat(o),m.push(this.filters)):(m.push(this.filters),m=m.concat(o)),m}getConfig(){const d={filters:this.filters,kernelInitializer:Va(this.kernelInitializer),kernelRegularizer:Ta(this.kernelRegularizer),kernelConstraint:Zl(this.kernelConstraint)},o=super.getConfig();return Object.assign(d,o),d}static verifyArgs(d){if(!("filters"in d)||"number"!=typeof d.filters||d.filters<1)throw new ln(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(d.filters)}`)}}let Np=(()=>{class u extends xf{constructor(o){super(2,o),u.verifyArgs(o)}getConfig(){const o=super.getConfig();return delete o.rank,o}static verifyArgs(o){if("number"!=typeof o.kernelSize&&!Fe(o.kernelSize,"number",1,2))throw new ln(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(o.kernelSize)}.`)}}return u.className="Conv2D",u})();l.m7h.registerClass(Np);let j_=(()=>{class u extends xf{constructor(o){super(3,o),u.verifyArgs(o)}getConfig(){const o=super.getConfig();return delete o.rank,o}static verifyArgs(o){if("number"!=typeof o.kernelSize&&(!Array.isArray(o.kernelSize)||1!==o.kernelSize.length&&3!==o.kernelSize.length))throw new ln(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(o.kernelSize)}.`)}}return u.className="Conv3D",u})();l.m7h.registerClass(j_);let j0=(()=>{class u extends Np{constructor(o){if(super(o),this.inputSpec=[new pi({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new ln(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(o){if(4!==(o=ao(o)).length)throw new ln("Input should have rank 4; Received input shape: "+JSON.stringify(o));const p="channelsFirst"===this.dataFormat?1:o.length-1;if(null==o[p])throw new ln("The channel dimension of the inputs should be defined. Found `None`.");const m=o[p],x=this.kernelSize.concat([this.filters,m]);this.kernel=this.addWeight("kernel",x,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new pi({ndim:4,axes:{[p]:m}})],this.built=!0}call(o,p){return l.lub(()=>{let m=li(o);if(4!==m.shape.length)throw new ln(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${m.shape.length}`);const x=m.shape;let $,j;"channelsFirst"===this.dataFormat?($=2,j=3):($=1,j=2);const fe=x[j],ze=this.kernelSize[1],Rt=this.strides[1],Pt=[x[0],kd(x[$],this.strides[0],this.kernelSize[0],this.padding),kd(fe,Rt,ze,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(m=l.p4s(m,[0,2,3,1]));let St=l.bc(m,this.kernel.read(),Pt,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(St=l.p4s(St,[0,3,1,2])),null!=this.bias&&(St=Mu(St,this.bias.read(),this.dataFormat)),null!=this.activation&&(St=this.activation.apply(St)),St})}computeOutputShape(o){const p=(o=ao(o)).slice();let m,x,R;"channelsFirst"===this.dataFormat?(m=1,x=2,R=3):(m=3,x=1,R=2);const $=this.kernelSize[0],j=this.kernelSize[1],ce=this.strides[0],fe=this.strides[1];return p[m]=this.filters,p[x]=kd(p[x],ce,$,this.padding),p[R]=kd(p[R],fe,j,this.padding),p}getConfig(){const o=super.getConfig();return delete o.dilationRate,o}}return u.className="Conv2DTranspose",u})();l.m7h.registerClass(j0);let G_=(()=>{class u extends j_{constructor(o){if(super(o),this.inputSpec=[new pi({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new ln(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(o){if(5!==(o=ao(o)).length)throw new ln("Input should have rank 5; Received input shape: "+JSON.stringify(o));const p="channelsFirst"===this.dataFormat?1:o.length-1;if(null==o[p])throw new ln("The channel dimension of the inputs should be defined. Found `None`.");const m=o[p],x=this.kernelSize.concat([this.filters,m]);this.kernel=this.addWeight("kernel",x,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new pi({ndim:5,axes:{[p]:m}})],this.built=!0}call(o,p){return l.lub(()=>{let m=li(o);if(5!==m.shape.length)throw new ln(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${m.shape.length}`);const x=m.shape;let $,j,ce;"channelsFirst"===this.dataFormat?(ce=2,$=3,j=4):(ce=1,$=2,j=3);const je=x[$],ze=x[j],Rt=this.kernelSize[1],bt=this.kernelSize[2],Pt=this.strides[1],St=this.strides[2],_n=[x[0],kd(x[ce],this.strides[0],this.kernelSize[0],this.padding),kd(je,Pt,Rt,this.padding),kd(ze,St,bt,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(m=l.p4s(m,[0,2,3,4,1]));let Cn=l.$QV(m,this.kernel.read(),_n,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(Cn=l.p4s(Cn,[0,4,1,2,3])),null!==this.bias&&(Cn=Mu(Cn,this.bias.read(),this.dataFormat)),null!==this.activation&&(Cn=this.activation.apply(Cn)),Cn})}computeOutputShape(o){const p=(o=ao(o)).slice();let m,x,R,$;"channelsFirst"===this.dataFormat?(m=1,x=2,R=3,$=4):(m=4,x=1,R=2,$=3);const j=this.kernelSize[0],ce=this.kernelSize[1],fe=this.kernelSize[2],je=this.strides[0],ze=this.strides[1],nt=this.strides[2];return p[m]=this.filters,p[x]=kd(p[x],je,j,this.padding),p[R]=kd(p[R],ze,ce,this.padding),p[$]=kd(p[$],nt,fe,this.padding),p}getConfig(){const o=super.getConfig();return delete o.dilationRate,o}}return u.className="Conv3DTranspose",u})();l.m7h.registerClass(G_);let G0=(()=>{class u extends xf{constructor(o,p){if(super(o,p),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==p.filters)throw new ln("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=p.kernelInitializer||null!=p.kernelRegularizer||null!=p.kernelConstraint)throw new ln("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=p.padding&&"same"!==p.padding&&"valid"!==p.padding)throw new ln(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(p.padding)}`);this.depthMultiplier=null==p.depthMultiplier?1:p.depthMultiplier,this.depthwiseInitializer=Uo(p.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Dl(p.depthwiseRegularizer),this.depthwiseConstraint=Ql(p.depthwiseConstraint),this.pointwiseInitializer=Uo(p.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Dl(p.pointwiseRegularizer),this.pointwiseConstraint=Ql(p.pointwiseConstraint)}build(o){if((o=ao(o)).length<this.rank+2)throw new ln(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(o)}`);const p="channelsFirst"===this.dataFormat?1:o.length-1;if(null==o[p]||o[p]<0)throw new ln(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(o[p])}`);const m=o[p],x=this.kernelSize.concat([m,this.depthMultiplier]),R=[];for(let j=0;j<this.rank;++j)R.push(1);R.push(m*this.depthMultiplier,this.filters);const $=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",x,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,$,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",R,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,$,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,$,this.biasConstraint):null,this.inputSpec=[new pi({ndim:this.rank+2,axes:{[p]:m}})],this.built=!0}call(o,p){return(0,l.lub)(()=>{let m;if(o=li(o),1===this.rank)throw new ei("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(o=l.p4s(o,[0,2,3,1])),m=l.U_I(o,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(m=Mu(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),"channelsFirst"===this.dataFormat&&(m=l.p4s(m,[0,3,1,2])),m})}getConfig(){const o=super.getConfig();return delete o.rank,delete o.kernelInitializer,delete o.kernelRegularizer,delete o.kernelConstraint,o.depthwiseInitializer=Va(this.depthwiseInitializer),o.pointwiseInitializer=Va(this.pointwiseInitializer),o.depthwiseRegularizer=Ta(this.depthwiseRegularizer),o.pointwiseRegularizer=Ta(this.pointwiseRegularizer),o.depthwiseConstraint=Zl(this.depthwiseConstraint),o.pointwiseConstraint=Zl(this.pointwiseConstraint),o}}return u.className="SeparableConv",u})(),K_=(()=>{class u extends G0{constructor(o){super(2,o)}}return u.className="SeparableConv2D",u})();l.m7h.registerClass(K_);let Mp=(()=>{class u extends xf{constructor(o){super(1,o),u.verifyArgs(o),this.inputSpec=[{ndim:3}]}getConfig(){const o=super.getConfig();return delete o.rank,delete o.dataFormat,o}static verifyArgs(o){if("number"!=typeof o.kernelSize&&!Fe(o.kernelSize,"number",1,1))throw new ln(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(o.kernelSize)}.`)}}return u.className="Conv1D",u})();l.m7h.registerClass(Mp);let cm=(()=>{class u extends gs{constructor(o){super(o),this.cropping="number"==typeof o.cropping?[[o.cropping,o.cropping],[o.cropping,o.cropping]]:"number"==typeof o.cropping[0]?[[o.cropping[0],o.cropping[0]],[o.cropping[1],o.cropping[1]]]:o.cropping,this.dataFormat=void 0===o.dataFormat?"channelsLast":o.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(o){return"channelsFirst"===this.dataFormat?[o[0],o[1],o[2]-this.cropping[0][0]-this.cropping[0][1],o[3]-this.cropping[1][0]-this.cropping[1][1]]:[o[0],o[1]-this.cropping[0][0]-this.cropping[0][1],o[2]-this.cropping[1][0]-this.cropping[1][1],o[3]]}call(o,p){return(0,l.lub)(()=>{if(o=li(o),"channelsLast"===this.dataFormat){const m=ju(o,this.cropping[0][0],o.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ju(m,this.cropping[1][0],o.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const m=ju(o,this.cropping[0][0],o.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ju(m,this.cropping[1][0],o.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const o={cropping:this.cropping,dataFormat:this.dataFormat},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Cropping2D",u})();l.m7h.registerClass(cm);let X_=(()=>{class u extends gs{constructor(o){super(o),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==o.size?this.DEFAULT_SIZE:o.size,this.dataFormat=null==o.dataFormat?"channelsLast":o.dataFormat,Ci(this.dataFormat),this.interpolation=null==o.interpolation?"nearest":o.interpolation,function Rl(u){me(Er,"InterpolationFormat",u)}(this.interpolation)}computeOutputShape(o){return"channelsFirst"===this.dataFormat?[o[0],o[1],null==o[2]?null:this.size[0]*o[2],null==o[3]?null:this.size[1]*o[3]]:[o[0],null==o[1]?null:this.size[0]*o[1],null==o[2]?null:this.size[1]*o[2],o[3]]}call(o,p){return l.lub(()=>{let m=li(o);const x=m.shape;if("channelsFirst"===this.dataFormat){m=l.p4s(m,[0,2,3,1]);const R=this.size[0]*x[2],$=this.size[1]*x[3],j="nearest"===this.interpolation?l.image.resizeNearestNeighbor(m,[R,$]):l.image.resizeBilinear(m,[R,$]);return l.p4s(j,[0,3,1,2])}{const R=this.size[0]*x[1],$=this.size[1]*x[2];return"nearest"===this.interpolation?l.image.resizeNearestNeighbor(m,[R,$]):l.image.resizeBilinear(m,[R,$])}})}getConfig(){const o={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},p=super.getConfig();return Object.assign(o,p),o}}return u.className="UpSampling2D",u})();l.m7h.registerClass(X_);let um=(()=>{class u extends bf{constructor(o){super(2,o),this.depthwiseKernel=null,this.depthMultiplier=null==o.depthMultiplier?1:o.depthMultiplier,this.depthwiseInitializer=Uo(o.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ql(o.depthwiseConstraint),this.depthwiseRegularizer=Dl(o.depthwiseRegularizer)}build(o){if((o=ao(o)).length<4)throw new ln(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(o)}.`);const p="channelsFirst"===this.dataFormat?1:3;if(null==o[p]||o[p]<0)throw new ln(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${o[p]}).`);const m=o[p];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],m,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[m*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(o,p){return(0,l.lub)(()=>{let m=function Y_(u,d,o=[1,1],p="valid",m,x){return(0,l.lub)(()=>{null==m&&(m="channelsLast"),Ci(m);let R=fg(u,m);if(4!==u.rank)throw new ln(`Input for depthwiseConv2d is required to be 4-D, but is instead ${u.rank}-D`);if(4!==d.rank)throw new ln(`depthwiseKernel is required to be 4-D, but is instead ${d.rank}-D`);return R=l.B10(R,d,o,"same"===p?"same":"valid","NHWC",x),"channelsFirst"===m&&(R=l.p4s(R,[0,3,1,2])),R})}(o=li(o),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(m=Mu(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),m})}computeOutputShape(o){o=ao(o);const m="channelsFirst"===this.dataFormat?o[3]:o[2],x="channelsFirst"===this.dataFormat?o[1]*this.depthMultiplier:o[3]*this.depthMultiplier,R=Ad("channelsFirst"===this.dataFormat?o[2]:o[1],this.kernelSize[0],this.padding,this.strides[0]),$=Ad(m,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[o[0],x,R,$]:[o[0],R,$,x]}getConfig(){const o=super.getConfig();return o.depthMultiplier=this.depthMultiplier,o.depthwiseInitializer=Va(this.depthwiseInitializer),o.depthwiseRegularizer=Ta(this.depthwiseRegularizer),o.depthwiseConstraint=Zl(this.depthwiseRegularizer),o}}return u.className="DepthwiseConv2D",u})();function K0(u,d,o,p){if(Array.isArray(u)){if(null!=d||null!=o)throw new ln("When inputs is an array, neither initialState or constants should be provided");null!=p&&(o=u.slice(u.length-p,u.length),u=u.slice(0,u.length-p)),u.length>1&&(d=u.slice(1,u.length)),u=u[0]}function m(x){return null==x||Array.isArray(x)?x:[x]}return{inputs:u,initialState:d=m(d),constants:o=m(o)}}function X0(u,d,o,p=!1,m,x,R=!1,$=!1){return l.lub(()=>{const j=d.shape.length;if(j<3)throw new ln(`Input should be at least 3D, but is ${j}D.`);const ce=[1,0].concat(Jc(2,j));if(d=l.p4s(d,ce),null!=x)throw new ei("The rnn() functoin of the deeplearn.js backend does not support constants yet.");R&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=m&&((m=l.pju(l.pju(m,"bool"),"float32")).rank===j-1&&(m=l.dt4(m,-1)),m=l.p4s(m,ce)),p&&(d=l.GYS(d,0),null!=m&&(m=l.GYS(m,0)));const fe=[];let je,ze=o;const nt=d.shape[0],Rt=l.HHK(d);let bt,xt;null!=m&&(bt=l.HHK(m));for(let Pt=0;Pt<nt;++Pt){const St=Rt[Pt],Ut=l.lub(()=>u(St,ze));if(null==m)je=Ut[0],ze=Ut[1];else{const Ft=l.lub(()=>{const sn=bt[Pt],_n=l.luU(l.JpU(sn),sn);return{output:l.IHx(l.dC7(Ut[0],sn),l.dC7(ze[0],_n)),newStates:ze.map((Vn,es)=>l.IHx(l.dC7(Ut[1][es],sn),l.dC7(Vn,_n)))}});je=Ft.output,ze=Ft.newStates}$&&fe.push(je)}return $&&(xt=l.knu(fe,1)),[je,xt,ze]})}l.m7h.registerClass(um);let Yh=(()=>{class u extends gs{constructor(o){let p;if(super(o),null==o.cell)throw new ln("cell property is missing for the constructor of RNN.");if(p=Array.isArray(o.cell)?new J_({cells:o.cell}):o.cell,null==p.stateSize)throw new ln("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=p,this.returnSequences=null!=o.returnSequences&&o.returnSequences,this.returnState=null!=o.returnState&&o.returnState,this.goBackwards=null!=o.goBackwards&&o.goBackwards,this._stateful=null!=o.stateful&&o.stateful,this.unroll=null!=o.unroll&&o.unroll,this.supportsMasking=!0,this.inputSpec=[new pi({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?Jc(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(p=>null):this.states_}setStates(o){this.states_=o}computeOutputShape(o){Xl(o)&&(o=o[0]);let p=this.cell.stateSize;Array.isArray(p)||(p=[p]);const m=p[0];let x;if(x=this.returnSequences?[o[0],o[1],m]:[o[0],m],this.returnState){const R=[];for(const $ of p)R.push([o[0],$]);return[x].concat(R)}return x}computeMask(o,p){return l.lub(()=>{Array.isArray(p)&&(p=p[0]);const m=this.returnSequences?p:null;if(this.returnState){const x=this.states.map(R=>null);return[m].concat(x)}return m})}get states(){if(null==this.states_){const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,p=[];for(let m=0;m<o;++m)p.push(null);return p}return this.states_}set states(o){this.states_=o}build(o){if(null!=this.numConstants)throw new ei("Constants support is not implemented in RNN yet.");Xl(o)&&(o=o[0]);const m=this.stateful?o[0]:null,x=o.slice(2);this.inputSpec[0]=new pi({shape:[m,null,...x]});const R=[o[0]].concat(o.slice(2));let $;if(this.cell.build(R),$=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!l.D5U.arraysEqual(this.stateSpec.map(j=>j.shape[j.shape.length-1]),$))throw new ln(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=$.map(j=>new pi({shape:[null,j]}));this.stateful&&this.resetStates()}resetStates(o,p=!1){(0,l.lub)(()=>{if(!this.stateful)throw new Eo("Cannot call resetStates() on an RNN Layer that is not stateful.");const m=this.inputSpec[0].shape[0];if(null==m)throw new ln("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(x=>l.lls([m,x])):[l.lls([m,this.cell.stateSize])];else if(null==o)l.B90(this.states_),null!=this.keptStates&&(l.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(x=>l.lls([m,x])):this.states_[0]=l.lls([m,this.cell.stateSize]);else{if(Array.isArray(o)||(o=[o]),o.length!==this.states_.length)throw new ln(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${o.length} state value(s). Input received: ${o}`);!0===p?this.keptStates.push(this.states_.slice()):l.B90(this.states_);for(let x=0;x<this.states_.length;++x){const R=o[x],$=Array.isArray(this.cell.stateSize)?this.cell.stateSize[x]:this.cell.stateSize,j=[m,$];if(!l.D5U.arraysEqual(R.shape,j))throw new ln(`State ${x} is incompatible with layer ${this.name}: expected shape=${j}, received shape=${R.shape}`);this.states_[x]=R}}this.states_=this.states_.map(x=>l.CnY(x.clone()))})}apply(o,p){let m=null==p?null:p.initialState,x=null==p?null:p.constants;null==p&&(p={});const R=K0(o,m,x,this.numConstants);o=R.inputs,m=R.initialState,x=R.constants;let $=[],j=[];if(null!=m){p.initialState=m,$=$.concat(m),this.stateSpec=[];for(const fe of m)this.stateSpec.push(new pi({shape:fe.shape}));j=j.concat(this.stateSpec)}if(null!=x&&(p.constants=x,$=$.concat(x),this.numConstants=x.length),$[0]instanceof Xr){const fe=[o].concat($),je=this.inputSpec.concat(j),ze=this.inputSpec;this.inputSpec=je;const nt=super.apply(fe,p);return this.inputSpec=ze,nt}return super.apply(o,p)}call(o,p){return(0,l.lub)(()=>{const m=null==p?null:p.mask,x=null==p?null:p.training;let R=null==p?null:p.initialState;o=li(o),null==R&&(R=this.stateful?this.states_:this.getInitialState(o));const $=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(R.length!==$)throw new ln(`RNN Layer has ${$} state(s) but was passed ${R.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const j={training:x},fe=X0((bt,xt)=>{const Pt=this.cell.call([bt].concat(xt),j);return[Pt[0],Pt.slice(1)]},o,R,this.goBackwards,m,null,this.unroll,this.returnSequences),je=fe[0],ze=fe[1],nt=fe[2];this.stateful&&this.resetStates(nt,x);const Rt=this.returnSequences?ze:je;return this.returnState?[Rt].concat(nt):Rt})}getInitialState(o){return(0,l.lub)(()=>{let p=l.lls(o.shape);return p=l.Smz(p,[1,2]),p=od(p),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(m=>m>1?ph(p,[1,m]):p):this.cell.stateSize>1?[ph(p,[1,this.cell.stateSize])]:[p]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(o){super.setFastWeightInitDuringBuild(o),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(o)}getConfig(){const o=super.getConfig(),p={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(p.numConstants=this.numConstants);const m=this.cell.getConfig();return this.getClassName()===u.className&&(p.cell={className:this.cell.getClassName(),config:m}),Object.assign(Object.assign(Object.assign({},m),o),p)}static fromConfig(o,p,m={}){const R=wu(p.cell,m);return new o(Object.assign(p,{cell:R}))}}return u.className="RNN",u})();l.m7h.registerClass(Yh);class Zh extends gs{}let Z_=(()=>{class u extends Zh{constructor(o){super(o),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=o.units,gt(this.units,"units"),this.activation=Xh(null==o.activation?this.DEFAULT_ACTIVATION:o.activation),this.useBias=null==o.useBias||o.useBias,this.kernelInitializer=Uo(o.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Uo(o.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Uo(o.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Dl(o.kernelRegularizer),this.recurrentRegularizer=Dl(o.recurrentRegularizer),this.biasRegularizer=Dl(o.biasRegularizer),this.kernelConstraint=Ql(o.kernelConstraint),this.recurrentConstraint=Ql(o.recurrentConstraint),this.biasConstraint=Ql(o.biasConstraint),this.dropout=dh([1,Nu([0,null==o.dropout?0:o.dropout])]),this.recurrentDropout=dh([1,Nu([0,null==o.recurrentDropout?0:o.recurrentDropout])]),this.dropoutFunc=o.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(o){o=ao(o),this.kernel=this.addWeight("kernel",[o[o.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(o,p){return(0,l.lub)(()=>{if(2!==o.length)throw new ln(`SimpleRNNCell expects 2 input Tensors, got ${o.length}.`);let m=o[1];o=o[0];const x=null!=p.training&&p.training;let R;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ch({ones:()=>l.JpU(o),rate:this.dropout,training:x,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ch({ones:()=>l.JpU(m),rate:this.recurrentDropout,training:x,dropoutFunc:this.dropoutFunc}));const $=this.dropoutMask,j=this.recurrentDropoutMask;R=bc(null!=$?l.dC7(o,$):o,this.kernel.read()),null!=this.bias&&(R=Mu(R,this.bias.read())),null!=j&&(m=l.dC7(m,j));let ce=l.IHx(R,bc(m,this.recurrentKernel.read()));return null!=this.activation&&(ce=this.activation.apply(ce)),[ce,ce]})}getConfig(){const o=super.getConfig(),p={units:this.units,activation:Eu(this.activation),useBias:this.useBias,kernelInitializer:Va(this.kernelInitializer),recurrentInitializer:Va(this.recurrentInitializer),biasInitializer:Va(this.biasInitializer),kernelRegularizer:Ta(this.kernelRegularizer),recurrentRegularizer:Ta(this.recurrentRegularizer),biasRegularizer:Ta(this.biasRegularizer),activityRegularizer:Ta(this.activityRegularizer),kernelConstraint:Zl(this.kernelConstraint),recurrentConstraint:Zl(this.recurrentConstraint),biasConstraint:Zl(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},o),p)}}return u.className="SimpleRNNCell",u})();l.m7h.registerClass(Z_);let Q_=(()=>{class u extends Yh{constructor(o){o.cell=new Z_(o),super(o)}call(o,p){return(0,l.lub)(()=>(null!=this.cell.dropoutMask&&(l.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(o,{mask:null==p?null:p.mask,training:null==p?null:p.training,initialState:null==p?null:p.initialState})))}static fromConfig(o,p){return new o(p)}}return u.className="SimpleRNN",u})();l.m7h.registerClass(Q_);let _g=(()=>{class u extends Zh{constructor(o){if(super(o),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",o.resetAfter)throw new ln("GRUCell does not support reset_after parameter set to true.");this.units=o.units,gt(this.units,"units"),this.activation=Xh(void 0===o.activation?this.DEFAULT_ACTIVATION:o.activation),this.recurrentActivation=Xh(void 0===o.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:o.recurrentActivation),this.useBias=null==o.useBias||o.useBias,this.kernelInitializer=Uo(o.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Uo(o.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Uo(o.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Dl(o.kernelRegularizer),this.recurrentRegularizer=Dl(o.recurrentRegularizer),this.biasRegularizer=Dl(o.biasRegularizer),this.kernelConstraint=Ql(o.kernelConstraint),this.recurrentConstraint=Ql(o.recurrentConstraint),this.biasConstraint=Ql(o.biasConstraint),this.dropout=dh([1,Nu([0,null==o.dropout?0:o.dropout])]),this.recurrentDropout=dh([1,Nu([0,null==o.recurrentDropout?0:o.recurrentDropout])]),this.dropoutFunc=o.dropoutFunc,this.implementation=o.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(o){o=ao(o),this.kernel=this.addWeight("kernel",[o[o.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(o,p){return(0,l.lub)(()=>{if(2!==o.length)throw new ln(`GRUCell expects 2 input Tensors (inputs, h, c), got ${o.length}.`);const m=null!=p.training&&p.training;let x=o[1];o=o[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ch({ones:()=>l.JpU(o),rate:this.dropout,training:m,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ch({ones:()=>l.JpU(x),rate:this.recurrentDropout,training:m,count:3,dropoutFunc:this.dropoutFunc}));const $=this.recurrentDropoutMask;let j,ce,fe;0<this.dropout&&this.dropout<1&&(o=l.dC7(o,this.dropoutMask[0]));let je=bc(o,this.kernel.read());this.useBias&&(je=Mu(je,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(x=l.dC7(x,$[0]));const ze=this.recurrentKernel.read(),[nt,Rt]=l.Vl2(ze,[2*this.units,this.units],ze.rank-1),bt=bc(x,nt),[xt,Pt,St]=l.Vl2(je,3,je.rank-1),[Ut,Ft]=l.Vl2(bt,2,bt.rank-1);j=this.recurrentActivation.apply(l.IHx(xt,Ut)),ce=this.recurrentActivation.apply(l.IHx(Pt,Ft));const sn=bc(l.dC7(ce,x),Rt);fe=this.activation.apply(l.IHx(St,sn));const _n=l.IHx(l.dC7(j,x),l.dC7(l.IHx(1,l.W76(j)),fe));return[_n,_n]})}getConfig(){const o=super.getConfig(),p={units:this.units,activation:Eu(this.activation),recurrentActivation:Eu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Va(this.kernelInitializer),recurrentInitializer:Va(this.recurrentInitializer),biasInitializer:Va(this.biasInitializer),kernelRegularizer:Ta(this.kernelRegularizer),recurrentRegularizer:Ta(this.recurrentRegularizer),biasRegularizer:Ta(this.biasRegularizer),activityRegularizer:Ta(this.activityRegularizer),kernelConstraint:Zl(this.kernelConstraint),recurrentConstraint:Zl(this.recurrentConstraint),biasConstraint:Zl(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},o),p)}}return u.className="GRUCell",u})();l.m7h.registerClass(_g);let dm=(()=>{class u extends Yh{constructor(o){0===o.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),o.cell=new _g(o),super(o)}call(o,p){return(0,l.lub)(()=>(null!=this.cell.dropoutMask&&(l.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(o,{mask:null==p?null:p.mask,training:null==p?null:p.training,initialState:null==p?null:p.initialState})))}static fromConfig(o,p){return 0===p.implmentation&&(p.implementation=1),new o(p)}}return u.className="GRU",u})();l.m7h.registerClass(dm);let wf=(()=>{class u extends Zh{constructor(o){super(o),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=o.units,gt(this.units,"units"),this.activation=Xh(void 0===o.activation?this.DEFAULT_ACTIVATION:o.activation),this.recurrentActivation=Xh(void 0===o.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:o.recurrentActivation),this.useBias=null==o.useBias||o.useBias,this.kernelInitializer=Uo(o.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Uo(o.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Uo(o.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=o.unitForgetBias,this.kernelRegularizer=Dl(o.kernelRegularizer),this.recurrentRegularizer=Dl(o.recurrentRegularizer),this.biasRegularizer=Dl(o.biasRegularizer),this.kernelConstraint=Ql(o.kernelConstraint),this.recurrentConstraint=Ql(o.recurrentConstraint),this.biasConstraint=Ql(o.biasConstraint),this.dropout=dh([1,Nu([0,null==o.dropout?0:o.dropout])]),this.recurrentDropout=dh([1,Nu([0,null==o.recurrentDropout?0:o.recurrentDropout])]),this.dropoutFunc=o.dropoutFunc,this.implementation=o.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(o){var p;let x;if(o=ao(o),this.kernel=this.addWeight("kernel",[o[o.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const R=this.biasInitializer,$=this.units;x=new((p=class extends Vc{apply(ce,fe){const je=R.apply([$]),ze=(new bp).apply([$]),nt=R.apply([2*$]);return Hf(Hf(je,ze),nt)}}).className="CustomInit",p)}else x=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,x,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(o,p){return(0,l.lub)(()=>{const m=null!=p.training&&p.training;if(3!==o.length)throw new ln(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${o.length}.`);let x=o[1];const R=o[2];o=o[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ch({ones:()=>l.JpU(o),rate:this.dropout,training:m,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ch({ones:()=>l.JpU(x),rate:this.recurrentDropout,training:m,count:4,dropoutFunc:this.dropoutFunc}));const j=this.recurrentDropoutMask;let ce,fe,je,ze;0<this.dropout&&this.dropout<1&&(o=l.dC7(o,this.dropoutMask[0]));let nt=bc(o,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(x=l.dC7(x,j[0])),nt=l.IHx(nt,bc(x,this.recurrentKernel.read())),this.useBias&&(nt=Mu(nt,this.bias.read()));const[Rt,bt,xt,Pt]=l.Vl2(nt,4,nt.rank-1);ce=this.recurrentActivation.apply(Rt),fe=this.recurrentActivation.apply(bt),je=l.IHx(l.dC7(fe,R),l.dC7(ce,this.activation.apply(xt))),ze=this.recurrentActivation.apply(Pt);const St=l.dC7(ze,this.activation.apply(je));return[St,St,je]})}getConfig(){const o=super.getConfig(),p={units:this.units,activation:Eu(this.activation),recurrentActivation:Eu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Va(this.kernelInitializer),recurrentInitializer:Va(this.recurrentInitializer),biasInitializer:Va(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ta(this.kernelRegularizer),recurrentRegularizer:Ta(this.recurrentRegularizer),biasRegularizer:Ta(this.biasRegularizer),activityRegularizer:Ta(this.activityRegularizer),kernelConstraint:Zl(this.kernelConstraint),recurrentConstraint:Zl(this.recurrentConstraint),biasConstraint:Zl(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},o),p)}}return u.className="LSTMCell",u})();l.m7h.registerClass(wf);let yg=(()=>{class u extends Yh{constructor(o){0===o.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),o.cell=new wf(o),super(o)}call(o,p){return(0,l.lub)(()=>(null!=this.cell.dropoutMask&&(l.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(o,{mask:null==p?null:p.mask,training:null==p?null:p.training,initialState:null==p?null:p.initialState})))}static fromConfig(o,p){return 0===p.implmentation&&(p.implementation=1),new o(p)}}return u.className="LSTM",u})();l.m7h.registerClass(yg);let J_=(()=>{class u extends Zh{constructor(o){super(o),this.cells=o.cells}get stateSize(){const o=[];for(const p of this.cells.slice().reverse())Array.isArray(p.stateSize)?o.push(...p.stateSize):o.push(p.stateSize);return o}call(o,p){return(0,l.lub)(()=>{let m=o.slice(1);const x=[];for(const j of this.cells.slice().reverse())Array.isArray(j.stateSize)?x.push(m.splice(0,j.stateSize.length)):x.push(m.splice(0,1));x.reverse();const R=[];let $;for(let j=0;j<this.cells.length;++j){const ce=this.cells[j];m=x[j],$=0===j?[o[0]].concat(m):[$[0]].concat(m),$=ce.call($,p),R.push($.slice(1))}m=[];for(const j of R.slice().reverse())m.push(...j);return[$[0]].concat(m)})}build(o){let p;Xl(o)&&(o=o[0]),this.cells.forEach((m,x)=>{$c(`RNNCell_${x}`,()=>{m.build(o),p=Array.isArray(m.stateSize)?m.stateSize[0]:m.stateSize,o=[o[0],p]})}),this.built=!0}getConfig(){const o=super.getConfig(),x={cells:this.cells.map(R=>({className:R.getClassName(),config:R.getConfig()}))};return Object.assign(Object.assign({},o),x)}static fromConfig(o,p,m={}){const x=[];for(const R of p.cells)x.push(wu(R,m));return new o({cells:x})}get trainableWeights(){if(!this.trainable)return[];const o=[];for(const p of this.cells)o.push(...p.trainableWeights);return o}get nonTrainableWeights(){const o=[];for(const p of this.cells)o.push(...p.nonTrainableWeights);if(!this.trainable){const p=[];for(const m of this.cells)p.push(...m.trainableWeights);return p.concat(o)}return o}getWeights(){const o=[];for(const p of this.cells)o.push(...p.weights);return js(o)}setWeights(o){const p=[];for(const m of this.cells){const R=o.splice(m.weights.length);for(let $=0;$<m.weights.length;++$)p.push([m.weights[$],R[$]])}pr(p)}}return u.className="StackedRNNCells",u})();function Ch(u){const{ones:d,rate:o,training:p=!1,count:m=1,dropoutFunc:x}=u,R=()=>null!=x?x(d(),o):yp(d(),o),$=()=>jd(R,d,p);return!m||m<=1?l.CnY($().clone()):Array(m).fill(void 0).map($).map(ce=>l.CnY(ce.clone()))}l.m7h.registerClass(J_);let Pp=(()=>{class u extends Yh{constructor(o){if(o.unroll)throw new ei("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(o.cell))throw new ei("It is not possible at the moment to stack convolutional cells.");super(o),this.inputSpec=[new pi({ndim:5})]}call(o,p){return l.lub(()=>{if(null!=this.cell.dropoutMask&&(l.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),p&&p.constants)throw new ln("ConvRNN2D cell does not support constants");return super.call(o,{mask:null==p?null:p.mask,training:null==p?null:p.training,initialState:null==p?null:p.initialState})})}computeOutputShape(o){let p=this.computeSingleOutputShape(o);return this.returnSequences||(p=[p[0],...p.slice(2)]),this.returnState&&(p=[p,...Array(2).fill([o[0],...p.slice(-3)])]),p}getInitialState(o){return l.lub(()=>{const{stateSize:p}=this.cell,x=this.computeSingleOutputShape(o.shape),R=[x[0],...x.slice(2)],$=l.lls(R);return Array.isArray(p)?Array(p.length).fill($):[$]})}resetStates(o,p=!1){l.lub(()=>{if(!this.stateful)throw new Eo("Cannot call resetStates() on an RNN Layer that is not stateful.");const m=this.inputSpec[0].shape,x=this.computeSingleOutputShape(m),R=[x[0],...x.slice(2)];if(null==m[0])throw new ln("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>l.lls(R)):[l.lls(R)];else if(null==o)l.B90(this.states_),null!=this.keptStates&&(l.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>l.lls(R)):this.states_[0]=l.lls(R);else{if(Array.isArray(o)||(o=[o]),o.length!==this.states_.length)throw new ln(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${o.length} state value(s). Input received: ${o}`);p?this.keptStates.push(this.states_.slice()):l.B90(this.states_);for(let j=0;j<this.states_.length;++j){const ce=o[j],fe=R;if(!l.D5U.arraysEqual(ce.shape,fe))throw new ln(`State ${j} is incompatible with layer ${this.name}: expected shape=${fe}, received shape=${ce.shape}`);this.states_[j]=ce}}this.states_=this.states_.map(j=>l.CnY(j.clone()))})}computeSingleOutputShape(o){const{dataFormat:p,filters:m,kernelSize:x,padding:R,strides:$,dilationRate:j}=this.cell,ce="channelsFirst"===p,je=o[ce?4:3],ze=Ad(o[ce?3:2],x[0],R,$[0],j[0]),nt=Ad(je,x[1],R,$[1],j[1]);return[...o.slice(0,2),...ce?[m,ze,nt]:[ze,nt,m]]}}return u.className="ConvRNN2D",u})(),vg=(()=>{class u extends wf{constructor(o){const{filters:p,kernelSize:m,strides:x,padding:R,dataFormat:$,dilationRate:j}=o;super(Object.assign(Object.assign({},o),{units:p})),this.filters=p,gt(this.filters,"filters"),this.kernelSize=vf(m,2,"kernelSize"),this.kernelSize.forEach(ce=>gt(ce,"kernelSize")),this.strides=vf(x||1,2,"strides"),this.strides.forEach(ce=>gt(ce,"strides")),this.padding=R||"valid",cl(this.padding),this.dataFormat=$||"channelsLast",Ci(this.dataFormat),this.dilationRate=vf(j||1,2,"dilationRate"),this.dilationRate.forEach(ce=>gt(ce,"dilationRate"))}build(o){var p;o=ao(o);const m="channelsFirst"===this.dataFormat?1:o.length-1;if(null==o[m])throw new ln(`The channel dimension of the input should be defined. Found ${o[m]}`);const $=this.kernelSize.concat([o[m],4*this.filters]);this.kernel=this.addWeight("kernel",$,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const j=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",j,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let ce;if(this.unitForgetBias){const fe=this.biasInitializer,je=this.filters;ce=new((p=class extends Vc{apply(nt,Rt){return $h([fe.apply([je]),l.iUs([je]),fe.apply([2*je])])}}).className="CustomInit",p)}else ce=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,ce,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(o,p){return l.lub(()=>{if(3!==o.length)throw new ln(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${o.length}.`);const m=p.training||!1,x=o[0],R=o[1],$=o[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ch({ones:()=>l.JpU(x),rate:this.dropout,training:m,count:4,dropoutFunc:this.dropoutFunc}));const ce=this.dropoutMask,fe=(Ls,nr,Vs)=>nr&&nr[Vs]?l.dC7(nr[Vs],Ls):Ls;let je=fe(x,ce,0),ze=fe(x,ce,1),nt=fe(x,ce,2),Rt=fe(x,ce,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ch({ones:()=>l.JpU(R),rate:this.recurrentDropout,training:m,count:4,dropoutFunc:this.dropoutFunc}));const bt=this.recurrentDropoutMask;let xt=fe(R,bt,0),Pt=fe(R,bt,1),St=fe(R,bt,2),Ut=fe(R,bt,3);const[sn,_n,Cn,Bn]=l.Vl2(this.kernel.read(),4,3),[Vn,es,ls,Cs]=this.useBias?l.Vl2(this.bias.read(),4):[null,null,null,null];je=this.inputConv(je,sn,Vn,this.padding),ze=this.inputConv(ze,_n,es,this.padding),nt=this.inputConv(nt,Cn,ls,this.padding),Rt=this.inputConv(Rt,Bn,Cs,this.padding);const[rs,hs,ms,_s]=l.Vl2(this.recurrentKernel.read(),4,3);xt=this.recurrentConv(xt,rs),Pt=this.recurrentConv(Pt,hs),St=this.recurrentConv(St,ms),Ut=this.recurrentConv(Ut,_s);const Ds=this.recurrentActivation.apply(l.IHx(je,xt)),ds=this.recurrentActivation.apply(l.IHx(ze,Pt)),ys=l.IHx(l.dC7(ds,$),l.dC7(Ds,this.activation.apply(l.IHx(nt,St)))),Ns=l.dC7(this.recurrentActivation.apply(l.IHx(Rt,Ut)),this.activation.apply(ys));return[Ns,Ns,ys]})}getConfig(){const m=function(u,d){var o={};for(var p in u)Object.prototype.hasOwnProperty.call(u,p)&&d.indexOf(p)<0&&(o[p]=u[p]);if(null!=u&&"function"==typeof Object.getOwnPropertySymbols){var m=0;for(p=Object.getOwnPropertySymbols(u);m<p.length;m++)d.indexOf(p[m])<0&&Object.prototype.propertyIsEnumerable.call(u,p[m])&&(o[p[m]]=u[p[m]])}return o}(super.getConfig(),["units"]),x={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},m),x)}inputConv(o,p,m,x){const R=l.Tek(o,p,this.strides,x||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return m?Mu(R,m,this.dataFormat):R}recurrentConv(o,p){return l.Tek(o,p,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return u.className="ConvLSTM2DCell",u})();l.m7h.registerClass(vg);let ey=(()=>{class u extends Pp{constructor(o){const p=new vg(o);super(Object.assign(Object.assign({},o),{cell:p}))}static fromConfig(o,p){return new o(p)}}return u.className="ConvLSTM2D",u})();l.m7h.registerClass(ey);let ty=(()=>{class u extends gs{constructor(o){super(o),this.rate=Math.max(Math.min(o.rate,1),0),this.noiseShape=o.noiseShape,this.seed=o.seed,this.supportsMasking=!0}getNoiseShape(o){if(null==this.noiseShape)return this.noiseShape;const p=o.shape,m=[];for(let x=0;x<this.noiseShape.length;++x)m.push(null==this.noiseShape[x]?p[x]:this.noiseShape[x]);return m}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);const m=li(o);if(0<this.rate&&this.rate<1){const x=null!=p.training&&p.training,R=this.getNoiseShape(m);return jd(()=>yp(m,this.rate,R,this.seed),()=>m,x)}return o})}getConfig(){const o={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},p=super.getConfig();return Object.assign(o,p),o}dispose(){return super.dispose()}}return u.className="Dropout",u})();l.m7h.registerClass(ty);let ax=(()=>{class u extends ty{constructor(o){super(o),this.inputSpec=[{ndim:3}]}getNoiseShape(o){const p=o.shape;return[p[0],1,p[2]]}}return u.className="SpatialDropout1D",u})();l.m7h.registerClass(ax);let hm=(()=>{class u extends gs{constructor(o){if(super(o),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==o.batchInputShape&&null==o.inputShape&&null!=o.inputDim){let p=null;null!=o.batchSize&&(p=o.batchSize),this.batchInputShape=[p,o.inputDim]}this.units=o.units,gt(this.units,"units"),this.activation=Xh(o.activation),null!=o.useBias&&(this.useBias=o.useBias),this.kernelInitializer=Uo(o.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Uo(o.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ql(o.kernelConstraint),this.biasConstraint=Ql(o.biasConstraint),this.kernelRegularizer=Dl(o.kernelRegularizer),this.biasRegularizer=Dl(o.biasRegularizer),this.activityRegularizer=Dl(o.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(o){const p=(o=ao(o))[o.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[p,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:p}}],this.built=!0}computeOutputShape(o){const p=(o=ao(o)).slice();return p[p.length-1]=this.units,p}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);const m=li(o),x=Pn(this.activation.getClassName());let R;return null!=x?R=bc(m,this.kernel.read(),x,this.bias?this.bias.read():null):(R=bc(m,this.kernel.read()),null!=this.bias&&(R=Mu(R,this.bias.read())),null!=this.activation&&(R=this.activation.apply(R))),R})}getConfig(){const o={units:this.units,activation:Eu(this.activation),useBias:this.useBias,kernelInitializer:Va(this.kernelInitializer),biasInitializer:Va(this.biasInitializer),kernelRegularizer:Ta(this.kernelRegularizer),biasRegularizer:Ta(this.biasRegularizer),activityRegularizer:Ta(this.activityRegularizer),kernelConstraint:Zl(this.kernelConstraint),biasConstraint:Zl(this.biasConstraint)},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Dense",u})();l.m7h.registerClass(hm);let Y0=(()=>{class u extends gs{constructor(o){super(o=o||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=o.dataFormat}computeOutputShape(o){o=ao(o);for(const p of o.slice(1))if(null==p)throw new ln(`The shape of the input to "Flatten" is not fully defined (got ${o.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[o[0],Sc(o,1)]}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);let m=li(o);if("channelsFirst"===this.dataFormat&&m.rank>1){const x=[0];for(let R=2;R<m.rank;++R)x.push(R);x.push(1),m=(0,l.p4s)(m,x)}return function Wd(u){if(u.rank<=1)throw new ln(`batchFlatten requires a minimum rank of 2. Got rank: ${u.rank}.`);const d=[u.shape[0],Sc(u.shape,1)];return l.XLQ(u,d)}(m)})}getConfig(){const o={};null!=this.dataFormat&&(o.dataFormat=this.dataFormat);const p=super.getConfig();return Object.assign(o,p),o}}return u.className="Flatten",u})();l.m7h.registerClass(Y0);let ny=(()=>{class u extends gs{constructor(o){super(o),this.supportsMasking=!0,this.activation=Xh(o.activation)}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);const m=li(o);return this.activation.apply(m)})}getConfig(){const o={activation:Eu(this.activation)},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Activation",u})();l.m7h.registerClass(ny);let sy=(()=>{class u extends gs{constructor(o){super(o),this.n=o.n,this.inputSpec=[{ndim:2}]}computeOutputShape(o){return[o[0],this.n,o[1]]}call(o,p){return(0,l.lub)(()=>function qp(u,d){return(0,l.lub)(()=>{if(2!==u.shape.length)throw new ln(`repeat() expects a rank-2 tensor, but received a rank-${u.shape.length} tensor.`);return ph(od(u,1),[1,d,1])})}(o=li(o),this.n))}getConfig(){const o={n:this.n},p=super.getConfig();return Object.assign(o,p),o}}return u.className="RepeatVector",u})();l.m7h.registerClass(sy);let ry=(()=>{class u extends gs{constructor(o){super(o),this.targetShape=o.targetShape;for(let p=0;p<this.targetShape.length;++p)this.isUnknown(this.targetShape[p])&&(this.targetShape[p]=null)}isUnknown(o){return o<0||null==o}fixUnknownDimension(o,p){const m="Total size of new array must be unchanged.",x=p.slice();let R=1,$=null;for(let ce=0;ce<x.length;++ce){const fe=x[ce];if(this.isUnknown(fe)){if(null!==$)throw new ln("Can only specifiy one unknown dimension.");$=ce}else R*=fe}const j=Sc(o);if(null!==$){if(0===R||j%R!=0)throw new ln(m);x[$]=j/R}else if(j!==R)throw new ln(m);return x}computeOutputShape(o){let p=!1;for(let m=0;m<o.length;++m)if(this.isUnknown(o[m])){p=!0;break}return p?o.slice(0,1).concat(this.targetShape):o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape))}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);const m=li(o),x=m.shape,R=x.slice(0,1).concat(this.fixUnknownDimension(x.slice(1),this.targetShape));return(0,l.XLQ)(m,R)})}getConfig(){const o={targetShape:this.targetShape},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Reshape",u})();l.m7h.registerClass(ry);let bg=(()=>{class u extends gs{constructor(o){if(super(o),null==o.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(o.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${o.dims} instead.`);const p=Jc(1,o.dims.length+1);if(!l.D5U.arraysEqual(o.dims.slice().sort(),p))throw new Error("Invalid permutation `dims`: "+JSON.stringify(o.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=o.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new pi({ndim:this.dims.length+1})]}computeOutputShape(o){const p=(o=ao(o)).slice();return this.dims.forEach((m,x)=>{p[x+1]=o[m]}),p}call(o,p){return(0,l.p4s)(li(o),this.dimsIncludingBatch)}getConfig(){const o={dims:this.dims},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Permute",u})();l.m7h.registerClass(bg);let xg=(()=>{class u extends gs{constructor(o){super(o??{}),this.supportsMasking=!0,this.maskValue=null!=o?null==o.maskValue?0:o.maskValue:0}computeOutputShape(o){return o}getConfig(){const o=super.getConfig(),p={maskValue:this.maskValue};return Object.assign(p,o),p}computeMask(o,p){const m=li(o);return(0,l.YjB)((0,l.Quu)(m,this.maskValue),-1)}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);const m=li(o),$=(0,l.YjB)((0,l.Quu)(m,this.maskValue),-1,!0);return(0,l.dC7)(m,(0,l.pju)($,m.dtype))})}}return u.className="Masking",u})();l.m7h.registerClass(xg);let pm=(()=>{class u extends gs{constructor(o){if(super(o),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==o.batchInputShape&&null==o.inputShape){let p=null;null!=o.batchSize&&(p=o.batchSize),this.batchInputShape=null==o.inputLength?[p,null]:[p].concat(ks(o.inputLength))}this.inputDim=o.inputDim,gt(this.inputDim,"inputDim"),this.outputDim=o.outputDim,gt(this.outputDim,"outputDim"),this.embeddingsInitializer=Uo(o.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Dl(o.embeddingsRegularizer),this.activityRegularizer=Dl(o.activityRegularizer),this.embeddingsConstraint=Ql(o.embeddingsConstraint),this.maskZero=o.maskZero,this.supportsMasking=o.maskZero,this.inputLength=o.inputLength}build(o){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(o){}computeMask(o,p){return(0,l.lub)(()=>this.maskZero?(o=li(o),(0,l.Quu)(o,(0,l.P84)(o))):null)}computeOutputShape(o){if(o=ao(o),null==this.inputLength)return[...o,this.outputDim];const p=ks(this.inputLength);if(p.length!==o.length-1)throw new ln(`"inputLength" is ${this.inputLength}, but received input shape has shape ${o}`);{let m=0;for(let x=0;x<p.length;++x){const R=p[x],$=o[x+1];if(null!=R&&null!=$&&R!==$)throw new ln(`"inputLength" is ${this.inputLength}, but received input shape has shape ${o}`);null==R&&(p[m]=$),m++}}return[o[0],...p,this.outputDim]}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);let m=li(o);"int32"!==m.dtype&&(m=qc(m,"int32"));const x=Pc(this.embeddings.read(),(0,l.XLQ)(m,[m.size]));return(0,l.XLQ)(x,ao(this.computeOutputShape(m.shape)))})}getConfig(){const o={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Va(this.embeddingsInitializer),embeddingsRegularizer:Ta(this.embeddingsRegularizer),activityRegularizer:Ta(this.activityRegularizer),embeddingsConstraint:Zl(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Embedding",u})();l.m7h.registerClass(pm);class qd extends gs{constructor(d){super(d||{}),this.supportsMasking=!0}mergeFunction(d){throw new ei}computeElementwiseOpOutputShape(d,o){if(null==d||null==o)return null;if(d.length<o.length)return this.computeElementwiseOpOutputShape(o,d);if(0===o.length)return d;const p=d.slice(0,d.length-o.length);for(let m=0;m<o.length;++m){const x=d[d.length-o.length+m],R=o[m];if(null==x||null==R||x<0||R<0)p.push(null);else if(1===x)p.push(R);else if(1===R)p.push(x);else{if(x!==R)throw new ln("Operands could not be broadcast together with shapes "+JSON.stringify(d)+" "+JSON.stringify(o));p.push(x)}}return p}build(d){if(Array.isArray(d)&&!Array.isArray(d[0])&&(d=[ao(d)]),d.length<2)throw new ln(`A merge layer should be called on an Array of at least 2 inputs. Got ${d.length} input(s).`);let o=[];for(const x of d)null!=x&&null!==x[0]&&o.push(x[0]);if(o=xe(o),o.length>1)throw new ln(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(d)}.`);let p=null==d[0]?null:d[0].slice(1);for(let x=1;x<d.length;++x){const R=null==d[x]?null:d[x].slice(1);p=this.computeElementwiseOpOutputShape(p,R)}const m=d.map(x=>x.length);this.reshapeRequired=-1!==d.indexOf(null)||1!==xe(m).length}call(d,o){return(0,l.lub)(()=>{if(this.reshapeRequired){const p=[],m=d.map(x=>x.rank);if(-1===m.indexOf(null)){const x=Nu(m);for(let R of d){const $=R.rank;for(let j=0;j<x-$;++j)R=od(R,1);p.push(R)}return this.mergeFunction(p)}{let x=!1;for(const j of d){const ce=j.rank;if(null==ce){const fe=j.shape,je=fe[0],ze=fe.slice(1).concat([je]);let nt=l.XLQ(j,[je].concat(Sc(fe.slice(1))));nt=l.p4s(nt,[1,0]),nt=l.XLQ(nt,ze),p.push(nt),x=!0}else if(ce>1){const fe=Jc(1,ce).concat([0]);p.push(l.p4s(j,fe)),x=!0}else p.push(j)}let R=this.mergeFunction(p);const $=R.rank;if(x)if(null==$){const j=R.shape,fe=j[j.length-1],je=[fe].concat(j.slice(0,j.length-1));R=l.XLQ(l.p4s(l.XLQ(R,[-1,fe]),[1,0]),je)}else if($>1){const j=[$-1].concat(Jc(0,$-1));R=l.p4s(R,j)}return R}}return this.mergeFunction(d)})}computeOutputShape(d){let o;o=null==d[0]?null:d[0].slice(1);for(let m=1;m<d.length;++m){const x=null==d[m]?null:d[m].slice(1);o=this.computeElementwiseOpOutputShape(o,x)}let p=[];for(const m of d)null!=m&&null!==m[0]&&p.push(m[0]);return p=xe(p),o=1===p.length?p.concat(o):[null].concat(o),o}computeMask(d,o){return l.lub(()=>{if(null==o)return null;if(!Array.isArray(o))throw new ln("`mask` should be an Array");if(!Array.isArray(d))throw new ln("`inputs` should be an Array");if(o.length!==d.length)throw new ln(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${d.length} vs ${o.length})`);if(o.every(m=>null==m))return null;let p=(o=o.map(m=>null==m?m:l.dt4(m,0)))[0];for(let m=1;m<o.length-1;++m)p=l.HvI(p,o[m]);return p})}}let fm=(()=>{class u extends qd{constructor(o){super(o)}mergeFunction(o){return(0,l.lub)(()=>{let p=o[0].clone();for(let m=1;m<o.length;++m)p=l.IHx(p,o[m]);return p})}}return u.className="Add",u})();l.m7h.registerClass(fm);let Fp=(()=>{class u extends qd{constructor(o){super(o)}mergeFunction(o){return(0,l.lub)(()=>{let p=o[0].clone();for(let m=1;m<o.length;++m)p=l.dC7(p,o[m]);return p})}}return u.className="Multiply",u})();l.m7h.registerClass(Fp);let Cf=(()=>{class u extends qd{constructor(o){super(o)}mergeFunction(o){return(0,l.lub)(()=>{let p=o[0].clone();for(let m=1;m<o.length;++m)p=l.IHx(p,o[m]);return l.dC7(1/o.length,p)})}}return u.className="Average",u})();l.m7h.registerClass(Cf);let Cg=(()=>{class u extends qd{constructor(o){super(o)}mergeFunction(o){return(0,l.lub)(()=>{let p=o[0];for(let m=1;m<o.length;++m)p=l.gWQ(p,o[m]);return p})}}return u.className="Maximum",u})();l.m7h.registerClass(Cg);let Eg=(()=>{class u extends qd{constructor(o){super(o)}mergeFunction(o){return(0,l.lub)(()=>{let p=o[0];for(let m=1;m<o.length;++m)p=l.LTh(p,o[m]);return p})}}return u.className="Minimum",u})();l.m7h.registerClass(Eg);let Dg=(()=>{class u extends qd{constructor(o){super(o),this.DEFAULT_AXIS=-1,null==o&&(o={}),this.axis=null==o.axis?this.DEFAULT_AXIS:o.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(o){if(!Array.isArray(o)||!Array.isArray(o[0])||1===o.length)throw new ln("A `Concatenate` layer should be called on a list of at least 2 inputs");let p=!0;for(const x of o)if(null!=x){p=!1;break}if(p)return;const m=[];for(let x=0;x<o.length;++x){const R=o[x].slice();R.splice(this.axis,1);let $=!1;for(const j of m)if(l.D5U.arraysEqual(j,R)){$=!0;break}$||m.push(R)}if(m.length>1)throw new ln("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(o))}mergeFunction(o){return(0,l.lub)(()=>$h(o,this.axis))}computeOutputShape(o){if(!Array.isArray(o)||!Array.isArray(o[0]))throw new ln("A `Concatenate` layer should be called on a list of inputs.");const p=o,m=p[0].slice(),x=this.axis<0?m.length+this.axis:this.axis;for(const R of p.slice(1)){if(null==m[x]||null==R[x]){m[x]=null;break}m[x]+=R[x]}return m}computeMask(o,p){if(null==p)return null;if(!Array.isArray(p))throw new ln("`mask` should be an array for Concatenate");if(!Array.isArray(o))throw new ln("`inputs` should be an array for Concatenate");if(p.length!==o.length)throw new ln(`Mismatch in the length of mask (${p.length}) and the legnth of inputs (${o.length})`);return l.lub(()=>{let m=!0;if(p.forEach($=>{null==$||(m=!1)}),m)return null;const x=[];for(let $=0;$<o.length;++$)x.push(null==p[$]?l.pju(l.JpU(o[$]),"bool"):p[$].rank<o[$].rank?l.dt4(p[$],-1):p[$]);const R=l.zoF(x,this.axis);return l.$6P(R,-1,!1)})}getConfig(){const o={axis:this.axis},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Concatenate",u})();function Ef(u,d){for(;u<0;)u+=d;return u}l.m7h.registerClass(Dg);let Ig=(()=>{class u extends qd{constructor(o){super(o),this.axes=o.axes,this.normalize=null!=o.normalize&&o.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(o){l.D5U.assert(Array.isArray(o)&&2===o.length&&Array.isArray(o[0])&&Array.isArray(o[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const p=o[0],m=o[1];if(p.length>3||m.length>3)throw new ei("Dot layer does not support tensors of 4D or higher rank yet.");const x=this.interpretAxes(p,m);if(p[x[0]]!==m[x[1]])throw new ln(`Dimension incompatibility: ${p[x[0]]} !== ${m[x[1]]}`)}mergeFunction(o){if(2!==o.length)throw new ln(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${o.length} input(s).`);let x,p=o[0],m=o[1];return x=Array.isArray(this.axes)?this.axes.map((R,$)=>Ef(R,o[$].shape.length)):[Ef(this.axes,p.shape.length),Ef(this.axes,m.shape.length)],this.normalize&&(p=vh(p,x[0]),m=vh(m,x[1])),function Sg(u,d,o){if(u.shape.length>3||d.shape.length>3)throw new ei("batchDot is not implemented for tensors of 4D or higher rank yet");if(l.D5U.assert(u.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${u.shape.length}`),l.D5U.assert(u.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${d.shape.length}`),"number"==typeof o&&(o=[o,o]),"complex64"===u.dtype||"complex64"===d.dtype)throw new ei("batchDot is not implemented for complex64-type Tensors yet.");const p=u.shape.length,m=d.shape.length;null==o&&(o=[p-1,m-2]);const x=o;return l.lub(()=>{let R,$;if(p>m){R=p-m;const j=[];for(let ce=0;ce<R;++ce)j.push(1);d=l.XLQ(d,d.shape.concat(j))}else if(m>p){R=m-p;const j=[];for(let ce=0;ce<R;++ce)j.push(1);u=l.XLQ(u,u.shape.concat(j))}else R=0;if($=2===u.shape.length&&2===d.shape.length?x[0]===x[1]?l.Smz(l.dC7(u,d),x[0]):l.Smz(l.dC7(l.p4s(u,[1,0]),d),x[1]):l.OI3(u,d,x[0]!==u.shape.length-1,x[1]===d.shape.length-1),R>0){let j;j=p>m?p+m-3:p-1;const ce=[];for(let fe=j;fe<j+R;++fe)ce.push(fe);$=l.L9e($,ce)}return 1===$.shape.length&&($=l.dt4($,1)),$})}(p,m,x)}interpretAxes(o,p){let m;return m=Array.isArray(this.axes)?this.axes:[Ef(this.axes,o.length),Ef(this.axes,p.length)],m}computeOutputShape(o){l.D5U.assert(Array.isArray(o)&&2===o.length&&Array.isArray(o[0])&&Array.isArray(o[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const p=o[0].slice(),m=o[1].slice();if(p.length>3||m.length>3)throw new ei("Dot layer does not support tensors of 4D or higher rank yet.");const x=this.interpretAxes(p,m);p.splice(x[0],1),m.splice(x[1],1),m.splice(0,1);const R=p.concat(m);return 1===R.length&&R.push(1),R}computeMask(o,p){return null}getConfig(){const o={axes:this.axes,normalize:this.normalize},p=super.getConfig();return Object.assign(o,p),o}}return u.className="Dot",u})();l.m7h.registerClass(Ig);let Lp=(()=>{class u extends gs{constructor(o){super(o),this.supportsMasking=!0,this.stddev=o.stddev}computeOutputShape(o){return o}getConfig(){const o=super.getConfig(),p={stddev:this.stddev};return Object.assign(p,o),p}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);const m=li(o);return jd(()=>(0,l.IHx)(Hd(m.shape,0,this.stddev),m),()=>m,p.training||!1)})}}return u.className="GaussianNoise",u})();l.m7h.registerClass(Lp);let Q0=(()=>{class u extends gs{constructor(o){super(o),this.supportsMasking=!0,this.rate=o.rate}computeOutputShape(o){return o}getConfig(){const o=super.getConfig(),p={rate:this.rate};return Object.assign(p,o),p}call(o,p){return(0,l.lub)(()=>{this.invokeCallHook(o,p);const m=li(o);return this.rate>0&&this.rate<1?jd(()=>{const R=Math.sqrt(this.rate/(1-this.rate));return(0,l.dC7)(m,Hd(m.shape,1,R))},()=>m,p.training||!1):m})}}return u.className="GaussianDropout",u})();l.m7h.registerClass(Q0);let J0=(()=>{class u extends gs{constructor(o){super(o),this.supportsMasking=!0,this.rate=o.rate,this.noiseShape=o.noiseShape}_getNoiseShape(o){return this.noiseShape||li(o).shape}computeOutputShape(o){return o}getConfig(){const o=super.getConfig(),p={rate:this.rate};return Object.assign(p,o),p}call(o,p){return(0,l.lub)(()=>{if(this.rate<1&&this.rate>0){const m=this._getNoiseShape(o);return jd(()=>{const R=li(o),ce=-1.7580993408473766;let fe=(0,l.brS)((0,l.LGj)(m),this.rate);fe=qc(fe,"float32");const je=((1-this.rate)*(1+this.rate*ce**2))**-.5,ze=-je*ce*this.rate,nt=(0,l.IHx)((0,l.dC7)(R,fe),(0,l.dC7)((0,l.IHx)(fe,-1),ce));return(0,l.IHx)((0,l.dC7)(nt,je),ze)},()=>li(o),p.training||!1)}return o})}}return u.className="AlphaDropout",u})();function Tg(u,d,o,p,m,x=.001){let R;if(2===u.rank)R=l.Dxk(u,d,o,p,m,x);else if(3===u.rank)R=l.JY5(u,d,o,p,m,x);else{if(4!==u.rank)throw new ei(`batchNormalization is not implemented for array of rank ${u.rank} yet`);R=l.p3b(u,d,o,p,m,x)}return R}l.m7h.registerClass(J0);let $p=(()=>{class u extends gs{constructor(o){null==o&&(o={}),super(o),this.supportsMasking=!0,this.axis=null==o.axis?-1:o.axis,this.momentum=null==o.momentum?.99:o.momentum,this.epsilon=null==o.epsilon?.001:o.epsilon,this.center=null==o.center||o.center,this.scale=null==o.scale||o.scale,this.betaInitializer=Uo(o.betaInitializer||"zeros"),this.gammaInitializer=Uo(o.gammaInitializer||"ones"),this.movingMeanInitializer=Uo(o.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Uo(o.movingVarianceInitializer||"ones"),this.betaConstraint=Ql(o.betaConstraint),this.gammaConstraint=Ql(o.gammaConstraint),this.betaRegularizer=Dl(o.betaRegularizer),this.gammaRegularizer=Dl(o.gammaRegularizer)}build(o){o=ao(o);const p=this.axis>=0?this.axis:this.axis+o.length,m=o[p];if(null==m)throw new ln(`Axis ${p} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(o)}.`);this.inputSpec=[new pi({ndim:o.length,axes:{[p]:m}})];const x=[m];this.scale&&(this.gamma=this.addWeight("gamma",x,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",x,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",x,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",x,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(o,p){return(0,l.lub)(()=>{const m=null!=p.training&&p.training,x=li(o),R=x.shape,$=R.length,j=Jc(0,$),ce=this.axis>=0?this.axis:this.axis+$;j.splice(ce,1);const fe=Ur(1,$);fe[ce]=R[ce];const je=j.slice();je.sort();const ze=!l.D5U.arraysEqual(je,Jc(0,$).slice(0,$-1));if(!m)return(()=>{if(ze){const Ut=(0,l.XLQ)(this.movingMean.read(),fe),Ft=(0,l.XLQ)(this.movingVariance.read(),fe),sn=this.center?(0,l.XLQ)(this.beta.read(),fe):null,_n=this.scale?(0,l.XLQ)(this.gamma.read(),fe):null;return Tg(x,Ut,Ft,sn,_n,this.epsilon)}return Tg(x,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[Rt,bt,xt]=function ux(u,d,o,p,m=.001){return l.D5U.arraysEqual(p.slice().sort(),Jc(0,u.rank-1))?function cx(u,d,o,p,m=.001){return(0,l.lub)(()=>{const x=l.Gi7(u,p),R=x.mean,$=x.variance;return[Tg(u,R,$,o,d,m),R,$]})}(u,d,o,p,m):function iy(u,d,o,p,m=.001){return(0,l.lub)(()=>{const x=l.Gi7(u,p),R=x.mean,$=x.variance,j=[];for(const Rt of Jc(0,u.rank))-1!==p.indexOf(Rt)?j.push(1):j.push(u.shape[Rt]);const ce=(0,l.XLQ)(R,j),fe=(0,l.XLQ)($,j),je=null==d?null:(0,l.XLQ)(d,j),ze=null==o?null:(0,l.XLQ)(o,j);return[Tg(u,ce,fe,ze,je,m),R,$]})}(u,d,o,p,m)}(x,this.gamma.read(),this.beta.read(),j,this.epsilon),Pt=(Ut,Ft,sn)=>{l.lub(()=>{const _n=1-sn,Cn=Ut.read(),Bn=l.dC7(l.luU(Cn,Ft),_n);Ut.write(l.luU(Cn,Bn))})};return(()=>{Pt(this.movingMean,bt,this.momentum),Pt(this.movingVariance,xt,this.momentum)})(),Rt})}getConfig(){const o={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Va(this.betaInitializer),gammaInitializer:Va(this.gammaInitializer),movingMeanInitializer:Va(this.movingMeanInitializer),movingVarianceInitializer:Va(this.movingVarianceInitializer),betaRegularizer:Ta(this.betaRegularizer),gammaRegularizer:Ta(this.gammaRegularizer),betaConstraint:Zl(this.betaConstraint),gammaConstraint:Zl(this.gammaConstraint)},p=super.getConfig();return Object.assign(o,p),o}}return u.className="BatchNormalization",u})();l.m7h.registerClass($p);let mm=(()=>{class u extends gs{constructor(o){if(null==o&&(o={}),super(o),this.axis=null==o.axis?-1:o.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const p of this.axis)if(!Number.isInteger(p))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==o.epsilon?.001:o.epsilon,this.center=null==o.center||o.center,this.scale=null==o.scale||o.scale,this.betaInitializer=Uo(o.betaInitializer||"zeros"),this.gammaInitializer=Uo(o.gammaInitializer||"ones"),this.betaRegularizer=Dl(o.betaRegularizer),this.gammaRegularizer=Dl(o.gammaRegularizer),this.supportsMasking=!0}build(o){const p=(o=ao(o)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let R=0;R<this.axis.length;++R)this.axis[R]<0&&(this.axis[R]+=p);for(const R of this.axis)if(R<0||R>=p)throw new Error(`Invalid axis: ${R}`);if(this.axis.length!==xe(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const m=this.axis.map(R=>o[R]);this.gamma=this.scale?this.addWeight("gamma",m,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",m,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(o,p){const m=li(o),x=m.shape,R=x.length;return(0,l.lub)(()=>{let{mean:j,variance:ce}=(0,l.Gi7)(m,this.axis,!0);const fe=Ur(1,R);for(const xt of this.axis)fe[xt]=x[xt];const je=xt=>null!=xt&&xt.shape.length!==R?l.XLQ(xt,fe):xt;let ze=this.scale?je(this.gamma.read()):null,nt=this.center?je(this.beta.read()):null;const Rt=[],bt=[];for(let xt=0;xt<R;++xt)-1!==this.axis.indexOf(xt)?(Rt.push(x[xt]),bt.push(1)):(Rt.push(1),bt.push(x[xt]));return j=l.Gg6(j,Rt),ce=l.Gg6(ce,Rt),null!=ze&&(ze=l.Gg6(ze,bt)),null!=nt&&(nt=l.Gg6(nt,bt)),Tg(m,j,ce,nt,ze,this.epsilon)})}getConfig(){const o={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Va(this.betaInitializer),gammaInitializer:Va(this.gammaInitializer),betaRegularizer:Ta(this.betaRegularizer),gammaRegularizer:Ta(this.gammaRegularizer)},p=super.getConfig();return Object.assign(o,p),o}}return u.className="LayerNormalization",u})();l.m7h.registerClass(mm);let oy=(()=>{class u extends gs{constructor(o){if(null==o&&(o={}),super(o),this.dataFormat=null==o.dataFormat?"channelsLast":o.dataFormat,null==o.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof o.padding)this.padding=[[o.padding,o.padding],[o.padding,o.padding]];else{if(o.padding=o.padding,2!==o.padding.length)throw new ln(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${o.padding.length} array.`);let p,m;if("number"==typeof o.padding[0])p=[o.padding[0],o.padding[0]],m=[o.padding[1],o.padding[1]];else{if(o.padding=o.padding,2!==o.padding[0].length)throw new ln(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${o.padding[0].length} array.`);if(p=o.padding[0],2!==o.padding[1].length)throw new ln(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${o.padding[1].length} array.`);m=o.padding[1]}this.padding=[p,m]}this.inputSpec=[new pi({ndim:4})]}computeOutputShape(o){let p,m;return o=ao(o),"channelsFirst"===this.dataFormat?(p=null!=o[2]&&o[2]>=0?o[2]+this.padding[0][0]+this.padding[0][1]:null,m=null!=o[3]&&o[3]>=0?o[3]+this.padding[1][0]+this.padding[1][1]:null,[o[0],o[1],p,m]):(p=null!=o[1]&&o[1]>=0?o[1]+this.padding[0][0]+this.padding[0][1]:null,m=null!=o[2]&&o[2]>=0?o[2]+this.padding[1][0]+this.padding[1][1]:null,[o[0],p,m,o[3]])}call(o,p){return(0,l.lub)(()=>function ev(u,d,o){return(0,l.lub)(()=>{if(4!==u.rank)throw new ln(`temporalPadding expects input tensor to be 4-D, but received a ${u.rank}-D tensor.`);if(null==d&&(d=[[1,1],[1,1]]),2!==d.length||2!==d[0].length||2!==d[1].length)throw new ln("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==o&&(o="channelsLast"),"channelsLast"!==o&&"channelsFirst"!==o)throw new ln(`Unknown data format: ${o}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let p;return p="channelsFirst"===o?[[0,0],[0,0],d[0],d[1]]:[[0,0],d[0],d[1],[0,0]],l.vku(u,p)})}(li(o),this.padding,this.dataFormat))}getConfig(){const o={padding:this.padding,dataFormat:this.dataFormat},p=super.getConfig();return Object.assign(o,p),o}}return u.className="ZeroPadding2D",u})();function gm(u,d,o,p,m,x){return(0,l.lub)(()=>{let R;Ci(m),id(x),cl(p),null==o&&(o=[1,1]),null==p&&(p="valid"),null==m&&(m="channelsLast"),null==x&&(x="max"),u=fg(u,m);const $="same"===p?"same":"valid";return R="max"===x?l._sB(u,d,o,$):l.wS1(u,d,o,$),"channelsFirst"===m&&(R=l.p4s(R,[0,3,1,2])),R})}function Qh(u,d,o,p,m,x){return(0,l.lub)(()=>{let R;Ci(m),id(x),cl(p),null==o&&(o=[1,1,1]),null==p&&(p="valid"),null==m&&(m="channelsLast"),null==x&&(x="max"),u=W_(u,m);const $="same"===p?"same":"valid";return R="max"===x?l.YQQ(u,d,o,$):l.uR5(u,d,o,$),"channelsFirst"===m&&(R=l.p4s(R,[0,4,1,2,3])),R})}l.m7h.registerClass(oy);class tv extends gs{constructor(d){if(null==d.poolSize&&(d.poolSize=2),super(d),"number"==typeof d.poolSize)this.poolSize=[d.poolSize];else{if(!Array.isArray(d.poolSize)||1!==d.poolSize.length||"number"!=typeof d.poolSize[0])throw new ln(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(d.poolSize)}`);this.poolSize=d.poolSize}if(gt(this.poolSize,"poolSize"),null==d.strides)this.strides=this.poolSize;else if("number"==typeof d.strides)this.strides=[d.strides];else{if(!Array.isArray(d.strides)||1!==d.strides.length||"number"!=typeof d.strides[0])throw new ln(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(d.strides)}`);this.strides=d.strides}gt(this.strides,"strides"),this.padding=null==d.padding?"valid":d.padding,cl(this.padding),this.inputSpec=[new pi({ndim:3})]}computeOutputShape(d){const o=Ad((d=ao(d))[1],this.poolSize[0],this.padding,this.strides[0]);return[d[0],o,d[2]]}call(d,o){return(0,l.lub)(()=>{this.invokeCallHook(d,o),d=od(li(d),2);const p=this.poolingFunction(li(d),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return l.L9e(p,[2])})}getConfig(){const d={poolSize:this.poolSize,padding:this.padding,strides:this.strides},o=super.getConfig();return Object.assign(d,o),d}}let dx=(()=>{class u extends tv{constructor(o){super(o)}poolingFunction(o,p,m,x,R){return Ci(R),cl(x),gm(o,p,m,x,R,"max")}}return u.className="MaxPooling1D",u})();l.m7h.registerClass(dx);let nv=(()=>{class u extends tv{constructor(o){super(o)}poolingFunction(o,p,m,x,R){return Ci(R),cl(x),gm(o,p,m,x,R,"avg")}}return u.className="AveragePooling1D",u})();l.m7h.registerClass(nv);class sv extends gs{constructor(d){if(null==d.poolSize&&(d.poolSize=[2,2]),super(d),this.poolSize=Array.isArray(d.poolSize)?d.poolSize:[d.poolSize,d.poolSize],null==d.strides)this.strides=this.poolSize;else if(Array.isArray(d.strides)){if(2!==d.strides.length)throw new ln(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${d.strides.length}.`);this.strides=d.strides}else this.strides=[d.strides,d.strides];gt(this.poolSize,"poolSize"),gt(this.strides,"strides"),this.padding=null==d.padding?"valid":d.padding,this.dataFormat=null==d.dataFormat?"channelsLast":d.dataFormat,Ci(this.dataFormat),cl(this.padding),this.inputSpec=[new pi({ndim:4})]}computeOutputShape(d){d=ao(d);let o="channelsFirst"===this.dataFormat?d[2]:d[1],p="channelsFirst"===this.dataFormat?d[3]:d[2];return o=Ad(o,this.poolSize[0],this.padding,this.strides[0]),p=Ad(p,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[d[0],d[1],o,p]:[d[0],o,p,d[3]]}call(d,o){return(0,l.lub)(()=>(this.invokeCallHook(d,o),this.poolingFunction(li(d),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const d={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},o=super.getConfig();return Object.assign(d,o),d}}let hx=(()=>{class u extends sv{constructor(o){super(o)}poolingFunction(o,p,m,x,R){return Ci(R),cl(x),gm(o,p,m,x,R,"max")}}return u.className="MaxPooling2D",u})();l.m7h.registerClass(hx);let Lu=(()=>{class u extends sv{constructor(o){super(o)}poolingFunction(o,p,m,x,R){return Ci(R),cl(x),gm(o,p,m,x,R,"avg")}}return u.className="AveragePooling2D",u})();l.m7h.registerClass(Lu);class Od extends gs{constructor(d){if(null==d.poolSize&&(d.poolSize=[2,2,2]),super(d),this.poolSize=Array.isArray(d.poolSize)?d.poolSize:[d.poolSize,d.poolSize,d.poolSize],null==d.strides)this.strides=this.poolSize;else if(Array.isArray(d.strides)){if(3!==d.strides.length)throw new ln(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${d.strides.length}.`);this.strides=d.strides}else this.strides=[d.strides,d.strides,d.strides];gt(this.poolSize,"poolSize"),gt(this.strides,"strides"),this.padding=null==d.padding?"valid":d.padding,this.dataFormat=null==d.dataFormat?"channelsLast":d.dataFormat,Ci(this.dataFormat),cl(this.padding),this.inputSpec=[new pi({ndim:5})]}computeOutputShape(d){d=ao(d);let o="channelsFirst"===this.dataFormat?d[2]:d[1],p="channelsFirst"===this.dataFormat?d[3]:d[2],m="channelsFirst"===this.dataFormat?d[4]:d[3];return o=Ad(o,this.poolSize[0],this.padding,this.strides[0]),p=Ad(p,this.poolSize[1],this.padding,this.strides[1]),m=Ad(m,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[d[0],d[1],o,p,m]:[d[0],o,p,m,d[4]]}call(d,o){return(0,l.lub)(()=>(this.invokeCallHook(d,o),this.poolingFunction(li(d),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const d={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},o=super.getConfig();return Object.assign(d,o),d}}let Ag=(()=>{class u extends Od{constructor(o){super(o)}poolingFunction(o,p,m,x,R){return Ci(R),cl(x),Qh(o,p,m,x,R,"max")}}return u.className="MaxPooling3D",u})();l.m7h.registerClass(Ag);let rv=(()=>{class u extends Od{constructor(o){super(o)}poolingFunction(o,p,m,x,R){return Ci(R),cl(x),Qh(o,p,m,x,R,"avg")}}return u.className="AveragePooling3D",u})();l.m7h.registerClass(rv);class iv extends gs{constructor(d){super(d),this.inputSpec=[new pi({ndim:3})]}computeOutputShape(d){return[d[0],d[2]]}call(d,o){throw new ei}}let ov=(()=>{class u extends iv{constructor(o){super(o||{})}call(o,p){return(0,l.lub)(()=>{const m=li(o);return l.J69(m,1)})}}return u.className="GlobalAveragePooling1D",u})();l.m7h.registerClass(ov);let av=(()=>{class u extends iv{constructor(o){super(o||{})}call(o,p){return(0,l.lub)(()=>{const m=li(o);return l.Fp7(m,1)})}}return u.className="GlobalMaxPooling1D",u})();l.m7h.registerClass(av);class lv extends gs{constructor(d){super(d),this.dataFormat=null==d.dataFormat?"channelsLast":d.dataFormat,Ci(this.dataFormat),this.inputSpec=[new pi({ndim:4})]}computeOutputShape(d){return"channelsLast"===this.dataFormat?[d[0],d[3]]:[d[0],d[1]]}call(d,o){throw new ei}getConfig(){const d={dataFormat:this.dataFormat},o=super.getConfig();return Object.assign(d,o),d}}let ay=(()=>{class u extends lv{call(o,p){return(0,l.lub)(()=>{const m=li(o);return l.J69(m,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return u.className="GlobalAveragePooling2D",u})();l.m7h.registerClass(ay);let cv=(()=>{class u extends lv{call(o,p){return(0,l.lub)(()=>{const m=li(o);return l.Fp7(m,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return u.className="GlobalMaxPooling2D",u})();l.m7h.registerClass(cv);class uv extends gs{constructor(d){super(d),this.layer=d.layer}build(d){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(d){null!=this.layer&&(this.layer.trainable=d)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(d){this.layer.setWeights(d)}getConfig(){const d={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},o=super.getConfig();return Object.assign(d,o),d}setFastWeightInitDuringBuild(d){super.setFastWeightInitDuringBuild(d),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(d)}static fromConfig(d,o,p={}){const x=wu(o.layer,p);delete o.layer;const R={layer:x};return Object.assign(R,o),new d(R)}}let dv=(()=>{class u extends uv{constructor(o){super(o),this.supportsMasking=!0}build(o){if((o=ao(o)).length<3)throw new ln(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(o)}`);this.inputSpec=[{shape:o}];const p=[o[0]].concat(o.slice(2));this.layer.built||(this.layer.build(p),this.layer.built=!0),super.build(o)}computeOutputShape(o){const p=[(o=ao(o))[0]].concat(o.slice(2)),m=this.layer.computeOutputShape(p);return[m[0],o[1]].concat(m.slice(1))}call(o,p){return(0,l.lub)(()=>X0(($,j)=>[li(this.layer.call($,p)),[]],o=li(o),[],!1,null,null,!1,!0)[1])}}return u.className="TimeDistributed",u})();l.m7h.registerClass(dv);let eh=(()=>{class u extends uv{constructor(o){super(o);const p=o.layer.getConfig(),m={};m.className=o.layer.getClassName(),m.config=p,this.forwardLayer=wu(m),p.goBackwards=!0!==p.goBackwards;const x={};if(x.className=o.layer.getClassName(),x.config=p,this.backwardLayer=wu(x),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===o.mergeMode?"concat":o.mergeMode,function px(u){me(vc,"BidirectionalMergeMode",u)}(this.mergeMode),o.weights)throw new ei("weights support is not implemented for Bidirectional layer yet.");this._stateful=o.layer.stateful,this.returnSequences=o.layer.returnSequences,this.returnState=o.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=o.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(o){this._trainable=o,null!=this.forwardLayer&&(this.forwardLayer.trainable=o),null!=this.backwardLayer&&(this.backwardLayer.trainable=o)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(o){const m=Math.floor(o.length/2);this.forwardLayer.setWeights(o.slice(0,m)),this.backwardLayer.setWeights(o.slice(m))}computeOutputShape(o){let m,x,R,p=this.forwardLayer.computeOutputShape(o);return Array.isArray(p)&&Array.isArray(p[0])||(p=[p]),this.returnState&&(R=p.slice(1)),m=p[0],"concat"===this.mergeMode?(m[m.length-1]*=2,x=[m]):x=null==this.mergeMode?[m,m.slice()]:[m],this.returnState?null==this.mergeMode?x.concat(R).concat(R.slice()):[m].concat(R).concat(R.slice()):Do(x)}apply(o,p){let m=null==p?null:p.initialState,x=null==p?null:p.constants;null==p&&(p={});const R=K0(o,m,x,this.numConstants);if(o=R.inputs,m=R.initialState,x=R.constants,Array.isArray(o)&&(m=o.slice(1),o=o[0]),(null==m||0===m.length)&&null==x)return super.apply(o,p);const $=[],j=[];if(null!=m){const fe=m.length;if(fe%2>0)throw new ln("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");p.initialState=m,$.push(...m);const je=m.map(ze=>new pi({shape:ze.shape}));this.forwardLayer.stateSpec=je.slice(0,fe/2),this.backwardLayer.stateSpec=je.slice(fe/2),j.push(...je)}if(null!=x)throw new ei("Support for constants in Bidirectional layers is not implemented yet.");const ce=$[0]instanceof Xr;for(const fe of $)if(fe instanceof Xr!==ce)throw new ln("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(ce){const fe=[o].concat($),je=this.inputSpec.concat(j),ze=this.inputSpec;this.inputSpec=je;const nt=super.apply(fe,p);return this.inputSpec=ze,nt}return super.apply(o,p)}call(o,p){return(0,l.lub)(()=>{const m=p.initialState;let x,R,$,j;if(null==m)x=this.forwardLayer.call(o,p),R=this.backwardLayer.call(o,p);else{const ce=m.slice(0,m.length/2),fe=m.slice(m.length/2);x=this.forwardLayer.call(o,Object.assign(p,{initialState:ce})),R=this.backwardLayer.call(o,Object.assign(p,{initialState:fe}))}return this.returnState&&(Array.isArray(x)&&($=x.slice(1).concat(R.slice(1))),x=x[0],R=R[0]),this.returnSequences&&(R=l.GYS(R,1)),"concat"===this.mergeMode?j=$h([x,R]):"sum"===this.mergeMode?j=l.IHx(x,R):"ave"===this.mergeMode?j=l.dC7(.5,l.IHx(x,R)):"mul"===this.mergeMode?j=l.dC7(x,R):null==this.mergeMode&&(j=[x,R]),this.returnState?null==this.mergeMode?j.concat($):[j].concat($):j})}resetStates(o){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(o){$c(this.forwardLayer.name,()=>{this.forwardLayer.build(o)}),$c(this.backwardLayer.name,()=>{this.backwardLayer.build(o)}),this.built=!0}computeMask(o,p){let m;if(Array.isArray(p)&&(p=p[0]),m=this.returnSequences?null==this.mergeMode?[p,p]:p:null==this.mergeMode?[null,null]:null,this.returnState){const R=this.forwardLayer.states.map($=>null);return Array.isArray(m)?m.concat(R).concat(R):[m].concat(R).concat(R)}return m}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(o){super.setFastWeightInitDuringBuild(o),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(o),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(o)}getConfig(){const o={mergeMode:this.mergeMode},p=super.getConfig();return Object.assign(o,p),o}static fromConfig(o,p){const m=wu(p.layer);if(delete p.layer,null!=p.numConstants)throw new ei("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const x=p;return x.layer=m,new o(x)}}return u.className="Bidirectional",u})();l.m7h.registerClass(eh);let Df=(()=>{class u extends gs{constructor(o){super(o),this.scale=o.scale,this.offset=o.offset?o.offset:0}getConfig(){const o={scale:this.scale,offset:this.offset},p=super.getConfig();return Object.assign(o,p),o}call(o,p){return(0,l.lub)(()=>("float32"!==(o=li(o)).dtype&&(o=qc(o,"float32")),(0,l.IHx)((0,l.dC7)(o,this.scale),this.offset)))}}return u.className="Rescaling",u})();l.m7h.registerClass(Df);const{resizeBilinear:fx,cropAndResize:hv}=l.image;let ly=(()=>{class u extends gs{constructor(o){super(o),this.height=o.height,this.width=o.width}centerCrop(o,p,m,x,R,$,j,ce){return(0,l.lub)(()=>{let fe,je=!1;const xt=[p/$,m/j,(x+p)/$,(R+m)/j],Pt=[];3===o.rank?(je=!0,fe=(0,l.knu)([o])):fe=o;for(let _n=0;_n<fe.shape[0];_n++)Pt.push(xt);const St=(0,l.XeE)(Pt,[Pt.length,4]),Ut=(0,l.w6H)(0,Pt.length,1,"int32"),sn=hv(fe,St,Ut,[x,R],"nearest");return qc(je?li((0,l.HHK)(sn)):sn,ce)})}upsize(o,p,m,x){return(0,l.lub)(()=>qc(fx(o,[p,m]),x))}call(o,p){return(0,l.lub)(()=>{const m=li(o),x=m.dtype,R=m.shape,$=R[R.length-3],j=R[R.length-2];let ce=0;$!==this.height&&(ce=Math.floor(($-this.height)/2));let fe=0;return j!==this.width&&(fe=Math.floor((j-this.width)/2),0===fe&&(fe=1)),ce>=0&&fe>=0?this.centerCrop(m,ce,fe,this.height,this.width,$,j,x):this.upsize(o,this.height,this.width,x)})}getConfig(){const o={height:this.height,width:this.width},p=super.getConfig();return Object.assign(o,p),o}computeOutputShape(o){const m=(o=ao(o)).length-2;return o[o.length-3]=this.height,o[m]=this.width,o}}return u.className="CenterCrop",u})();l.m7h.registerClass(ly);let mx=(()=>{class u extends gs{constructor(o){super(o),this.numTokens=o.numTokens,this.outputMode=o.outputMode?o.outputMode:"multiHot"}getConfig(){const o={numTokens:this.numTokens,outputMode:this.outputMode},p=super.getConfig();return Object.assign(o,p),o}computeOutputShape(o){return null==(o=ao(o))?[this.numTokens]:"oneHot"===this.outputMode&&1!==o[o.length-1]?(o.push(this.numTokens),o):(o[o.length-1]=this.numTokens,o)}call(o,p){return(0,l.lub)(()=>{let m;if("int32"!==(o=li(o)).dtype&&(o=qc(o,"int32")),typeof p.countWeights<"u"){if("count"!==this.outputMode)throw new ln(`countWeights is not used when outputMode !== count.\n              Received countWeights=${p.countWeights}`);m=li(p.countWeights)}const x=(0,l.Fp7)(o),R=(0,l.VV$)(o),$=(0,l.pjt)(this.numTokens,x).bufferSync().get(0),j=(0,l.brS)(R,0).bufferSync().get(0);if(!$||!j)throw new ln(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function sT(u,d,o,p){let m=li(u);if("int32"!==m.dtype&&(m=qc(m,"int32")),"int"===d)return m;const x=m.shape;if(0===m.rank&&(m=(0,l.dt4)(m,-1)),"oneHot"===d&&1!==m.shape[m.shape.length-1]&&(m=(0,l.dt4)(m,-1)),m.rank>2)throw new ln(`When outputMode is not int, maximum output rank is 2 Received outputMode ${d} and input shape ${x} which would result in output rank ${m.rank}.`);const R=["multiHot","oneHot"].includes(d);let j;if(j=(0,l.ppE)(m,typeof p<"u"&&"count"===d?p:[],o,R),"tfIdf"!==d)return j;if(p)return(0,l.dC7)(j,p);throw new ln("When outputMode is 'tfIdf', weights must be provided.")}(o,this.outputMode,this.numTokens,m)})}}return u.className="CategoryEncoding",u})();l.m7h.registerClass(mx);const Og=new Set(["bilinear","nearest"]);let Rg=(()=>{class u extends gs{constructor(o){if(super(o),this.height=o.height,this.width=o.width,o.interpolation){if(!Og.has(o.interpolation))throw new ln(`Invalid interpolation parameter: ${o.interpolation} is not implemented`);this.interpolation=o.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!o.cropToAspectRatio}computeOutputShape(o){return o=ao(o),[this.height,this.width,o[2]]}getConfig(){const o={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},p=super.getConfig();return Object.assign(o,p),o}call(o,p){return(0,l.lub)(()=>{const m=[this.height,this.width];if("bilinear"===this.interpolation)return l.image.resizeBilinear(o,m,!this.cropToAspectRatio);if("nearest"===this.interpolation)return l.image.resizeNearestNeighbor(o,m,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Og]} are supported`)})}}return u.className="Resizing",u})();l.m7h.registerClass(Rg);let c1=(()=>{class u{constructor(o){this.seed=o}next(){if(void 0!==this.seed)return this.seed++}}return u.className="RandomSeed",u})(),u1=(()=>{class u extends gs{constructor(o){super(o),this.randomGenerator=new c1(o.seed)}getConfig(){const o={seed:this.randomGenerator.seed},p=super.getConfig();return Object.assign(o,p),o}}return u.className="BaseRandomLayer",u})();const pv=new Set(["bilinear","nearest"]);let fv=(()=>{class u extends u1{constructor(o){super(o);const{factor:p,interpolation:m="bilinear"}=o;if(this.factor=p,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new ln(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new ln(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ln(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(m){if(!pv.has(m))throw new ln(`Invalid interpolation parameter: ${m} is not implemented`);this.interpolation=m}}getConfig(){const o={factor:this.factor,interpolation:this.interpolation},p=super.getConfig();return Object.assign(o,p),o}computeOutputShape(o){return o=ao(o),[this.imgHeight,-1,o[2]]}call(o,p){return(0,l.lub)(()=>{const m=li(o);this.imgHeight=m.shape[m.shape.length-3];const x=m.shape[m.shape.length-2];this.widthFactor=(0,l.LGj)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let R=this.widthFactor.dataSync()[0]*x;R=Math.round(R);const $=[this.imgHeight,R];switch(this.interpolation){case"bilinear":return l.image.resizeBilinear(o,$);case"nearest":return l.image.resizeNearestNeighbor(o,$);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...pv]} are supported`)}})}}return u.className="RandomWidth",u})();function d1(u){return new zo(u)}function _x(u){return new pg(u)}function mv(u){return new Du(u)}function Ng(u){return new hg(u)}function gv(u){return new z_(u)}function cy(u){return new yf(u)}function yx(u){return new tu(u)}function nu(u){return new Mp(u)}function vx(u){return new Np(u)}function bx(u){return new j0(u)}function uy(u){return new j_(u)}function _v(u){return new G_(u)}function xx(u){return new K_(u)}function wx(u){return new cm(u)}function Cx(u){return new X_(u)}function Ex(u){return new um(u)}function yv(u){return new ny(u)}function Dx(u){return new hm(u)}function h1(u){return new ty(u)}function _m(u){return new ax(u)}function Zn(u){return new Y0(u)}function ym(u){return new sy(u)}function vv(u){return new ry(u)}function dy(u){return new bg(u)}function hy(u){return new pm(u)}function py(u){return new fm(u)}function Sx(u){return new Cf(u)}function bv(u){return new Dg(u)}function xv(u){return new Cg(u)}function Mg(u){return new Eg(u)}function p1(u){return new Fp(u)}function fy(u){return new Ig(u)}function Ix(u){return new $p(u)}function my(u){return new mm(u)}function wv(u){return new oy(u)}function Pg(u){return new nv(u)}function Bp(u){return Pg(u)}function Tx(u){return Pg(u)}function vm(u){return new Lu(u)}function gy(u){return vm(u)}function Ax(u){return vm(u)}function bm(u){return new rv(u)}function _y(u){return bm(u)}function Yu(u){return bm(u)}function Fg(u){return new ov(u)}function yy(u){return new ay(u)}function Cv(u){return new av(u)}function Ev(u){return new cv(u)}function vy(u){return new dx(u)}function Jh(u){return new hx(u)}function kx(u){return new Ag(u)}function Ox(u){return new dm(u)}function Rx(u){return new _g(u)}function Eh(u){return new yg(u)}function Sf(u){return new wf(u)}function Nx(u){return new Q_(u)}function Dv(u){return new Z_(u)}function qh(u){return new ey(u)}function f1(u){return new vg(u)}function ac(u){return new Yh(u)}function by(u){return new J_(u)}function Mx(u){return new eh(u)}function m1(u){return new dv(u)}l.m7h.registerClass(fv);const g1=Cv,Lg=Ev,Px=vy,xy=Jh;function wy(u){return new Lp(u)}function C(u){return new Q0(u)}function b(u){return new J0(u)}function _(u){return new xg(u)}function S(u){return new Df(u)}function k(u){return new ly(u)}function H(u){return new Rg(u)}function Q(u){return new mx(u)}function ue(u){return new fv(u)}function ae(u,d){return mr(u,d)}function Se(u,d){return ya(u,d)}function Ne(u,d){return sa(u,d)}function Je(u,d){return _a(u,d)}function rt(u,d){return xh(u,d)}function ft(u,d){return Ji(u,d)}function Ot(u,d){return function na(u,d){return(0,l.lub)(()=>{const o=Gr(u,d),p=function ul(u,d){return(0,l.lub)(()=>l.pju(l.Smz(l.HvI(l.DgJ(u,1),l.DgJ(d,0))),"float32"))}(u,d),m=l.IHx(o,p);return l.pju(l.arb(l.pjt(m,0),l.hiC(o,m),0),"float32")})}(u,d)}function Kt(u,d){return Ie(u,d)}function tn(u,d){return Yd(u,d)}function Zt(u,d){return Zd(u,d)}function hn(u,d){return Zd(u,d)}function ts(u,d){return Zd(u,d)}function us(u,d){return Hh(u,d)}function Us(u,d){return Hh(u,d)}function _i(u,d){return Hh(u,d)}function ii(u){return new _f(u)}function Sr(u){return function rx(u){return V_(u),new _f({l1:null!=u?u.l1:null,l2:0})}(u)}function vo(u){return function ix(u){return V_(u),new _f({l2:null!=u?u.l2:null,l1:0})}(u)}class Ti extends Wh{constructor(){super(...arguments),this.model=null}setModel(d){if(!(d instanceof Jd))throw new Error("model must be a LayersModel, not some other Container");this.model=d}}function Aa(u,d){return u<d}function ql(u,d){return u>d}class cd extends Ti{constructor(d){if(super(),null==d&&(d={}),d.restoreBestWeights)throw new ei("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=d.monitor||"val_loss",this.minDelta=Math.abs(d.minDelta||0),this.patience=d.patience||0,this.verbose=d.verbose||0,this.mode=d.mode||"auto",this.baseline=d.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.monitorFunc="min"===this.mode?Aa:"max"===this.mode||-1!==this.monitor.indexOf("acc")?ql:Aa,this.monitorFunc===Aa&&(this.minDelta*=-1)}onTrainBegin(d){var o=this;return(0,ns.Z)(function*(){o.wait=0,o.stoppedEpoch=0,o.best=null!=o.baseline?o.baseline:o.monitorFunc===Aa?1/0:-1/0})()}onEpochEnd(d,o){var p=this;return(0,ns.Z)(function*(){yield Id(o);const m=p.getMonitorValue(o);null!=m&&(p.monitorFunc(m-p.minDelta,p.best)?(p.best=m,p.wait=0):(p.wait++,p.wait>=p.patience&&(p.stoppedEpoch=d,p.model.stopTraining=!0)))})()}onTrainEnd(d){var o=this;return(0,ns.Z)(function*(){o.stoppedEpoch>0&&o.verbose&&console.log(`Epoch ${o.stoppedEpoch}: early stopping.`)})()}getMonitorValue(d){null==d&&(d={});const o=d[this.monitor];return null==o&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(d)}`),o}}const Bu={earlyStopping:function $u(u){return new cd(u)}};var lc,su=h(7926),Zu=h(9128);function Vu(u,d,o=new Map,p=new Set){if(null==u)return null;if("function"==typeof Blob&&u instanceof Blob)return u.slice();if(p.has(u))throw new Error("Circular references are not supported.");if(o.has(u))return o.get(u);const m=d(u);if(m.recurse&&null!==m.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(m.recurse){if(np(u)){const x=Array.isArray(u)?[]:{};p.add(u);for(const R in u){const j=Vu(u[R],d,o,p);x[R]=j}return p.delete(u),u.__proto__&&(x.__proto__=u.__proto__),x}throw new Error(`Can't recurse into non-iterable type: ${u}`)}return o.set(u,m.value),m.value}function yr(u,d=tp){return xm(u,d)}function xm(u,d,o=new Set){const p=u[0];if(o.has(p))throw new Error("Circular references are not supported.");const m=d(u);if(m.recurse&&null!==m.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(m.recurse){if(np(p)){const x=Array.isArray(p)?[]:{};o.add(p);for(const R in p){const j=xm(u.map(ce=>ce[R]),d,o);x[R]=j}return o.delete(p),x}throw new Error(`Can't recurse into non-iterable type: ${p}`)}return m.value}function tp(u){return null===u?null:np(u[0])?{value:null,recurse:!0}:{value:u,recurse:!1}}function th(u,d){return(lc=lc||(0,ns.Z)(function*(o,p){const m=new Map;Vu(o,p,m);for(const R of Array.from(m.keys())){const $=m.get(R);if(l.D5U.isPromise($)){const j=yield $;m.set(R,j)}}return Vu(o,p,m)})).apply(this,arguments)}function np(u){let d=!1;if(l.OBj().get("IS_BROWSER"))d=u instanceof TextDecoder;else{const{StringDecoder:o}=h(4977);d=u instanceof o}return null!=u&&!ArrayBuffer.isView(u)&&(Array.isArray(u)||"object"==typeof u&&!(u instanceof l.esB)&&!(u instanceof Promise)&&!d)}function Fx(u){return u instanceof l.esB?{value:u.clone(),recurse:!1}:np(u)?{value:null,recurse:!0}:{value:u,recurse:!1}}class iT{constructor(d){if(this.capacity=d,this.begin=0,this.end=0,null==d)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(d<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(d),this.doubledCapacity=2*d}wrap(d){for(;d<0;)d+=this.doubledCapacity;return d%this.doubledCapacity}get(d){if(d<0)throw new RangeError("Can't get item at a negative index.");return this.data[d%this.capacity]}set(d,o){if(d<0)throw new RangeError("Can't set item at a negative index.");this.data[d%this.capacity]=o}length(){let d=this.end-this.begin;return d<0&&(d=this.doubledCapacity+d),d}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(d){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,d),this.end=this.wrap(this.end+1)}pushAll(d){for(const o of d)this.push(o)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const d=this.get(this.end);return this.set(this.end,void 0),d}unshift(d){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,d)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const d=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),d}shuffleExcise(d){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const o=this.wrap(this.begin+d),p=this.get(o);return this.set(o,this.pop()),p}}let Lx=(()=>{class u extends iT{constructor(){super(u.INITIAL_CAPACITY)}isFull(){return!1}push(o){super.isFull()&&this.expand(),super.push(o)}unshift(o){super.isFull()&&this.expand(),super.unshift(o)}expand(){const o=2*this.capacity,p=new Array(o),m=this.length();for(let x=0;x<m;x++)p[x]=this.get(this.wrap(this.begin+x));this.data=p,this.capacity=o,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=m}}return u.INITIAL_CAPACITY=32,u})();function $x(u){return new oT(u)}function Cy(u){return new JN(u)}class ru{toArray(){var d=this;return(0,ns.Z)(function*(){const o=[];let p=yield d.next();for(;!p.done;)o.push(p.value),p=yield d.next();return o})()}toArrayForTest(){var d=this;return(0,ns.Z)(function*(){const o=d.prefetch(100),p=[];let m=yield o.next();for(;!m.done;)p.push(m.value),m=yield o.next();return p})()}resolveFully(){var d=this;return(0,ns.Z)(function*(){let o=yield d.next();for(;!o.done;)o=yield d.next()})()}resolveWhile(d){var o=this;return(0,ns.Z)(function*(){let p=yield o.next(),m=d(p.value);for(;!p.done&&m;)p=yield o.next(),m=d(p.value)})()}handleErrors(d){return new nh(this,d)}filter(d){return new qN(this,d)}map(d){return new Vx(this,d)}mapAsync(d){return new Iv(this,d)}serialMapAsync(d){return new Iv(this,d).serial()}flatmap(d){return new eM(this,d)}forEachAsync(d){var o=this;return(0,ns.Z)(function*(){return o.map(d).resolveFully()})()}serialForEach(d){var o=this;return(0,ns.Z)(function*(){return o.serialMapAsync(d).resolveWhile(p=>!0===p)})()}rowMajorBatch(d,o=!0){return new b1(this,d,o)}columnMajorBatch(d,o=!0,p=tp){return this.rowMajorBatch(d,o).map(x=>yr(x,p))}concatenate(d,o){return new x1($x([this,d]),o)}take(d){return d<0||null==d?this:new Wc(this,d)}skip(d){return d<0||null==d?this:new v1(this,d)}prefetch(d){return new zx(this,d)}shuffle(d,o){return new aT(this,d,o)}serial(){return new y1(this)}}class oT extends ru{constructor(d){super(),this.items=d,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var d=this;return(0,ns.Z)(function*(){if(d.trav>=d.items.length)return{value:null,done:!0};const o=d.items[d.trav];return d.trav++,{value:(u=o,function ep(u,d){return Vu(u,d)}(u,Fx)),done:!1};var u})()}}class JN extends ru{constructor(d){super(),this.nextFn=d}summary(){return"Function call"}next(){var d=this;return(0,ns.Z)(function*(){try{return d.nextFn()}catch(o){throw o.message=`Error thrown while iterating through a dataset: ${o.message}`,o}})()}}class y1 extends ru{constructor(d){super(),this.upstream=d,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.lastRead.then(()=>d.serialNext()),d.lastRead})()}serialNext(){var d=this;return(0,ns.Z)(function*(){return d.upstream.next()})()}}class v1 extends ru{constructor(d,o){super(),this.upstream=d,this.maxCount=o,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.lastRead.then(()=>d.serialNext()),d.lastRead})()}serialNext(){var d=this;return(0,ns.Z)(function*(){for(;d.count++<d.maxCount;){const o=yield d.upstream.next();if(o.done)return o;l.B90(o.value)}return d.upstream.next()})()}}class Wc extends ru{constructor(d,o){super(),this.upstream=d,this.maxCount=o,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var d=this;return(0,ns.Z)(function*(){return d.count++>=d.maxCount?{value:null,done:!0}:d.upstream.next()})()}}class b1 extends ru{constructor(d,o,p=!0){super(),this.upstream=d,this.batchSize=o,this.enableSmallLastBatch=p,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.lastRead.then(()=>d.serialNext()),d.lastRead})()}serialNext(){var d=this;return(0,ns.Z)(function*(){const o=[];for(;o.length<d.batchSize;){const p=yield d.upstream.next();if(p.done)return d.enableSmallLastBatch&&o.length>0?{value:o,done:!1}:{value:null,done:!0};o.push(p.value)}return{value:o,done:!1}})()}}class qN extends ru{constructor(d,o){super(),this.upstream=d,this.predicate=o,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.lastRead.then(()=>d.serialNext()),d.lastRead})()}serialNext(){var d=this;return(0,ns.Z)(function*(){for(;;){const o=yield d.upstream.next();if(o.done||d.predicate(o.value))return o;l.B90(o.value)}})()}}class Vx extends ru{constructor(d,o){super(),this.upstream=d,this.transform=o}summary(){return`${this.upstream.summary()} -> Map`}next(){var d=this;return(0,ns.Z)(function*(){const o=yield d.upstream.next();if(o.done)return{value:null,done:!0};const p=l.piX.getTensorsInContainer(o.value),m=d.transform(o.value),x=l.piX.getTensorsInContainer(m);for(const R of p)l.piX.isTensorInList(R,x)||R.dispose();return{value:m,done:!1}})()}}class nh extends ru{constructor(d,o){super(),this.upstream=d,this.handler=o,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.lastRead.then(()=>d.serialNext()),d.lastRead})()}serialNext(){var d=this;return(0,ns.Z)(function*(){for(;;)try{return yield d.upstream.next()}catch(o){if(!d.handler(o))return{value:null,done:!0}}})()}}class Iv extends ru{constructor(d,o){super(),this.upstream=d,this.transform=o}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var d=this;return(0,ns.Z)(function*(){const o=yield d.upstream.next();if(o.done)return{value:null,done:!0};const p=l.piX.getTensorsInContainer(o.value),m=yield d.transform(o.value),x=l.piX.getTensorsInContainer(m);for(const R of p)l.piX.isTensorInList(R,x)||R.dispose();return{value:m,done:!1}})()}}class Ux extends ru{constructor(){super(),this.outputQueue=new Lx,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.lastRead.then(()=>d.serialNext()),d.lastRead})()}serialNext(){var d=this;return(0,ns.Z)(function*(){for(;0===d.outputQueue.length();)if(!(yield d.pump()))return{value:null,done:!0};return{value:d.outputQueue.shift(),done:!1}})()}}class eM extends Ux{constructor(d,o){super(),this.upstream=d,this.transform=o}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var d=this;return(0,ns.Z)(function*(){const o=yield d.upstream.next();if(o.done)return!1;const p=l.piX.getTensorsInContainer(o.value),m=d.transform(o.value),x=l.piX.getTensorsInContainer(m);d.outputQueue.pushAll(m);for(const R of p)l.piX.isTensorInList(R,x)||R.dispose();return!0})()}}class x1 extends ru{constructor(d,o){super(),this.baseErrorHandler=o,this.lastRead=null,this.iterator=null,this.moreIterators=d}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.readFromChain(d.lastRead),d.lastRead})()}readFromChain(d){var o=this;return(0,ns.Z)(function*(){if(yield d,null==o.iterator){const m=yield o.moreIterators.next();if(m.done)return{value:null,done:!0};o.iterator=m.value,null!=o.baseErrorHandler&&(o.iterator=o.iterator.handleErrors(o.baseErrorHandler))}const p=yield o.iterator.next();return p.done?(o.iterator=null,o.readFromChain(d)):p})()}}var Vp=function(u){return u[u.FAIL=0]="FAIL",u[u.SHORTEST=1]="SHORTEST",u[u.LONGEST=2]="LONGEST",u}(Vp||{});class Rr extends ru{constructor(d,o=Vp.FAIL){super(),this.iterators=d,this.mismatchMode=o,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}nextState(d){var o=this;return(0,ns.Z)(function*(){yield d;let p=0,m=0;const R=yield th(o.iterators,function x($){return $ instanceof ru?{value:$.next().then(ce=>(p++,ce.done&&m++,ce.value)),recurse:!1}:{value:null,recurse:!0}});if(p===m)return{value:null,done:!0};if(m>0)switch(o.mismatchMode){case Vp.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${o.count}.`);case Vp.SHORTEST:return{value:null,done:!0}}return o.count++,{value:R,done:!1}})()}next(){var d=this;return(0,ns.Z)(function*(){return d.currentPromise=d.nextState(d.currentPromise),d.currentPromise})()}}class zx extends ru{constructor(d,o){super(),this.upstream=d,this.bufferSize=o,this.buffer=new iT(o)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const d=this.upstream.next();this.buffer.push(d)}}next(){return this.refill(),this.buffer.shift()}}class aT extends zx{constructor(d,o,p){super(d,o),this.upstream=d,this.windowSize=o,this.upstreamExhausted=!1,this.random=Zu.alea(p||l.D5U.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var d=this;return(0,ns.Z)(function*(){return d.lastRead=d.lastRead.then(()=>d.serialNext()),d.lastRead})()}randomInt(d){return Math.floor(this.random()*d)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var d=this;return(0,ns.Z)(function*(){for(d.upstreamExhausted||d.refill();!d.buffer.isEmpty();){const o=d.chooseIndex(),p=yield d.buffer.shuffleExcise(o);if(!p.done)return d.refill(),p;d.upstreamExhausted=!0}return{value:null,done:!0}})()}}let Tv=(()=>{class u{constructor(){this.size=null}batch(o,p=!0){const m=this;let x;return l.D5U.assert(o>0,()=>`batchSize needs to be positive, but it is\n      ${o}`),x=this.size===1/0||null==this.size?this.size:p?Math.ceil(this.size/o):Math.floor(this.size/o),Gs((0,ns.Z)(function*(){return(yield m.iterator()).columnMajorBatch(o,p,cT)}),x)}concatenate(o){const p=this;let m;return m=this.size===1/0||o.size===1/0?1/0:null!=this.size&&null!=o.size?this.size+o.size:null,Gs((0,ns.Z)(function*(){return(yield p.iterator()).concatenate(yield o.iterator())}),m)}filter(o){const p=this;let m;return m=this.size===1/0?1/0:null,Gs((0,ns.Z)(function*(){return(yield p.iterator()).filter(x=>l.lub(()=>o(x)))}),m)}forEachAsync(o){var p=this;return(0,ns.Z)(function*(){return(yield p.iterator()).forEachAsync(o)})()}map(o){const p=this;return Gs((0,ns.Z)(function*(){return(yield p.iterator()).map(m=>l.lub(()=>o(m)))}),this.size)}mapAsync(o){const p=this;return Gs((0,ns.Z)(function*(){return(yield p.iterator()).mapAsync(o)}),this.size)}prefetch(o){if(null==o)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const p=this;return Gs((0,ns.Z)(function*(){return(yield p.iterator()).prefetch(o)}),this.size)}repeat(o){const p=this;let m;return m=null!=this.size&&o>0?this.size*o:0===o?0:null!=this.size&&(void 0===o||o<0)?1/0:null,Gs((0,ns.Z)(function*(){return function Bx(u,d){return new x1(u,d)}(Cy((0,ns.Z)(function*(){return{value:yield p.iterator(),done:!1}})).take(o))}),m)}skip(o){const p=this;let m;return m=null!=this.size&&o>=0&&this.size>=o?this.size-o:null!=this.size&&(this.size<o||void 0===o||o<0)?0:null,Gs((0,ns.Z)(function*(){return(yield p.iterator()).skip(o)}),m)}shuffle(o,p,m=!0){if(null==o||o<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const x=this,R=Zu.alea(p||l.D5U.now().toString());return Gs((0,ns.Z)(function*(){let $=R.int32();return m&&($+=R.int32()),(yield x.iterator()).shuffle(o,$.toString())}),this.size)}take(o){const p=this;let m;return m=null!=this.size&&this.size>o?o:null!=this.size&&this.size<=o?this.size:null,Gs((0,ns.Z)(function*(){return(yield p.iterator()).take(o)}),m)}toArray(){var o=this;return(0,ns.Z)(function*(){if(o.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield o.iterator()).toArray()})()}toArrayForTest(){var o=this;return(0,ns.Z)(function*(){if(o.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield o.iterator()).toArrayForTest()})()}}return u.MAX_BUFFER_SIZE=1e4,u})();function Gs(u,d=null){return new class extends Tv{constructor(){super(...arguments),this.size=d}iterator(){return(0,ns.Z)(function*(){return u()})()}}}function lT(u){return Gs((0,ns.Z)(function*(){return $x(u)}),u.length)}function Wx(u){if(!np(u))throw new Error("The argument to zip() must be an object or array.");let d;if(Array.isArray(u))for(let o=0;o<u.length;o++)d=null==d?u[o].size:Math.min(d,u[o].size);else if(u instanceof Object)for(const o in u)d=null==d?u[o].size:Math.min(d,u[o].size);return Gs((0,ns.Z)(function*(){return function _1(u,d=Vp.FAIL){return new Rr(u,d)}(yield th(u,p=>{if(p instanceof Tv)return{value:p.iterator(),recurse:!1};if(np(p))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),Vp.SHORTEST)}),d)}function cT(u){return null===u?null:function Sv(u){return null==u||function wm(u){return null===u||"object"!=typeof u&&"function"!=typeof u}(u)||Array.isArray(u)||"object"==typeof u&&u instanceof l.esB||l.D5U.isTypedArray(u)}(u[0])?{value:uT(u),recurse:!1}:{value:null,recurse:!0}}function uT(u){if(0===u.length)throw new Error("Can't make a batch of zero elements.");return u[0]instanceof l.esB?l.knu(u):l.XeE(u)}class Av extends Tv{constructor(d){super(),this.input=d}iterator(){var d=this;return(0,ns.Z)(function*(){return(yield d.input.iterator()).decodeUTF8().split("\n").map(x=>(x.endsWith("\r")&&(x=x.slice(0,-1)),x))})()}}const $g=Symbol("out"),w1=Symbol("field"),Dy=Symbol("quote"),kv=Symbol("quoteafterquote"),C1=Symbol("quoteinquote");class E1 extends Tv{columnNames(){var d=this;return(0,ns.Z)(function*(){return d.columnNamesValidated||(yield d.setColumnNames()),d.configuredColumnsOnly?Object.keys(d.columnConfigs):d.fullColumnNames})()}setColumnNames(){var d=this;return(0,ns.Z)(function*(){const o=yield d.maybeReadHeaderLine();if(!d.fullColumnNames&&!o)throw new Error("Column names must be provided if there is no header line.");d.fullColumnNames&&o&&l.D5U.assert(o.length===d.fullColumnNames.length,()=>"The length of provided columnNames ("+d.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+o.length.toString()+")."),d.fullColumnNames||(d.fullColumnNames=o);const p=d.fullColumnNames.reduce((x,R)=>(x[R]=x[R]+1||1,x),{}),m=Object.keys(p).filter(x=>p[x]>1);if(l.D5U.assert(0===m.length,()=>"Duplicate column names found: "+m.toString()),d.columnConfigs)for(const x of Object.keys(d.columnConfigs))if(-1===d.fullColumnNames.indexOf(x))throw new Error('The key "'+x+'" provided in columnConfigs does not match any of the column names ('+d.fullColumnNames.toString()+").");d.columnNamesValidated=!0})()}maybeReadHeaderLine(){var d=this;return(0,ns.Z)(function*(){if(d.hasHeader){const p=yield(yield d.base.iterator()).next();if(p.done)throw new Error("No data was found for CSV parsing.");return d.parseRow(p.value,!1)}return null})()}constructor(d,o){super(),this.input=d,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Av(d),o||(o={}),this.hasHeader=!1!==o.hasHeader,this.fullColumnNames=o.columnNames,this.columnConfigs=o.columnConfigs,this.configuredColumnsOnly=o.configuredColumnsOnly,o.delimWhitespace?(l.D5U.assert(null==o.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=o.delimiter?o.delimiter:","}iterator(){var d=this;return(0,ns.Z)(function*(){d.columnNamesValidated||(yield d.setColumnNames());let o=yield d.base.iterator();return d.hasHeader&&(o=o.skip(1)),o.map(p=>d.makeDataElement(p))})()}makeDataElement(d){const o=this.parseRow(d),p={},m={};for(let x=0;x<this.fullColumnNames.length;x++){const R=this.fullColumnNames[x],$=this.columnConfigs?this.columnConfigs[R]:null;if(!this.configuredColumnsOnly||$){const j=o[x];let ce=null;if(""===j)if($&&void 0!==$.default)ce=$.default;else{if($&&($.required||$.isLabel))throw new Error(`Required column ${R} is empty in this line: ${d}`);ce=void 0}else{const fe=Number(j);if(isNaN(fe))ce=$&&"bool"===$.dtype?this.getBoolean(j):j;else if($&&$.dtype)switch($.dtype){case"float32":default:ce=fe;break;case"int32":ce=Math.floor(fe);break;case"bool":ce=this.getBoolean(j)}else ce=fe}$&&$.isLabel?m[R]=ce:p[R]=ce}}return 0===Object.keys(m).length?p:{xs:p,ys:m}}getBoolean(d){return"1"===d||"true"===d.toLowerCase()?1:0}parseRow(d,o=!0){const p=[];let m=0;const x=d.length;let R=$g;for(let $=0;$<x;$++)switch(R){case $g:switch(d.charAt($)){case'"':m=$+1,R=Dy;break;case this.delimiter:if(m=$+1," "===this.delimiter&&this.delimWhitespace)break;p.push(""),R=$g;break;default:R=w1,m=$}break;case w1:d.charAt($)===this.delimiter&&(p.push(d.substring(m,$)),R=$g,m=$+1);break;case Dy:'"'===d.charAt($)&&(R=kv);break;case kv:switch(d.charAt($)){case this.delimiter:p.push(d.substring(m,$-1)),R=$g,m=$+1;break;case'"':R=Dy;break;default:R=C1}break;case C1:'"'===d.charAt($)&&(R=Dy)}if(p.push(R===kv?d.substring(m,x-1):d.substring(m)),o&&p.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${p}`);return p}}class Hx extends ru{constructor(d){super(),this.microphoneConfig=d,this.isClosed=!1,this.fftSize=d.fftSize||1024;const o=Math.log2(this.fftSize);if(this.fftSize<0||o<4||o>14||!Number.isInteger(o))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=d.numFramesPerSpectrogram||43,this.sampleRateHz=d.sampleRateHz,this.columnTruncateLength=d.columnTruncateLength||this.fftSize,this.audioTrackConstraints=d.audioTrackConstraints,this.smoothingTimeConstant=d.smoothingTimeConstant||0,this.includeSpectrogram=!1!==d.includeSpectrogram,this.includeWaveform=!0===d.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static create(d={}){return(0,ns.Z)(function*(){if(!(0,l.OBj)().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const o=new Hx(d);return yield o.start(),o})()}start(){var d=this;return(0,ns.Z)(function*(){try{d.stream=yield navigator.mediaDevices.getUserMedia({audio:null==d.audioTrackConstraints||d.audioTrackConstraints,video:!1})}catch(m){throw new Error(`Error thrown while initializing video stream: ${m.message}`)}if(!d.stream)throw new Error("Could not obtain audio from microphone.");const o=window.AudioContext||window.webkitAudioContext;if(d.audioContext=new o,d.sampleRateHz){if(d.audioContext.sampleRate!==d.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${d.sampleRateHz}; Actual: ${d.audioContext.sampleRate}`)}else d.sampleRateHz=d.audioContext.sampleRate;const p=d.audioContext.createMediaStreamSource(d.stream);d.analyser=d.audioContext.createAnalyser(),d.analyser.fftSize=2*d.fftSize,d.analyser.smoothingTimeConstant=d.smoothingTimeConstant,p.connect(d.analyser),d.freqData=new Float32Array(d.fftSize),d.timeData=new Float32Array(d.fftSize)})()}next(){var d=this;return(0,ns.Z)(function*(){if(d.isClosed)return{value:null,done:!0};let o,p;const m=yield d.getAudioData();if(d.includeSpectrogram){const x=d.flattenQueue(m.freqDataQueue);o=d.getTensorFromAudioDataArray(x,[d.numFrames,d.columnTruncateLength,1])}if(d.includeWaveform){const x=d.flattenQueue(m.timeDataQueue);p=d.getTensorFromAudioDataArray(x,[d.numFrames*d.fftSize,1])}return{value:{spectrogram:o,waveform:p},done:!1}})()}capture(){var d=this;return(0,ns.Z)(function*(){return(yield d.next()).value})()}getAudioData(){var d=this;return(0,ns.Z)(function*(){const o=[],p=[];let m=0;return new Promise(x=>{const R=setInterval(()=>{d.includeSpectrogram&&(d.analyser.getFloatFrequencyData(d.freqData),d.freqData[0]===-1/0&&x({freqDataQueue:o,timeDataQueue:p}),o.push(d.freqData.slice(0,d.columnTruncateLength))),d.includeWaveform&&(d.analyser.getFloatTimeDomainData(d.timeData),p.push(d.timeData.slice())),++m===d.numFrames&&(clearInterval(R),x({freqDataQueue:o,timeDataQueue:p}))},d.fftSize/d.sampleRateHz*1e3)})})()}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(d){const o=d[0].length,p=new Float32Array(d.length*o);return d.forEach((m,x)=>p.set(m,x*o)),p}getTensorFromAudioDataArray(d,o){const p=new Float32Array(l.D5U.sizeFromShape(o));return p.set(d,p.length-d.length),(0,l.XeE)(p,o)}}class Ov extends ru{constructor(d,o){if(super(),this.webcamVideoElement=d,this.webcamConfig=o,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=(0,l.RRF)([0],"int32"),this.webcamConfig.centerCrop){const p=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,m=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,x=(1-p)/2,R=(1-m)/2;this.cropBox=(0,l.odF)([R,x,m+R,x+p],[1,4])}else this.cropBox=(0,l.odF)([0,0,1,1],[1,4])}summary(){return"webcam"}static create(d,o={}){return(0,ns.Z)(function*(){if(!(0,l.OBj)().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!d){if(d=document.createElement("video"),!o.resizeWidth||!o.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");d.width=o.resizeWidth,d.height=o.resizeHeight}const p=new Ov(d,o);return yield p.start(),p})()}start(){var d=this;return(0,ns.Z)(function*(){d.webcamConfig.facingMode&&l.D5U.assert("user"===d.webcamConfig.facingMode||"environment"===d.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${d.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{d.stream=yield navigator.mediaDevices.getUserMedia({video:{deviceId:d.webcamConfig.deviceId,facingMode:d.webcamConfig.facingMode?d.webcamConfig.facingMode:"user",width:d.webcamVideoElement.width,height:d.webcamVideoElement.height}})}catch(o){throw o.message=`Error thrown while initializing video stream: ${o.message}`,o}if(!d.stream)throw new Error("Could not obtain video from webcam.");try{d.webcamVideoElement.srcObject=d.stream}catch(o){console.log(o),d.webcamVideoElement.src=window.URL.createObjectURL(d.stream)}return d.webcamVideoElement.play(),d.isClosed=!1,new Promise(o=>{d.webcamVideoElement.onloadedmetadata=()=>{o()}})})()}next(){var d=this;return(0,ns.Z)(function*(){if(d.isClosed)return{value:null,done:!0};let o;try{o=l.Xhn.fromPixels(d.webcamVideoElement)}catch(p){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(p)}`)}if(!d.resize)return{value:o,done:!1};try{return{value:d.cropAndResizeFrame(o),done:!1}}catch(p){throw new Error(`Error thrown cropping the video: ${p.message}`)}finally{o.dispose()}})()}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(d){return(0,l.lub)(()=>{const o=(0,l.dt4)((0,l.pju)(d,"float32"),0);let p;return p=l.image.cropAndResize(o,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear"),(0,l.XLQ)(p,p.shape.slice(1))})}capture(){var d=this;return(0,ns.Z)(function*(){return(yield d.next()).value})()}stop(){this.stream.getTracks().forEach(o=>o.stop());try{this.webcamVideoElement.srcObject=null}catch(o){console.log(o),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class Cm{}class sp extends ru{split(d){return new Bg(this,d)}}class Bg extends sp{constructor(d,o){super(),this.upstream=d,this.impl=new dT(d,o)}summary(){return this.impl.summary()}next(){var d=this;return(0,ns.Z)(function*(){return d.impl.next()})()}}class dT extends Ux{constructor(d,o){super(),this.upstream=d,this.separator=o,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}pump(){var d=this;return(0,ns.Z)(function*(){const o=yield d.upstream.next();if(o.done)return""!==d.carryover&&(d.outputQueue.push(d.carryover),d.carryover="",!0);const p=o.value.split(d.separator);p[0]=d.carryover+p[0];for(const m of p.slice(0,-1))d.outputQueue.push(m);return d.carryover=p[p.length-1],!0})()}}class hT extends ru{decodeUTF8(){return new D1(this)}}class D1 extends sp{constructor(d){super(),this.upstream=d,this.impl=new S1(d)}summary(){return this.impl.summary()}next(){var d=this;return(0,ns.Z)(function*(){return d.impl.next()})()}}class S1 extends Ux{constructor(d){if(super(),this.upstream=d,(0,l.OBj)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:o}=h(1601);this.decoder=new o("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}pump(){var d=this;return(0,ns.Z)(function*(){const o=yield d.upstream.next();let p,m;return!o.done&&(p=o.value,m=(0,l.OBj)().get("IS_BROWSER")?d.decoder.decode(p,{stream:!0}):d.decoder.write(Buffer.from(p.buffer)),d.outputQueue.push(m),!0)})()}}class Rv extends hT{constructor(d,o={}){super(),this.file=d,this.options=o,l.D5U.assert(d instanceof Uint8Array||!!(0,l.OBj)().get("IS_BROWSER")&&(d instanceof File||d instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=o.offset||0,this.chunkSize=o.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}next(){var d=this;return(0,ns.Z)(function*(){return d.offset>=(d.file instanceof Uint8Array?d.file.byteLength:d.file.size)?{value:null,done:!0}:{value:yield new Promise((p,m)=>{const x=d.offset+d.chunkSize;if(d.file instanceof Uint8Array)p(new Uint8Array(d.file.slice(d.offset,x)));else{const R=new FileReader;R.onload=j=>{let ce=R.result;if(ce instanceof ArrayBuffer&&(ce=new Uint8Array(ce)),!(ce instanceof Uint8Array))return m(new TypeError("FileReader returned unknown type."));p(ce)},R.onabort=j=>m(new Error("Aborted")),R.onerror=j=>m(new Error(j.type));const $=d.file.slice(d.offset,x);R.readAsArrayBuffer($)}d.offset=x}),done:!1}})()}}var Vg;function jx(u){return"string"==typeof u&&"file://"===u.slice(0,7)}class T1 extends Cm{constructor(d,o={}){super(),this.input=d,this.options=o}iterator(){var d=this;return(0,ns.Z)(function*(){if(jx(d.input)&&(0,l.OBj)().get("IS_NODE")){const o=h(7792);d.input=o.readFileSync(d.input.slice(7))}return new Rv(d.input,d.options)})()}}class A1 extends Cm{constructor(d,o={}){super(),this.url=d,this.fileOptions=o}iterator(){var d=this;return(0,ns.Z)(function*(){return jx(d.url)?new T1(d.url,d.fileOptions).iterator():function Nv(u){return(Vg=Vg||(0,ns.Z)(function*(d,o={},p){let m,x;"string"==typeof d?m=d:(m=d.url,x=(u=>({method:u.method,headers:u.headers,body:u.body,mode:u.mode,credentials:u.credentials,cache:u.cache,redirect:u.redirect,referrer:u.referrer,integrity:u.integrity}))(d));const R=yield(p||l.D5U.fetch)(m,x);if(R.ok){const $=new Uint8Array(yield R.arrayBuffer());return new Rv($,o)}throw new Error(R.statusText)})).apply(this,arguments)}(d.url,d.fileOptions)})()}}var k1,O1;function R1(u,d={}){return new E1(new A1(u),d)}function tM(u){const d=Cy(u);return Gs((0,ns.Z)(function*(){return d}))}function pT(u){return Gs((0,ns.Z)(function*(){const d=yield u();return Cy(()=>d.next())}))}function nM(u,d){return(k1=k1||(0,ns.Z)(function*(o,p){return Ov.create(o,p)})).apply(this,arguments)}function sM(u){return(O1=O1||(0,ns.Z)(function*(d){return Hx.create(d)})).apply(this,arguments)}const Gx="4.11.0";var ni=h(4050);const rM=l.GDt.whereImpl;let Sy=(()=>{class u extends l.Zuw{nextDataId(){return u.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new l.JLz(this,(0,l.SRH)())}write(o,p,m){this.firstUse&&(this.firstUse=!1,(0,l.OBj)().get("IS_NODE")&&l.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const x={id:this.nextDataId()};return this.data.set(x,{values:o,dtype:m,refCount:1}),x}makeTensorInfo(o,p,m){let x;if("string"===p&&null!=m&&m.length>0&&l.D5U.isString(m[0])){const R=m.map($=>l.D5U.encodeString($));x=this.write(R,o,p)}else x=this.write(m,o,p);return{dataId:x,shape:o,dtype:p}}refCount(o){return this.data.has(o)?this.data.get(o).refCount:0}incRef(o){this.data.get(o).refCount++}decRef(o){this.data.has(o)&&this.data.get(o).refCount--}move(o,p,m,x,R){this.data.set(o,{values:p,dtype:x,refCount:R})}numDataIds(){return this.data.numDataIds()}read(o){var p=this;return(0,ns.Z)(function*(){return p.readSync(o)})()}readSync(o){const{dtype:p,complexTensorInfos:m}=this.data.get(o);if("complex64"===p){const x=this.readSync(m.real.dataId),R=this.readSync(m.imag.dataId);return l.backend_util.mergeRealAndImagArrays(x,R)}return l.D5U.convertBackendValuesAndArrayBuffer(this.data.get(o).values,p)}bufferSync(o){const p=this.readSync(o.dataId);if("string"===o.dtype)try{const m=p.map(x=>l.D5U.decodeString(x));return(0,l.f3b)(o.shape,o.dtype,m)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,l.f3b)(o.shape,o.dtype,p)}makeOutput(o,p,m){return(0,l.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(p,m,o),this)}disposeData(o,p=!1){if(this.data.has(o)){if(this.data.get(o).refCount--,!p&&this.data.get(o).refCount>0)return!1;const{complexTensorInfos:m}=this.data.get(o);null!=m&&(this.disposeData(m.real.dataId,!0),this.disposeData(m.imag.dataId,!0)),this.data.delete(o)}return!0}disposeIntermediateTensorInfo(o){this.disposeData(o.dataId)}time(o){return(0,ns.Z)(function*(){const p=l.D5U.now();return o(),{kernelMs:l.D5U.now()-p}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(o){(0,ni.H)([o],"where");const p=this.readSync(o.dataId);return rM(o.shape,p)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return u.nextDataId=0,u})();var iM=h(8669);const Kx="4.11.0";(0,l.jqO)("cpu",()=>new Sy,1);var Qa=h(1832);const N1=(0,Qa.A)(l.SX0,u=>u>=0?u:Math.exp(u)-1),M1={kernelName:l.SX0,backendName:"cpu",kernelFunc:N1};var Up=h(6781);function zi(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{alpha:x}=p;(0,ni.H)([m],"leakyRelu");const R=l.D5U.sizeFromShape(m.shape),$=o.data.get(m.dataId).values,j=l.D5U.getTypedArrayFromDType("float32",R);for(let ce=0;ce<$.length;ce++)j[ce]=$[ce]<0?x*$[ce]:$[ce];return o.makeTensorInfo(m.shape,"float32",j)}const Un={kernelName:l.J$2,backendName:"cpu",kernelFunc:zi};var If=h(9450);const lt=(0,If.b)((u,d)=>u<0?d*u:u);function Tf(u){const{inputs:d,backend:o}=u,{x:p,alpha:m}=d;(0,ni.H)([p,m],"prelu");const x=o.data.get(p.dataId).values,R=o.data.get(m.dataId).values,[$,j]=lt(p.shape,m.shape,x,R,"float32");return o.makeTensorInfo(j,"float32",$)}const fT={kernelName:l.o0g,backendName:"cpu",kernelFunc:Tf},Iy=(0,Qa.A)(l.qkr,u=>Math.max(0,u)),Ug={kernelName:l.qkr,backendName:"cpu",kernelFunc:Iy},Mv=(0,Qa.A)(l.SbG,u=>Math.min(Math.max(0,u),6)),Ty={kernelName:l.SbG,backendName:"cpu",kernelFunc:Mv};var Xx=h(2250);function zg(u,d,o,p,m){if("linear"===o)return(0,Up.y)({inputs:{x:d},backend:u});if("relu"===o)return Iy({inputs:{x:d},backend:u});if("elu"===o)return N1({inputs:{x:d},backend:u});if("relu6"===o)return Mv({inputs:{x:d},backend:u});if("prelu"===o)return Tf({inputs:{x:d,alpha:p},backend:u});if("leakyrelu"===o)return zi({inputs:{x:d},backend:u,attrs:{alpha:m}});if("sigmoid"===o)return(0,Xx.XD)({inputs:{x:d},backend:u});throw new Error(`Activation ${o} has not been implemented for the CPU backend.`)}var Af=h(6931);function Ja(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{shape:x}=p,R=l.D5U.sizeFromShape(m.shape),$=l.D5U.inferFromImplicitShape(x,R),j=l.D5U.sizeFromShape($);l.D5U.assert(R===j,()=>`The new shape (${$}) has ${j} elements and the old shape (${m.shape}) has ${R} elements. The new shape and old shape must have the same number of elements.`),o.incRef(m.dataId);const ce=o.data.get(m.dataId);if(null!=ce.complexTensorInfos){const je=ce.complexTensorInfos.imag;ce.complexTensorInfos.real.shape=$,je.shape=$}return{dataId:m.dataId,shape:$,dtype:m.dtype}}const P1={kernelName:l.HZH,backendName:"cpu",kernelFunc:Ja};function Pv(u){const{inputs:d,backend:o,attrs:p}=u,{a:m,b:x}=d,{transposeA:R,transposeB:$}=p;(0,ni.H)([m,x],"matMul");const j=m.shape.length,ce=x.shape.length,fe=R?m.shape[j-2]:m.shape[j-1],je=$?x.shape[ce-1]:x.shape[ce-2],ze=R?m.shape[j-1]:m.shape[j-2],nt=$?x.shape[ce-2]:x.shape[ce-1],Rt=m.shape.slice(0,-2),bt=x.shape.slice(0,-2),xt=l.D5U.sizeFromShape(Rt),Pt=l.D5U.sizeFromShape(bt),Ut=l.Jyw.assertAndGetBroadcastShape(m.shape.slice(0,-2),x.shape.slice(0,-2)).concat([ze,nt]);l.D5U.assert(fe===je,()=>`Error in matMul: inner shapes (${fe}) and (${je}) of Tensors with shapes ${m.shape} and ${x.shape} and transposeA=${R} and transposeB=${$} must match.`);const sn=$?[Pt,nt,je]:[Pt,je,nt],_n=Ja({inputs:{x:m},backend:o,attrs:{shape:R?[xt,fe,ze]:[xt,ze,fe]}}),Cn=Ja({inputs:{x},backend:o,attrs:{shape:sn}}),Bn=R?_n.shape[1]:_n.shape[2],Vn=R?_n.shape[2]:_n.shape[1],es=$?Cn.shape[1]:Cn.shape[2],ls=Math.max(xt,Pt),Cs=o.data.get(_n.dataId).values,rs=o.data.get(Cn.dataId).values,hs=l.D5U.computeStrides(_n.shape),ms=l.D5U.computeStrides(Cn.shape),[_s,Ds,ds]=R?[hs[0],1,hs[1]]:[hs[0],hs[1],1],[ys,Ns,Ls]=$?[1,ms[1],ms[0]]:[ms[1],1,ms[0]],nr=Vn*es,Vs=(0,l.f3b)([ls,Vn,es],_n.dtype),gr=Vs.values,rr=o.blockSize;for(let Lr=0;Lr<ls;Lr++){const oi=Lr%xt,bi=Lr%Pt;for(let fi=0;fi<Vn;fi+=rr){const qi=Math.min(fi+rr,Vn);for(let po=0;po<es;po+=rr){const Ua=Math.min(po+rr,es);for(let dl=0;dl<Bn;dl+=rr){const xc=Math.min(dl+rr,Bn);for(let Sl=fi;Sl<qi;Sl++)for(let qa=po;qa<Ua;qa++){let cc=0;for(let Il=dl;Il<xc;Il++)cc+=Cs[oi*_s+Sl*Ds+Il*ds]*rs[Il*ys+qa*Ns+bi*Ls];gr[Lr*nr+(Sl*es+qa)]+=cc}}}}}return o.disposeIntermediateTensorInfo(_n),o.disposeIntermediateTensorInfo(Cn),o.makeTensorInfo(Ut,Vs.dtype,Vs.values)}const mT={kernelName:l.XLW,backendName:"cpu",kernelFunc:Pv},_T={kernelName:l.usg,backendName:"cpu",kernelFunc:function gT(u){const{inputs:d,backend:o,attrs:p}=u,{a:m,b:x,bias:R,preluActivationWeights:$}=d,{transposeA:j,transposeB:ce,activation:fe,leakyreluAlpha:je}=p;let ze,nt,Rt;const bt=[];ze=Pv({inputs:{a:m,b:x},attrs:{transposeA:j,transposeB:ce},backend:o}),R&&(nt=(0,Af.IH)({inputs:{a:ze,b:R},backend:o}),bt.push(ze),ze=nt),fe&&(Rt=zg(o,ze,fe,$,je),bt.push(ze),ze=Rt);for(const Pt of bt)o.disposeIntermediateTensorInfo(Pt);return ze}};var F1=h(3777);const yT=(0,Qa.A)(l.VGw,u=>Math.acos(u)),vT={kernelName:l.VGw,backendName:"cpu",kernelFunc:yT},bT=(0,Qa.A)(l.SpW,u=>Math.acosh(u)),xT={kernelName:l.SpW,backendName:"cpu",kernelFunc:bT},$1={kernelName:l.Xze,backendName:"cpu",kernelFunc:function L1(u){const{inputs:d,backend:o}=u,p=d;(0,ni.H)(d,"addN");const m=p.map($=>o.data.get($.dataId).values),x=(0,l.f3b)(p[0].shape,p[0].dtype),R=x.values;for(let $=0;$<p.length;$++){const j=m[$];for(let ce=0;ce<R.length;ce++)R[ce]+=j[ce]}return o.makeTensorInfo(x.shape,x.dtype,x.values)}};var ud=h(1239);const Rd={kernelName:l.oT6,backendName:"cpu",kernelFunc:function wT(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x,keepDims:R}=p;(0,ni.H)(m,"all");const $=l.D5U.parseAxisParam(x,m.shape);let j=$;const ce=l.backend_util.getAxesPermutation(j,m.shape.length);let fe=m;null!=ce&&(fe=(0,ud.p)({inputs:{x:m},backend:o,attrs:{perm:ce}}),j=l.backend_util.getInnerMostAxes(j.length,m.shape.length)),l.backend_util.assertAxesAreInnerMostDims("all",j,fe.shape.length);const[je,ze]=l.backend_util.computeOutAndReduceShapes(fe.shape,j),nt=l.D5U.sizeFromShape(ze),Rt=l.D5U.makeZerosTypedArray(l.D5U.sizeFromShape(je),fe.dtype),bt=o.data.get(fe.dataId).values;for(let Pt=0;Pt<Rt.length;++Pt){const St=Pt*nt;let Ut=bt[St];for(let Ft=0;Ft<nt;++Ft)Ut=Ut&&bt[St+Ft];Rt[Pt]=Ut}null!=ce&&o.disposeIntermediateTensorInfo(fe);const xt=o.makeTensorInfo(je,fe.dtype,Rt);if(R){const St=Ja({inputs:{x:xt},backend:o,attrs:{shape:l.backend_util.expandShapeToKeepDim(je,$)}});return o.disposeIntermediateTensorInfo(xt),St}return xt}},ET={kernelName:l.IKK,backendName:"cpu",kernelFunc:function CT(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x,keepDims:R}=p;(0,ni.H)(m,"any");const $=l.D5U.parseAxisParam(x,m.shape);let j=$;const ce=l.backend_util.getAxesPermutation(j,m.shape.length);let fe=m;null!=ce&&(fe=(0,ud.p)({inputs:{x:m},backend:o,attrs:{perm:ce}}),j=l.backend_util.getInnerMostAxes(j.length,m.shape.length)),l.backend_util.assertAxesAreInnerMostDims("any",j,fe.shape.length);const[je,ze]=l.backend_util.computeOutAndReduceShapes(fe.shape,j),nt=l.D5U.sizeFromShape(ze),Rt=l.D5U.makeZerosTypedArray(l.D5U.sizeFromShape(je),fe.dtype),bt=o.data.get(fe.dataId).values;for(let Pt=0;Pt<Rt.length;++Pt){const St=Pt*nt;let Ut=bt[St];for(let Ft=0;Ft<nt;++Ft)Ut=Ut||bt[St+Ft];Rt[Pt]=Ut}null!=ce&&o.disposeIntermediateTensorInfo(fe);const xt=o.makeTensorInfo(je,fe.dtype,Rt);if(R){const St=Ja({inputs:{x:xt},backend:o,attrs:{shape:l.backend_util.expandShapeToKeepDim(je,$)}});return o.disposeIntermediateTensorInfo(xt),St}return xt}},Yx={kernelName:l.sJF,backendName:"cpu",kernelFunc:function oM(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x}=p;(0,ni.H)(m,"argMax");let R=l.D5U.parseAxisParam(x,m.shape);const $=l.backend_util.getAxesPermutation(R,m.shape.length);let j=m;const ce=[];null!=$&&(j=(0,ud.p)({inputs:{x:m},backend:o,attrs:{perm:$}}),ce.push(j),R=l.backend_util.getInnerMostAxes(R.length,j.shape.length)),R=[R[0]],l.backend_util.assertAxesAreInnerMostDims("argMax",R,j.shape.length);const[fe,je]=l.backend_util.computeOutAndReduceShapes(j.shape,R),ze=l.D5U.sizeFromShape(fe),nt=l.D5U.makeZerosTypedArray(ze,"int32"),Rt=l.D5U.sizeFromShape(je),bt=o.data.get(j.dataId).values;for(let xt=0;xt<nt.length;++xt){const Pt=xt*Rt;let St=bt[Pt],Ut=0;for(let Ft=0;Ft<Rt;++Ft){const sn=bt[Pt+Ft];sn>St&&(St=sn,Ut=Ft)}nt[xt]=Ut}return ce.forEach(xt=>o.disposeIntermediateTensorInfo(xt)),o.makeTensorInfo(fe,"int32",nt)}},DT={kernelName:l.aJk,backendName:"cpu",kernelFunc:function B1(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x}=p;(0,ni.H)(m,"argMin");let R=l.D5U.parseAxisParam(x,m.shape);const $=l.backend_util.getAxesPermutation(R,m.shape.length);let j=m;const ce=[];null!=$&&(j=(0,ud.p)({inputs:{x:m},backend:o,attrs:{perm:$}}),ce.push(j),R=l.backend_util.getInnerMostAxes(R.length,j.shape.length)),R=[R[0]],l.backend_util.assertAxesAreInnerMostDims("argMin",R,j.shape.length);const[fe,je]=l.backend_util.computeOutAndReduceShapes(j.shape,R),ze=l.D5U.sizeFromShape(fe),nt=l.D5U.makeZerosTypedArray(ze,"int32"),Rt=l.D5U.sizeFromShape(je),bt=o.data.get(j.dataId).values;for(let xt=0;xt<nt.length;++xt){const Pt=xt*Rt;let St=bt[Pt],Ut=0;for(let Ft=0;Ft<Rt;++Ft){const sn=bt[Pt+Ft];sn<St&&(St=sn,Ut=Ft)}nt[xt]=Ut}return ce.forEach(xt=>o.disposeIntermediateTensorInfo(xt)),o.makeTensorInfo(fe,"int32",nt)}},ST=(0,Qa.A)(l.M2y,u=>Math.asin(u)),IT={kernelName:l.M2y,backendName:"cpu",kernelFunc:ST},V1=(0,Qa.A)(l.qw7,u=>Math.asinh(u)),TT={kernelName:l.qw7,backendName:"cpu",kernelFunc:V1},AT=(0,Qa.A)(l.jMg,u=>Math.atan(u)),Zx={kernelName:l.jMg,backendName:"cpu",kernelFunc:AT};var Wg=h(9642);const kT=(0,If.b)((u,d)=>Math.atan2(u,d)),OT=(0,Wg.j)(l.QCc,kT),RT={kernelName:l.QCc,backendName:"cpu",kernelFunc:OT},NT=(0,Qa.A)(l.Oyi,u=>Math.atanh(u)),rp={kernelName:l.Oyi,backendName:"cpu",kernelFunc:NT};function Ay(u,d,o,p,m,x){const R=m.strideHeight,$=m.strideWidth,j=m.dilationHeight,ce=m.dilationWidth,fe=m.effectiveFilterHeight,je=m.effectiveFilterWidth,ze=m.padInfo.top,nt=m.padInfo.left,Rt="max"===x?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,bt=(0,l.f3b)(m.outShape,o),xt=bt.values,Pt=m.outShape[1]*m.outShape[2]*m.outShape[3],St=m.outShape[2]*m.outShape[3],Ut=m.outShape[3];for(let Ft=0;Ft<m.batchSize;++Ft){const sn=Ft*Pt,_n=Ft*p[0];for(let Cn=0;Cn<m.inChannels;++Cn)for(let Bn=0;Bn<m.outHeight;++Bn){const Vn=Bn*R-ze,es=Math.max(0,Vn),ls=Math.min(m.inHeight,fe+Vn),Cs=sn+Bn*St;for(let rs=0;rs<m.outWidth;++rs){const hs=rs*$-nt,ms=Math.max(0,hs),_s=Math.min(m.inWidth,je+hs);let Ds=Rt,ds=0,ys=0;for(let Ls=es;Ls<ls;Ls+=j){const nr=_n+Ls*p[1];for(let Vs=ms;Vs<_s;Vs+=ce){const rr=u[nr+Vs*p[2]+Cn];"max"===x&&rr>Ds?Ds=rr:"avg"===x&&(ds+=rr,ys++)}if(isNaN(Ds))break}xt[Cs+rs*Ut+Cn]="avg"===x?ds/ys:Ds}}}return bt}function U1(u,d,o,p,m=!1,x=!1){const R=(0,l.f3b)(p.outShape,"int32"),$=p.strideHeight,j=p.strideWidth,ce=p.dilationHeight,fe=p.dilationWidth,je=p.effectiveFilterHeight,ze=p.effectiveFilterWidth,nt=p.padInfo.top,Rt=p.padInfo.left,bt=(0,l.f3b)(d,o,u);for(let xt=0;xt<p.batchSize;++xt)for(let Pt=0;Pt<p.inChannels;++Pt)for(let St=0;St<p.outHeight;++St){const Ut=St*$-nt;let Ft=Ut;for(;Ft<0;)Ft+=ce;const sn=Math.min(p.inHeight,je+Ut);for(let _n=0;_n<p.outWidth;++_n){const Cn=_n*j-Rt;let Bn=Cn;for(;Bn<0;)Bn+=fe;const Vn=Math.min(p.inWidth,ze+Cn);let es=Number.NEGATIVE_INFINITY,ls=-1;for(let Cs=Ft;Cs<sn;Cs+=ce){const rs=Cs-Ut;for(let hs=Bn;hs<Vn;hs+=fe){const ms=hs-Cn,_s=bt.get(xt,Cs,hs,Pt);_s>es&&(es=_s,ls=m?x?((xt*p.inHeight+Cs)*p.inWidth+hs)*p.inChannels+Pt:(Cs*p.inWidth+hs)*p.inChannels+Pt:rs*ze+ms)}}R.set(ls,xt,St,_n,Pt)}}return R}function Qx(u,d,o,p,m,x){const R=m.strideDepth,$=m.strideHeight,j=m.strideWidth,ce=m.dilationDepth,fe=m.dilationHeight,je=m.dilationWidth,ze=m.effectiveFilterDepth,nt=m.effectiveFilterHeight,Rt=m.effectiveFilterWidth,bt=m.padInfo.front,xt=m.padInfo.top,Pt=m.padInfo.left,St="max"===x?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Ut=(0,l.f3b)(m.outShape,o),Ft=Ut.values,sn=m.outShape[1]*m.outShape[2]*m.outShape[3]*m.outShape[4],_n=m.outShape[2]*m.outShape[3]*m.outShape[4],Cn=m.outShape[3]*m.outShape[4],Bn=m.outShape[4];for(let Vn=0;Vn<m.batchSize;++Vn){const es=Vn*sn,ls=Vn*p[0];for(let Cs=0;Cs<m.inChannels;++Cs)for(let rs=0;rs<m.outDepth;++rs){const hs=rs*R-bt;let ms=hs;for(;ms<0;)ms+=ce;const _s=Math.min(m.inDepth,ze+hs),Ds=es+rs*_n;for(let ds=0;ds<m.outHeight;++ds){const ys=ds*$-xt;let Ns=ys;for(;Ns<0;)Ns+=fe;const Ls=Math.min(m.inHeight,nt+ys),nr=Ds+ds*Cn;for(let Vs=0;Vs<m.outWidth;++Vs){const gr=Vs*j-Pt;let rr=gr;for(;rr<0;)rr+=je;const Lr=Math.min(m.inWidth,Rt+gr),oi=nr+Vs*Bn;let bi=St,fi=0,qi=0;for(let Ua=ms;Ua<_s;Ua+=ce){const dl=ls+Ua*p[1];for(let xc=Ns;xc<Ls;xc+=fe){const Sl=dl+xc*p[2];for(let qa=rr;qa<Lr;qa+=je){const Il=u[Sl+qa*p[3]+Cs];if("max"===x&&Il>bi?bi=Il:"avg"===x&&(fi+=Il,qi++),isNaN(bi))break}if(isNaN(bi))break}if(isNaN(bi))break}Ft[oi+Cs]="avg"===x?fi/Math.max(qi,1):bi}}}}return Ut}const W1={kernelName:l.JhU,backendName:"cpu",kernelFunc:function z1(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d;(0,ni.H)(m,"avgPool");const{filterSize:x,strides:R,pad:$,dimRoundingMode:j}=p;l.D5U.assert(l.backend_util.eitherStridesOrDilationsAreOne(R,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${R} and dilations '1'`);const fe=l.backend_util.computePool2DInfo(m.shape,x,R,1,$,j);let je;if(1===fe.filterWidth&&1===fe.filterHeight&&l.D5U.arraysEqual(fe.inShape,fe.outShape))je=(0,Up.y)({inputs:{x:m},backend:o});else{const ze=o.data.get(m.dataId).values,nt=l.D5U.computeStrides(m.shape),Rt=Ay(ze,0,m.dtype,nt,fe,"avg");je=o.makeTensorInfo(fe.outShape,m.dtype,Rt.values)}return je}},Jx={kernelName:l._k9,backendName:"cpu",kernelFunc:function Fv(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{filterSize:x,strides:R,pad:$,dimRoundingMode:j,dataFormat:ce}=p;(0,ni.H)(m,"avgPool3d");const fe=l.backend_util.computePool3DInfo(m.shape,x,R,1,$,j,ce),ze=Qx(o.data.get(m.dataId).values,0,m.dtype,l.D5U.computeStrides(m.shape),fe,"avg");return o.makeTensorInfo(ze.shape,"float32",ze.values)}},H1={kernelName:l.IMb,backendName:"cpu",kernelFunc:function aM(u){const{inputs:d,backend:o,attrs:p}=u,{dy:m,input:x}=d,{filterSize:R,strides:$,pad:j,dimRoundingMode:ce}=p;(0,ni.H)([m,x],"avgPool3DGrad");const fe=l.backend_util.computePool3DInfo(x.shape,R,$,1,j,ce),je=fe.strideDepth,ze=fe.strideHeight,nt=fe.strideWidth,Rt=fe.filterDepth,bt=fe.filterHeight,xt=fe.filterWidth,Pt=fe.dilationDepth,St=fe.dilationHeight,Ut=fe.dilationWidth,Ft=fe.effectiveFilterDepth,sn=fe.effectiveFilterHeight,_n=fe.effectiveFilterWidth,Cn=Ft-1-fe.padInfo.front,Bn=_n-1-fe.padInfo.left,Vn=sn-1-fe.padInfo.top,es=(0,l.f3b)(x.shape,"float32"),ls=1/(Rt*bt*xt),Cs=o.bufferSync(m);for(let rs=0;rs<fe.batchSize;++rs)for(let hs=0;hs<fe.inChannels;++hs)for(let ms=0;ms<fe.inDepth;++ms)for(let _s=0;_s<fe.inHeight;++_s)for(let Ds=0;Ds<fe.inWidth;++Ds){const ds=ms-Cn,ys=_s-Vn,Ns=Ds-Bn;let Ls=0;for(let nr=0;nr<Ft;nr+=Pt){const Vs=(ds+nr)/je;if(!(Vs<0||Vs>=fe.outDepth||Math.floor(Vs)!==Vs))for(let gr=0;gr<sn;gr+=St){const rr=(ys+gr)/ze;if(!(rr<0||rr>=fe.outHeight||Math.floor(rr)!==rr))for(let Lr=0;Lr<_n;Lr+=Ut){const oi=(Ns+Lr)/nt;oi<0||oi>=fe.outWidth||Math.floor(oi)!==oi||(Ls+=Cs.get(rs,Vs,rr,oi,hs))}}}es.set(Ls*ls,rs,ms,_s,Ds,hs)}return o.makeTensorInfo(es.shape,es.dtype,es.values)}},G1={kernelName:l.ROF,backendName:"cpu",kernelFunc:function j1(u){const{inputs:d,backend:o,attrs:p}=u,{dy:m,input:x}=d,R=x;(0,ni.H)([m,x],"avgPoolGrad");const{filterSize:$,strides:j,pad:ce}=p,fe=l.backend_util.computePool2DInfo(R.shape,$,j,1,ce),je=fe.strideHeight,ze=fe.strideWidth,nt=fe.filterHeight,Rt=fe.filterWidth,bt=fe.dilationHeight,xt=fe.dilationWidth,Pt=fe.effectiveFilterHeight,St=fe.effectiveFilterWidth,Ut=St-1-fe.padInfo.left,Ft=Pt-1-fe.padInfo.top,sn=(0,l.f3b)(R.shape,"float32"),_n=1/(nt*Rt),Cn=o.data.get(m.dataId).values,Bn=(0,l.f3b)(m.shape,"float32",Cn);for(let Vn=0;Vn<fe.batchSize;++Vn)for(let es=0;es<fe.inChannels;++es)for(let ls=0;ls<fe.inHeight;++ls)for(let Cs=0;Cs<fe.inWidth;++Cs){const rs=ls-Ft,hs=Cs-Ut;let ms=0;for(let _s=0;_s<Pt;_s+=bt){const Ds=(rs+_s)/je;if(!(Ds<0||Ds>=fe.outHeight||Math.floor(Ds)!==Ds))for(let ds=0;ds<St;ds+=xt){const ys=(hs+ds)/ze;ys<0||ys>=fe.outWidth||Math.floor(ys)!==ys||(ms+=Bn.get(Vn,Ds,ys,es))}}sn.set(ms*_n,Vn,ls,Cs,es)}return o.makeTensorInfo(sn.shape,sn.dtype,sn.values)}},qx={kernelName:l.sHE,backendName:"cpu",kernelFunc:function K1(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,scale:x,offset:R,mean:$,variance:j}=d;l.D5U.assert($.shape.length===j.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),l.D5U.assert(null==R||$.shape.length===R.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),l.D5U.assert(null==x||$.shape.length===x.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),(0,ni.H)([m,$,j,x,R],"batchNorm");let{varianceEpsilon:ce}=p;null==ce&&(ce=.001);const fe=o.data.get(m.dataId).values,je=o.data.get($.dataId).values,ze=o.data.get(j.dataId).values,nt=x?o.data.get(x.dataId).values:new Float32Array([1]),Rt=R?o.data.get(R.dataId).values:new Float32Array([0]),bt=new Float32Array(fe.length),xt=Rt.length,Pt=nt.length,St=ze.length,Ut=je.length;let Ft=0,sn=0,_n=0,Cn=0;for(let Bn=0;Bn<fe.length;++Bn)bt[Bn]=Rt[Ft++]+(fe[Bn]-je[sn++])*nt[_n++]/Math.sqrt(ze[Cn++]+ce),Ft>=xt&&(Ft=0),sn>=Ut&&(sn=0),_n>=Pt&&(_n=0),Cn>=St&&(Cn=0);return o.makeTensorInfo(m.shape,m.dtype,bt)}};var Qu=h(5006);const FT={kernelName:l.zws,backendName:"cpu",kernelFunc:function PT(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{blockShape:x,crops:R}=p;(0,ni.H)([m],"batchToSpaceND");const $=x.reduce((Pt,St)=>Pt*St),j=l.backend_util.getReshaped(m.shape,x,$),ce=l.backend_util.getPermuted(j.length,x.length),fe=l.backend_util.getReshapedPermuted(m.shape,x,$),je=l.backend_util.getSliceBeginCoords(R,x.length),ze=l.backend_util.getSliceSize(fe,R,x.length),nt=Ja({inputs:{x:m},backend:o,attrs:{shape:j}}),Rt=(0,ud.p)({inputs:{x:nt},backend:o,attrs:{perm:ce}}),bt=Ja({inputs:{x:Rt},backend:o,attrs:{shape:fe}}),xt=(0,Qu.tP)({inputs:{x:bt},backend:o,attrs:{begin:je,size:ze}});return o.disposeIntermediateTensorInfo(nt),o.disposeIntermediateTensorInfo(Rt),o.disposeIntermediateTensorInfo(bt),xt}};var ky=h(9569);const X1={kernelName:l.zvY,backendName:"cpu",kernelFunc:function LT(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,weights:x}=d,{size:R}=p,$=o.data.get(m.dataId).values,j=o.data.get(x.dataId).values,ce=(0,ky.W)($,j,x.dtype,x.shape,R);return o.makeTensorInfo([R],x.dtype,ce)}};var $T=h(8642);const Oy={kernelName:l.eEB,backendName:"cpu",kernelFunc:function Lv(u){const{inputs:d,backend:o}=u,{s0:p,s1:m}=d,x=o.data.get(p.dataId).values,R=o.data.get(m.dataId).values,$=l.backend_util.assertAndGetBroadcastShape(Array.from(x),Array.from(R));return o.makeTensorInfo([$.length],"int32",Int32Array.from($))}};var Ry=h(1928),$v=h(5079);const lM=(0,Qa.A)(l.xnO,(u,d)=>u>d.clipValueMax?d.clipValueMax:u<d.clipValueMin?d.clipValueMin:u),BT={kernelName:l.xnO,backendName:"cpu",kernelFunc:lM};var sh=h(3392);const VT={kernelName:l.yj2,backendName:"cpu",kernelFunc:u=>{const{x:d}=u.inputs,o=u.backend,p=new Float32Array(l.D5U.sizeFromShape(d.shape)),m=o.data.get(d.dataId),R=m.complexTensorInfos.imag,$=o.data.get(m.complexTensorInfos.real.dataId).values,j=o.data.get(R.dataId).values;for(let ce=0;ce<$.length;ce++)p[ce]=Math.hypot($[ce],j[ce]);return o.makeOutput(p,d.shape,"float32")}};var UT=h(9971);function Em(u){const{inputs:d,backend:o}=u,{input:p}=d,m=o.data.get(p.dataId).complexTensorInfos.imag,x=o.data.get(m.dataId).values;return o.makeTensorInfo(m.shape,m.dtype,x)}const Z1={kernelName:l.J_u,backendName:"cpu",kernelFunc:Em};var ip=h(4353);function Hg(u){const{inputs:d,backend:o,attrs:p}=u,{axis:m}=p,x=l.D5U.parseAxisParam(m,d[0].shape)[0],R=d.map(bt=>bt.shape);l.backend_util.assertParamsConsistent(R,x);let $=l.backend_util.computeOutShape(d.map(bt=>bt.shape),x);if(0===l.D5U.sizeFromShape($))return o.makeTensorInfo($,d[0].dtype,[]);const j=d.filter(bt=>l.D5U.sizeFromShape(bt.shape)>0);if(1===j.length)return(0,Up.y)({inputs:{x:j[0]},backend:o});if("complex64"===j[0].dtype){const bt=j.map(Ft=>(0,ip.k)({inputs:{input:Ft},backend:o})),xt=j.map(Ft=>Em({inputs:{input:Ft},backend:o})),Pt=Hg({inputs:bt,backend:o,attrs:{axis:x}}),St=Hg({inputs:xt,backend:o,attrs:{axis:x}}),Ut=(0,sh.P)({inputs:{real:Pt,imag:St},backend:o});return bt.forEach(Ft=>o.disposeIntermediateTensorInfo(Ft)),xt.forEach(Ft=>o.disposeIntermediateTensorInfo(Ft)),o.disposeIntermediateTensorInfo(Pt),o.disposeIntermediateTensorInfo(St),Ut}const ce=j.map(bt=>{const Pt=[-1,l.D5U.sizeFromShape(bt.shape.slice(x))];return Ja({inputs:{x:bt},backend:o,attrs:{shape:Pt}})}),fe=ce.map(bt=>({vals:o.data.get(bt.dataId).values,shape:bt.shape}));$=l.backend_util.computeOutShape(ce.map(bt=>bt.shape),1);const ze=(0,UT.j)(fe,$,d[0].dtype,1===ce[0].shape[0]),nt=l.backend_util.computeOutShape(j.map(bt=>bt.shape),x),Rt=o.makeTensorInfo(nt,d[0].dtype,ze);return ce.forEach(bt=>o.disposeIntermediateTensorInfo(bt)),Rt}const Q1={kernelName:l.Eh3,backendName:"cpu",kernelFunc:Hg};function ew(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,filter:x}=d,{strides:R,pad:$,dataFormat:j,dilations:ce,dimRoundingMode:fe}=p;(0,ni.H)([m,x],"conv2d");const je=l.backend_util.convertConv2DDataFormat(j),ze=l.backend_util.computeConv2DInfo(m.shape,x.shape,R,ce,$,fe,!1,je),nt=ze.filterHeight,Rt=ze.filterWidth,bt=ze.dilationHeight,xt=ze.dilationWidth,Pt=ze.padInfo.left,St=ze.padInfo.top,Ut="channelsLast"===ze.dataFormat,Ft=new l.YDk(ze.outShape,m.dtype),sn=l.D5U.computeStrides(m.shape),_n=l.D5U.computeStrides(x.shape),Cn=sn[0],Bn=Ut?sn[1]:sn[2],Vn=Ut?sn[2]:1,es=Ut?1:sn[1],ls=Ft.strides[0],Cs=Ut?Ft.strides[1]:Ft.strides[2],rs=Ut?Ft.strides[2]:1,hs=Ut?1:Ft.strides[1],ms=o.data.get(m.dataId).values,_s=o.data.get(x.dataId).values,Ds=Ft.values;for(let ds=0;ds<ze.batchSize;++ds){const ys=ds*Cn,Ns=ds*ls;for(let Ls=0;Ls<ze.outHeight;++Ls){const nr=Ns+Ls*Cs,Vs=Ls*ze.strideHeight-St;for(let gr=0;gr<nt;++gr){const rr=Vs+gr*bt;if(rr<0||rr>=ze.inHeight)continue;const Lr=gr*_n[0],oi=ys+rr*Bn;for(let bi=0;bi<ze.outWidth;++bi){const fi=nr+bi*rs,qi=bi*ze.strideWidth-Pt;for(let po=0;po<Rt;++po){const Ua=qi+po*xt;if(Ua<0||Ua>=ze.inWidth)continue;const xc=oi+Ua*Vn;let Sl=Lr+po*_n[1];for(let qa=0;qa<ze.inChannels;++qa){const cc=ms[xc+qa*es];for(let Il=0;Il<ze.outChannels;++Il)Ds[fi+Il*hs]+=cc*_s[Sl+Il];Sl+=ze.outChannels}}}}}}return o.makeTensorInfo(Ft.shape,Ft.dtype,Ds)}const zT={kernelName:l.mhS,backendName:"cpu",kernelFunc:ew},Ny={kernelName:l.wUP,backendName:"cpu",kernelFunc:function WT(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,dy:x}=d,{strides:R,pad:$,dataFormat:j,dimRoundingMode:ce,filterShape:fe}=p;(0,ni.H)([m,x],"conv2dBackpropFilter");const je=l.backend_util.convertConv2DDataFormat(j),ze=l.backend_util.computeConv2DInfo(m.shape,fe,R,1,$,ce,!1,je),{strideHeight:nt,strideWidth:Rt,filterHeight:bt,filterWidth:xt}=ze,Pt="channelsLast"===ze.dataFormat,St=new l.YDk(ze.filterShape,"float32"),Ut=ze.padInfo.left,Ft=ze.padInfo.top,sn=o.data.get(m.dataId).values,_n=o.data.get(x.dataId).values,Cn=new l.YDk(m.shape,m.dtype,sn),Bn=new l.YDk(x.shape,x.dtype,_n);for(let Vn=0;Vn<bt;++Vn){const es=Math.max(0,Math.ceil((Ft-Vn)/nt)),ls=Math.min(ze.outHeight,(ze.inHeight+Ft-Vn)/nt);for(let Cs=0;Cs<xt;++Cs){const rs=Math.max(0,Math.ceil((Ut-Cs)/Rt)),hs=Math.min(ze.outWidth,(ze.inWidth+Ut-Cs)/Rt);for(let ms=0;ms<ze.inChannels;++ms)for(let _s=0;_s<ze.outChannels;++_s){let Ds=0;for(let ds=0;ds<ze.batchSize;++ds)for(let ys=es;ys<ls;++ys){const Ns=Vn+ys*nt-Ft;for(let Ls=rs;Ls<hs;++Ls){const nr=Cs+Ls*Rt-Ut;Ds+=Pt?Cn.get(ds,Ns,nr,ms)*Bn.get(ds,ys,Ls,_s):Cn.get(ds,ms,Ns,nr)*Bn.get(ds,_s,ys,Ls)}}St.set(Ds,Vn,Cs,ms,_s)}}}return o.makeTensorInfo(St.shape,St.dtype,St.values)}},jT={kernelName:l.wm,backendName:"cpu",kernelFunc:function HT(u){const{inputs:d,backend:o,attrs:p}=u,{dy:m,filter:x}=d,{inputShape:R,strides:$,pad:j,dataFormat:ce,dimRoundingMode:fe}=p;(0,ni.H)([m,x],"conv2dBackpropInput");const je=l.D5U.computeStrides(x.shape),ze=l.D5U.computeStrides(m.shape);let nt=l.backend_util.convertConv2DDataFormat(ce);const Rt=l.backend_util.computeConv2DInfo(R,x.shape,$,1,j,fe,!1,nt),bt=new l.YDk(Rt.inShape,"float32"),xt=bt.values,Pt=o.data.get(m.dataId).values,St=o.data.get(x.dataId).values,[Ut,Ft,sn]=je,{batchSize:_n,filterHeight:Cn,filterWidth:Bn,inChannels:Vn,inHeight:es,inWidth:ls,outChannels:Cs,outHeight:rs,outWidth:hs,strideHeight:ms,strideWidth:_s}=Rt;nt=Rt.dataFormat;const Ds=Cn-1-Rt.padInfo.top,ds=Bn-1-Rt.padInfo.left,ys="channelsLast"===nt,Ns=bt.strides[0],Ls=ys?bt.strides[1]:bt.strides[2],nr=ys?bt.strides[2]:1,Vs=ys?1:bt.strides[1],gr=ze[0],rr=ys?ze[1]:ze[2],Lr=ys?ze[2]:1,oi=ys?1:ze[1];for(let bi=0;bi<_n;++bi)for(let fi=0;fi<Vn;++fi)for(let qi=0;qi<es;++qi){const po=qi-Ds,Ua=Math.max(0,Math.ceil(po/ms)),dl=Math.min(rs,(Cn+po)/ms);for(let xc=0;xc<ls;++xc){const Sl=xc-ds,qa=Math.max(0,Math.ceil(Sl/_s)),cc=Math.min(hs,(Bn+Sl)/_s);let Il=0;for(let au=Ua;au<dl;++au){const up=au*ms-po;for(let Md=qa;Md<cc;++Md){const Pd=gr*bi+rr*au+Lr*Md,Wp=Ut*(Cn-1-up)+Ft*(Bn-1-(Md*_s-Sl))+sn*fi;for(let vr=0;vr<Cs;++vr)Il+=Pt[Pd+oi*vr]*St[Wp+vr]}}xt[Ns*bi+Ls*qi+nr*xc+Vs*fi]=Il}}return o.makeTensorInfo(bt.shape,bt.dtype,bt.values)}},KT={kernelName:l.x12,backendName:"cpu",kernelFunc:function GT(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,filter:x}=d,{strides:R,pad:$,dilations:j}=p;(0,ni.H)([m,x],"conv3d");const ce=l.backend_util.computeConv3DInfo(m.shape,x.shape,R,j,$),{filterDepth:fe,filterHeight:je,filterWidth:ze,dilationDepth:nt,dilationHeight:Rt,dilationWidth:bt,padInfo:xt}=ce,Pt=xt.front,St=xt.left,Ut=xt.top,Ft=new l.YDk(ce.outShape,m.dtype),sn=o.data.get(m.dataId).values,_n=o.data.get(x.dataId).values,Cn=Ft.values,Bn=l.D5U.computeStrides(m.shape),Vn=l.D5U.computeStrides(x.shape);for(let es=0;es<ce.batchSize;++es){const ls=es*Bn[0],Cs=es*Ft.strides[0];for(let rs=0;rs<ce.outDepth;++rs){const hs=Cs+rs*Ft.strides[1],ms=rs*ce.strideDepth-Pt;for(let _s=0;_s<fe;++_s){const Ds=ms+_s*nt;if(Ds<0||Ds>=ce.inDepth)continue;const ds=_s*Vn[0],ys=ls+Ds*Bn[1];for(let Ns=0;Ns<ce.outHeight;++Ns){const Ls=hs+Ns*Ft.strides[2],nr=Ns*ce.strideHeight-Ut;for(let Vs=0;Vs<je;++Vs){const gr=nr+Vs*Rt;if(gr<0||gr>=ce.inHeight)continue;const rr=ds+Vs*Vn[1],Lr=ys+gr*Bn[2];for(let oi=0;oi<ce.outWidth;++oi){const bi=Ls+oi*ce.outChannels,fi=oi*ce.strideWidth-St;for(let qi=0;qi<ze;++qi){const po=fi+qi*bt;if(po<0||po>=ce.inWidth)continue;const dl=Lr+po*ce.inChannels;let xc=rr+qi*Vn[2];for(let Sl=0;Sl<ce.inChannels;++Sl){const qa=sn[dl+Sl];for(let cc=0;cc<ce.outChannels;++cc)Cn[bi+cc]+=qa*_n[xc+cc];xc+=ce.outChannels}}}}}}}}return o.makeTensorInfo(Ft.shape,Ft.dtype,Ft.values)}},YT={kernelName:l.o2y,backendName:"cpu",kernelFunc:function XT(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,dy:x}=d,{strides:R,pad:$,filterShape:j}=p;(0,ni.H)([m,x],"conv3dBackpropFilterV2");const ce=l.D5U.computeStrides(m.shape),fe=l.D5U.computeStrides(x.shape),je=l.backend_util.computeConv3DInfo(m.shape,j,R,1,$),ze=je.strideDepth,nt=je.strideHeight,Rt=je.strideWidth,bt=je.filterDepth,xt=je.filterHeight,Pt=je.filterWidth,St=new l.YDk(je.filterShape,"float32"),Ut=St.values,[Ft,sn,_n,Cn]=St.strides,Bn=o.data.get(x.dataId).values,[Vn,es,ls,Cs]=fe,rs=o.data.get(m.dataId).values,[hs,ms,_s,Ds]=ce,ds=je.padInfo.front,ys=je.padInfo.left,Ns=je.padInfo.top;for(let Ls=0;Ls<bt;++Ls){const nr=Math.max(0,Math.ceil((ds-Ls)/ze)),Vs=Math.min(je.outDepth,(je.inDepth+ds-Ls)/ze),gr=Ls*Ft;for(let rr=0;rr<xt;++rr){const Lr=Math.max(0,Math.ceil((Ns-rr)/nt)),oi=Math.min(je.outHeight,(je.inHeight+Ns-rr)/nt),bi=rr*sn+gr;for(let fi=0;fi<Pt;++fi){const qi=Math.max(0,Math.ceil((ys-fi)/Rt)),po=Math.min(je.outWidth,(je.inWidth+ys-fi)/Rt),Ua=fi*_n+bi;for(let dl=0;dl<je.inChannels;++dl){const xc=dl*Cn+Ua;for(let Sl=0;Sl<je.outChannels;++Sl){let qa=0;for(let cc=0;cc<je.batchSize;++cc){const Il=cc*hs,Ih=cc*Vn;for(let au=nr;au<Vs;++au){const Md=(Ls+au*ze-ds)*ms+Il,km=au*es+Ih;for(let Pd=Lr;Pd<oi;++Pd){const vr=(rr+Pd*nt-Ns)*_s+Md,md=Pd*ls+km;for(let Hp=qi;Hp<po;++Hp)qa+=rs[(fi+Hp*Rt-ys)*Ds+vr+dl]*Bn[Hp*Cs+md+Sl]}}}Ut[xc+Sl]=qa}}}}}return o.makeTensorInfo(St.shape,St.dtype,St.values)}},QT={kernelName:l.ik2,backendName:"cpu",kernelFunc:function ZT(u){const{inputs:d,backend:o,attrs:p}=u,{dy:m,filter:x}=d,{pad:R,strides:$,inputShape:j}=p;(0,ni.H)([m],"conv3dBackpropInputV2");const ce=l.D5U.computeStrides(m.shape),fe=l.D5U.computeStrides(x.shape),je=l.backend_util.computeConv3DInfo(j,x.shape,$,1,R),ze=new l.YDk(je.inShape,"float32"),nt=ze.values,[Rt,bt,xt,Pt]=ze.strides,St=o.data.get(m.dataId).values,[Ut,Ft,sn,_n]=ce,Cn=o.data.get(x.dataId).values,[Bn,Vn,es,ls]=fe,{batchSize:Cs,filterDepth:rs,filterHeight:hs,filterWidth:ms,inChannels:_s,inDepth:Ds,inHeight:ds,inWidth:ys,outChannels:Ns,outDepth:Ls,outHeight:nr,outWidth:Vs,strideDepth:gr,strideHeight:rr,strideWidth:Lr}=je,oi=rs-1-je.padInfo.front,bi=hs-1-je.padInfo.top,fi=ms-1-je.padInfo.left;for(let qi=0;qi<Cs;++qi)for(let po=0;po<_s;++po)for(let Ua=0;Ua<Ds;++Ua){const dl=Ua-oi,xc=Math.max(0,Math.ceil(dl/gr)),Sl=Math.min(Ls,(rs+dl)/gr);for(let qa=0;qa<ds;++qa){const cc=qa-bi,Il=Math.max(0,Math.ceil(cc/rr)),Ih=Math.min(nr,(hs+cc)/rr);for(let au=0;au<ys;++au){const up=au-fi,Md=Math.max(0,Math.ceil(up/Lr)),km=Math.min(Vs,(ms+up)/Lr);let Pd=0;for(let Wp=xc;Wp<Sl;++Wp){const vr=Wp*gr-dl;for(let md=Il;md<Ih;++md){const Hp=md*rr-cc;for(let jy=Md;jy<km;++jy){const Gy=Ut*qi+Ft*Wp+sn*md+_n*jy,bw=Bn*(rs-1-vr)+Vn*(hs-1-Hp)+es*(ms-1-(jy*Lr-up))+ls*po;for(let Qv=0;Qv<Ns;++Qv)Pd+=St[Gy+Qv]*Cn[bw+Qv]}}}nt[Rt*qi+bt*Ua+xt*qa+Pt*au+po]=Pd}}}return o.makeTensorInfo(ze.shape,ze.dtype,ze.values)}},J1=(0,Qa.A)(l.mc4,u=>Math.cos(u)),Ps={kernelName:l.mc4,backendName:"cpu",kernelFunc:J1},JT=(0,Qa.A)(l.TR1,u=>Math.cosh(u)),Bv={kernelName:l.TR1,backendName:"cpu",kernelFunc:JT},eA={kernelName:l.VcC,backendName:"cpu",kernelFunc:function qT(u){const{inputs:d,backend:o,attrs:p}=u,{image:m,boxes:x,boxInd:R}=d,{cropSize:$,method:j,extrapolationValue:ce}=p,[fe,je,ze,nt]=m.shape,Rt=x.shape[0],[bt,xt]=$,Pt=(0,l.f3b)([Rt,bt,xt,nt],"float32"),St=o.data.get(x.dataId).values,Ut=o.data.get(R.dataId).values,Ft=o.data.get(m.dataId).values,sn=l.D5U.computeStrides(m.shape),_n=l.D5U.computeStrides(Pt.shape);for(let Cn=0;Cn<Rt;Cn++){const Bn=4*Cn,Vn=St[Bn],es=St[Bn+1],ls=St[Bn+2],Cs=St[Bn+3],rs=Ut[Cn];if(rs>=fe)continue;const hs=bt>1?(ls-Vn)*(je-1)/(bt-1):0,ms=xt>1?(Cs-es)*(ze-1)/(xt-1):0;for(let _s=0;_s<bt;_s++){const Ds=bt>1?Vn*(je-1)+_s*hs:.5*(Vn+ls)*(je-1);if(Ds<0||Ds>je-1)for(let ds=0;ds<xt;ds++)for(let ys=0;ys<nt;ys++)Pt.values[ys+ds*_n[2]+_s*_n[1]+Cn*_n[0]]=ce;else if("bilinear"===j){const ds=Math.floor(Ds),ys=Math.ceil(Ds),Ns=Ds-ds;for(let Ls=0;Ls<xt;Ls++){const nr=xt>1?es*(ze-1)+Ls*ms:.5*(es+Cs)*(ze-1);if(nr<0||nr>ze-1){for(let Lr=0;Lr<nt;Lr++)Pt.values[Lr+Ls*_n[2]+_s*_n[1]+Cn*_n[0]]=ce;continue}const Vs=Math.floor(nr),gr=Math.ceil(nr),rr=nr-Vs;for(let Lr=0;Lr<nt;Lr++){let oi=Lr+Vs*sn[2]+ds*sn[1]+rs*sn[0];const bi=Ft[oi];oi=Lr+gr*sn[2]+ds*sn[1]+rs*sn[0];const fi=Ft[oi];oi=Lr+Vs*sn[2]+ys*sn[1]+rs*sn[0];const qi=Ft[oi];oi=Lr+gr*sn[2]+ys*sn[1]+rs*sn[0];const po=Ft[oi],Ua=bi+(fi-bi)*rr;oi=Lr+Ls*_n[2]+_s*_n[1]+Cn*_n[0],Pt.values[oi]=Ua+(qi+(po-qi)*rr-Ua)*Ns}}}else for(let ds=0;ds<xt;++ds){const ys=xt>1?es*(ze-1)+ds*ms:.5*(es+Cs)*(ze-1);if(ys<0||ys>ze-1){for(let nr=0;nr<nt;nr++)Pt.values[nr+ds*_n[2]+_s*_n[1]+Cn*_n[0]]=ce;continue}const Ns=Math.round(ys),Ls=Math.round(Ds);for(let nr=0;nr<nt;nr++)Pt.values[nr+ds*_n[2]+_s*_n[1]+Cn*_n[0]]=Ft[nr+Ns*sn[2]+Ls*sn[1]+rs*sn[0]]}}}return o.makeTensorInfo(Pt.shape,Pt.dtype,Pt.values)}},nA={kernelName:l.Byc,backendName:"cpu",kernelFunc:function tA(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x,exclusive:R,reverse:$}=p;(0,ni.H)(m,"cumprod");const j=l.backend_util.getAxesPermutation([x],m.shape.length);let ce=m;null!=j&&(ce=(0,ud.p)({inputs:{x:m},backend:o,attrs:{perm:j}}));const fe=l.backend_util.getInnerMostAxes(1,m.shape.length)[0];if(fe!==ce.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${ce.shape.length-1} but got axis=${fe}`);const je=(0,l.x8V)(ce.dtype,"int32"),ze=l.D5U.makeOnesTypedArray(l.D5U.sizeFromShape(ce.shape),je),nt=o.data.get(ce.dataId).values,Rt=ce.shape[ce.shape.length-1],bt=$?(Pt,St)=>Pt+Rt-St-1:(Pt,St)=>Pt+St;for(let Pt=0;Pt<nt.length;Pt+=Rt)for(let St=0;St<Rt;St++){const Ut=bt(Pt,St);if(0===St)ze[Ut]=R?1:nt[Ut];else{const Ft=bt(Pt,St-1);ze[Ut]=R?nt[Ft]*ze[Ft]:nt[Ut]*ze[Ft]}}const xt=o.makeTensorInfo(ce.shape,je,ze);if(null!=j){const Pt=l.backend_util.getUndoAxesPermutation(j),St=(0,ud.p)({inputs:{x:xt},backend:o,attrs:{perm:Pt}});return o.disposeIntermediateTensorInfo(xt),o.disposeIntermediateTensorInfo(ce),St}return xt}},rA={kernelName:l.iHb,backendName:"cpu",kernelFunc:function sA(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x,exclusive:R,reverse:$}=p;(0,ni.H)(m,"cumsum");const j=l.backend_util.getAxesPermutation([x],m.shape.length);let ce=m;null!=j&&(ce=(0,ud.p)({inputs:{x:m},backend:o,attrs:{perm:j}}));const fe=l.backend_util.getInnerMostAxes(1,m.shape.length)[0];if(fe!==ce.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${ce.shape.length-1} but got axis=${fe}`);const je=(0,l.x8V)(ce.dtype,"int32"),ze=l.D5U.makeZerosTypedArray(l.D5U.sizeFromShape(ce.shape),je),nt=o.data.get(ce.dataId).values,Rt=ce.shape[ce.shape.length-1],bt=$?(Pt,St)=>Pt+Rt-St-1:(Pt,St)=>Pt+St;for(let Pt=0;Pt<nt.length;Pt+=Rt)for(let St=0;St<Rt;St++){const Ut=bt(Pt,St);if(0===St)ze[Ut]=R?0:nt[Ut];else{const Ft=bt(Pt,St-1);ze[Ut]=R?nt[Ft]+ze[Ft]:nt[Ut]+ze[Ft]}}const xt=o.makeTensorInfo(ce.shape,je,ze);if(null!=j){const Pt=l.backend_util.getUndoAxesPermutation(j),St=(0,ud.p)({inputs:{x:xt},backend:o,attrs:{perm:Pt}});return o.disposeIntermediateTensorInfo(xt),o.disposeIntermediateTensorInfo(ce),St}return xt}},q1={kernelName:l.QRR,backendName:"cpu",kernelFunc:function iA(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,weights:x}=d,{size:R,binaryOutput:$}=p;if(1===m.shape.length){const j=o.data.get(m.dataId).values,ce=o.data.get(x.dataId).values,fe=(0,ky.W)(j,ce,x.dtype,x.shape,R);return o.makeTensorInfo([R],x.dtype,fe)}if(2===m.shape.length){const j=o.bufferSync(m),ce=o.bufferSync(x),fe=(0,ky.i)(j,ce,R,$);return o.makeTensorInfo(fe.shape,x.dtype,fe.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${m.shape.length}.`)}},oA={kernelName:l.T0n,backendName:"cpu",kernelFunc:function eE(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{blockSize:x,dataFormat:R}=p;l.D5U.assert("NHWC"===R,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${R}`);const $=m.shape[0],j=m.shape[1],ce=m.shape[2],fe=m.shape[3],je=j*x,ze=ce*x,nt=fe/(x*x),Rt=o.data.get(m.dataId).values,bt=new Float32Array($*je*ze*nt);let xt=0;for(let Pt=0;Pt<$;++Pt)for(let St=0;St<je;++St){const Ut=Math.floor(St/x),Ft=St%x;for(let sn=0;sn<ze;++sn){const _n=Math.floor(sn/x),Bn=(Ft*x+sn%x)*nt;for(let Vn=0;Vn<nt;++Vn)bt[xt++]=Rt[Vn+Bn+fe*(_n+ce*(Ut+j*Pt))]}}return o.makeTensorInfo([$,je,ze,nt],m.dtype,bt)}};function aA(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,filter:x}=d,{strides:R,pad:$,dilations:j,dimRoundingMode:ce}=p;(0,ni.H)([m,x],"depthwiseConv2DNative");const fe=l.D5U.computeStrides(m.shape),je=l.D5U.computeStrides(x.shape);let ze=j;null==ze&&(ze=[1,1]),l.D5U.assert(l.backend_util.eitherStridesOrDilationsAreOne(R,ze),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${R} and dilations '${ze}'`);const nt=l.backend_util.computeConv2DInfo(m.shape,x.shape,R,ze,$,ce,!0),{filterHeight:Rt,filterWidth:bt,dilationHeight:xt,dilationWidth:Pt,padInfo:St}=nt,Ut=St.left,Ft=St.top,sn=nt.outChannels/nt.inChannels,_n=new l.YDk(nt.outShape,m.dtype),Cn=o.data.get(m.dataId).values,Bn=o.data.get(x.dataId).values,Vn=_n.values;for(let es=0;es<nt.batchSize;++es){const ls=es*fe[0],Cs=es*_n.strides[0];for(let rs=0;rs<nt.outHeight;++rs){const hs=Cs+rs*_n.strides[1],ms=rs*nt.strideHeight-Ft;for(let _s=0;_s<Rt;++_s){const Ds=ms+_s*xt;if(Ds<0||Ds>=nt.inHeight)continue;const ds=_s*je[0],ys=ls+Ds*fe[1];for(let Ns=0;Ns<nt.outWidth;++Ns){const Ls=hs+Ns*_n.strides[2],nr=Ns*nt.strideWidth-Ut;for(let Vs=0;Vs<bt;++Vs){const gr=nr+Vs*Pt;if(gr<0||gr>=nt.inWidth)continue;const Lr=ys+gr*nt.inChannels;let oi=Ls,bi=ds+Vs*je[1];for(let fi=0;fi<nt.inChannels;++fi){const qi=Cn[Lr+fi];for(let po=0;po<sn;++po)Vn[oi+po]+=qi*Bn[bi+po];oi+=sn,bi+=sn}}}}}}return o.makeTensorInfo(_n.shape,_n.dtype,_n.values)}const tE={kernelName:l.cie,backendName:"cpu",kernelFunc:aA},cM={kernelName:l.sL$,backendName:"cpu",kernelFunc:function nE(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,dy:x}=d,{strides:R,dilations:$,pad:j,dimRoundingMode:ce,filterShape:fe}=p;(0,ni.H)([m,x],"depthwiseConv2dNativeBackpropFilter");const je=l.backend_util.computeConv2DInfo(m.shape,fe,R,$,j,ce,!0),{strideHeight:ze,strideWidth:nt,filterHeight:Rt,filterWidth:bt}=je,xt=new l.YDk(je.filterShape,"float32"),Pt=je.padInfo.left,St=je.padInfo.top,Ut=je.outChannels/je.inChannels,Ft=o.data.get(m.dataId).values,sn=new l.YDk(m.shape,m.dtype,Ft),_n=o.data.get(x.dataId).values,Cn=new l.YDk(x.shape,x.dtype,_n);for(let Bn=0;Bn<Rt;++Bn){const Vn=Math.max(0,Math.ceil((St-Bn)/ze)),es=Math.min(je.outHeight,(je.inHeight+St-Bn)/ze);for(let ls=0;ls<bt;++ls){const Cs=Math.max(0,Math.ceil((Pt-ls)/nt)),rs=Math.min(je.outWidth,(je.inWidth+Pt-ls)/nt);for(let hs=0;hs<je.outChannels;++hs){const ms=Math.trunc(hs/Ut),_s=hs%Ut;let Ds=0;for(let ds=0;ds<je.batchSize;++ds)for(let ys=Vn;ys<es;++ys){const Ns=Bn+ys*ze-St;for(let Ls=Cs;Ls<rs;++Ls)Ds+=sn.get(ds,Ns,ls+Ls*nt-Pt,ms)*Cn.get(ds,ys,Ls,hs)}xt.set(Ds,Bn,ls,ms,_s)}}}return o.makeTensorInfo(xt.shape,xt.dtype,xt.values)}},lA={kernelName:l.y7R,backendName:"cpu",kernelFunc:function Vv(u){const{inputs:d,backend:o,attrs:p}=u,{dy:m,filter:x}=d,{strides:R,dilations:$,pad:j,dimRoundingMode:ce,inputShape:fe}=p;(0,ni.H)([m,x],"depthwiseConv2DNativeBackpropInput");const je=l.D5U.computeStrides(m.shape),ze=l.D5U.computeStrides(x.shape),nt=l.backend_util.computeConv2DInfo(fe,x.shape,R,$,j,ce,!0),Rt=new l.YDk(nt.inShape,"float32"),bt=Rt.values,[xt,Pt,St]=Rt.strides,Ut=o.data.get(m.dataId).values,[Ft,sn,_n]=je,Cn=o.data.get(x.dataId).values,[Bn,Vn,es]=ze,{batchSize:ls,filterHeight:Cs,filterWidth:rs,inChannels:hs,inHeight:ms,inWidth:_s,outChannels:Ds,outHeight:ds,outWidth:ys,strideHeight:Ns,strideWidth:Ls}=nt,nr=Cs-1-nt.padInfo.top,Vs=rs-1-nt.padInfo.left,gr=Ds/hs;for(let rr=0;rr<ls;++rr)for(let Lr=0;Lr<hs;++Lr)for(let oi=0;oi<ms;++oi){const bi=oi-nr,fi=Math.max(0,Math.ceil(bi/Ns)),qi=Math.min(ds,(Cs+bi)/Ns);for(let po=0;po<_s;++po){const Ua=po-Vs,dl=Math.max(0,Math.ceil(Ua/Ls)),xc=Math.min(ys,(rs+Ua)/Ls);let Sl=0;for(let qa=fi;qa<qi;++qa){const cc=qa*Ns-bi;for(let Il=dl;Il<xc;++Il){const au=Ft*rr+sn*qa+_n*Il,up=Bn*(Cs-1-cc)+Vn*(rs-1-(Il*Ls-Ua))+es*Lr;for(let Md=0;Md<gr;++Md)Sl+=Ut[au+(Lr*gr+Md)]*Cn[up+Md]}}bt[xt*rr+Pt*oi+St*po+Lr]=Sl}}return o.makeTensorInfo(Rt.shape,Rt.dtype,Rt.values)}},tw={kernelName:l.$w,backendName:"cpu",kernelFunc:function cA(u){const{inputs:d,backend:o}=u,{x:p}=d,m=l.D5U.sizeFromShape(p.shape),x=o.data.get(p.dataId).values,R=(0,l.f3b)([m,m],p.dtype),$=R.values;for(let ce=0;ce<x.length;ce++)$[ce*m+ce]=x[ce];const j=[...p.shape,...p.shape];return o.makeTensorInfo(j,R.dtype,R.values)}},uA={kernelName:l.p4S,backendName:"cpu",kernelFunc:({inputs:u,backend:d,attrs:o})=>{const{x:p,filter:m}=u,{strides:x,pad:R,dilations:$}=o,j=d,ce=j.data.get(p.dataId).values,fe=p.shape.length,je=j.data.get(m.dataId).values,ze=m.shape.length,{batchSize:nt,inHeight:Rt,inWidth:bt,inChannels:xt,outHeight:Pt,outWidth:St,padInfo:Ut,strideHeight:Ft,strideWidth:sn,filterHeight:_n,filterWidth:Cn,dilationHeight:Bn,dilationWidth:Vn,outShape:es}=l.backend_util.computeDilation2DInfo(p.shape,m.shape,x,R,"NHWC",$),ls=l.D5U.sizeFromShape(es),Cs=es.length,rs=l.D5U.getArrayFromDType(p.dtype,ls);for(let ms=0;ms<nt;++ms)for(let _s=0;_s<Pt;++_s){const Ds=_s*Ft-Ut.top;for(let ds=0;ds<St;++ds){const ys=ds*sn-Ut.left;for(let Ns=0;Ns<xt;++Ns){let Ls=Number.MIN_SAFE_INTEGER;for(let Vs=0;Vs<_n;++Vs){const gr=Ds+Vs*Bn;if(gr>=0&&gr<Rt)for(let rr=0;rr<Cn;++rr){const Lr=ys+rr*Vn;if(Lr>=0&&Lr<bt){const oi=l.D5U.locToIndex([ms,gr,Lr,Ns],fe,l.D5U.computeStrides(p.shape)),bi=l.D5U.locToIndex([Vs,rr,Ns],ze,l.D5U.computeStrides(m.shape)),fi=ce[oi]+je[bi];fi>Ls&&(Ls=fi)}}}rs[l.D5U.locToIndex([ms,_s,ds,Ns],Cs,l.D5U.computeStrides(es))]=Ls}}}return{dataId:j.write(l.D5U.toTypedArray(rs,p.dtype),es,p.dtype),shape:es,dtype:p.dtype}}},op={kernelName:l.Vn9,backendName:"cpu",kernelFunc:({inputs:u,backend:d,attrs:o})=>{const{x:p,filter:m,dy:x}=u,{strides:R,pad:$,dilations:j}=o,ce=d,fe=l.D5U.toNestedArray(p.shape,ce.data.get(p.dataId).values),je=l.D5U.toNestedArray(m.shape,ce.data.get(m.dataId).values),{batchSize:ze,inHeight:nt,inWidth:Rt,inChannels:bt,outHeight:xt,outWidth:Pt,padInfo:St,strideHeight:Ut,strideWidth:Ft,filterHeight:sn,filterWidth:_n,dilationHeight:Cn,dilationWidth:Bn,outShape:Vn}=l.backend_util.computeDilation2DInfo(p.shape,m.shape,R,$,"NHWC",j);l.D5U.assert(x.rank===Vn.length,()=>`Error in ${l.Vn9}, dy must have the same rank as output ${Vn.length}, but got ${x.rank}`);const es=l.D5U.toNestedArray(Vn,ce.data.get(x.dataId).values),ls=l.D5U.makeZerosNestedTypedArray(m.shape,m.dtype);for(let rs=0;rs<ze;++rs)for(let hs=0;hs<xt;++hs){const ms=hs*Ut-St.top;for(let _s=0;_s<Pt;++_s){const Ds=_s*Ft-St.left;for(let ds=0;ds<bt;++ds){let ys=Number.MIN_SAFE_INTEGER,Ns=0,Ls=0;for(let nr=0;nr<sn;++nr){const Vs=ms+nr*Cn;if(Vs>=0&&Vs<nt)for(let gr=0;gr<_n;++gr){const rr=Ds+gr*Bn;if(rr>=0&&rr<Rt){const Lr=fe[rs][Vs][rr][ds]+je[nr][gr][ds];Lr>ys&&(ys=Lr,Ns=nr,Ls=gr)}}}ls[Ns][Ls][ds]+=es[rs][hs][_s][ds]}}}return{dataId:ce.write(l.D5U.toTypedArray(ls,p.dtype),m.shape,m.dtype),shape:m.shape,dtype:m.dtype}}},My={kernelName:l.ekb,backendName:"cpu",kernelFunc:({inputs:u,backend:d,attrs:o})=>{const{x:p,filter:m,dy:x}=u,{strides:R,pad:$,dilations:j}=o,ce=d,fe=l.D5U.toNestedArray(p.shape,ce.data.get(p.dataId).values),je=l.D5U.toNestedArray(m.shape,ce.data.get(m.dataId).values),{batchSize:ze,inHeight:nt,inWidth:Rt,inChannels:bt,outHeight:xt,outWidth:Pt,padInfo:St,strideHeight:Ut,strideWidth:Ft,filterHeight:sn,filterWidth:_n,dilationHeight:Cn,dilationWidth:Bn,outShape:Vn}=l.backend_util.computeDilation2DInfo(p.shape,m.shape,R,$,"NHWC",j);l.D5U.assert(x.rank===Vn.length,()=>`Error in ${l.ekb}, dy must have the same rank as output ${Vn.length}, but got ${x.rank}`);const es=l.D5U.toNestedArray(Vn,ce.data.get(x.dataId).values),ls=l.D5U.makeZerosNestedTypedArray(p.shape,p.dtype);for(let rs=0;rs<ze;++rs)for(let hs=0;hs<xt;++hs){const ms=hs*Ut-St.top;for(let _s=0;_s<Pt;++_s){const Ds=_s*Ft-St.left;for(let ds=0;ds<bt;++ds){let ys=Number.MIN_SAFE_INTEGER,Ns=ms<0?0:ms,Ls=Ds<0?0:Ds;for(let nr=0;nr<sn;++nr){const Vs=ms+nr*Cn;if(Vs>=0&&Vs<nt)for(let gr=0;gr<_n;++gr){const rr=Ds+gr*Bn;if(rr>=0&&rr<Rt){const Lr=fe[rs][Vs][rr][ds]+je[nr][gr][ds];Lr>ys&&(ys=Lr,Ns=Vs,Ls=rr)}}}ls[rs][Ns][Ls][ds]+=es[rs][hs][_s][ds]}}}return{dataId:ce.write(l.D5U.toTypedArray(ls,p.dtype),p.shape,p.dtype),shape:p.shape,dtype:p.dtype}}},Dm={kernelName:l.hGc,backendName:"cpu",kernelFunc:function Uu(u){const{inputs:d,backend:o,attrs:p}=u,{image:m}=d,{canvas:x,options:R}=p,{contextOptions:$,imageOptions:j}=R||{},ce=j?.alpha||1,fe=$?.contextType||"2d";if("2d"!==fe)throw new Error(`Context type ${$.contextType} is not supported by the CPU backend.`);const je=x.getContext(fe,$?.contextAttributes||{});if(null==je)throw new Error(`Could not get the context with ${fe} type.`);const[ze,nt]=m.shape.slice(0,2),Rt=2===m.shape.length?1:m.shape[2],bt=o.data.get(m.dataId).values,xt="float32"===m.dtype?255:1,Pt=new Uint8ClampedArray(nt*ze*4);for(let Ut=0;Ut<ze*nt;++Ut){const Ft=[0,0,0,255*ce];for(let _n=0;_n<Rt;_n++){const Cn=bt[Ut*Rt+_n];if("float32"===m.dtype){if(Cn<0||Cn>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Cn}.`)}else if("int32"===m.dtype&&(Cn<0||Cn>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Cn}.`);1===Rt?(Ft[0]=Cn*xt,Ft[1]=Cn*xt,Ft[2]=Cn*xt):Ft[_n]=Cn*xt}const sn=4*Ut;Pt[sn+0]=Math.round(Ft[0]),Pt[sn+1]=Math.round(Ft[1]),Pt[sn+2]=Math.round(Ft[2]),Pt[sn+3]=Math.round(Ft[3])}x.width=nt,x.height=ze;const St=new ImageData(Pt,nt,ze);return je.putImageData(St,0,0),m}};var Sm=h(7985),rh=h(3176);function si(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x,keepDims:R}=p;let $;(0,ni.H)(m,"sum"),$="bool"===m.dtype?(0,Ry.pj)({inputs:{x:m},backend:o,attrs:{dtype:"int32"}}):(0,Up.y)({inputs:{x:m},backend:o});const j=$.shape.length,ce=l.D5U.parseAxisParam(x,$.shape),fe=l.backend_util.getAxesPermutation(ce,j);let je=ce,ze=$;null!=fe&&(ze=(0,ud.p)({inputs:{x:$},backend:o,attrs:{perm:fe}}),je=l.backend_util.getInnerMostAxes(je.length,j)),l.backend_util.assertAxesAreInnerMostDims("sum",je,ze.shape.length);const[nt,Rt]=l.backend_util.computeOutAndReduceShapes(ze.shape,je),bt=l.backend_util.upcastType(ze.dtype,"int32");let xt=(0,rh.l)(o,nt,bt);const Pt=l.D5U.sizeFromShape(Rt),St=o.data.get(xt.dataId).values,Ut=o.data.get(ze.dataId).values;for(let Ft=0;Ft<St.length;++Ft){const sn=Ft*Pt;let _n=0;for(let Cn=0;Cn<Pt;++Cn)_n+=Ut[sn+Cn];St[Ft]=_n}if(R){const sn=xt;xt=Ja({inputs:{x:xt},backend:o,attrs:{shape:l.backend_util.expandShapeToKeepDim(xt.shape,ce)}}),o.disposeIntermediateTensorInfo(sn)}return o.disposeIntermediateTensorInfo($),null!=fe&&o.disposeIntermediateTensorInfo(ze),xt}const jg={kernelName:l.GBy,backendName:"cpu",kernelFunc:si},Kg={kernelName:l.$g6,backendName:"cpu",kernelFunc:function Gg(u){const{inputs:d,backend:o,attrs:p}=u,{equation:m}=p,x=d,{allDims:R,summedDims:$,idDims:j}=l.backend_util.decodeEinsumEquation(m,x.length);l.backend_util.checkEinsumDimSizes(R.length,j,x);const{path:ce,steps:fe}=l.backend_util.getEinsumComputePath($,j),je=fe.length;let ze=null,nt=R.length;const Rt=[];for(let bt=0;bt<je;++bt){for(const xt of fe[bt]){const{permutationIndices:Pt,expandDims:St}=l.backend_util.getEinsumPermutation(nt,j[xt]);let Ut;l.backend_util.isIdentityPermutation(Pt)?Ut=x[xt]:(Ut=(0,ud.p)({inputs:{x:x[xt]},backend:o,attrs:{perm:Pt}}),Rt.push(Ut));const Ft=Ut.shape.slice();for(let sn=0;sn<St.length;++sn)Ft.splice(St[sn],0,1);l.D5U.arraysEqual(Ut.shape,Ft)||(Ut=Ja({inputs:{x:Ut},backend:o,attrs:{shape:Ft}}),Rt.push(Ut)),null===ze?ze=Ut:(ze=(0,Sm.Jp)({inputs:{a:Ut,b:ze},backend:o}),Rt.push(ze))}bt<je-1&&(ce[bt]>=0&&(ze=si({inputs:{x:ze},backend:o,attrs:{axis:ce[bt]-(R.length-nt),keepDims:!1}}),Rt.push(ze)),nt--)}for(const bt of Rt)bt!==ze&&o.disposeIntermediateTensorInfo(bt);return ze}},Yg={kernelName:l.HEU,backendName:"cpu",kernelFunc:function Xg(u){const{inputs:d,backend:o}=u,{dy:p,y:m}=d;(0,ni.H)([p,m],"eluGrad");const x=new Float32Array(l.D5U.sizeFromShape(m.shape)),R=o.data.get(m.dataId).values,$=o.data.get(p.dataId).values;for(let j=0;j<R.length;++j){const ce=R[j];x[j]=ce>=0?$[j]:$[j]*(ce+1)}return o.makeTensorInfo(m.shape,"float32",x)}};var Im=h(5190);const Zg=l.backend_util.ERF_P,Qg=l.backend_util.ERF_A1,Jg=l.backend_util.ERF_A2,sE=l.backend_util.ERF_A3,rE=l.backend_util.ERF_A4,iE=l.backend_util.ERF_A5,oE=(0,Qa.A)(l.Omj,u=>{const d=Math.sign(u),o=Math.abs(u),p=1/(1+Zg*o);return d*(1-((((iE*p+rE)*p+sE)*p+Jg)*p+Qg)*p*Math.exp(-o*o))}),aE={kernelName:l.Omj,backendName:"cpu",kernelFunc:oE};var nw=h(622);function Py(u){const{inputs:d,backend:o,attrs:p}=u,{input:m}=d,{dim:x}=p,R=m.shape.length,$=m.shape.slice();let j=x;return x<0&&(l.D5U.assert(-(R+1)<=x,()=>`Axis must be in the interval [${-(R+1)}, ${R}]`),j=R+x+1),$.splice(j,0,1),Ja({inputs:{x:m},backend:o,attrs:{shape:$}})}const lE={kernelName:l.YFo,backendName:"cpu",kernelFunc:Py};var cE=h(7166);const sw=(0,If.b)((u,d)=>u/d),rw=(0,Wg.j)(l.oHH,sw),uE={kernelName:l.oHH,backendName:"cpu",kernelFunc:rw};var dE=h(1981);function hE(u,d,o){const p=u.shape,m=p[0],x=p[1],R=o.data.get(u.dataId),$=R.complexTensorInfos.real,j=R.complexTensorInfos.imag,ce=[m,x],fe=l.D5U.sizeFromShape(ce),je=l.D5U.getTypedArrayFromDType("float32",fe),ze=l.D5U.getTypedArrayFromDType("float32",fe);for(let xt=0;xt<m;xt++){const Pt=(0,Qu.tP)({inputs:{x:$},backend:o,attrs:{begin:[xt,0],size:[1,x]}}),St=(0,Qu.tP)({inputs:{x:j},backend:o,attrs:{begin:[xt,0],size:[1,x]}}),Ut=(0,sh.P)({inputs:{real:Pt,imag:St},backend:o}),{real:Ft,imag:sn}=dA(Ut,d,o),_n=l.backend_util.mergeRealAndImagArrays(Ft,sn);for(let Cn=0;Cn<x;Cn++){const Bn=l.backend_util.getComplexWithIndex(_n,Cn);je[xt*x+Cn]=Bn.real,ze[xt*x+Cn]=Bn.imag}o.disposeIntermediateTensorInfo(Pt),o.disposeIntermediateTensorInfo(St),o.disposeIntermediateTensorInfo(Ut)}const nt=o.makeTensorInfo(ce,"float32",je),Rt=o.makeTensorInfo(ce,"float32",ze),bt=(0,sh.P)({inputs:{real:nt,imag:Rt},backend:o});return o.disposeIntermediateTensorInfo(nt),o.disposeIntermediateTensorInfo(Rt),bt}function dA(u,d,o){const p=l.D5U.sizeFromShape(u.shape),m=o.data.get(u.dataId),x=o.data.get(m.complexTensorInfos.real.dataId).values,R=o.data.get(m.complexTensorInfos.imag.dataId).values;if(function uM(u){return 0==(u&u-1)}(p)){const $=iw(x,R,p,d,o),j=[u.shape[0],u.shape[1]];if(d){const ce=o.makeTensorInfo(j,"float32",$.real),fe=o.makeTensorInfo(j,"float32",$.imag),je=o.makeTensorInfo([],"float32",l.D5U.createScalarValue(p,"float32")),ze=(0,Up.y)({inputs:{x:je},backend:o}),nt=uE.kernelFunc({inputs:{a:ce,b:je},backend:o}),Rt=uE.kernelFunc({inputs:{a:fe,b:ze},backend:o}),bt=o.data.get(nt.dataId).values,xt=o.data.get(Rt.dataId).values;return o.disposeIntermediateTensorInfo(ce),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(je),o.disposeIntermediateTensorInfo(ze),o.disposeIntermediateTensorInfo(nt),o.disposeIntermediateTensorInfo(Rt),{real:bt,imag:xt}}return $}{const j=function dM(u,d,o){const p=new Float32Array(2*d);for(let m=0;m<d;m++){let x=0,R=0;for(let $=0;$<d;$++){const j=l.backend_util.exponent(m*$,d,o),ce=l.backend_util.getComplexWithIndex(u,$);x+=ce.real*j.real-ce.imag*j.imag,R+=ce.real*j.imag+ce.imag*j.real}o&&(x/=d,R/=d),l.backend_util.assignToTypedArray(p,x,R,m)}return p}(l.backend_util.mergeRealAndImagArrays(x,R),p,d);return l.backend_util.splitRealAndImagArrays(j)}}function iw(u,d,o,p,m){if(1===o)return{real:u,imag:d};const x=l.backend_util.mergeRealAndImagArrays(u,d),R=o/2,$=l.backend_util.complexWithEvenIndex(x),j=$.real,ce=$.imag,fe=[j.length],je=m.makeTensorInfo(fe,"float32",j),ze=m.makeTensorInfo(fe,"float32",ce),nt=(0,sh.P)({inputs:{real:je,imag:ze},backend:m}),Rt=l.backend_util.complexWithOddIndex(x),bt=Rt.real,xt=Rt.imag,Pt=[bt.length],St=m.makeTensorInfo(Pt,"float32",bt),Ut=m.makeTensorInfo(Pt,"float32",xt),Ft=(0,sh.P)({inputs:{real:St,imag:Ut},backend:m}),sn=iw(j,ce,R,p,m),_n=sn.real,Cn=sn.imag,Bn=[_n.length],Vn=m.makeTensorInfo(Bn,"float32",_n),es=m.makeTensorInfo(Bn,"float32",Cn),ls=(0,sh.P)({inputs:{real:Vn,imag:es},backend:m}),Cs=iw(bt,xt,R,p,m),rs=Cs.real,hs=Cs.imag,ms=[rs.length],_s=m.makeTensorInfo(ms,"float32",rs),Ds=m.makeTensorInfo(ms,"float32",hs),ds=(0,sh.P)({inputs:{real:_s,imag:Ds},backend:m}),ys=l.backend_util.exponents(o,p),Ns=[ys.real.length],Ls=m.makeTensorInfo(Ns,"float32",ys.real),nr=m.makeTensorInfo(Ns,"float32",ys.imag),Vs=(0,sh.P)({inputs:{real:Ls,imag:nr},backend:m}),gr=(0,Sm.Jp)({inputs:{a:Vs,b:ds},backend:m}),rr=(0,Af.IH)({inputs:{a:ls,b:gr},backend:m}),Lr=(0,dE.lu)({inputs:{a:ls,b:gr},backend:m}),oi=(0,ip.k)({inputs:{input:rr},backend:m}),bi=(0,ip.k)({inputs:{input:Lr},backend:m}),fi=Em({inputs:{input:rr},backend:m}),qi=Em({inputs:{input:Lr},backend:m}),po=Hg({inputs:[oi,bi],backend:m,attrs:{axis:0}}),Ua=Hg({inputs:[fi,qi],backend:m,attrs:{axis:0}}),dl=m.data.get(po.dataId).values,xc=m.data.get(Ua.dataId).values;return m.disposeIntermediateTensorInfo(je),m.disposeIntermediateTensorInfo(ze),m.disposeIntermediateTensorInfo(nt),m.disposeIntermediateTensorInfo(St),m.disposeIntermediateTensorInfo(Ut),m.disposeIntermediateTensorInfo(Ft),m.disposeIntermediateTensorInfo(Vn),m.disposeIntermediateTensorInfo(es),m.disposeIntermediateTensorInfo(ls),m.disposeIntermediateTensorInfo(_s),m.disposeIntermediateTensorInfo(Ds),m.disposeIntermediateTensorInfo(ds),m.disposeIntermediateTensorInfo(Ls),m.disposeIntermediateTensorInfo(nr),m.disposeIntermediateTensorInfo(Vs),m.disposeIntermediateTensorInfo(gr),m.disposeIntermediateTensorInfo(rr),m.disposeIntermediateTensorInfo(Lr),m.disposeIntermediateTensorInfo(oi),m.disposeIntermediateTensorInfo(fi),m.disposeIntermediateTensorInfo(bi),m.disposeIntermediateTensorInfo(qi),m.disposeIntermediateTensorInfo(po),m.disposeIntermediateTensorInfo(Ua),{real:dl,imag:xc}}const pA={kernelName:l.vwp,backendName:"cpu",kernelFunc:function hA(u){const{inputs:d,backend:o}=u,{input:p}=d,m=l.D5U.sizeFromShape(p.shape),x=p.shape[p.shape.length-1],$=Ja({inputs:{x:p},backend:o,attrs:{shape:[m/x,x]}}),j=hE($,!1,o),ce=Ja({inputs:{x:j},backend:o,attrs:{shape:p.shape}});return o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(j),ce}};function ow(u){const{backend:d,attrs:o}=u,{shape:p,value:m,dtype:x}=o,R=x||l.D5U.inferDtype(m),$=l.D5U.getArrayFromDType(R,l.D5U.sizeFromShape(p));return function Fy(u,d,o){u.fill(d)}($,m),d.makeTensorInfo(p,R,$)}const aw={kernelName:l.deh,backendName:"cpu",kernelFunc:ow},lw={kernelName:l.Uyb,backendName:"cpu",kernelFunc:({inputs:u,backend:o})=>{const{image:p}=u,m=o,x=l.D5U.getTypedArrayFromDType(p.dtype,l.D5U.sizeFromShape(p.shape)),[R,$,j,ce]=p.shape,fe=m.data.get(p.dataId).values;for(let ze=0;ze<R;ze++){const nt=ze*j*$*ce;for(let Rt=0;Rt<$;Rt++){const bt=Rt*(j*ce);for(let xt=0;xt<j;xt++){const Pt=xt*ce;for(let St=0;St<ce;St++){const Ut=Math.round(j-xt-1),Ft=nt+bt+Pt+St;let sn=fe[Ft];Ut>=0&&Ut<j&&(sn=fe[nt+bt+Ut*ce+St]),x[Ft]=sn}}}}return{dataId:m.write(x,p.shape,p.dtype),shape:p.shape,dtype:p.dtype}}};var Uv=h(1471),pE=h(7846);const fE={kernelName:l._V0,backendName:"cpu",kernelFunc:function Ly(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,filter:x,bias:R,preluActivationWeights:$}=d,{strides:j,pad:ce,dataFormat:fe,dilations:je,dimRoundingMode:ze,activation:nt,leakyreluAlpha:Rt}=p;let bt=ew({inputs:{x:m,filter:x},backend:o,attrs:{strides:j,pad:ce,dataFormat:fe,dilations:je,dimRoundingMode:ze}});if(R){const xt=bt;if("NCHW"===fe&&1===R.shape.length&&1!==R.shape[0]){const Pt=Ja({inputs:{x:R},backend:o,attrs:{shape:[R.shape[0],1,1]}});bt=(0,Af.IH)({inputs:{a:bt,b:Pt},backend:o}),o.disposeIntermediateTensorInfo(Pt)}else bt=(0,Af.IH)({inputs:{a:bt,b:R},backend:o});o.disposeIntermediateTensorInfo(xt)}if(nt){const xt=bt;if("NCHW"===fe&&"prelu"===nt&&1===$.shape.length&&1!==$.shape[0]){const Pt=Ja({inputs:{x:$},backend:o,attrs:{shape:[$.shape[0],1,1]}});bt=zg(o,bt,nt,Pt,Rt),o.disposeIntermediateTensorInfo(Pt)}else bt=zg(o,bt,nt,$,Rt);o.disposeIntermediateTensorInfo(xt)}return bt}},$y={kernelName:l.luS,backendName:"cpu",kernelFunc:function fA(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,filter:x,bias:R,preluActivationWeights:$}=d,{strides:j,pad:ce,dataFormat:fe,dilations:je,dimRoundingMode:ze,activation:nt,leakyreluAlpha:Rt}=p;let bt=aA({inputs:{x:m,filter:x},backend:o,attrs:{strides:j,pad:ce,dataFormat:fe,dilations:je,dimRoundingMode:ze}});if(R){const xt=bt;bt=(0,Af.IH)({inputs:{a:bt,b:R},backend:o}),o.disposeIntermediateTensorInfo(xt)}if(nt){const xt=bt;bt=zg(o,bt,nt,$,Rt),o.disposeIntermediateTensorInfo(xt)}return bt}};var mA=h(2465);const _A={kernelName:l.q1x,backendName:"cpu",kernelFunc:function gA(u){const{inputs:d,backend:o}=u,{params:p,indices:m}=d,x=l.D5U.sizeFromShape(p.shape),R=m.shape,$=R[R.length-1],[j,ce,fe,je]=l.backend_util.prepareAndValidate(p,m);if(0===ce)return o.makeTensorInfo(j,p.dtype,[]);const ze=o.data.get(m.dataId).values,nt=o.bufferSync(p),Rt=(0,mA.m)(ze,nt,p.dtype,ce,$,fe,je,p.shape,x);return o.makeTensorInfo(j,p.dtype,Rt.values)}};var yA=h(2697);const zv={kernelName:l.qi_,backendName:"cpu",kernelFunc:function cw(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,indices:x}=d,{axis:R,batchDims:$}=p;(0,ni.H)([m,x],"gatherV2");const j=l.D5U.parseAxisParam(R,m.shape)[0],ce=o.data.get(x.dataId).values,fe=m.shape[j];for(let Ft=0;Ft<ce.length;++Ft){const sn=ce[Ft];l.D5U.assert(sn<=fe-1&&sn>=0,()=>`GatherV2: the index value ${sn} is not in [0, ${fe-1}]`)}let je=$;null==$&&(je=0);const ze=l.D5U.sizeFromShape(x.shape),nt=l.backend_util.segment_util.collectGatherOpShapeInfo(m,x,j,je),Rt=Ja({inputs:{x:m},backend:o,attrs:{shape:[nt.batchSize,nt.outerSize,nt.dimSize,nt.sliceSize]}}),bt=Ja({inputs:{x},backend:o,attrs:{shape:[nt.batchSize,ze/nt.batchSize]}}),xt=[nt.batchSize,nt.outerSize,ze/nt.batchSize,nt.sliceSize],Pt=o.bufferSync(bt),St=o.bufferSync(Rt),Ut=(0,yA.i)(St,Pt,xt);return o.disposeIntermediateTensorInfo(Rt),o.disposeIntermediateTensorInfo(bt),o.makeTensorInfo(nt.outputShape,Ut.dtype,Ut.values)}};var Wv=h(4730),hM=h(7310);const bA={kernelName:l.Qg5,backendName:"cpu",kernelFunc:function vA(u){const{inputs:d,backend:o}=u,{input:p}=d,m=l.D5U.sizeFromShape(p.shape),x=p.shape[p.shape.length-1],$=Ja({inputs:{x:p},backend:o,attrs:{shape:[m/x,x]}}),j=hE($,!0,o),ce=Ja({inputs:{x:j},backend:o,attrs:{shape:p.shape}});return o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(j),ce}},uw=(0,Qa.A)(l.avt,u=>Number.isFinite(u)?1:0,"bool"),xA={kernelName:l.avt,backendName:"cpu",kernelFunc:uw},mE=(0,Qa.A)(l.iWB,u=>Math.abs(u)===1/0?1:0,"bool"),wA={kernelName:l.iWB,backendName:"cpu",kernelFunc:mE},CA=(0,Qa.A)(l.r7n,u=>Number.isNaN(u)?1:0,"bool"),Fs={kernelName:l.r7n,backendName:"cpu",kernelFunc:CA};var gE=h(2339),_E=h(33),EA=h(3373);const SA={kernelName:l.e7N,backendName:"cpu",kernelFunc:function DA(u){const{backend:d,attrs:o}=u,{start:p,stop:m,num:x}=o,R=(0,EA.b)(p,m,x);return d.makeTensorInfo([R.length],"float32",R)}};var zp=h(6723);const Yn=(0,Qa.A)(l.kU,u=>Math.log1p(u)),dw={kernelName:l.kU,backendName:"cpu",kernelFunc:Yn},IA=(0,If.b)((u,d)=>u&&d),yn=(0,Wg.j)(l.PYm,IA,null,"bool"),In={kernelName:l.PYm,backendName:"cpu",kernelFunc:yn},ti=(0,Qa.A)(l.VfG,u=>u?0:1,"bool"),yE={kernelName:l.VfG,backendName:"cpu",kernelFunc:ti},TA=(0,If.b)((u,d)=>u||d),AA=(0,Wg.j)(l.MZg,TA,null,"bool"),kA={kernelName:l.MZg,backendName:"cpu",kernelFunc:AA},hd={kernelName:l.eZ0,backendName:"cpu",kernelFunc:function dd(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{depthRadius:x,bias:R,alpha:$,beta:j}=p;(0,ni.H)(m,"LRN");const ce=m.shape[3],fe=ce-1,je=o.data.get(m.dataId).values,ze=l.D5U.sizeFromShape(m.shape),nt=new Float32Array(ze);function Rt(bt){const xt=bt%ce;let Pt=bt-xt+Math.max(0,xt-x);const St=bt-xt+Math.min(xt+x,fe);let Ut=0;for(;Pt<=St;Pt++){const Ft=je[Pt];Ut+=Ft*Ft}return Ut}for(let bt=0;bt<ze;bt++){const xt=Rt(bt),Pt=je[bt]*Math.pow(R+$*xt,-j);nt[bt]=Pt}return o.makeTensorInfo(m.shape,m.dtype,nt)}},vE={kernelName:l.Hhh,backendName:"cpu",kernelFunc:function Nd(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,y:x,dy:R}=d,{depthRadius:$,bias:j,alpha:ce,beta:fe}=p;(0,ni.H)(R,"LRNGrad");const je=l.D5U.sizeFromShape(R.shape),ze=R.shape[3],nt=o.data.get(R.dataId).values,Rt=o.data.get(m.dataId).values,bt=o.data.get(x.dataId).values,xt=new Float32Array(je),Pt=je;for(let St=0;St<Pt;St++){const Ut=St%ze,Ft=St-Ut+Math.max(0,Ut-$),sn=St-Ut+Math.min(ze,Ut+$+1);let _n=0;for(let Cn=Ft;Cn<sn;Cn++)_n+=Math.pow(Rt[Cn],2);_n=ce*_n+j;for(let Cn=Ft;Cn<sn;Cn++){let Bn=-2*ce*fe*Rt[Cn]*bt[St]/_n;St===Cn&&(Bn+=Math.pow(_n,-fe)),Bn*=nt[St],xt[Cn]+=Bn}}return o.makeTensorInfo(R.shape,m.dtype,xt)}};var OA=h(7727),RA=h(8385);function iu(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{reductionIndices:x,keepDims:R}=p,$=o;let j=m.shape;const ce=j.length,fe=l.D5U.parseAxisParam(x,j);let je=fe;const ze=l.backend_util.getAxesPermutation(je,ce);let nt=$.data.get(m.dataId).values;if(null!=ze){const Ft=new Array(ce);for(let sn=0;sn<Ft.length;sn++)Ft[sn]=j[ze[sn]];nt=(0,RA.H)(nt,j,m.dtype,ze,Ft),je=l.backend_util.getInnerMostAxes(je.length,ce),j=Ft}(0,ni.H)(m,"max"),l.backend_util.assertAxesAreInnerMostDims("max",je,ce);const[Rt,bt]=l.backend_util.computeOutAndReduceShapes(j,je),xt=l.D5U.sizeFromShape(bt),Pt=(0,OA.B)(nt,xt,Rt,m.dtype),St=$.write(Pt,Rt,m.dtype);let Ut=Rt;return R&&(Ut=l.backend_util.expandShapeToKeepDim(Rt,fe)),{dataId:St,shape:Ut,dtype:m.dtype}}const By={kernelName:l.YoZ,backendName:"cpu",kernelFunc:iu};var bE=h(6160);const xE={kernelName:l.mTV,backendName:"cpu",kernelFunc:function qs(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d;(0,ni.H)(m,"maxPool");const{filterSize:x,strides:R,pad:$,dimRoundingMode:j}=p;l.D5U.assert(l.backend_util.eitherStridesOrDilationsAreOne(R,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${R} and dilations '1'`);const fe=l.backend_util.computePool2DInfo(m.shape,x,R,1,$,j);let je;if(1===fe.filterWidth&&1===fe.filterHeight&&l.D5U.arraysEqual(fe.inShape,fe.outShape))je=(0,Up.y)({inputs:{x:m},backend:o});else{const ze=o.data.get(m.dataId).values,nt=l.D5U.computeStrides(m.shape),Rt=Ay(ze,0,m.dtype,nt,fe,"max");je=o.makeTensorInfo(fe.outShape,m.dtype,Rt.values)}return je}},wE={kernelName:l.OAf,backendName:"cpu",kernelFunc:function NA(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{filterSize:x,strides:R,pad:$,dimRoundingMode:j,dataFormat:ce}=p;(0,ni.H)(m,"maxPool3d");const fe=l.backend_util.computePool3DInfo(m.shape,x,R,1,$,j,ce),ze=Qx(o.data.get(m.dataId).values,0,m.dtype,l.D5U.computeStrides(m.shape),fe,"max");return o.makeTensorInfo(ze.shape,"float32",ze.values)}},EE={kernelName:l.OU7,backendName:"cpu",kernelFunc:function CE(u){const{inputs:d,backend:o,attrs:p}=u,{dy:m,input:x}=d,{filterSize:R,strides:$,pad:j,dimRoundingMode:ce}=p;(0,ni.H)([m,x],"maxPool3DGrad");const fe=l.backend_util.computePool3DInfo(x.shape,R,$,1,j,ce),ze=function MT(u,d){const o=(0,l.f3b)(d.outShape,"int32"),p=d.strideDepth,m=d.strideHeight,x=d.strideWidth,R=d.dilationDepth,$=d.dilationHeight,j=d.dilationWidth,ce=d.effectiveFilterDepth,fe=d.effectiveFilterHeight,je=d.effectiveFilterWidth,ze=d.padInfo.front,nt=d.padInfo.top,Rt=d.padInfo.left;for(let bt=0;bt<d.batchSize;++bt)for(let xt=0;xt<d.inChannels;++xt)for(let Pt=0;Pt<d.outDepth;++Pt){const St=Pt*p-ze;let Ut=St;for(;Ut<0;)Ut+=R;const Ft=Math.min(d.inDepth,ce+St);for(let sn=0;sn<d.outHeight;++sn){const _n=sn*m-nt;let Cn=_n;for(;Cn<0;)Cn+=$;const Bn=Math.min(d.inHeight,fe+_n);for(let Vn=0;Vn<d.outWidth;++Vn){const es=Vn*x-Rt;let ls=es;for(;ls<0;)ls+=j;const Cs=Math.min(d.inWidth,je+es);let rs=Number.NEGATIVE_INFINITY,hs=-1;for(let ms=Ut;ms<Ft;ms+=R){const _s=ms-St;for(let Ds=Cn;Ds<Bn;Ds+=$){const ds=Ds-_n;for(let ys=ls;ys<Cs;ys+=j){const Ns=ys-es,Ls=u.get(bt,ms,Ds,ys,xt);Ls>=rs&&(rs=Ls,hs=_s*fe*je+ds*fe+Ns)}}}o.set(hs,bt,Pt,sn,Vn,xt)}}}return o}(o.bufferSync(x),fe),nt=fe.strideDepth,Rt=fe.strideHeight,bt=fe.strideWidth,xt=fe.dilationDepth,Pt=fe.dilationHeight,St=fe.dilationWidth,Ut=fe.effectiveFilterDepth,Ft=fe.effectiveFilterHeight,sn=fe.effectiveFilterWidth,_n=Ut-1-fe.padInfo.front,Cn=sn-1-fe.padInfo.left,Bn=Ft-1-fe.padInfo.top,Vn=(0,l.f3b)(x.shape,"float32"),es=o.bufferSync(m);for(let ls=0;ls<fe.batchSize;++ls)for(let Cs=0;Cs<fe.inChannels;++Cs)for(let rs=0;rs<fe.inDepth;++rs)for(let hs=0;hs<fe.inHeight;++hs)for(let ms=0;ms<fe.inWidth;++ms){const _s=rs-_n,Ds=hs-Bn,ds=ms-Cn;let ys=0;for(let Ns=0;Ns<Ut;Ns+=xt){const Ls=(_s+Ns)/nt;if(!(Ls<0||Ls>=fe.outDepth||Math.floor(Ls)!==Ls))for(let nr=0;nr<Ft;nr+=Pt){const Vs=(Ds+nr)/Rt;if(!(Vs<0||Vs>=fe.outHeight||Math.floor(Vs)!==Vs))for(let gr=0;gr<sn;gr+=St){const rr=(ds+gr)/bt;if(rr<0||rr>=fe.outWidth||Math.floor(rr)!==rr)continue;const bi=Ut*Ft*sn-1-ze.get(ls,Ls,Vs,rr,Cs)===Ns*Ft*sn+nr*sn+gr?1:0;0!==bi&&(ys+=es.get(ls,Ls,Vs,rr,Cs)*bi)}}}Vn.set(ys,ls,rs,hs,ms,Cs)}return o.makeTensorInfo(Vn.shape,Vn.dtype,Vn.values)}},MA={kernelName:l.OV7,backendName:"cpu",kernelFunc:function bs(u){const{inputs:d,backend:o,attrs:p}=u,{dy:m,input:x,output:R}=d,$=x;(0,ni.H)([x,R],"maxPoolGrad");const{filterSize:j,strides:ce,pad:fe,dimRoundingMode:je}=p,ze=l.backend_util.computePool2DInfo($.shape,j,ce,1,fe,je),nt=o.data.get($.dataId).values,Rt=(0,l.f3b)(ze.outShape,$.dtype,U1(nt,$.shape,$.dtype,ze).values),bt=ze.strideHeight,xt=ze.strideWidth,Pt=ze.dilationHeight,St=ze.dilationWidth,Ut=ze.effectiveFilterHeight,Ft=ze.effectiveFilterWidth,sn=Ft-1-ze.padInfo.left,_n=Ut-1-ze.padInfo.top,Cn=(0,l.f3b)($.shape,"float32"),Bn=o.data.get(m.dataId).values,Vn=(0,l.f3b)(m.shape,"float32",Bn);for(let es=0;es<ze.batchSize;++es)for(let ls=0;ls<ze.inChannels;++ls)for(let Cs=0;Cs<ze.inHeight;++Cs)for(let rs=0;rs<ze.inWidth;++rs){const hs=Cs-_n,ms=rs-sn;let _s=0;for(let Ds=0;Ds<Ut;Ds+=Pt){const ds=(hs+Ds)/bt;if(!(ds<0||ds>=ze.outHeight||Math.floor(ds)!==ds))for(let ys=0;ys<Ft;ys+=St){const Ns=(ms+ys)/xt;if(Ns<0||Ns>=ze.outWidth||Math.floor(Ns)!==Ns)continue;const Vs=Ut*Ft-1-Rt.get(es,ds,Ns,ls)===Ds*Ft+ys?1:0;0!==Vs&&(_s+=Vn.get(es,ds,Ns,ls)*Vs)}}Cn.set(_s,es,Cs,rs,ls)}return o.makeTensorInfo(Cn.shape,Cn.dtype,Cn.values)}},ri={kernelName:l.vFR,backendName:"cpu",kernelFunc:({inputs:u,attrs:d,backend:o})=>{const{x:p}=u,{filterSize:m,strides:x,pad:R,includeBatchInIndex:$}=d,j=o;(0,ni.H)(p,"MaxPoolWithArgmax");const ce=j.data.get(p.dataId).values,fe=l.backend_util.computePool2DInfo(p.shape,m,x,[1,1],R),[je,ze]=function Pl(u,d,o,p,m){const R=Ay(u,0,o,l.D5U.computeStrides(d),m,"max"),$=U1(u,d,o,m,!0,p);return[R.values,$.values]}(ce,p.shape,p.dtype,$,fe),nt=j.write(je,fe.outShape,p.dtype),Rt=j.write(ze,fe.outShape,p.dtype);return[{dataId:nt,shape:fe.outShape,dtype:p.dtype},{dataId:Rt,shape:fe.outShape,dtype:"int32"}]}},hw={kernelName:l.q2K,backendName:"cpu",kernelFunc:function Hv(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x,keepDims:R}=p,$=l.D5U.parseAxisParam(x,m.shape),ce=l.backend_util.computeOutAndReduceShapes(m.shape,$)[1],fe=l.D5U.sizeFromShape(ce),je=[],ze=o.makeTensorInfo([],"float32",new Float32Array([fe]));je.push(ze);const nt=(0,Ry.pj)({inputs:{x:m},backend:o,attrs:{dtype:"float32"}});je.push(nt);const Rt=rw({inputs:{a:nt,b:ze},backend:o});je.push(Rt);const bt=si({inputs:{x:Rt},backend:o,attrs:{axis:x,keepDims:R}});return je.forEach(xt=>o.disposeIntermediateTensorInfo(xt)),bt}},SE={kernelName:l.c17,backendName:"cpu",kernelFunc:function DE(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{axis:x,keepDims:R}=p;(0,ni.H)(m,"min");const $=l.D5U.parseAxisParam(x,m.shape);let j=$;const ce=l.backend_util.getAxesPermutation(j,m.shape.length);let fe=m;null!=ce&&(fe=(0,ud.p)({inputs:{x:m},backend:o,attrs:{perm:ce}}),j=l.backend_util.getInnerMostAxes(j.length,m.shape.length)),l.backend_util.assertAxesAreInnerMostDims("min",j,fe.shape.length);const[je,ze]=l.backend_util.computeOutAndReduceShapes(fe.shape,j),nt=l.D5U.sizeFromShape(ze),Rt=l.D5U.makeZerosTypedArray(l.D5U.sizeFromShape(je),fe.dtype),bt=o.data.get(fe.dataId).values;for(let Pt=0;Pt<Rt.length;++Pt){const St=Pt*nt;let Ut=bt[St];for(let Ft=0;Ft<nt;++Ft){const sn=bt[St+Ft];(Number.isNaN(sn)||sn<Ut)&&(Ut=sn)}Rt[Pt]=Ut}null!=ce&&o.disposeIntermediateTensorInfo(fe);const xt=o.makeTensorInfo(je,fe.dtype,Rt);if(R){const St=Ja({inputs:{x:xt},backend:o,attrs:{shape:l.backend_util.expandShapeToKeepDim(je,$)}});return o.disposeIntermediateTensorInfo(xt),St}return xt}};var IE=h(8170);const AE={kernelName:l.jQs,backendName:"cpu",kernelFunc:function TE(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{paddings:x,mode:R}=p;(0,ni.H)(m,"mirrorPad");const $=x.map((Ut,Ft)=>Ut[0]+m.shape[Ft]+Ut[1]),j=x.map(Ut=>Ut[0]),ce=x.map((Ut,Ft)=>Ut[0]+m.shape[Ft]),fe="reflect"===R?0:1,je=o.data.get(m.dataId).values,ze=m.shape.length,nt=l.D5U.computeStrides(m.shape),Rt=l.D5U.sizeFromShape($),bt=$.length,xt=l.D5U.computeStrides($),Pt=l.D5U.getTypedArrayFromDType(m.dtype,Rt);for(let Ut=0;Ut<Rt;Ut++){let Ft=l.D5U.indexToLoc(Ut,bt,xt);for(let _n=0;_n<bt;_n++)Ft[_n]<j[_n]?Ft[_n]=2*j[_n]-Ft[_n]-fe:Ft[_n]>=ce[_n]&&(Ft[_n]=2*(ce[_n]-1)-Ft[_n]+fe);Ft=Ft.map((_n,Cn)=>_n-j[Cn]);const sn=l.D5U.locToIndex(Ft,ze,nt);Pt[Ut]=je[sn]}return{dataId:o.write(Pt,$,m.dtype),shape:$,dtype:m.dtype}}},kE=(0,If.b)((u,d)=>{const o=u%d;return u<0&&d<0||u>=0&&d>=0?o:(o+d)%d}),OE=(0,Wg.j)(l.Vbg,kE),RE={kernelName:l.Vbg,backendName:"cpu",kernelFunc:OE};function Vy(u){const{inputs:d,backend:o,attrs:p}=u,{logits:m}=d,{dim:x}=p,R=m.shape.length;let $=x;if(-1===$&&($=R-1),$!==R-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${R} and dim was ${$}`);const j=l.D5U.parseAxisParam([$],m.shape),ce=iu({inputs:{x:m},backend:o,attrs:{reductionIndices:j,keepDims:!1}}),fe=l.backend_util.expandShapeToKeepDim(ce.shape,j),je=Ja({inputs:{x:ce},backend:o,attrs:{shape:fe}}),ze=(0,dE.lu)({inputs:{a:m,b:je},backend:o}),nt=(0,nw.Qq)({inputs:{x:ze},backend:o}),Rt=si({inputs:{x:nt},backend:o,attrs:{axis:j,keepDims:!1}}),bt=Ja({inputs:{x:Rt},backend:o,attrs:{shape:fe}}),xt=rw({inputs:{a:nt,b:bt},backend:o});return o.disposeIntermediateTensorInfo(ce),o.disposeIntermediateTensorInfo(je),o.disposeIntermediateTensorInfo(ze),o.disposeIntermediateTensorInfo(nt),o.disposeIntermediateTensorInfo(Rt),o.disposeIntermediateTensorInfo(bt),xt}const kf={kernelName:l.Gcp,backendName:"cpu",kernelFunc:Vy},FA={kernelName:l.NZg,backendName:"cpu",kernelFunc:function PA(u){const{inputs:d,backend:o,attrs:p}=u,{logits:m}=d,{numSamples:x,seed:R,normalized:$}=p;(0,ni.H)(m,"multinomial");const j=$?m:Vy({inputs:{logits:m},backend:o,attrs:{dim:-1}}),ce=j.shape[0],fe=j.shape[1],je=o.data.get(j.dataId).values,ze=[ce,x],nt=l.D5U.makeZerosTypedArray(l.D5U.sizeFromShape(ze),"int32");for(let Rt=0;Rt<ce;++Rt){const bt=Rt*fe,xt=new Float32Array(fe-1);xt[0]=je[bt];for(let Ut=1;Ut<xt.length;++Ut)xt[Ut]=xt[Ut-1]+je[bt+Ut];const Pt=Zu.alea(R.toString()),St=Rt*x;for(let Ut=0;Ut<x;++Ut){const Ft=Pt();nt[St+Ut]=xt.length;for(let sn=0;sn<xt.length;sn++)if(Ft<xt[sn]){nt[St+Ut]=sn;break}}}return $||o.disposeIntermediateTensorInfo(j),o.makeTensorInfo(ze,"int32",nt)}};var pw=h(9994);const Tm=l.GDt.nonMaxSuppressionV3Impl,LA={kernelName:l.uv1,backendName:"cpu",kernelFunc:function fw(u){const{inputs:d,backend:o,attrs:p}=u,{boxes:m,scores:x}=d,{maxOutputSize:R,iouThreshold:$,scoreThreshold:j}=p;(0,ni.H)(m,"NonMaxSuppression");const ce=o.data.get(m.dataId).values,fe=o.data.get(x.dataId).values,{selectedIndices:je}=Tm(ce,fe,R,$,j);return o.makeTensorInfo([je.length],"int32",new Int32Array(je))}},mw=l.GDt.nonMaxSuppressionV4Impl,fM={kernelName:l.cye,backendName:"cpu",kernelFunc:function pM(u){const{inputs:d,backend:o,attrs:p}=u,{boxes:m,scores:x}=d,{maxOutputSize:R,iouThreshold:$,scoreThreshold:j,padToMaxOutputSize:ce}=p;(0,ni.H)(m,"NonMaxSuppressionPadded");const fe=o.data.get(m.dataId).values,je=o.data.get(x.dataId).values,{selectedIndices:ze,validOutputs:nt}=mw(fe,je,R,$,j,ce);return[o.makeTensorInfo([ze.length],"int32",new Int32Array(ze)),o.makeTensorInfo([],"int32",new Int32Array([nt]))]}},$A=l.GDt.nonMaxSuppressionV5Impl,NE={kernelName:l.W0H,backendName:"cpu",kernelFunc:function BA(u){const{inputs:d,backend:o,attrs:p}=u,{boxes:m,scores:x}=d,{maxOutputSize:R,iouThreshold:$,scoreThreshold:j,softNmsSigma:ce}=p;(0,ni.H)(m,"NonMaxSuppressionWithScore");const fe=o.data.get(m.dataId).values,je=o.data.get(x.dataId).values,ze=R,nt=$,Rt=j,bt=ce,{selectedIndices:xt,selectedScores:Pt}=$A(fe,je,ze,nt,Rt,bt);return[o.makeTensorInfo([xt.length],"int32",new Int32Array(xt)),o.makeTensorInfo([Pt.length],"float32",new Float32Array(Pt))]}};var VA=h(7555);const ME={kernelName:l.we_,backendName:"cpu",kernelFunc:function ou(u){const{inputs:d,backend:o,attrs:p}=u,{indices:m}=d,{dtype:x,depth:R,onValue:$,offValue:j}=p;(0,ni.H)(m,"oneHot");const ce=l.D5U.sizeFromShape(m.shape),fe=new Float32Array(ce*R);fe.fill(j);const je=o.data.get(m.dataId).values;for(let ze=0;ze<ce;++ze)je[ze]>=0&&je[ze]<R&&(fe[ze*R+je[ze]]=$);return o.makeTensorInfo([...m.shape,R],x,fe)}};function jv(u){const{inputs:d,backend:o}=u,{x:p}=d;if("string"===p.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===p.dtype){const m=(0,ip.k)({inputs:{input:p},backend:o}),x=jv({inputs:{x:m},backend:o}),R=Em({inputs:{input:p},backend:o}),$=jv({inputs:{x:R},backend:o}),j=(0,sh.P)({inputs:{real:x,imag:$},backend:o});return o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo($),j}return ow({backend:o,attrs:{shape:p.shape,value:0,dtype:p.dtype}})}const UA={kernelName:l.RuY,backendName:"cpu",kernelFunc:jv},zA={kernelName:l.qWM,backendName:"cpu",kernelFunc:function gw(u){const{inputs:d,backend:o}=u,{x:p}=d;if("string"===p.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===p.dtype){const m=(0,ip.k)({inputs:{input:p},backend:o}),x=gw({inputs:{x:m},backend:o}),R=Em({inputs:{input:p},backend:o}),$=jv({inputs:{x:R},backend:o}),j=(0,sh.P)({inputs:{real:x,imag:$},backend:o});return o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo($),j}return ow({backend:o,attrs:{shape:p.shape,value:1,dtype:p.dtype}})}};function _w(u){const{inputs:d,backend:o,attrs:p}=u,{axis:m}=p;if(1===d.length)return Py({inputs:{input:d[0]},backend:o,attrs:{dim:m}});const x=d[0].shape,R=d[0].dtype;d.forEach(fe=>{l.D5U.assertShapesMatch(x,fe.shape,"All tensors passed to stack must have matching shapes"),l.D5U.assert(R===fe.dtype,()=>"All tensors passed to stack must have matching dtypes")});const $=[],ce=Hg({inputs:d.map(fe=>{const je=Py({inputs:{input:fe},backend:o,attrs:{dim:m}});return $.push(je),je}),backend:o,attrs:{axis:m}});return $.forEach(fe=>o.disposeIntermediateTensorInfo(fe)),ce}const PE={kernelName:l.QiL,backendName:"cpu",kernelFunc:_w},FE={kernelName:l.lyA,backendName:"cpu",kernelFunc:function qg(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{paddings:x,constantValue:R}=p;(0,ni.H)(m,"pad");const $=x.map((St,Ut)=>St[0]+m.shape[Ut]+St[1]),j=x.map(St=>St[0]),ce=o.data.get(m.dataId).values,fe=l.D5U.sizeFromShape(m.shape),je=m.shape.length,ze=l.D5U.computeStrides(m.shape),nt=l.D5U.sizeFromShape($),Rt=$.length,bt=l.D5U.computeStrides($),xt=l.D5U.getTypedArrayFromDType(m.dtype,nt);0!==R&&xt.fill(R);for(let St=0;St<fe;St++){const Ft=l.D5U.indexToLoc(St,je,ze).map((_n,Cn)=>_n+j[Cn]);xt[l.D5U.locToIndex(Ft,Rt,bt)]=ce[St]}return{dataId:o.write(xt,$,m.dtype),shape:$,dtype:m.dtype}}},WA=(0,If.b)((u,d)=>Math.pow(u,d)),LE=(0,Wg.j)(l.pe_,WA),HA={kernelName:l.pe_,backendName:"cpu",kernelFunc:LE};var $E=h(2585),mM=h(6134);const Ei={kernelName:l.dDz,backendName:"cpu",kernelFunc:function Ju(u){const{inputs:d,backend:o,attrs:p}=u,{paramsNestedSplits:m,paramsDenseValues:x,indices:R}=d,{outputRaggedRank:$}=p,j=m.map(Pt=>o.data.get(Pt.dataId).values),ce=m.map(Pt=>Pt.shape),fe=o.data.get(x.dataId).values,je=o.data.get(R.dataId).values,[ze,nt,Rt]=(0,mM.c)(j,ce,fe,x.shape,x.dtype,je,R.shape,$),bt=ze.map(Pt=>o.makeTensorInfo([Pt.length],"int32",Pt)),xt=o.makeTensorInfo(Rt,x.dtype,nt);return bt.concat([xt])}};var ap=h(832);const BE={kernelName:l.CQl,backendName:"cpu",kernelFunc:function jA(u){const{inputs:d,backend:o}=u,{starts:p,limits:m,deltas:x}=d,R=o.data.get(p.dataId).values,$=o.data.get(m.dataId).values,j=o.data.get(x.dataId).values,[ce,fe]=(0,ap.S)(R,p.shape,p.dtype,$,m.shape,j,x.shape);return[o.makeTensorInfo([ce.length],"int32",ce),o.makeTensorInfo([fe.length],p.dtype,fe)]}};var lp=h(820);const Sh={kernelName:l.BiW,backendName:"cpu",kernelFunc:function Dh(u){const{inputs:d,backend:o,attrs:p}=u,{shape:m,values:x,defaultValue:R,rowPartitionTensors:$}=d,{rowPartitionTypes:j}=p,ce=o.data.get(m.dataId).values,fe=o.data.get(x.dataId).values,je=o.data.get(R.dataId).values,ze=$.map(xt=>o.data.get(xt.dataId).values),nt=$.map(xt=>xt.shape),[Rt,bt]=(0,lp.p)(ce,m.shape,fe,x.shape,x.dtype,je,R.shape,ze,nt,j);return o.makeTensorInfo(Rt,x.dtype,bt)}};var VE=h(6229);const GA={kernelName:l.e6w,backendName:"cpu",kernelFunc:function UE(u){const{backend:d,attrs:o}=u,{start:p,stop:m,dtype:x,step:R}=o,$=(0,VE.b)(p,m,R,x);return d.makeTensorInfo([$.length],x,$)}},KA=(0,Qa.A)(l.$HU,u=>1/u),XA={kernelName:l.$HU,backendName:"cpu",kernelFunc:KA},yw={kernelName:l._Yw,backendName:"cpu",kernelFunc:function YA(u){const{inputs:d,backend:o,attrs:p}=u,{images:m}=d,{alignCorners:x,halfPixelCenters:R,size:$}=p;(0,ni.H)(m,"resizeBilinear");const j=l.D5U.computeStrides(m.shape),[ce,fe]=$,[je,ze,nt,Rt]=m.shape,bt=o.data.get(m.dataId).values,xt=new Float32Array(l.D5U.sizeFromShape([je,ce,fe,Rt])),Pt=[x&&ce>1?ze-1:ze,x&&fe>1?nt-1:nt],St=[x&&ce>1?ce-1:ce,x&&fe>1?fe-1:fe];let Ut=0;const Ft=Pt[0]/St[0],sn=Pt[1]/St[1];for(let _n=0;_n<je;_n++)for(let Cn=0;Cn<ce;Cn++){let Bn;Bn=R?Ft*(Cn+.5)-.5:Ft*Cn;const Vn=Math.max(0,Math.floor(Bn)),es=Bn-Vn,ls=Math.min(ze-1,Math.ceil(Bn)),Cs=_n*j[0]+Vn*j[1],rs=_n*j[0]+ls*j[1];for(let hs=0;hs<fe;hs++){let ms;ms=R?sn*(hs+.5)-.5:sn*hs;const _s=Math.max(0,Math.floor(ms)),Ds=ms-_s,ds=Math.min(nt-1,Math.ceil(ms)),ys=Cs+_s*j[2],Ns=rs+_s*j[2],Ls=Cs+ds*j[2],nr=rs+ds*j[2];for(let Vs=0;Vs<Rt;Vs++){const gr=bt[ys+Vs],rr=bt[Ns+Vs],bi=gr+(bt[Ls+Vs]-gr)*Ds;xt[Ut++]=bi+(rr+(bt[nr+Vs]-rr)*Ds-bi)*es}}}return o.makeTensorInfo([je,ce,fe,Rt],"float32",xt)}},ZA={kernelName:l.zbQ,backendName:"cpu",kernelFunc:function Uy(u){const{inputs:d,backend:o,attrs:p}=u,{images:m,dy:x}=d,{alignCorners:R}=p;(0,ni.H)([x,m],"resizeBilinearGrad");const $=l.D5U.computeStrides(m.shape),[j,ce,fe,je]=m.shape,[,ze,nt]=x.shape,Rt=new Float32Array(j*ce*fe*je),bt=[R&&ze>1?ce-1:ce,R&&nt>1?fe-1:fe],xt=[R&&ze>1?ze-1:ze,R&&nt>1?nt-1:nt],Pt=bt[0]/xt[0],St=bt[1]/xt[1],Ut=o.data.get(x.dataId).values;let Ft=0;for(let sn=0;sn<j;sn++){const _n=sn*$[0];for(let Cn=0;Cn<ze;Cn++){const Bn=Cn*Pt,Vn=Math.floor(Bn),es=Math.min(Math.ceil(Bn),ce-1),ls=_n+Vn*$[1],Cs=_n+es*$[1],rs=Bn-Vn,hs=1-rs;for(let ms=0;ms<nt;ms++){const _s=ms*St,Ds=Math.floor(_s),ds=Math.min(Math.ceil(_s),fe-1),ys=_s-Ds,Ns=1-ys,Ls=ls+Ds*$[2],nr=ls+ds*$[2],Vs=Cs+Ds*$[2],gr=Cs+ds*$[2],rr=hs*Ns,Lr=hs*ys,oi=rs*Ns,bi=rs*ys;for(let fi=0;fi<je;fi++){const qi=Ut[Ft++];Rt[Ls+fi]+=qi*rr,Rt[nr+fi]+=qi*Lr,Rt[Vs+fi]+=qi*oi,Rt[gr+fi]+=qi*bi}}}}return o.makeTensorInfo([j,fe,ce,je],"float32",Rt)}},QA={kernelName:l.dpD,backendName:"cpu",kernelFunc:function zE(u){const{inputs:d,backend:o,attrs:p}=u,{images:m}=d,{alignCorners:x,halfPixelCenters:R,size:$}=p;(0,ni.H)(m,"resizeNearestNeighbor");const j=l.D5U.computeStrides(m.shape),[ce,fe]=$,[je,ze,nt,Rt]=m.shape,bt=o.data.get(m.dataId).values,xt=new Float32Array(je*ce*fe*Rt),Pt=[x&&ce>1?ze-1:ze,x&&fe>1?nt-1:nt],St=[x&&ce>1?ce-1:ce,x&&fe>1?fe-1:fe],Ut=Pt[0]/St[0],Ft=Pt[1]/St[1];let sn=0;for(let _n=0;_n<je;_n++){const Cn=_n*j[0];for(let Bn=0;Bn<ce;Bn++){const Vn=R?Ut*(Bn+.5):Ut*Bn;let es=Math.min(ze-1,x?Math.round(Vn):Math.floor(Vn));R&&(es=Math.max(0,es));const ls=Cn+es*j[1];for(let Cs=0;Cs<fe;Cs++){const rs=R?Ft*(Cs+.5):Ft*Cs;let hs=Math.min(nt-1,x?Math.round(rs):Math.floor(rs));R&&(hs=Math.max(0,hs));const ms=ls+hs*j[2];for(let _s=0;_s<Rt;_s++)xt[sn++]=bt[ms+_s]}}}return o.makeTensorInfo([je,ce,fe,Rt],m.dtype,xt)}},WE={kernelName:l.Hmb,backendName:"cpu",kernelFunc:function JA(u){const{inputs:d,backend:o,attrs:p}=u,{images:m,dy:x}=d,{alignCorners:R}=p;(0,ni.H)([x,m],"resizeNearestNeighborGrad");const $=l.D5U.computeStrides(m.shape),j=l.D5U.computeStrides(x.shape),[ce,fe,je,ze]=m.shape,[,nt,Rt]=x.shape,bt=new Float32Array(ce*fe*je*ze),xt=o.data.get(x.dataId).values,Pt=[R&&nt>1?fe-1:fe,R&&Rt>1?je-1:je],St=[R&&nt>1?nt-1:nt,R&&Rt>1?Rt-1:Rt],Ut=Pt[0]/St[0],Ft=Pt[1]/St[1],sn=1/Ut,_n=1/Ft,Cn=2*Math.ceil(sn)+2,Bn=2*Math.ceil(_n)+2;for(let Vn=0;Vn<ce;Vn++){const es=Vn*$[0];for(let ls=0;ls<fe;ls++){const Cs=es+ls*$[1],rs=Math.floor(ls*sn),hs=Math.floor(rs-Cn/2);for(let ms=0;ms<je;ms++){const _s=Cs+ms*$[2],Ds=Math.floor(ms*_n),ds=Math.floor(Ds-Bn/2);for(let ys=0;ys<ze;ys++){let Ns=0;for(let Ls=0;Ls<Cn;Ls++){const nr=Ls+hs;if(nr<0||nr>=nt)continue;const Vs=es+nr*j[1],gr=nr*Ut;if(ls===Math.min(fe-1,R?Math.round(gr):Math.floor(gr)))for(let Lr=0;Lr<Bn;Lr++){const oi=Lr+ds;if(oi<0||oi>=Rt)continue;const bi=Vs+oi*j[2],fi=oi*Ft;ms===Math.min(je-1,R?Math.round(fi):Math.floor(fi))&&(Ns+=xt[bi+ys])}}bt[_s+ys]=Ns}}}}return o.makeTensorInfo(m.shape,m.dtype,bt)}},Gv={kernelName:l.mKl,backendName:"cpu",kernelFunc:function HE(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{dims:x}=p;(0,ni.H)(m,"reverse");const R=m.shape.length,$=l.D5U.parseAxisParam(x,m.shape);if(0===R)return(0,Up.y)({inputs:{x:m},backend:o});const j=new l.YDk(m.shape,m.dtype),ce=o.bufferSync(m);for(let fe=0;fe<j.size;fe++){const je=j.indexToLoc(fe),ze=je.slice();$.forEach(nt=>ze[nt]=m.shape[nt]-1-ze[nt]),j.set(ce.get(...ze),...je)}return o.makeTensorInfo(j.shape,j.dtype,j.values)}},qA={kernelName:l.b9H,backendName:"cpu",kernelFunc:({inputs:u,attrs:d,backend:o})=>{const{image:p}=u,{radians:m,fillValue:x,center:R}=d,$=o,j=l.D5U.getTypedArrayFromDType(p.dtype,l.D5U.sizeFromShape(p.shape)),[ce,fe,je,ze]=p.shape,[nt,Rt]=l.backend_util.getImageCenter(R,fe,je),xt=Math.sin(m),Pt=Math.cos(m),St=$.data.get(p.dataId).values;for(let Ft=0;Ft<ce;Ft++){const sn=Ft*je*fe*ze;for(let _n=0;_n<fe;_n++){const Cn=_n*(je*ze);for(let Bn=0;Bn<je;Bn++){const Vn=Bn*ze;for(let es=0;es<ze;es++){const ls=[ce,_n,Bn,es],Cs=ls[2],rs=ls[1];let hs=(Cs-nt)*Pt-(rs-Rt)*xt,ms=(Cs-nt)*xt+(rs-Rt)*Pt;hs=Math.round(hs+nt),ms=Math.round(ms+Rt);let _s=x;"number"!=typeof x&&(_s=3===es?255:x[es]),hs>=0&&hs<je&&ms>=0&&ms<fe&&(_s=St[sn+ms*(je*ze)+hs*ze+es]),j[sn+Cn+Vn+es]=_s}}}}return{dataId:$.write(j,p.shape,p.dtype),shape:p.shape,dtype:p.dtype}}},jE=(0,Qa.A)(l.e07,u=>{const d=Math.floor(u);return u-d<.5?Math.floor(u):u-d>.5?Math.ceil(u):d%2==0?d:d+1}),Ys={kernelName:l.e07,backendName:"cpu",kernelFunc:jE};var GE=h(1509),e_=h(2529);const zu={kernelName:l.xQA,backendName:"cpu",kernelFunc:function ek(u){const{inputs:d,backend:o,attrs:p}=u,{indices:m,updates:x}=d,{shape:R}=p,{sliceRank:$,numUpdates:j,sliceSize:ce,strides:fe,outputSize:je}=l.backend_util.calculateShapes(x,m,R),nt=o.bufferSync(m),Rt=o.bufferSync(x),bt=(0,e_.N)(nt,Rt,R,je,ce,j,$,fe,0,!0);return o.makeTensorInfo(R,bt.dtype,bt.values)}};function pd(u,d){let o=0,p=u.length,m=0;for(;o<p;)m=Math.floor((o+p)/2),u[m]<d?o=m+1:p=m;return p}function Kv(u,d){let o=0,p=u.length,m=0;for(;o<p;)m=Math.floor((o+p)/2),u[m]<=d?o=m+1:p=m;return p}const YE={kernelName:l.nr8,backendName:"cpu",kernelFunc:function XE(u){const{inputs:d,backend:o,attrs:p}=u,{sortedSequence:m,values:x}=d,{side:R}=p,ce=function KE(u,d,o,p,m,x){const R=l.D5U.getArrayFromDType("int32",o*m);for(let $=0;$<o;++$){const j=u.slice($*p,($+1)*p),ce=$*m;for(let fe=0;fe<m;++fe)R[ce+fe]="left"===x?pd(j,d[fe+ce]):Kv(j,d[fe+ce])}return R}(o.data.get(m.dataId).values,o.data.get(x.dataId).values,m.shape[0],m.shape[1],x.shape[1],R);return o.makeTensorInfo(x.shape,"int32",ce)}},QE={kernelName:l.PhF,backendName:"cpu",kernelFunc:function ZE(u){const{inputs:d,backend:o}=u,{condition:p,t:m,e:x}=d;(0,ni.H)([p,m,x],"select");const R=p.shape.length,$=o.data.get(p.dataId).values,j=o.data.get(m.dataId).values,ce=o.data.get(x.dataId).values,fe=(0,l.x8V)(m.dtype,x.dtype),je=l.D5U.makeZerosTypedArray(l.D5U.sizeFromShape(m.shape),fe);let ze=0;const nt=0===R||R>1||1===m.shape.length?1:l.D5U.sizeFromShape(m.shape.slice(1));for(let Rt=0;Rt<$.length;Rt++)for(let bt=0;bt<nt;bt++)je[ze++]=1===$[Rt]?j[Rt]:ce[Rt];return o.makeTensorInfo(m.shape,fe,je)}},JE=l.backend_util.SELU_SCALEALPHA,qE=l.backend_util.SELU_SCALE,eD=(0,Qa.A)(l.oFR,u=>u>=0?qE*u:JE*(Math.exp(u)-1)),tk={kernelName:l.oFR,backendName:"cpu",kernelFunc:eD},nk=(0,Qa.A)(l.i5y,u=>u<0?-1:u>0?1:0),sk={kernelName:l.i5y,backendName:"cpu",kernelFunc:nk},rk=(0,Qa.A)(l.RQH,u=>Math.sin(u)),ik={kernelName:l.RQH,backendName:"cpu",kernelFunc:rk},ok=(0,Qa.A)(l.wYB,u=>Math.sinh(u)),ak={kernelName:l.wYB,backendName:"cpu",kernelFunc:ok},tD=Math.log(1.1920928955078125e-7)+2,lk=(0,Qa.A)(l.MRv,u=>{const d=u>-tD,o=u<tD,p=Math.exp(u);let m;return m=o?p:d?u:Math.log(1+p),m}),ck={kernelName:l.MRv,backendName:"cpu",kernelFunc:lk},dk={kernelName:l.TQc,backendName:"cpu",kernelFunc:function uk(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{blockShape:x,paddings:R}=p;(0,ni.H)([m],"spaceToBatchND");const $=l.D5U.sizeFromShape(x),j=[[0,0]];j.push(...R);for(let _n=1+x.length;_n<m.shape.length;++_n)j.push([0,0]);const ce=FE.kernelFunc({inputs:{x:m},backend:o,attrs:{paddings:j,constantValue:0}}),fe=l.backend_util.getReshaped(ce.shape,x,$,!1),je=l.backend_util.getPermuted(fe.length,x.length,!1),ze=l.backend_util.getReshapedPermuted(ce.shape,x,$,!1),bt=Ja({inputs:{x:ce},backend:o,attrs:{shape:fe}}),St=(0,ud.p)({inputs:{x:bt},backend:o,attrs:{perm:je}}),sn=Ja({inputs:{x:St},backend:o,attrs:{shape:ze}});return o.disposeIntermediateTensorInfo(ce),o.disposeIntermediateTensorInfo(bt),o.disposeIntermediateTensorInfo(St),sn}};var hk=h(5483);const fk={kernelName:l.O3z,backendName:"cpu",kernelFunc:function pk(u){const{inputs:d,backend:o}=u,{indices:p,values:m,denseShape:x,defaultValue:R}=d;if(1!==x.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${x.shape}`);if(2!==p.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${p.shape}`);if(1!==m.shape.length)throw new Error(`Values must be a vector, saw:\n        ${m.shape}`);if(0!==R.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${R.shape}`);const $=o.data.get(p.dataId).values,j=o.data.get(m.dataId).values,ce=o.data.get(x.dataId).values,fe=o.data.get(R.dataId).values[0],[je,ze,nt,Rt,bt]=(0,hk.c)($,p.shape,p.dtype,j,m.dtype,ce,fe);return[o.makeTensorInfo(ze,p.dtype,je),o.makeTensorInfo([ze[0]],m.dtype,nt),o.makeTensorInfo([Rt.length],"bool",new Uint8Array(Rt.map(xt=>Number(xt)))),o.makeTensorInfo([bt.length],p.dtype,new Int32Array(bt))]}};var mk=h(9912);const sD={kernelName:l.nhH,backendName:"cpu",kernelFunc:function nD(u){const{inputs:d,backend:o}=u,{inputIndices:p,inputShape:m,newShape:x}=d;if(2!==p.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${p.shape}`);if(1!==m.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${m.shape}`);if(1!==x.shape.length)throw new Error(`Target shape should be a vector but received shape ${x.shape}`);const R=Array.from(o.data.get(m.dataId).values),$=o.data.get(p.dataId).values,j=Array.from(o.data.get(x.dataId).values),[ce,fe,je]=(0,mk.U)($,p.shape,p.dtype,R,j);return[o.makeTensorInfo(fe,p.dtype,ce),o.makeTensorInfo([je.length],x.dtype,new Int32Array(je))]}};var vw=h(391);const iD={kernelName:l.w3H,backendName:"cpu",kernelFunc:function rD(u){const{inputs:d,backend:o}=u,{data:p,indices:m,segmentIds:x}=d;if(p.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==m.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${m.shape}`);if(1!==x.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${x.shape}`);if(m.shape[0]!==x.shape[0])throw new Error("segmentIds and indices should have same size.");const R=o.data.get(p.dataId).values,$=o.data.get(m.dataId).values,j=o.data.get(x.dataId).values,[ce,fe]=(0,vw.V)(R,p.shape,p.dtype,$,j,!0);return o.makeTensorInfo(fe,p.dtype,ce)}},aD={kernelName:l.ZjV,backendName:"cpu",kernelFunc:function oD(u){const{inputs:d,backend:o}=u,{data:p,indices:m,segmentIds:x}=d;if(p.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==m.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${m.shape}`);if(1!==x.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${x.shape}`);if(m.shape[0]!==x.shape[0])throw new Error("segmentIds and indices should have same size.");const R=o.data.get(p.dataId).values,$=o.data.get(m.dataId).values,j=o.data.get(x.dataId).values,[ce,fe]=(0,vw.V)(R,p.shape,p.dtype,$,j);return o.makeTensorInfo(fe,p.dtype,ce)}},cD={kernelName:l.D2d,backendName:"cpu",kernelFunc:function lD(u){const{inputs:d,backend:o,attrs:p}=u,{sparseIndices:m,sparseValues:x,defaultValue:R}=d,{outputShape:$}=p,{sliceRank:j,numUpdates:ce,sliceSize:fe,strides:je,outputSize:ze}=l.backend_util.calculateShapes(x,m,$),nt=!1,Rt=o.bufferSync(m);let bt;switch(x.dtype){case"bool":{const xt=o.bufferSync(x),Pt=!!o.data.get(R.dataId).values[0];bt=(0,e_.N)(Rt,xt,$,ze,fe,ce,j,je,Pt,nt);break}case"float32":{const xt=o.bufferSync(x),Pt=o.data.get(R.dataId).values[0];bt=(0,e_.N)(Rt,xt,$,ze,fe,ce,j,je,Pt,nt);break}case"int32":{const xt=o.bufferSync(x),Pt=o.data.get(R.dataId).values[0];bt=(0,e_.N)(Rt,xt,$,ze,fe,ce,j,je,Pt,nt);break}case"string":{const xt=o.bufferSync(x),Pt=l.D5U.decodeString(o.data.get(R.dataId).values[0]);bt=(0,e_.N)(Rt,xt,$,ze,fe,ce,j,je,Pt,nt);break}default:throw new Error(`Unsupported type ${x.dtype}`)}return o.makeTensorInfo($,bt.dtype,bt.values)}},uD={kernelName:l.L8s,backendName:"cpu",kernelFunc:function ih(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{numOrSizeSplits:x,axis:R}=p,$=l.D5U.parseAxisParam(R,m.shape)[0],j=l.backend_util.prepareSplitSize(m,x,$),ce=new Array(m.shape.length).fill(0),fe=m.shape.slice();return j.map(je=>{const ze=[...fe];ze[$]=je;const nt=(0,Qu.tP)({inputs:{x:m},backend:o,attrs:{begin:ce,size:ze}});return ce[$]+=je,nt})}};var Am=h(6769);const gk={kernelName:l.bK0,backendName:"cpu",kernelFunc:({inputs:u,backend:d})=>{const{x:o}=u,p=d;(0,ni.H)(o,"square");const m=p.data.get(o.dataId).values,x=new Float32Array(m.length);for(let $=0;$<m.length;++$){const j=m[$];x[$]=j*j}return{dataId:p.write(x,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var _k=h(4376),t_=h(6893);const _M=(0,Qa.A)(l.h8e,(u,d)=>{const o=d;return isNaN(u)?NaN:u>0?1:o.alpha}),qu={kernelName:l.h8e,backendName:"cpu",kernelFunc:_M};var yM=h(5549);const hD={kernelName:l.jQk,backendName:"cpu",kernelFunc:function dD(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{begin:x,end:R,strides:$,beginMask:j,endMask:ce,ellipsisMask:fe,newAxisMask:je,shrinkAxisMask:ze}=p;(0,ni.H)(m,"stridedSlice");const{finalShapeSparse:nt,finalShape:Rt,isIdentity:bt,sliceDim0:xt,isSimpleSlice:Pt,begin:St,end:Ut,strides:Ft}=l.kuN.sliceInfo(m.shape,x,R,$,j,ce,fe,je,ze);let sn;if(bt)sn=Ja({inputs:{x:m},backend:o,attrs:{shape:Rt}});else if(xt||Pt){l.D5U.assert(m.shape.length>=1,()=>`Input must have rank at least 1, got: ${m.shape.length}`);const _n=l.kuN.computeOutShape(St,Ut,Ft),Cn=(0,Qu.tP)({inputs:{x:m},backend:o,attrs:{begin:St,size:_n}});sn=Ja({inputs:{x:Cn},backend:o,attrs:{shape:Rt}}),o.disposeIntermediateTensorInfo(Cn)}else{const _n=o.bufferSync(m),Cn=(0,yM.t)(nt,_n,Ft,St);sn=o.makeTensorInfo(Rt,Cn.dtype,Cn.values)}return sn}};var vM=h(3118);const yk={kernelName:l._JP,backendName:"cpu",kernelFunc:function Fl(u){const{inputs:d,backend:o,attrs:p}=u,{separator:m,nGramWidths:x,leftPad:R,rightPad:$,padWidth:j,preserveShortSequences:ce}=p,{data:fe,dataSplits:je}=d,ze=o.data.get(fe.dataId).values,nt=o.data.get(je.dataId).values,[Rt,bt]=(0,vM.A)(ze,nt,m,x,R,$,j,ce);return[o.makeTensorInfo([Rt.length],"string",Rt),o.makeTensorInfo(je.shape,"int32",bt)]}};var vk=h(6482);const n_={kernelName:l.s1s,backendName:"cpu",kernelFunc:function bk(u){const{inputs:d,backend:o,attrs:p}=u,{skipEmpty:m}=p,{input:x,delimiter:R}=d;if("string"!==x.dtype)throw new Error("Input must be of datatype string");if(1!==x.shape.length)throw new Error(`Input must be a vector, got shape: ${x.shape}`);if(0!==R.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${R.shape}`);const $=o.data.get(x.dataId).values,j=o.data.get(R.dataId).values[0],[ce,fe,je]=(0,vk.Q)($,j,m),ze=fe.length;return[o.makeTensorInfo([ze,2],"int32",ce),o.makeTensorInfo([ze],"string",fe),o.makeTensorInfo([2],"int32",new Int32Array(je))]}};var xk=h(4105);const Yv={kernelName:l.XkS,backendName:"cpu",kernelFunc:function Xv(u){const{inputs:d,backend:o,attrs:p}=u,{numBuckets:m}=p,{input:x}=d;if("string"!==x.dtype)throw new Error("Input must be of datatype string");if(m<=0)throw new Error("Number of buckets must be at least 1");const R=o.data.get(x.dataId).values,$=(0,xk.h)(R,m);return o.makeTensorInfo(x.shape,"int32",$)}},fd=(0,Qa.A)(l.sEM,u=>Math.tan(u)),bM={kernelName:l.sEM,backendName:"cpu",kernelFunc:fd},pD=(0,Qa.A)(l.MIZ,u=>Math.tanh(u)),fD={kernelName:l.MIZ,backendName:"cpu",kernelFunc:pD},mD={kernelName:l.SIB,backendName:"cpu",kernelFunc:function wk(u){const{inputs:d,backend:o}=u,{tensor:p,indices:m,updates:x}=d,{sliceRank:R,numUpdates:$,sliceSize:j,strides:ce,outputSize:fe}=l.backend_util.calculateShapes(x,m,p.shape),ze=o.bufferSync(m),nt=o.bufferSync(x),Rt=o.bufferSync(p),bt=(0,e_.N)(ze,nt,p.shape,fe,j,$,R,ce,Rt,!1);return o.makeTensorInfo(p.shape,bt.dtype,bt.values)}};var gD=h(1692);const yD={kernelName:l.n9L,backendName:"cpu",kernelFunc:function _D(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{reps:x}=p;(0,ni.H)(m,"tile");const R=(0,gD.R)(o.bufferSync(m),x);return o.makeTensorInfo(R.shape,R.dtype,R.values)}};var Ck=h(9942);const Dk={kernelName:l.cWu,backendName:"cpu",kernelFunc:function Ek(u){const{inputs:d,backend:o,attrs:p}=u,{x:m}=d,{k:x,sorted:R}=p;(0,ni.H)(m,"topk");const $=o.data.get(m.dataId).values,[j,ce]=(0,Ck.W)($,m.shape,m.dtype,x,R);return[o.makeTensorInfo(j.shape,j.dtype,j.values),o.makeTensorInfo(ce.shape,ce.dtype,ce.values)]}},Sk={kernelName:l.wx7,backendName:"cpu",kernelFunc:function zy(u){const{inputs:d,attrs:o,backend:p}=u,{image:m,transforms:x}=d,{interpolation:R,fillMode:$,fillValue:j,outputShape:ce}=o,[fe,je,ze,nt]=m.shape,[Rt,bt]=ce??[je,ze],xt=[fe,Rt,bt,nt],Pt=l.D5U.computeStrides(m.shape),St=Pt[0],Ut=Pt[1],Ft=Pt[2],sn=l.D5U.computeStrides(xt),_n=sn[0],Cn=sn[1],Bn=sn[2],Vn=l.D5U.getTypedArrayFromDType(m.dtype,l.D5U.sizeFromShape(xt));Vn.fill(j);const es=p.data.get(m.dataId).values,ls=p.data.get(x.dataId).values;for(let rs=0;rs<fe;++rs){const hs=1===x.shape[0]?ls:ls.subarray(8*rs,8*rs+8);for(let ms=0;ms<Rt;++ms)for(let _s=0;_s<bt;++_s)for(let Ds=0;Ds<nt;++Ds){let ds;const ys=hs[6]*_s+hs[7]*ms+1;if(0===ys)continue;const Ls=(hs[3]*_s+hs[4]*ms+hs[5])/ys,nr=vD((hs[0]*_s+hs[1]*ms+hs[2])/ys,ze,$),Vs=vD(Ls,je,$);switch(R){case"nearest":ds=Tk(es,je,ze,St,Ut,Ft,rs,Vs,nr,Ds,j);break;case"bilinear":ds=Wy(es,je,ze,St,Ut,Ft,rs,Vs,nr,Ds,j);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${R}`)}Vn[rs*_n+ms*Cn+_s*Bn+Ds]=ds}return p.makeTensorInfo(xt,m.dtype,Vn)}return{dataId:p.write(Vn,xt,m.dtype),shape:m.shape,dtype:m.dtype}}};function vD(u,d,o){switch(o){case"reflect":return function Ik(u,d){let o=u;if(o<0)if(d<=1)o=0;else{const p=2*d;o<p&&(o=p*Math.trunc(-o/p)+o),o=o<-d?o+p:-o-1}else if(o>d-1)if(d<=1)o=0;else{const p=2*d;o-=p*Math.trunc(o/p),o>=d&&(o=p-o-1)}return l.D5U.clamp(0,o,d-1)}(u,d);case"wrap":return function Zv(u,d){let o=u;return o<0?d<=1?o=0:o+=d*(Math.trunc(-o/(d-1))+1):o>d-1&&(d<=1?o=0:o-=d*Math.trunc(o/(d-1))),l.D5U.clamp(0,o,d-1)}(u,d);case"nearest":return function xD(u,d){return l.D5U.clamp(0,u,d-1)}(u,d);default:return function bD(u,d){return u}(u)}}function s_(u,d,o,p,m,x,R,$,j,ce,fe){return 0<=$&&$<d&&0<=j&&j<o?u[R*p+$*m+j*x+ce]:fe}function Tk(u,d,o,p,m,x,R,$,j,ce,fe){return s_(u,d,o,p,m,x,R,Math.round($),Math.round(j),ce,fe)}function Wy(u,d,o,p,m,x,R,$,j,ce,fe){const je=Math.floor($),ze=Math.floor(j),nt=je+1,Rt=ze+1;return(nt-$)*((Rt-j)*s_(u,d,o,p,m,x,R,je,ze,ce,fe)+(j-ze)*s_(u,d,o,p,m,x,R,je,Rt,ce,fe))+($-je)*((Rt-j)*s_(u,d,o,p,m,x,R,nt,ze,ce,fe)+(j-ze)*s_(u,d,o,p,m,x,R,nt,Rt,ce,fe))}var Hy=h(705);const Rk=[_T,F1.fC,vT,xT,Af.j4,$1,Rd,ET,Yx,DT,IT,TT,Zx,RT,rp,W1,Jx,H1,G1,mT,qx,FT,X1,$T.T0,Oy,Ry.Mq,$v.y2,BT,sh.z,VT,Q1,zT,Ny,jT,KT,YT,QT,Ps,Bv,eA,nA,rA,q1,oA,tE,cM,lA,tw,uA,op,My,Dm,Kg,M1,Yg,Im.Kx,aE,nw.SX,lE,cE.Vu,pA,aw,lw,Uv.Ao,pE.EE,fE,$y,_A,zv,Wv.Ce,hM.V,Up.I,bA,Z1,xA,wA,Fs,Un,gE.zh,_E.m3,SA,zp.xM,dw,In,yE,kA,hd,vE,By,bE.eJ,xE,wE,EE,MA,ri,hw,SE,IE.u0,AE,RE,FA,Sm.f$,pw.AF,LA,fM,NE,VA.nP,ME,zA,PE,FE,HA,fT,$E.Iz,Ei,BE,Sh,GA,ip.O,uE,XA,Ug,Ty,P1,yw,ZA,QA,WE,Gv,qA,Ys,GE.FY,zu,YE,QE,tk,Xx.BP,sk,ik,ak,Qu.C6,kf,ck,dk,fk,sD,iD,aD,cD,uD,Am.cz,gk,_k.MS,t_.j,qu,hD,yk,n_,Yv,dE.GR,jg,bM,fD,mD,yD,Dk,Sk,ud.b,{kernelName:l.kpP,backendName:"cpu",kernelFunc:function Ak(u){const{inputs:d,attrs:o,backend:p}=u,{axis:m}=o,{x}=d;(0,ni.H)(x,"unique");const R=p.data.get(x.dataId).values,{outputValues:$,outputShape:j,indices:ce}=(0,Hy.S)(R,m,x.shape,x.dtype);return[p.makeTensorInfo(j,x.dtype,$),p.makeTensorInfo([ce.length],"int32",ce)]}},{kernelName:l.ToN,backendName:"cpu",kernelFunc:function Ok(u){const{inputs:d,backend:o,attrs:p}=u,{value:m}=d;let{axis:x}=p;x<0&&(x+=m.shape.length);const R=m.shape.length,$=m.shape[x],j=new Array(R-1);let ce=0;for(let nt=0;nt<R;nt++)nt!==x&&(j[ce++]=m.shape[nt]);const fe=new Array(R).fill(0),je=m.shape.slice();je[x]=1;const ze=new Array($);for(let nt=0;nt<ze.length;nt++){fe[x]=nt;const Rt=(0,Qu.tP)({inputs:{x:m},backend:o,attrs:{begin:fe,size:je}});ze[nt]=Ja({inputs:{x:Rt},backend:o,attrs:{shape:j}}),o.disposeIntermediateTensorInfo(Rt)}return ze}},{kernelName:l.Qvg,backendName:"cpu",kernelFunc:function CD(u){const{inputs:d,backend:o,attrs:p}=u,{x:m,segmentIds:x}=d,{numSegments:R}=p;(0,ni.H)(m,"unsortedSegmentSum");const ce=[],fe=[],je=m.shape.length-x.shape.length;let ze=x;for(let Rt=0;Rt<je;++Rt){const bt=Py({inputs:{input:ze},backend:o,attrs:{dim:Rt+1}});ze=bt,fe.push(bt)}for(let Rt=0;Rt<R;++Rt){const bt=l.D5U.createScalarValue(Rt,"int32"),xt=o.makeTensorInfo([],"int32",bt),Pt=(0,Im.Dg)({inputs:{a:xt,b:ze},backend:o}),St=(0,Ry.pj)({inputs:{x:Pt},backend:o,attrs:{dtype:"float32"}}),Ut=(0,Sm.Jp)({inputs:{a:St,b:m},backend:o}),Ft=si({inputs:{x:Ut},backend:o,attrs:{axis:0,keepDims:!1}});ce.push(Ft),fe.push(xt),fe.push(Pt),fe.push(St),fe.push(Ut),fe.push(Ft)}const nt=_w({inputs:ce,backend:o,attrs:{axis:0}});return fe.forEach(Rt=>o.disposeIntermediateTensorInfo(Rt)),nt}},UA];for(const u of Rk)(0,l.wCN)(u);var cp=h(3421);const Mk={"tfjs-core":l.jTM,"tfjs-backend-cpu":Kx,"tfjs-backend-webgl":cp.ic,"tfjs-data":Gx,"tfjs-layers":R_,"tfjs-converter":su.gJ,tfjs:"4.11.0"}},4860:(Et,le,h)=>{"use strict";function U(I){return(U="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(W){return typeof W}:function(W){return W&&"function"==typeof Symbol&&W.constructor===Symbol&&W!==Symbol.prototype?"symbol":typeof W})(I)}function Z(I,N,W){var l=W.value;if("function"!=typeof l)throw new TypeError("@boundMethod decorator can only be applied to methods not: ".concat(U(l)));var w=!1;return{configurable:!0,get:function(){if(w||this===I.prototype||this.hasOwnProperty(N)||"function"!=typeof l)return l;var T=l.bind(this);return w=!0,Object.defineProperty(this,N,{configurable:!0,get:function(){return T},set:function(G){l=G,delete this[N]}}),w=!1,T},set:function(T){l=T}}}function y(I){var N;return typeof Reflect<"u"&&"function"==typeof Reflect.ownKeys?N=Reflect.ownKeys(I.prototype):(N=Object.getOwnPropertyNames(I.prototype),"function"==typeof Object.getOwnPropertySymbols&&(N=N.concat(Object.getOwnPropertySymbols(I.prototype)))),N.forEach(function(W){if("constructor"!==W){var l=Object.getOwnPropertyDescriptor(I.prototype,W);"function"==typeof l.value&&Object.defineProperty(I.prototype,W,Z(I,W,l))}}),I}function F(){return 1===arguments.length?y.apply(void 0,arguments):Z.apply(void 0,arguments)}h.r(le),h.d(le,{boundClass:()=>y,boundMethod:()=>Z,default:()=>F})},186:Et=>{Et.exports=h;var le=null;try{le=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function h(de,P,oe){this.low=0|de,this.high=0|P,this.unsigned=!!oe}function U(de){return!0===(de&&de.__isLong__)}Object.defineProperty(h.prototype,"__isLong__",{value:!0}),h.isLong=U;var Z={},y={};function F(de,P){var oe,ye,Te;return P?(Te=0<=(de>>>=0)&&de<256)&&(ye=y[de])?ye:(oe=N(de,(0|de)<0?-1:0,!0),Te&&(y[de]=oe),oe):(Te=-128<=(de|=0)&&de<128)&&(ye=Z[de])?ye:(oe=N(de,de<0?-1:0,!1),Te&&(Z[de]=oe),oe)}function I(de,P){if(isNaN(de))return P?Re:_e;if(P){if(de<0)return Re;if(de>=G)return Le}else{if(de<=-J)return De;if(de+1>=J)return ie}return de<0?I(-de,P).neg():N(de%D|0,de/D|0,P)}function N(de,P,oe){return new h(de,P,oe)}h.fromInt=F,h.fromNumber=I,h.fromBits=N;var W=Math.pow;function l(de,P,oe){if(0===de.length)throw Error("empty string");if("NaN"===de||"Infinity"===de||"+Infinity"===de||"-Infinity"===de)return _e;if("number"==typeof P?(oe=P,P=!1):P=!!P,(oe=oe||10)<2||36<oe)throw RangeError("radix");var ye;if((ye=de.indexOf("-"))>0)throw Error("interior hyphen");if(0===ye)return l(de.substring(1),P,oe).neg();for(var Te=I(W(oe,8)),v=_e,at=0;at<de.length;at+=8){var Xe=Math.min(8,de.length-at),Ue=parseInt(de.substring(at,at+Xe),oe);if(Xe<8){var pt=I(W(oe,Xe));v=v.mul(pt).add(I(Ue))}else v=(v=v.mul(Te)).add(I(Ue))}return v.unsigned=P,v}function w(de,P){return"number"==typeof de?I(de,P):"string"==typeof de?l(de,P):N(de.low,de.high,"boolean"==typeof P?P:de.unsigned)}h.fromString=l,h.fromValue=w;var D=4294967296,G=D*D,J=G/2,K=F(1<<24),_e=F(0);h.ZERO=_e;var Re=F(0,!0);h.UZERO=Re;var we=F(1);h.ONE=we;var We=F(1,!0);h.UONE=We;var Oe=F(-1);h.NEG_ONE=Oe;var ie=N(-1,2147483647,!1);h.MAX_VALUE=ie;var Le=N(-1,-1,!0);h.MAX_UNSIGNED_VALUE=Le;var De=N(0,-2147483648,!1);h.MIN_VALUE=De;var te=h.prototype;te.toInt=function(){return this.unsigned?this.low>>>0:this.low},te.toNumber=function(){return this.unsigned?(this.high>>>0)*D+(this.low>>>0):this.high*D+(this.low>>>0)},te.toString=function(P){if((P=P||10)<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(De)){var oe=I(P),ye=this.div(oe),Te=ye.mul(oe).sub(this);return ye.toString(P)+Te.toInt().toString(P)}return"-"+this.neg().toString(P)}for(var v=I(W(P,6),this.unsigned),at=this,Xe="";;){var Ue=at.div(v),Ct=(at.sub(Ue.mul(v)).toInt()>>>0).toString(P);if((at=Ue).isZero())return Ct+Xe;for(;Ct.length<6;)Ct="0"+Ct;Xe=""+Ct+Xe}},te.getHighBits=function(){return this.high},te.getHighBitsUnsigned=function(){return this.high>>>0},te.getLowBits=function(){return this.low},te.getLowBitsUnsigned=function(){return this.low>>>0},te.getNumBitsAbs=function(){if(this.isNegative())return this.eq(De)?64:this.neg().getNumBitsAbs();for(var P=0!=this.high?this.high:this.low,oe=31;oe>0&&!(P&1<<oe);oe--);return 0!=this.high?oe+33:oe+1},te.isZero=function(){return 0===this.high&&0===this.low},te.eqz=te.isZero,te.isNegative=function(){return!this.unsigned&&this.high<0},te.isPositive=function(){return this.unsigned||this.high>=0},te.isOdd=function(){return 1==(1&this.low)},te.isEven=function(){return 0==(1&this.low)},te.equals=function(P){return U(P)||(P=w(P)),(this.unsigned===P.unsigned||this.high>>>31!=1||P.high>>>31!=1)&&this.high===P.high&&this.low===P.low},te.eq=te.equals,te.notEquals=function(P){return!this.eq(P)},te.neq=te.notEquals,te.ne=te.notEquals,te.lessThan=function(P){return this.comp(P)<0},te.lt=te.lessThan,te.lessThanOrEqual=function(P){return this.comp(P)<=0},te.lte=te.lessThanOrEqual,te.le=te.lessThanOrEqual,te.greaterThan=function(P){return this.comp(P)>0},te.gt=te.greaterThan,te.greaterThanOrEqual=function(P){return this.comp(P)>=0},te.gte=te.greaterThanOrEqual,te.ge=te.greaterThanOrEqual,te.compare=function(P){if(U(P)||(P=w(P)),this.eq(P))return 0;var oe=this.isNegative(),ye=P.isNegative();return oe&&!ye?-1:!oe&&ye?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},te.comp=te.compare,te.negate=function(){return!this.unsigned&&this.eq(De)?De:this.not().add(we)},te.neg=te.negate,te.add=function(P){U(P)||(P=w(P));var Ct=0,It=0,nn=0,Bt=0;return nn+=(Bt+=(65535&this.low)+(65535&P.low))>>>16,It+=(nn+=(this.low>>>16)+(P.low>>>16))>>>16,Ct+=(It+=(65535&this.high)+(65535&P.high))>>>16,Ct+=(this.high>>>16)+(P.high>>>16),N((nn&=65535)<<16|(Bt&=65535),(Ct&=65535)<<16|(It&=65535),this.unsigned)},te.subtract=function(P){return U(P)||(P=w(P)),this.add(P.neg())},te.sub=te.subtract,te.multiply=function(P){if(this.isZero())return _e;if(U(P)||(P=w(P)),le)return N(le.mul(this.low,this.high,P.low,P.high),le.get_high(),this.unsigned);if(P.isZero())return _e;if(this.eq(De))return P.isOdd()?De:_e;if(P.eq(De))return this.isOdd()?De:_e;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(K)&&P.lt(K))return I(this.toNumber()*P.toNumber(),this.unsigned);var Te=65535&this.high,v=this.low>>>16,at=65535&this.low,Ue=65535&P.high,pt=P.low>>>16,Ct=65535&P.low,It=0,nn=0,Bt=0,bn=0;return Bt+=(bn+=at*Ct)>>>16,nn+=(Bt+=v*Ct)>>>16,Bt&=65535,nn+=(Bt+=at*pt)>>>16,It+=(nn+=Te*Ct)>>>16,nn&=65535,It+=(nn+=v*pt)>>>16,nn&=65535,It+=(nn+=at*Ue)>>>16,It+=(this.high>>>16)*Ct+Te*pt+v*Ue+at*(P.high>>>16),N((Bt&=65535)<<16|(bn&=65535),(It&=65535)<<16|(nn&=65535),this.unsigned)},te.mul=te.multiply,te.divide=function(P){if(U(P)||(P=w(P)),P.isZero())throw Error("division by zero");var ye,Te,v;if(le)return this.unsigned||-2147483648!==this.high||-1!==P.low||-1!==P.high?N((this.unsigned?le.div_u:le.div_s)(this.low,this.high,P.low,P.high),le.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Re:_e;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return Re;if(P.gt(this.shru(1)))return We;v=Re}else{if(this.eq(De))return P.eq(we)||P.eq(Oe)?De:P.eq(De)?we:(ye=this.shr(1).div(P).shl(1)).eq(_e)?P.isNegative()?we:Oe:(Te=this.sub(P.mul(ye)),v=ye.add(Te.div(P)));if(P.eq(De))return this.unsigned?Re:_e;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();v=_e}for(Te=this;Te.gte(P);){ye=Math.max(1,Math.floor(Te.toNumber()/P.toNumber()));for(var Xe=Math.ceil(Math.log(ye)/Math.LN2),Ue=Xe<=48?1:W(2,Xe-48),pt=I(ye),Ct=pt.mul(P);Ct.isNegative()||Ct.gt(Te);)Ct=(pt=I(ye-=Ue,this.unsigned)).mul(P);pt.isZero()&&(pt=we),v=v.add(pt),Te=Te.sub(Ct)}return v},te.div=te.divide,te.modulo=function(P){return U(P)||(P=w(P)),le?N((this.unsigned?le.rem_u:le.rem_s)(this.low,this.high,P.low,P.high),le.get_high(),this.unsigned):this.sub(this.div(P).mul(P))},te.mod=te.modulo,te.rem=te.modulo,te.not=function(){return N(~this.low,~this.high,this.unsigned)},te.and=function(P){return U(P)||(P=w(P)),N(this.low&P.low,this.high&P.high,this.unsigned)},te.or=function(P){return U(P)||(P=w(P)),N(this.low|P.low,this.high|P.high,this.unsigned)},te.xor=function(P){return U(P)||(P=w(P)),N(this.low^P.low,this.high^P.high,this.unsigned)},te.shiftLeft=function(P){return U(P)&&(P=P.toInt()),0==(P&=63)?this:P<32?N(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):N(0,this.low<<P-32,this.unsigned)},te.shl=te.shiftLeft,te.shiftRight=function(P){return U(P)&&(P=P.toInt()),0==(P&=63)?this:P<32?N(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):N(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},te.shr=te.shiftRight,te.shiftRightUnsigned=function(P){if(U(P)&&(P=P.toInt()),0==(P&=63))return this;var oe=this.high;return P<32?N(this.low>>>P|oe<<32-P,oe>>>P,this.unsigned):N(32===P?oe:oe>>>P-32,0,this.unsigned)},te.shru=te.shiftRightUnsigned,te.shr_u=te.shiftRightUnsigned,te.toSigned=function(){return this.unsigned?N(this.low,this.high,!1):this},te.toUnsigned=function(){return this.unsigned?this:N(this.low,this.high,!0)},te.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},te.toBytesLE=function(){var P=this.high,oe=this.low;return[255&oe,oe>>>8&255,oe>>>16&255,oe>>>24,255&P,P>>>8&255,P>>>16&255,P>>>24]},te.toBytesBE=function(){var P=this.high,oe=this.low;return[P>>>24,P>>>16&255,P>>>8&255,255&P,oe>>>24,oe>>>16&255,oe>>>8&255,255&oe]},h.fromBytes=function(P,oe,ye){return ye?h.fromBytesLE(P,oe):h.fromBytesBE(P,oe)},h.fromBytesLE=function(P,oe){return new h(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,oe)},h.fromBytesBE=function(P,oe){return new h(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],oe)}},9128:(Et,le,h)=>{var U=h(9864),Z=h(3919),y=h(3263),F=h(5353),I=h(3358),N=h(3789),W=h(2508);W.alea=U,W.xor128=Z,W.xorwow=y,W.xorshift7=F,W.xor4096=I,W.tychei=N,Et.exports=W},9864:function(Et,le,h){var U;!function(Z,y,F){function I(w){var M=this,T=function l(){var w=4022871197;return function(T){T=String(T);for(var D=0;D<T.length;D++){var G=.02519603282416938*(w+=T.charCodeAt(D));G-=w=G>>>0,w=(G*=w)>>>0,w+=4294967296*(G-=w)}return 2.3283064365386963e-10*(w>>>0)}}();M.next=function(){var D=2091639*M.s0+2.3283064365386963e-10*M.c;return M.s0=M.s1,M.s1=M.s2,M.s2=D-(M.c=0|D)},M.c=1,M.s0=T(" "),M.s1=T(" "),M.s2=T(" "),M.s0-=T(w),M.s0<0&&(M.s0+=1),M.s1-=T(w),M.s1<0&&(M.s1+=1),M.s2-=T(w),M.s2<0&&(M.s2+=1),T=null}function N(w,M){return M.c=w.c,M.s0=w.s0,M.s1=w.s1,M.s2=w.s2,M}function W(w,M){var T=new I(w),D=M&&M.state,G=T.next;return G.int32=function(){return 4294967296*T.next()|0},G.double=function(){return G()+11102230246251565e-32*(2097152*G()|0)},G.quick=G,D&&("object"==typeof D&&N(D,T),G.state=function(){return N(T,{})}),G}y&&y.exports?y.exports=W:h.amdD&&h.amdO?void 0!==(U=function(){return W}.call(le,h,le,y))&&(y.exports=U):this.alea=W}(0,Et=h.nmd(Et))},3789:function(Et,le,h){var U;!function(Z,y,F){function I(l){var w=this,M="";w.next=function(){var D=w.b,G=w.c,J=w.d,K=w.a;return D=D<<25^D>>>7^G,G=G-J|0,J=J<<24^J>>>8^K,K=K-D|0,w.b=D=D<<20^D>>>12^G,w.c=G=G-J|0,w.d=J<<16^G>>>16^K,w.a=K-D|0},w.a=0,w.b=0,w.c=-1640531527,w.d=1367130551,l===Math.floor(l)?(w.a=l/4294967296|0,w.b=0|l):M+=l;for(var T=0;T<M.length+20;T++)w.b^=0|M.charCodeAt(T),w.next()}function N(l,w){return w.a=l.a,w.b=l.b,w.c=l.c,w.d=l.d,w}function W(l,w){var M=new I(l),T=w&&w.state,D=function(){return(M.next()>>>0)/4294967296};return D.double=function(){do{var K=((M.next()>>>11)+(M.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},D.int32=M.next,D.quick=D,T&&("object"==typeof T&&N(T,M),D.state=function(){return N(M,{})}),D}y&&y.exports?y.exports=W:h.amdD&&h.amdO?void 0!==(U=function(){return W}.call(le,h,le,y))&&(y.exports=U):this.tychei=W}(0,Et=h.nmd(Et))},3919:function(Et,le,h){var U;!function(Z,y,F){function I(l){var w=this,M="";w.x=0,w.y=0,w.z=0,w.w=0,w.next=function(){var D=w.x^w.x<<11;return w.x=w.y,w.y=w.z,w.z=w.w,w.w^=w.w>>>19^D^D>>>8},l===(0|l)?w.x=l:M+=l;for(var T=0;T<M.length+64;T++)w.x^=0|M.charCodeAt(T),w.next()}function N(l,w){return w.x=l.x,w.y=l.y,w.z=l.z,w.w=l.w,w}function W(l,w){var M=new I(l),T=w&&w.state,D=function(){return(M.next()>>>0)/4294967296};return D.double=function(){do{var K=((M.next()>>>11)+(M.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},D.int32=M.next,D.quick=D,T&&("object"==typeof T&&N(T,M),D.state=function(){return N(M,{})}),D}y&&y.exports?y.exports=W:h.amdD&&h.amdO?void 0!==(U=function(){return W}.call(le,h,le,y))&&(y.exports=U):this.xor128=W}(0,Et=h.nmd(Et))},3358:function(Et,le,h){var U;!function(Z,y,F){function I(l){var w=this;w.next=function(){var J,K,T=w.w,D=w.X,G=w.i;return w.w=T=T+1640531527|0,K=D[G+34&127],J=D[G=G+1&127],K^=K<<13,J^=J<<17,K=D[G]=(K^=K>>>15)^(J^=J>>>12),w.i=G,K+(T^T>>>16)|0},function M(T,D){var G,J,K,_e,Re,we=[],We=128;for(D===(0|D)?(J=D,D=null):(D+="\0",J=0,We=Math.max(We,D.length)),K=0,_e=-32;_e<We;++_e)D&&(J^=D.charCodeAt((_e+32)%D.length)),0===_e&&(Re=J),J^=J<<10,J^=J>>>15,J^=J<<4,J^=J>>>13,_e>=0&&(K=0==(G=we[127&_e]^=J+(Re=Re+1640531527|0))?K+1:0);for(K>=128&&(we[127&(D&&D.length||0)]=-1),K=127,_e=512;_e>0;--_e)J=we[K+34&127],G=we[K=K+1&127],J^=J<<13,G^=G<<17,we[K]=(J^=J>>>15)^(G^=G>>>12);T.w=Re,T.X=we,T.i=K}(w,l)}function N(l,w){return w.i=l.i,w.w=l.w,w.X=l.X.slice(),w}function W(l,w){null==l&&(l=+new Date);var M=new I(l),T=w&&w.state,D=function(){return(M.next()>>>0)/4294967296};return D.double=function(){do{var K=((M.next()>>>11)+(M.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},D.int32=M.next,D.quick=D,T&&(T.X&&N(T,M),D.state=function(){return N(M,{})}),D}y&&y.exports?y.exports=W:h.amdD&&h.amdO?void 0!==(U=function(){return W}.call(le,h,le,y))&&(y.exports=U):this.xor4096=W}(0,Et=h.nmd(Et))},5353:function(Et,le,h){var U;!function(Z,y,F){function I(l){var w=this;w.next=function(){var G,J,T=w.x,D=w.i;return G=T[D],J=(G^=G>>>7)^G<<24,J^=(G=T[D+1&7])^G>>>10,J^=(G=T[D+3&7])^G>>>3,J^=(G=T[D+4&7])^G<<7,G=T[D+7&7],T[D]=J^=(G^=G<<13)^G<<9,w.i=D+1&7,J},function M(T,D){var G,K=[];if(D===(0|D))K[0]=D;else for(D=""+D,G=0;G<D.length;++G)K[7&G]=K[7&G]<<15^D.charCodeAt(G)+K[G+1&7]<<13;for(;K.length<8;)K.push(0);for(G=0;G<8&&0===K[G];++G);for(8==G&&(K[7]=-1),T.x=K,T.i=0,G=256;G>0;--G)T.next()}(w,l)}function N(l,w){return w.x=l.x.slice(),w.i=l.i,w}function W(l,w){null==l&&(l=+new Date);var M=new I(l),T=w&&w.state,D=function(){return(M.next()>>>0)/4294967296};return D.double=function(){do{var K=((M.next()>>>11)+(M.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},D.int32=M.next,D.quick=D,T&&(T.x&&N(T,M),D.state=function(){return N(M,{})}),D}y&&y.exports?y.exports=W:h.amdD&&h.amdO?void 0!==(U=function(){return W}.call(le,h,le,y))&&(y.exports=U):this.xorshift7=W}(0,Et=h.nmd(Et))},3263:function(Et,le,h){var U;!function(Z,y,F){function I(l){var w=this,M="";w.next=function(){var D=w.x^w.x>>>2;return w.x=w.y,w.y=w.z,w.z=w.w,w.w=w.v,(w.d=w.d+362437|0)+(w.v=w.v^w.v<<4^D^D<<1)|0},w.x=0,w.y=0,w.z=0,w.w=0,w.v=0,l===(0|l)?w.x=l:M+=l;for(var T=0;T<M.length+64;T++)w.x^=0|M.charCodeAt(T),T==M.length&&(w.d=w.x<<10^w.x>>>4),w.next()}function N(l,w){return w.x=l.x,w.y=l.y,w.z=l.z,w.w=l.w,w.v=l.v,w.d=l.d,w}function W(l,w){var M=new I(l),T=w&&w.state,D=function(){return(M.next()>>>0)/4294967296};return D.double=function(){do{var K=((M.next()>>>11)+(M.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},D.int32=M.next,D.quick=D,T&&("object"==typeof T&&N(T,M),D.state=function(){return N(M,{})}),D}y&&y.exports?y.exports=W:h.amdD&&h.amdO?void 0!==(U=function(){return W}.call(le,h,le,y))&&(y.exports=U):this.xorwow=W}(0,Et=h.nmd(Et))},2508:function(Et,le,h){var U;!function(Z,y,F){var G,I=256,w=F.pow(I,6),M=F.pow(2,52),T=2*M,D=I-1;function J(ie,Le,De){var te=[],de=we(Re((Le=1==Le?{entropy:!0}:Le||{}).entropy?[ie,Oe(y)]:ie??function We(){try{var ie;return G&&(ie=G.randomBytes)?ie=ie(I):(ie=new Uint8Array(I),(Z.crypto||Z.msCrypto).getRandomValues(ie)),Oe(ie)}catch{var Le=Z.navigator,De=Le&&Le.plugins;return[+new Date,Z,De,Z.screen,Oe(y)]}}(),3),te),P=new K(te),oe=function(){for(var ye=P.g(6),Te=w,v=0;ye<M;)ye=(ye+v)*I,Te*=I,v=P.g(1);for(;ye>=T;)ye/=2,Te/=2,v>>>=1;return(ye+v)/Te};return oe.int32=function(){return 0|P.g(4)},oe.quick=function(){return P.g(4)/4294967296},oe.double=oe,we(Oe(P.S),y),(Le.pass||De||function(ye,Te,v,at){return at&&(at.S&&_e(at,P),ye.state=function(){return _e(P,{})}),v?(F.random=ye,Te):ye})(oe,de,"global"in Le?Le.global:this==F,Le.state)}function K(ie){var Le,De=ie.length,te=this,de=0,P=te.i=te.j=0,oe=te.S=[];for(De||(ie=[De++]);de<I;)oe[de]=de++;for(de=0;de<I;de++)oe[de]=oe[P=D&P+ie[de%De]+(Le=oe[de])],oe[P]=Le;(te.g=function(ye){for(var Te,v=0,at=te.i,Xe=te.j,Ue=te.S;ye--;)Te=Ue[at=D&at+1],v=v*I+Ue[D&(Ue[at]=Ue[Xe=D&Xe+Te])+(Ue[Xe]=Te)];return te.i=at,te.j=Xe,v})(I)}function _e(ie,Le){return Le.i=ie.i,Le.j=ie.j,Le.S=ie.S.slice(),Le}function Re(ie,Le){var de,De=[],te=typeof ie;if(Le&&"object"==te)for(de in ie)try{De.push(Re(ie[de],Le-1))}catch{}return De.length?De:"string"==te?ie:ie+"\0"}function we(ie,Le){for(var te,De=ie+"",de=0;de<De.length;)Le[D&de]=D&(te^=19*Le[D&de])+De.charCodeAt(de++);return Oe(Le)}function Oe(ie){return String.fromCharCode.apply(0,ie)}if(we(F.random(),y),Et.exports){Et.exports=J;try{G=h(5042)}catch{}}else void 0!==(U=function(){return J}.call(le,h,le,Et))&&(Et.exports=U)}(typeof self<"u"?self:this,[],Math)},9957:()=>{},2074:()=>{},5410:()=>{},8628:()=>{},1601:()=>{},7792:()=>{},4977:()=>{},5042:()=>{},5861:(Et,le,h)=>{"use strict";function U(y,F,I,N,W,l,w){try{var M=y[l](w),T=M.value}catch(D){return void I(D)}M.done?F(T):Promise.resolve(T).then(N,W)}function Z(y){return function(){var F=this,I=arguments;return new Promise(function(N,W){var l=y.apply(F,I);function w(T){U(l,N,W,w,M,"next",T)}function M(T){U(l,N,W,w,M,"throw",T)}w(void 0)})}}h.d(le,{Z:()=>Z})}},Et=>{Et(Et.s=5388)}]);